identificador,codigo_original,codigo_desenvolvedor,codigo_llm,codebleu_original_vs_dev,ngram_match_original_vs_dev,weighted_ngram_match_original_vs_dev,syntax_match_original_vs_dev,dataflow_match_original_vs_dev,codebleu_original_vs_llm,ngram_match_original_vs_llm,weighted_ngram_match_original_vs_llm,syntax_match_original_vs_llm,dataflow_match_original_vs_llm,codebleu_llm_vs_dev,ngram_match_llm_vs_dev,weighted_ngram_match_llm_vs_dev,syntax_match_llm_vs_dev,dataflow_match_llm_vs_dev
0,"  parseAsync(argv, parseOptions) {

    this.parse(argv, parseOptions);

    return Promise.all(this._actionResults).then(() => this);
","  async parseAsync(argv, parseOptions) {

    const userArgs = this._prepareUserArgs(argv, parseOptions);

    await this._parseCommand([], userArgs);



    return this;
","`async parseAsync(argv, parseOptions) {`

    await this.parse(argv, parseOptions);

    return Promise.all(this._actionResults);

  }`",0.37148963787027417,0.08032276872815308,0.14247788801610148,0.2631578947368421,1.0,0.4275189572311655,0.13134549472120793,0.15767770262450664,0.42105263157894735,0.0,0.33917828623918733,0.037619851267908594,0.04131551591106297,0.2777777777777778,0.0
1,"    ""Sanity check operations"": browser => {

        import(""../operations/samples/Images.mjs"")

            .then(Images => {

                testOp(browser, [""From Hex"", ""Add Text To Image"", ""To Hex""], Images.PNG_HEX, Images.PNG_CHEF_HEX);

                testOp(browser, ""A1Z26 Cipher Decode"", ""20 5 19 20 15 21 20 16 21 20"", ""testoutput"");

                testOp(browser, ""A1Z26 Cipher Encode"", ""test input"", ""20 5 19 20 9 14 16 21 20"");

            });

    },

    ""Sanity  check operations"": browser => {

        import(""../operations/samples/Images.mjs"").then(Images => {

            testOp(browser, ""ADD"", ""test input"", ""Ê»ÉÊv¿ÄÆËÊ"", [{ ""option"": ""Hex"", ""string"": ""56"" }]);

            testOp(browser, ""AES Decrypt"", ""b443f7f7c16ac5396a34273f6f639caa"", ""test output"", [{ ""option"": ""Hex"", ""string"": ""00112233445566778899aabbccddeeff"" }, { ""option"": ""Hex"", ""string"": ""00000000000000000000000000000000"" }, ""CBC"", ""Hex"", ""Raw"", { ""option"": ""Hex"", ""string"": """" }]);

            testOp(browser, ""AES Encrypt"", ""test input"", ""e42eb8fbfb7a98fff061cd2c1a794d92"", [{""option"": ""Hex"", ""string"": ""00112233445566778899aabbccddeeff""}, {""option"": ""Hex"", ""string"": ""00000000000000000000000000000000""}, ""CBC"", ""Raw"", ""Hex""]);

            testOp(browser, ""AND"", ""test input"", ""4$04  $044"", [{ ""option"": ""Hex"", ""string"": ""34"" }]);

            testOp(browser, ""Add line numbers"", ""test input"", ""1 test input"");

            // testOp(browser, [""From Hex"", ""Add Text To Image"", ""To Hex""], Images.PNG_HEX, Images.PNG_CHEF_HEX);

            // testOp(browser, ""Add Text To Image"", ""test input"", ""test_output"");

            testOp(browser, ""Adler-32 Checksum"", ""test input"", ""16160411"");

            testOp(browser, ""Affine Cipher Decode"", ""test input"", ""rcqr glnsr"", [1, 2]);

            testOp(browser, ""Affine Cipher Encode"", ""test input"", ""njln rbfpn"", [2, 1]);

            testOp(browser, ""Analyse hash"", ""0123456789abcdef"", /CRC-64/);

            testOp(browser, ""Atbash Cipher"", ""test input"", ""gvhg rmkfg"");

            // testOp(browser, ""Avro to JSON"", ""test input"", ""test_output"");

            // testOp(browser, ""BLAKE2b"", ""test input"", ""test_output"");

            // testOp(browser, ""BLAKE2s"", ""test input"", ""test_output"");

            // testOp(browser, ""BSON deserialise"", ""test input"", ""test_output"");

            // testOp(browser, ""BSON serialise"", ""test input"", ""test_output"");

            // testOp(browser, ""Bacon Cipher Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bacon Cipher Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bcrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Bcrypt compare"", ""test input"", ""test_output"");

            // testOp(browser, ""Bcrypt parse"", ""test input"", ""test_output"");

            // testOp(browser, ""Bifid Cipher Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bifid Cipher Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bit shift left"", ""test input"", ""test_output"");

            // testOp(browser, ""Bit shift right"", ""test input"", ""test_output"");

            testOp(browser, ""Blowfish Decrypt"", ""10884e15427dd84ec35204e9c8e921ae"", ""test_output"", [{""option"": ""Hex"", ""string"": ""1234567801234567""}, {""option"": ""Hex"", ""string"": ""0011223344556677""}, ""CBC"", ""Hex"", ""Raw""]);

            testOp(browser, ""Blowfish Encrypt"", ""test input"", ""f0fadbd1d90d774f714248cf26b96410"", [{""option"": ""Hex"", ""string"": ""1234567801234567""}, {""option"": ""Hex"", ""string"": ""0011223344556677""}, ""CBC"", ""Raw"", ""Hex""]);

            // console.log(Images);

            // testOp(browser, ""Blur Image"", Images.PNG_HEX, ""test_output"");

            // Imaged Error : Undefined ! Must be a way to Reference Exports



            // testOp(browser, ""Bombe"", ""test input"", ""test_output"");

            testOp(browser, ""Bzip2 Compress"", ""test input"", ""BZh91AY&SYÏ........@..!N. .!.Â.À.3..ß.rE8P.Ï..."");

            testOp(browser, [""From Hex"", ""Bzip2 Decompress""], ""425a68393141592653597b0884b7000003038000008200ce00200021a647a4218013709517c5dc914e14241ec2212dc0"", ""test_output"", [true]);

            // testOp(browser, ""CRC-16 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""CRC-32 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""CRC-8 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""CSS Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""CSS Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""CSS selector"", ""test input"", ""test_output"");

            // testOp(browser, ""CSV to JSON"", ""test input"", ""test_output"");

            // testOp(browser, ""CTPH"", ""test input"", ""test_output"");

            // testOp(browser, ""Cartesian Product"", ""test input"", ""test_output"");

            // testOp(browser, ""Change IP format"", ""test input"", ""test_output"");

            // testOp(browser, ""Chi Square"", ""test input"", ""test_output"");

            // testOp(browser, ""CipherSaber2 Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""CipherSaber2 Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Citrix CTX1 Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Citrix CTX1 Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Colossus"", ""test input"", ""test_output"");

            // testOp(browser, ""Comment"", ""test input"", ""test_output"");

            // testOp(browser, ""Compare CTPH hashes"", ""test input"", ""test_output"");

            // testOp(browser, ""Compare SSDEEP hashes"", ""test input"", ""test_output"");

            // /testOp(browser, ""Conditional Jump"", ""test input"", ""test_output"");

            // testOp(browser, ""Contain Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert area"", ""test input"", ""test_output"");

            // /testOp(browser, ""Convert co-ordinate format"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert data units"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert distance"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert Image Format"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert mass"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert speed"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert to NATO alphabet"", ""test input"", ""test_output"");

            // testOp(browser, ""Count occurrences"", ""test input"", ""test_output"");

            // testOp(browser, ""Cover Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Crop Image"", ""test input"", ""test_output"");

            // testOp(browser, ""DES Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""DES Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""DNS over HTTPS"", ""test input"", ""test_output"");

            // testOp(browser, ""Dechunk HTTP response"", ""test input"", ""test_output"");

            // testOp(browser, ""Decode NetBIOS Name"", ""test input"", ""test_output"");

            // testOp(browser, ""Decode text"", ""test input"", ""test_output"");

            // testOp(browser, ""Defang IP Addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Defang URL"", ""test input"", ""test_output"");

            // testOp(browser, ""Derive EVP key"", ""test input"", ""test_output"");

            // testOp(browser, ""Derive PBKDF2 key"", ""test input"", ""test_output"");

            // testOp(browser, ""Detect File Type"", ""test input"", ""test_output"");

            // testOp(browser, ""Diff"", ""test input"", ""test_output"");

            // testOp(browser, ""Disassemble x86"", ""test input"", ""test_output"");

            // testOp(browser, ""Dither Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Divide"", ""test input"", ""test_output"");

            // testOp(browser, ""Drop bytes"", ""test input"", ""test_output"");

            // testOp(browser, ""Encode NetBIOS Name"", ""test input"", ""test_output"");

            // testOp(browser, ""Encode text"", ""test input"", ""test_output"");

            // testOp(browser, ""Enigma"", ""test input"", ""test_output"");

            // testOp(browser, ""Entropy"", ""test input"", ""test_output"");

            // testOp(browser, ""Escape string"", ""test input"", ""test_output"");

            // testOp(browser, ""Escape Unicode Characters"", ""test input"", ""test_output"");

            // testOp(browser, ""Expand alphabet range"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract dates"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract domains"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract EXIF"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract email addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract file paths"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract Files"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract IP addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract LSB"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract MAC addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract RGBA"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract URLs"", ""test input"", ""test_output"");

            // testOp(browser, ""Filter"", ""test input"", ""test_output"");

            // testOp(browser, ""Find / Replace"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-16 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-32 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-64 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-8 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Flip Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Fork"", ""test input"", ""test_output"");

            // testOp(browser, ""Format MAC addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Frequency distribution"", ""test input"", ""test_output"");

            // testOp(browser, ""From BCD"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base32"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base58"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base62"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base64"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base85"", ""test input"", ""test_output"");

            // testOp(browser, ""From Binary"", ""test input"", ""test_output"");

            // testOp(browser, ""From Braille"", ""test input"", ""test_output"");

            // testOp(browser, ""From Case Insensitive Regex"", ""test input"", ""test_output"");

            // testOp(browser, ""From Charcode"", ""test input"", ""test_output"");

            // testOp(browser, ""From Decimal"", ""test input"", ""test_output"");

            // testOp(browser, ""From HTML Entity"", ""test input"", ""test_output"");

            // testOp(browser, ""From Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""From Hex Content"", ""test input"", ""test_output"");

            // testOp(browser, ""From Hexdump"", ""test input"", ""test_output"");

            // testOp(browser, ""From MessagePack"", ""test input"", ""test_output"");

            // testOp(browser, ""From Morse Code"", ""test input"", ""test_output"");

            // testOp(browser, ""From Octal"", ""test input"", ""test_output"");

            // testOp(browser, ""From Punycode"", ""test input"", ""test_output"");

            // testOp(browser, ""From Quoted Printable"", ""test input"", ""test_output"");

            // testOp(browser, ""From UNIX Timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""GOST hash"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate all hashes"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate HOTP"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate Lorem Ipsum"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate PGP Key Pair"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate QR Code"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate TOTP"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate UUID"", ""test input"", ""test_output"");

            // testOp(browser, ""Generic Code Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""Group IP addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Gunzip"", ""test input"", ""test_output"");

            // testOp(browser, ""Gzip"", ""test input"", ""test_output"");

            // testOp(browser, ""HAS-160"", ""test input"", ""test_output"");

            // testOp(browser, ""HMAC"", ""test input"", ""test_output"");

            // testOp(browser, ""HTML To Text"", ""test input"", ""test_output"");

            // testOp(browser, ""HTTP request"", ""test input"", ""test_output"");

            // testOp(browser, ""Hamming Distance"", ""test input"", ""test_output"");

            // testOp(browser, ""Haversine distance"", ""test input"", ""test_output"");

            // testOp(browser, ""Head"", ""test input"", ""test_output"");

            // testOp(browser, ""Heatmap chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Hex Density chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Hex to Object Identifier"", ""test input"", ""test_output"");

            // testOp(browser, ""Hex to PEM"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Brightness / Contrast"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Filter"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Hue/Saturation/Lightness"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Opacity"", ""test input"", ""test_output"");

            // testOp(browser, ""Index of Coincidence"", ""test input"", ""test_output"");

            // testOp(browser, ""Invert Image"", ""test input"", ""test_output"");

            // testOp(browser, ""JPath expression"", ""test input"", ""test_output"");

            // testOp(browser, ""JSON Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""JSON Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""JSON to CSV"", ""test input"", ""test_output"");

            // testOp(browser, ""JWT Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""JWT Sign"", ""test input"", ""test_output"");

            // testOp(browser, ""JWT Verify"", ""test input"", ""test_output"");

            // testOp(browser, ""JavaScript Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""JavaScript Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""JavaScript Parser"", ""test input"", ""test_output"");

            // testOp(browser, ""Jump"", ""test input"", ""test_output"");

            // testOp(browser, ""Keccak"", ""test input"", ""test_output"");

            // testOp(browser, ""Label"", ""test input"", ""test_output"");

            // testOp(browser, ""Lorenz"", ""test input"", ""test_output"");

            // testOp(browser, ""Luhn Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""MD2"", ""test input"", ""test_output"");

            // testOp(browser, ""MD4"", ""test input"", ""test_output"");

            // testOp(browser, ""MD5"", ""test input"", ""test_output"");

            // testOp(browser, ""MD6"", ""test input"", ""test_output"");

            // testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""td"", /Result snippet/);

            // testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""tr:nth-of-type(1) td:nth-of-type(2)"", ""Result snippet"");

            // testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""tr:eq(1) td:eq(1)"", ""test_output"");

            // testOp(browser, ""Mean"", ""test input"", ""test_output"");

            // testOp(browser, ""Median"", ""test input"", ""test_output"");`

            // testOp(browser, ""Merge"", ""test input"", ""test_output"");`

            // testOp(browser, ""Microsoft Script Decoder"", ""test input"", ""test_output"");

            // testOp(browser, ""Multiple Bombe"", ""test input"", ""test_output"");

            // testOp(browser, ""Multiply"", ""test input"", ""test_output"");

            // testOp(browser, ""NOT"", ""test input"", ""test_output"");

            // testOp(browser, ""Normalise Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Normalise Unicode"", ""test input"", ""test_output"");

            // testOp(browser, ""Numberwang"", ""test input"", ""test_output"");

            // testOp(browser, ""OR"", ""test input"", ""test_output"");

            // testOp(browser, ""Object Identifier to Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""Offset checker"", ""test input"", ""test_output"");

            // testOp(browser, ""Optical Character Recognition"", ""test input"", ""test_output"");

            // testOp(browser, ""PEM to Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Decrypt and Verify"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Encrypt and Sign"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Verify"", ""test input"", ""test_output"");

            // testOp(browser, ""PHP Deserialize"", ""test input"", ""test_output"");

            // testOp(browser, ""Pad lines"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse ASN.1 hex string"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse colour code"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse DateTime"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse IP range"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse IPv4 header"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse IPv6 address"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse ObjectID timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse QR Code"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse SSH Host Key"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse TLV"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse UDP"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse UNIX file permissions"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse URI"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse User Agent"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse X.509 certificate"", ""test input"", ""test_output"");

            // testOp(browser, ""Play Media"", ""test input"", ""test_output"");

            // testOp(browser, ""Power Set"", ""test input"", ""test_output"");

            // testOp(browser, ""Protobuf Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Pseudo-Random Number Generator"", ""test input"", ""test_output"");

            // testOp(browser, ""RC2 Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""RC2 Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""RC4"", ""test input"", ""test_output"");

            // testOp(browser, ""RC4 Drop"", ""test input"", ""test_output"");

            // testOp(browser, ""RIPEMD"", ""test input"", ""test_output"");

            // testOp(browser, ""ROT13"", ""test input"", ""test_output"");

            // testOp(browser, ""ROT47"", ""test input"", ""test_output"");

            // testOp(browser, ""Rail Fence Cipher Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Rail Fence Cipher Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Randomize Colour Palette"", ""test input"", ""test_output"");

            // testOp(browser, ""Raw Deflate"", ""test input"", ""test_output"");

            // testOp(browser, ""Raw Inflate"", ""test input"", ""test_output"");

            // testOp(browser, ""Register"", ""test input"", ""test_output"");

            // testOp(browser, ""Regular expression"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove Diacritics"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove EXIF"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove line numbers"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove null bytes"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove whitespace"", ""test input"", ""test_output"");

            // testOp(browser, ""Render Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Render Markdown"", ""test input"", ""test_output"");

            // testOp(browser, ""Resize Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Return"", ""test input"", ""test_output"");

            // testOp(browser, ""Reverse"", ""test input"", ""test_output"");

            // testOp(browser, ""Rotate Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Rotate left"", ""test input"", ""test_output"");

            // testOp(browser, ""Rotate right"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA0"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA1"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA2"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA3"", ""test input"", ""test_output"");

            // testOp(browser, ""SQL Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""SQL Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""SSDEEP"", ""test input"", ""test_output"");

            // testOp(browser, ""SUB"", ""test input"", ""test_output"");

            // testOp(browser, ""Scan for Embedded Files"", ""test input"", ""test_output"");

            // testOp(browser, ""Scatter chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Scrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Series chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Set Difference"", ""test input"", ""test_output"");

            // testOp(browser, ""Set Intersection"", ""test input"", ""test_output"");

            // testOp(browser, ""Set Union"", ""test input"", ""test_output"");

            // testOp(browser, ""Shake"", ""test input"", ""test_output"");

            // testOp(browser, ""Sharpen Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Show Base64 offsets"", ""test input"", ""test_output"");

            // testOp(browser, ""Show on map"", ""test input"", ""test_output"");

            // testOp(browser, ""Sleep"", ""test input"", ""test_output"");

            // testOp(browser, ""Snefru"", ""test input"", ""test_output"");

            // testOp(browser, ""Sort"", ""test input"", ""test_output"");

            // testOp(browser, ""Split"", ""test input"", ""test_output"");

            // testOp(browser, ""Split Colour Channels"", ""test input"", ""test_output"");

            // testOp(browser, ""Standard Deviation"", ""test input"", ""test_output"");

            // testOp(browser, ""Streebog"", ""test input"", ""test_output"");

            // testOp(browser, ""Strings"", ""test input"", ""test_output"");

            // testOp(browser, ""Strip HTML tags"", ""test input"", ""test_output"");

            // testOp(browser, ""Strip HTTP headers"", ""test input"", ""test_output"");

            // testOp(browser, ""Subsection"", ""test input"", ""test_output"");

            // testOp(browser, ""Substitute"", ""test input"", ""test_output"");

            // testOp(browser, ""Subtract"", ""test input"", ""test_output"");

            // testOp(browser, ""Sum"", ""test input"", ""test_output"");

            // testOp(browser, ""Swap endianness"", ""test input"", ""test_output"");

            // testOp(browser, ""Symmetric Difference"", ""test input"", ""test_output"");

            // testOp(browser, ""Syntax highlighter"", ""test input"", ""test_output"");

            // testOp(browser, ""TCP/IP Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Tail"", ""test input"", ""test_output"");

            // testOp(browser, ""Take bytes"", ""test input"", ""test_output"");

            // testOp(browser, ""Tar"", ""test input"", ""test_output"");

            // testOp(browser, ""Text Encoding Brute Force"", ""test input"", ""test_output"");

            // testOp(browser, ""To BCD"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base32"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base58"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base62"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base64"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base85"", ""test input"", ""test_output"");

            // testOp(browser, ""To Binary"", ""test input"", ""test_output"");

            // testOp(browser, ""To Braille"", ""test input"", ""test_output"");

            // testOp(browser, ""To Camel case"", ""test input"", ""test_output"");

            // testOp(browser, ""To Case Insensitive Regex"", ""test input"", ""test_output"");

            // testOp(browser, ""To Charcode"", ""test input"", ""test_output"");

            // testOp(browser, ""To Decimal"", ""test input"", ""test_output"");

            // testOp(browser, ""To HTML Entity"", ""test input"", ""test_output"");

            // testOp(browser, ""To Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""To Hex Content"", ""test input"", ""test_output"");

            // testOp(browser, ""To Hexdump"", ""test input"", ""test_output"");

            // testOp(browser, ""To Kebab case"", ""test input"", ""test_output"");

            // testOp(browser, ""To Lower case"", ""test input"", ""test_output"");

            // testOp(browser, ""To MessagePack"", ""test input"", ""test_output"");

            // testOp(browser, ""To Morse Code"", ""test input"", ""test_output"");

            // testOp(browser, ""To Octal"", ""test input"", ""test_output"");

            // testOp(browser, ""To Punycode"", ""test input"", ""test_output"");

            // testOp(browser, ""To Quoted Printable"", ""test input"", ""test_output"");

            // testOp(browser, ""To Snake case"", ""test input"", ""test_output"");

            // testOp(browser, ""To Table"", ""test input"", ""test_output"");

            // testOp(browser, ""To UNIX Timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""To Upper case"", ""test input"", ""test_output"");

            // testOp(browser, ""Translate DateTime Format"", ""test input"", ""test_output"");

            // testOp(browser, ""Triple DES Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Triple DES Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Typex"", ""test input"", ""test_output"");

            // testOp(browser, ""UNIX Timestamp to Windows Filetime"", ""test input"", ""test_output"");

            // testOp(browser, ""URL Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""URL Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Unescape string"", ""test input"", ""test_output"");

            // testOp(browser, ""Unescape Unicode Characters"", ""test input"", ""test_output"");

            // testOp(browser, ""Unique"", ""test input"", ""test_output"");

            // testOp(browser, ""Untar"", ""test input"", ""test_output"");

            // testOp(browser, ""Unzip"", ""test input"", ""test_output"");

            // testOp(browser, ""VarInt Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""VarInt Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""View Bit Plane"", ""test input"", ""test_output"");

            // testOp(browser, ""Vigenère Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Vigenère Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Whirlpool"", ""test input"", ""test_output"");

            // testOp(browser, ""Windows Filetime to UNIX Timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""XKCD Random Number"", ""test input"", ""test_output"");

            // testOp(browser, ""XML Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""XML Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""XOR"", ""test input"", ""test_output"");

            // testOp(browser, ""XOR Brute Force"", ""test input"", ""test_output"");

            // testOp(browser, ""XPath expression"", ""test input"", ""test_output"");

            // testOp(browser, ""YARA Rules"", ""test input"", ""test_output"");

            // testOp(browser, ""Zip"", ""test input"", ""test_output"");

            // testOp(browser, ""Zlib Deflate"", ""test input"", ""test_output"");

            // testOp(browser, ""Zlib Inflate"", ""test input"", ""test_output"");

        });
","    ""Sanity check operations"": async browser => {

        const Images = await import(""../samples/Images.mjs"");

        testOp(browser, ""A1Z26 Cipher Decode"", ""20 5 19 20 15 21 20 16 21 20"", ""testoutput"");

        testOp(browser, ""A1Z26 Cipher Encode"", ""test input"", ""20 5 19 20 9 14 16 21 20"");

        testOp(browser, ""ADD"", ""test input"", ""Ê»ÉÊv¿ÄÆËÊ"", [{ ""option"": ""Hex"", ""string"": ""56"" }]);

        testOp(browser, ""AES Decrypt"", ""b443f7f7c16ac5396a34273f6f639caa"", ""test output"", [{ ""option"": ""Hex"", ""string"": ""00112233445566778899aabbccddeeff"" }, { ""option"": ""Hex"", ""string"": ""00000000000000000000000000000000"" }, ""CBC"", ""Hex"", ""Raw"", { ""option"": ""Hex"", ""string"": """" }]);

        testOp(browser, ""AES Encrypt"", ""test input"", ""e42eb8fbfb7a98fff061cd2c1a794d92"", [{""option"": ""Hex"", ""string"": ""00112233445566778899aabbccddeeff""}, {""option"": ""Hex"", ""string"": ""00000000000000000000000000000000""}, ""CBC"", ""Raw"", ""Hex""]);

        testOp(browser, ""AND"", ""test input"", ""4$04  $044"", [{ ""option"": ""Hex"", ""string"": ""34"" }]);

        testOp(browser, ""Add line numbers"", ""test input"", ""1 test input"");

        testOp(browser, [""From Hex"", ""Add Text To Image"", ""To Base64""], Images.PNG_HEX, Images.PNG_CHEF_B64, [""Chef"", ""Center"", ""Middle"", 0, 0, 16]);

        testOp(browser, ""Adler-32 Checksum"", ""test input"", ""16160411"");

        testOp(browser, ""Affine Cipher Decode"", ""test input"", ""rcqr glnsr"", [1, 2]);

        testOp(browser, ""Affine Cipher Encode"", ""test input"", ""njln rbfpn"", [2, 1]);

        testOp(browser, ""Analyse hash"", ""0123456789abcdef"", /CRC-64/);

        testOp(browser, ""Atbash Cipher"", ""test input"", ""gvhg rmkfg"");

        // testOp(browser, ""Avro to JSON"", ""test input"", ""test_output"");

        // testOp(browser, ""BLAKE2b"", ""test input"", ""test_output"");

        // testOp(browser, ""BLAKE2s"", ""test input"", ""test_output"");

        // testOp(browser, ""BSON deserialise"", ""test input"", ""test_output"");

        // testOp(browser, ""BSON serialise"", ""test input"", ""test_output"");

        // testOp(browser, ""Bacon Cipher Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""Bacon Cipher Encode"", ""test input"", ""test_output"");

        // testOp(browser, ""Bcrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""Bcrypt compare"", ""test input"", ""test_output"");

        // testOp(browser, ""Bcrypt parse"", ""test input"", ""test_output"");

        // testOp(browser, ""Bifid Cipher Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""Bifid Cipher Encode"", ""test input"", ""test_output"");

        // testOp(browser, ""Bit shift left"", ""test input"", ""test_output"");

        // testOp(browser, ""Bit shift right"", ""test input"", ""test_output"");

        testOp(browser, ""Blowfish Decrypt"", ""10884e15427dd84ec35204e9c8e921ae"", ""test_output"", [{""option"": ""Hex"", ""string"": ""1234567801234567""}, {""option"": ""Hex"", ""string"": ""0011223344556677""}, ""CBC"", ""Hex"", ""Raw""]);

        testOp(browser, ""Blowfish Encrypt"", ""test input"", ""f0fadbd1d90d774f714248cf26b96410"", [{""option"": ""Hex"", ""string"": ""1234567801234567""}, {""option"": ""Hex"", ""string"": ""0011223344556677""}, ""CBC"", ""Raw"", ""Hex""]);

        testOp(browser, [""From Hex"", ""Blur Image"", ""To Base64""], Images.PNG_HEX, Images.PNG_BLUR_B64);

        // testOp(browser, ""Bombe"", ""test input"", ""test_output"");

        testOp(browser, ""Bzip2 Compress"", ""test input"", ""BZh91AY&SYÏ........@..!N. .!.Â.À.3..ß.rE8P.Ï..."");

        testOp(browser, [""From Hex"", ""Bzip2 Decompress""], ""425a68393141592653597b0884b7000003038000008200ce00200021a647a4218013709517c5dc914e14241ec2212dc0"", ""test_output"", [true]);

        // testOp(browser, ""CRC-16 Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""CRC-32 Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""CRC-8 Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""CSS Beautify"", ""test input"", ""test_output"");

        // testOp(browser, ""CSS Minify"", ""test input"", ""test_output"");

        // testOp(browser, ""CSS selector"", ""test input"", ""test_output"");

        // testOp(browser, ""CSV to JSON"", ""test input"", ""test_output"");

        // testOp(browser, ""CTPH"", ""test input"", ""test_output"");

        // testOp(browser, ""Cartesian Product"", ""test input"", ""test_output"");

        // testOp(browser, ""Change IP format"", ""test input"", ""test_output"");

        // testOp(browser, ""Chi Square"", ""test input"", ""test_output"");

        // testOp(browser, ""CipherSaber2 Decrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""CipherSaber2 Encrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""Citrix CTX1 Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""Citrix CTX1 Encode"", ""test input"", ""test_output"");

        // testOp(browser, ""Colossus"", ""test input"", ""test_output"");

        // testOp(browser, ""Comment"", ""test input"", ""test_output"");

        // testOp(browser, ""Compare CTPH hashes"", ""test input"", ""test_output"");

        // testOp(browser, ""Compare SSDEEP hashes"", ""test input"", ""test_output"");

        // /testOp(browser, ""Conditional Jump"", ""test input"", ""test_output"");

        // testOp(browser, ""Contain Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Convert area"", ""test input"", ""test_output"");

        // /testOp(browser, ""Convert co-ordinate format"", ""test input"", ""test_output"");

        // testOp(browser, ""Convert data units"", ""test input"", ""test_output"");

        // testOp(browser, ""Convert distance"", ""test input"", ""test_output"");

        // testOp(browser, ""Convert Image Format"", ""test input"", ""test_output"");

        // testOp(browser, ""Convert mass"", ""test input"", ""test_output"");

        // testOp(browser, ""Convert speed"", ""test input"", ""test_output"");

        // testOp(browser, ""Convert to NATO alphabet"", ""test input"", ""test_output"");

        // testOp(browser, ""Count occurrences"", ""test input"", ""test_output"");

        // testOp(browser, ""Cover Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Crop Image"", ""test input"", ""test_output"");

        // testOp(browser, ""DES Decrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""DES Encrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""DNS over HTTPS"", ""test input"", ""test_output"");

        // testOp(browser, ""Dechunk HTTP response"", ""test input"", ""test_output"");

        // testOp(browser, ""Decode NetBIOS Name"", ""test input"", ""test_output"");

        // testOp(browser, ""Decode text"", ""test input"", ""test_output"");

        // testOp(browser, ""Defang IP Addresses"", ""test input"", ""test_output"");

        // testOp(browser, ""Defang URL"", ""test input"", ""test_output"");

        // testOp(browser, ""Derive EVP key"", ""test input"", ""test_output"");

        // testOp(browser, ""Derive PBKDF2 key"", ""test input"", ""test_output"");

        // testOp(browser, ""Detect File Type"", ""test input"", ""test_output"");

        // testOp(browser, ""Diff"", ""test input"", ""test_output"");

        // testOp(browser, ""Disassemble x86"", ""test input"", ""test_output"");

        // testOp(browser, ""Dither Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Divide"", ""test input"", ""test_output"");

        // testOp(browser, ""Drop bytes"", ""test input"", ""test_output"");

        // testOp(browser, ""Encode NetBIOS Name"", ""test input"", ""test_output"");

        // testOp(browser, ""Encode text"", ""test input"", ""test_output"");

        // testOp(browser, ""Enigma"", ""test input"", ""test_output"");

        // testOp(browser, ""Entropy"", ""test input"", ""test_output"");

        // testOp(browser, ""Escape string"", ""test input"", ""test_output"");

        // testOp(browser, ""Escape Unicode Characters"", ""test input"", ""test_output"");

        // testOp(browser, ""Expand alphabet range"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract dates"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract domains"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract EXIF"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract email addresses"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract file paths"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract Files"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract IP addresses"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract LSB"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract MAC addresses"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract RGBA"", ""test input"", ""test_output"");

        // testOp(browser, ""Extract URLs"", ""test input"", ""test_output"");

        // testOp(browser, ""Filter"", ""test input"", ""test_output"");

        // testOp(browser, ""Find / Replace"", ""test input"", ""test_output"");

        // testOp(browser, ""Fletcher-16 Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""Fletcher-32 Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""Fletcher-64 Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""Fletcher-8 Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""Flip Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Fork"", ""test input"", ""test_output"");

        // testOp(browser, ""Format MAC addresses"", ""test input"", ""test_output"");

        // testOp(browser, ""Frequency distribution"", ""test input"", ""test_output"");

        // testOp(browser, ""From BCD"", ""test input"", ""test_output"");

        // testOp(browser, ""From Base"", ""test input"", ""test_output"");

        // testOp(browser, ""From Base32"", ""test input"", ""test_output"");

        // testOp(browser, ""From Base58"", ""test input"", ""test_output"");

        // testOp(browser, ""From Base62"", ""test input"", ""test_output"");

        // testOp(browser, ""From Base64"", ""test input"", ""test_output"");

        // testOp(browser, ""From Base85"", ""test input"", ""test_output"");

        // testOp(browser, ""From Binary"", ""test input"", ""test_output"");

        // testOp(browser, ""From Braille"", ""test input"", ""test_output"");

        // testOp(browser, ""From Case Insensitive Regex"", ""test input"", ""test_output"");

        // testOp(browser, ""From Charcode"", ""test input"", ""test_output"");

        // testOp(browser, ""From Decimal"", ""test input"", ""test_output"");

        // testOp(browser, ""From HTML Entity"", ""test input"", ""test_output"");

        // testOp(browser, ""From Hex"", ""test input"", ""test_output"");

        // testOp(browser, ""From Hex Content"", ""test input"", ""test_output"");

        // testOp(browser, ""From Hexdump"", ""test input"", ""test_output"");

        // testOp(browser, ""From MessagePack"", ""test input"", ""test_output"");

        // testOp(browser, ""From Morse Code"", ""test input"", ""test_output"");

        // testOp(browser, ""From Octal"", ""test input"", ""test_output"");

        // testOp(browser, ""From Punycode"", ""test input"", ""test_output"");

        // testOp(browser, ""From Quoted Printable"", ""test input"", ""test_output"");

        // testOp(browser, ""From UNIX Timestamp"", ""test input"", ""test_output"");

        // testOp(browser, ""GOST hash"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate all hashes"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate HOTP"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate Lorem Ipsum"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate PGP Key Pair"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate QR Code"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate TOTP"", ""test input"", ""test_output"");

        // testOp(browser, ""Generate UUID"", ""test input"", ""test_output"");

        // testOp(browser, ""Generic Code Beautify"", ""test input"", ""test_output"");

        // testOp(browser, ""Group IP addresses"", ""test input"", ""test_output"");

        // testOp(browser, ""Gunzip"", ""test input"", ""test_output"");

        // testOp(browser, ""Gzip"", ""test input"", ""test_output"");

        // testOp(browser, ""HAS-160"", ""test input"", ""test_output"");

        // testOp(browser, ""HMAC"", ""test input"", ""test_output"");

        // testOp(browser, ""HTML To Text"", ""test input"", ""test_output"");

        // testOp(browser, ""HTTP request"", ""test input"", ""test_output"");

        // testOp(browser, ""Hamming Distance"", ""test input"", ""test_output"");

        // testOp(browser, ""Haversine distance"", ""test input"", ""test_output"");

        // testOp(browser, ""Head"", ""test input"", ""test_output"");

        // testOp(browser, ""Heatmap chart"", ""test input"", ""test_output"");

        // testOp(browser, ""Hex Density chart"", ""test input"", ""test_output"");

        // testOp(browser, ""Hex to Object Identifier"", ""test input"", ""test_output"");

        // testOp(browser, ""Hex to PEM"", ""test input"", ""test_output"");

        // testOp(browser, ""Image Brightness / Contrast"", ""test input"", ""test_output"");

        // testOp(browser, ""Image Filter"", ""test input"", ""test_output"");

        // testOp(browser, ""Image Hue/Saturation/Lightness"", ""test input"", ""test_output"");

        // testOp(browser, ""Image Opacity"", ""test input"", ""test_output"");

        // testOp(browser, ""Index of Coincidence"", ""test input"", ""test_output"");

        // testOp(browser, ""Invert Image"", ""test input"", ""test_output"");

        // testOp(browser, ""JPath expression"", ""test input"", ""test_output"");

        // testOp(browser, ""JSON Beautify"", ""test input"", ""test_output"");

        // testOp(browser, ""JSON Minify"", ""test input"", ""test_output"");

        // testOp(browser, ""JSON to CSV"", ""test input"", ""test_output"");

        // testOp(browser, ""JWT Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""JWT Sign"", ""test input"", ""test_output"");

        // testOp(browser, ""JWT Verify"", ""test input"", ""test_output"");

        // testOp(browser, ""JavaScript Beautify"", ""test input"", ""test_output"");

        // testOp(browser, ""JavaScript Minify"", ""test input"", ""test_output"");

        // testOp(browser, ""JavaScript Parser"", ""test input"", ""test_output"");

        // testOp(browser, ""Jump"", ""test input"", ""test_output"");

        // testOp(browser, ""Keccak"", ""test input"", ""test_output"");

        // testOp(browser, ""Label"", ""test input"", ""test_output"");

        // testOp(browser, ""Lorenz"", ""test input"", ""test_output"");

        // testOp(browser, ""Luhn Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""MD2"", ""test input"", ""test_output"");

        // testOp(browser, ""MD4"", ""test input"", ""test_output"");

        // testOp(browser, ""MD5"", ""test input"", ""test_output"");

        // testOp(browser, ""MD6"", ""test input"", ""test_output"");

        // testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""td"", /Result snippet/);

        testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""tr:{1} td:{2}"", ""Result snippet"");

        // testOp(browser, ""Mean"", ""test input"", ""test_output"");

        // testOp(browser, ""Median"", ""test input"", ""test_output"");`

        // testOp(browser, ""Merge"", ""test input"", ""test_output"");`

        // testOp(browser, ""Microsoft Script Decoder"", ""test input"", ""test_output"");

        // testOp(browser, ""Multiple Bombe"", ""test input"", ""test_output"");

        // testOp(browser, ""Multiply"", ""test input"", ""test_output"");

        // testOp(browser, ""NOT"", ""test input"", ""test_output"");

        // testOp(browser, ""Normalise Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Normalise Unicode"", ""test input"", ""test_output"");

        // testOp(browser, ""Numberwang"", ""test input"", ""test_output"");

        // testOp(browser, ""OR"", ""test input"", ""test_output"");

        // testOp(browser, ""Object Identifier to Hex"", ""test input"", ""test_output"");

        // testOp(browser, ""Offset checker"", ""test input"", ""test_output"");

        // testOp(browser, ""Optical Character Recognition"", ""test input"", ""test_output"");

        // testOp(browser, ""PEM to Hex"", ""test input"", ""test_output"");

        // testOp(browser, ""PGP Decrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""PGP Decrypt and Verify"", ""test input"", ""test_output"");

        // testOp(browser, ""PGP Encrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""PGP Encrypt and Sign"", ""test input"", ""test_output"");

        // testOp(browser, ""PGP Verify"", ""test input"", ""test_output"");

        // testOp(browser, ""PHP Deserialize"", ""test input"", ""test_output"");

        // testOp(browser, ""Pad lines"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse ASN.1 hex string"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse colour code"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse DateTime"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse IP range"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse IPv4 header"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse IPv6 address"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse ObjectID timestamp"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse QR Code"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse SSH Host Key"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse TLV"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse UDP"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse UNIX file permissions"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse URI"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse User Agent"", ""test input"", ""test_output"");

        // testOp(browser, ""Parse X.509 certificate"", ""test input"", ""test_output"");

        // testOp(browser, ""Play Media"", ""test input"", ""test_output"");

        // testOp(browser, ""Power Set"", ""test input"", ""test_output"");

        // testOp(browser, ""Protobuf Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""Pseudo-Random Number Generator"", ""test input"", ""test_output"");

        // testOp(browser, ""RC2 Decrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""RC2 Encrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""RC4"", ""test input"", ""test_output"");

        // testOp(browser, ""RC4 Drop"", ""test input"", ""test_output"");

        // testOp(browser, ""RIPEMD"", ""test input"", ""test_output"");

        // testOp(browser, ""ROT13"", ""test input"", ""test_output"");

        // testOp(browser, ""ROT47"", ""test input"", ""test_output"");

        // testOp(browser, ""Rail Fence Cipher Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""Rail Fence Cipher Encode"", ""test input"", ""test_output"");

        // testOp(browser, ""Randomize Colour Palette"", ""test input"", ""test_output"");

        // testOp(browser, ""Raw Deflate"", ""test input"", ""test_output"");

        // testOp(browser, ""Raw Inflate"", ""test input"", ""test_output"");

        // testOp(browser, ""Register"", ""test input"", ""test_output"");

        // testOp(browser, ""Regular expression"", ""test input"", ""test_output"");

        // testOp(browser, ""Remove Diacritics"", ""test input"", ""test_output"");

        // testOp(browser, ""Remove EXIF"", ""test input"", ""test_output"");

        // testOp(browser, ""Remove line numbers"", ""test input"", ""test_output"");

        // testOp(browser, ""Remove null bytes"", ""test input"", ""test_output"");

        // testOp(browser, ""Remove whitespace"", ""test input"", ""test_output"");

        // testOp(browser, ""Render Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Render Markdown"", ""test input"", ""test_output"");

        // testOp(browser, ""Resize Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Return"", ""test input"", ""test_output"");

        // testOp(browser, ""Reverse"", ""test input"", ""test_output"");

        // testOp(browser, ""Rotate Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Rotate left"", ""test input"", ""test_output"");

        // testOp(browser, ""Rotate right"", ""test input"", ""test_output"");

        // testOp(browser, ""SHA0"", ""test input"", ""test_output"");

        // testOp(browser, ""SHA1"", ""test input"", ""test_output"");

        // testOp(browser, ""SHA2"", ""test input"", ""test_output"");

        // testOp(browser, ""SHA3"", ""test input"", ""test_output"");

        // testOp(browser, ""SQL Beautify"", ""test input"", ""test_output"");

        // testOp(browser, ""SQL Minify"", ""test input"", ""test_output"");

        // testOp(browser, ""SSDEEP"", ""test input"", ""test_output"");

        // testOp(browser, ""SUB"", ""test input"", ""test_output"");

        // testOp(browser, ""Scan for Embedded Files"", ""test input"", ""test_output"");

        // testOp(browser, ""Scatter chart"", ""test input"", ""test_output"");

        // testOp(browser, ""Scrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""Series chart"", ""test input"", ""test_output"");

        // testOp(browser, ""Set Difference"", ""test input"", ""test_output"");

        // testOp(browser, ""Set Intersection"", ""test input"", ""test_output"");

        // testOp(browser, ""Set Union"", ""test input"", ""test_output"");

        // testOp(browser, ""Shake"", ""test input"", ""test_output"");

        // testOp(browser, ""Sharpen Image"", ""test input"", ""test_output"");

        // testOp(browser, ""Show Base64 offsets"", ""test input"", ""test_output"");

        // testOp(browser, ""Show on map"", ""test input"", ""test_output"");

        // testOp(browser, ""Sleep"", ""test input"", ""test_output"");

        // testOp(browser, ""Snefru"", ""test input"", ""test_output"");

        // testOp(browser, ""Sort"", ""test input"", ""test_output"");

        // testOp(browser, ""Split"", ""test input"", ""test_output"");

        // testOp(browser, ""Split Colour Channels"", ""test input"", ""test_output"");

        // testOp(browser, ""Standard Deviation"", ""test input"", ""test_output"");

        // testOp(browser, ""Streebog"", ""test input"", ""test_output"");

        // testOp(browser, ""Strings"", ""test input"", ""test_output"");

        // testOp(browser, ""Strip HTML tags"", ""test input"", ""test_output"");

        // testOp(browser, ""Strip HTTP headers"", ""test input"", ""test_output"");

        // testOp(browser, ""Subsection"", ""test input"", ""test_output"");

        // testOp(browser, ""Substitute"", ""test input"", ""test_output"");

        // testOp(browser, ""Subtract"", ""test input"", ""test_output"");

        // testOp(browser, ""Sum"", ""test input"", ""test_output"");

        // testOp(browser, ""Swap endianness"", ""test input"", ""test_output"");

        // testOp(browser, ""Symmetric Difference"", ""test input"", ""test_output"");

        // testOp(browser, ""Syntax highlighter"", ""test input"", ""test_output"");

        // testOp(browser, ""TCP/IP Checksum"", ""test input"", ""test_output"");

        // testOp(browser, ""Tail"", ""test input"", ""test_output"");

        // testOp(browser, ""Take bytes"", ""test input"", ""test_output"");

        // testOp(browser, ""Tar"", ""test input"", ""test_output"");

        // testOp(browser, ""Text Encoding Brute Force"", ""test input"", ""test_output"");

        // testOp(browser, ""To BCD"", ""test input"", ""test_output"");

        // testOp(browser, ""To Base"", ""test input"", ""test_output"");

        // testOp(browser, ""To Base32"", ""test input"", ""test_output"");

        // testOp(browser, ""To Base58"", ""test input"", ""test_output"");

        // testOp(browser, ""To Base62"", ""test input"", ""test_output"");

        // testOp(browser, ""To Base64"", ""test input"", ""test_output"");

        // testOp(browser, ""To Base85"", ""test input"", ""test_output"");

        // testOp(browser, ""To Binary"", ""test input"", ""test_output"");

        // testOp(browser, ""To Braille"", ""test input"", ""test_output"");

        // testOp(browser, ""To Camel case"", ""test input"", ""test_output"");

        // testOp(browser, ""To Case Insensitive Regex"", ""test input"", ""test_output"");

        // testOp(browser, ""To Charcode"", ""test input"", ""test_output"");

        // testOp(browser, ""To Decimal"", ""test input"", ""test_output"");

        // testOp(browser, ""To HTML Entity"", ""test input"", ""test_output"");

        // testOp(browser, ""To Hex"", ""test input"", ""test_output"");

        // testOp(browser, ""To Hex Content"", ""test input"", ""test_output"");

        // testOp(browser, ""To Hexdump"", ""test input"", ""test_output"");

        // testOp(browser, ""To Kebab case"", ""test input"", ""test_output"");

        // testOp(browser, ""To Lower case"", ""test input"", ""test_output"");

        // testOp(browser, ""To MessagePack"", ""test input"", ""test_output"");

        // testOp(browser, ""To Morse Code"", ""test input"", ""test_output"");

        // testOp(browser, ""To Octal"", ""test input"", ""test_output"");

        // testOp(browser, ""To Punycode"", ""test input"", ""test_output"");

        // testOp(browser, ""To Quoted Printable"", ""test input"", ""test_output"");

        // testOp(browser, ""To Snake case"", ""test input"", ""test_output"");

        // testOp(browser, ""To Table"", ""test input"", ""test_output"");

        // testOp(browser, ""To UNIX Timestamp"", ""test input"", ""test_output"");

        // testOp(browser, ""To Upper case"", ""test input"", ""test_output"");

        // testOp(browser, ""Translate DateTime Format"", ""test input"", ""test_output"");

        // testOp(browser, ""Triple DES Decrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""Triple DES Encrypt"", ""test input"", ""test_output"");

        // testOp(browser, ""Typex"", ""test input"", ""test_output"");

        // testOp(browser, ""UNIX Timestamp to Windows Filetime"", ""test input"", ""test_output"");

        // testOp(browser, ""URL Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""URL Encode"", ""test input"", ""test_output"");

        // testOp(browser, ""Unescape string"", ""test input"", ""test_output"");

        // testOp(browser, ""Unescape Unicode Characters"", ""test input"", ""test_output"");

        // testOp(browser, ""Unique"", ""test input"", ""test_output"");

        // testOp(browser, ""Untar"", ""test input"", ""test_output"");

        // testOp(browser, ""Unzip"", ""test input"", ""test_output"");

        // testOp(browser, ""VarInt Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""VarInt Encode"", ""test input"", ""test_output"");

        // testOp(browser, ""View Bit Plane"", ""test input"", ""test_output"");

        // testOp(browser, ""Vigenère Decode"", ""test input"", ""test_output"");

        // testOp(browser, ""Vigenère Encode"", ""test input"", ""test_output"");

        // testOp(browser, ""Whirlpool"", ""test input"", ""test_output"");

        // testOp(browser, ""Windows Filetime to UNIX Timestamp"", ""test input"", ""test_output"");

        // testOp(browser, ""XKCD Random Number"", ""test input"", ""test_output"");

        // testOp(browser, ""XML Beautify"", ""test input"", ""test_output"");

        // testOp(browser, ""XML Minify"", ""test input"", ""test_output"");

        // testOp(browser, ""XOR"", ""test input"", ""test_output"");

        // testOp(browser, ""XOR Brute Force"", ""test input"", ""test_output"");

        // testOp(browser, ""XPath expression"", ""test input"", ""test_output"");

        // testOp(browser, ""YARA Rules"", ""test input"", ""test_output"");

        // testOp(browser, ""Zip"", ""test input"", ""test_output"");

        // testOp(browser, ""Zlib Deflate"", ""test input"", ""test_output"");

        // testOp(browser, ""Zlib Inflate"", ""test input"", ""test_output"");
","describe(""My Test"", function() {
  it(""Does something"", function() {
    expect(true).toBe(true);
  });
});",0.8645817587631123,0.9693415381683453,0.9694939714603751,0.9194915254237288,0.6,0.3665492342791543,4.2604211065608013e-106,9.524220136302447e-05,0.4661016949152542,0.0,0.37396993355767105,2.142171676305445e-104,8.141490295304881e-05,0.4957983193277311,0.0
2,"}

function initGreeter() {

    let shellContainer = document.getElementById(""main_shell"");

    let greeter = document.getElementById(""main_shell_greeting"");

    require(""systeminformation"").users()

        .then((userlist) => {

            greeter.innerHTML += `Welcome back, <em>${userlist[0].user}</em>`;

        })

        .catch(() => {

            greeter.innerHTML += ""Welcome back"";

    .then(() => {

        greeter.setAttribute(""style"", ""opacity: 1;"");

        setTimeout(() => {

            greeter.setAttribute(""style"", ""opacity: 0;"");

            setTimeout(() => {

                greeter.remove();

                setTimeout(() => {

                    shellContainer.innerHTML += `

                        <ul id=""main_shell_tabs"">

                            <li id=""shell_tab0"" onclick=""window.focusShellTab(0);"" class=""active"">MAIN SHELL</li>

                            <li id=""shell_tab1"" onclick=""window.focusShellTab(1);"">EMPTY</li>

                            <li id=""shell_tab2"" onclick=""window.focusShellTab(2);"">EMPTY</li>

                            <li id=""shell_tab3"" onclick=""window.focusShellTab(3);"">EMPTY</li>

                            <li id=""shell_tab4"" onclick=""window.focusShellTab(4);"">EMPTY</li>

                        </ul>

                        <div id=""main_shell_innercontainer"">

                            <pre id=""terminal0"" class=""active""></pre>

                            <pre id=""terminal1""></pre>

                            <pre id=""terminal2""></pre>

                            <pre id=""terminal3""></pre>

                            <pre id=""terminal4""></pre>

                        </div>`;

                    window.term = {

                        0: new Terminal({

                            role: ""client"",

                            parentId: ""terminal0"",

                            port: window.settings.port || 3000

                        })

                    };

                    window.currentTerm = 0;

                    window.term[0].onprocesschange = p => {

                        document.getElementById(""shell_tab0"").innerText = ""MAIN - ""+p;

                    };

                    // Prevent losing hardware keyboard focus on the terminal when using touch keyboard

                    window.onmouseup = (e) => {

                        if (window.keyboard.linkedToTerm) window.term[window.currentTerm].term.focus();

                    };

                    window.term[0].term.writeln(""\033[1m""+`Welcome to eDEX-UI v${electron.remote.app.getVersion()} - Electron v${process.versions.electron}`+""\033[0m"");



                    window.fsDisp = new FilesystemDisplay({

                        parentId: ""filesystem""

                    });

                    setTimeout(() => {

                        document.getElementById(""filesystem"").setAttribute(""style"", ""opacity: 1;"");

                        window.updateCheck = new UpdateChecker();

                    }, 300);

                }, 100);

            }, 500);

        }, 1100);

window.themeChanger = (theme) => {

window.remakeKeyboard = (layout) => {
","    await _delay(100);

    // Initialize the terminal

    let shellContainer = document.getElementById(""main_shell"");

    shellContainer.innerHTML += `

        <ul id=""main_shell_tabs"">

            <li id=""shell_tab0"" onclick=""window.focusShellTab(0);"" class=""active"">MAIN SHELL</li>

            <li id=""shell_tab1"" onclick=""window.focusShellTab(1);"">EMPTY</li>

            <li id=""shell_tab2"" onclick=""window.focusShellTab(2);"">EMPTY</li>

            <li id=""shell_tab3"" onclick=""window.focusShellTab(3);"">EMPTY</li>

            <li id=""shell_tab4"" onclick=""window.focusShellTab(4);"">EMPTY</li>

        </ul>

        <div id=""main_shell_innercontainer"">

            <pre id=""terminal0"" class=""active""></pre>

            <pre id=""terminal1""></pre>

            <pre id=""terminal2""></pre>

            <pre id=""terminal3""></pre>

            <pre id=""terminal4""></pre>

        </div>`;

    window.term = {

        0: new Terminal({

            role: ""client"",

            parentId: ""terminal0"",

            port: window.settings.port || 3000

    };

    window.currentTerm = 0;

    window.term[0].onprocesschange = p => {

        document.getElementById(""shell_tab0"").innerText = ""MAIN - ""+p;

    };

    // Prevent losing hardware keyboard focus on the terminal when using touch keyboard

    window.onmouseup = (e) => {

        if (window.keyboard.linkedToTerm) window.term[window.currentTerm].term.focus();

    };

    window.term[0].term.writeln(""\033[1m""+`Welcome to eDEX-UI v${electron.remote.app.getVersion()} - Electron v${process.versions.electron}`+""\033[0m"");



    await _delay(100);

    window.fsDisp = new FilesystemDisplay({

        parentId: ""filesystem""



    await _delay(200);



    document.getElementById(""filesystem"").setAttribute(""style"", ""opacity: 1;"");



    await _delay(200);



    window.updateCheck = new UpdateChecker();

window.themeChanger = theme => {

window.remakeKeyboard = layout => {
","async function initGreeter() {
  let shellContainer = document.getElementById(""main_shell"");
  let greeter = document.getElementById(""main_shell_greeting"");

  try {
    const userlist = await require(""systeminformation"").users();
    greeter.innerHTML += `Welcome back, <em>${userlist[0].user}</em>`;
  } catch (err) {
    greeter.innerHTML += ""Welcome back"";
  } finally {
    greeter.setAttribute(""style"", ""opacity: 1;"");
    setTimeout(() => {
      greeter.setAttribute(""style"", ""opacity: 0;"");
      setTimeout(() => {
        greeter.remove();
        setTimeout(() => {
          shellContainer.innerHTML += `
            <ul id=""main_shell_tabs"">
              <li id=""shell_tab0"" onclick=""window.focusShellTab(0);"" class=""active"">MAIN SHELL</li>
              <li id=""shell_tab1"" onclick=""window.focusShellTab(1);"">EMPTY</li>
              <li id=""shell_tab2"" onclick=""window.focusShellTab(2);"">EMPTY</li>
              <li id=""shell_tab3"" onclick=""window.focusShellTab(3);"">EMPTY</li>
              <li id=""shell_tab4"" onclick=""window.focusShellTab(4);"">EMPTY</li>
            </ul>
            <div id=""main_shell_innercontainer"">
              <pre id=""terminal0"" class=""active""></pre>
              <pre id=""terminal1""></pre>
              <pre id=""terminal2""></pre>
              <pre id=""terminal3""></pre>
              <pre id=""terminal4""></pre>
            </div>`;
          window.term = {
            0: new Terminal({
              role: ""client"",
              parentId: ""terminal0"",
              port: window.settings.port || 3000,
            }),
          };
          window.currentTerm = 0;
          window.term[0].onprocesschange = (p) => {
            document.getElementById(""shell_tab0"").innerText = ""MAIN - "" + p;
          };
        }, 100);
      }, 500);
    }, 1100);
  }
}",0.46984067623076686,0.5749914966277376,0.6018311013434582,0.5775401069518716,0.125,0.5387929974799456,0.5098540675385961,0.5399257655184411,0.6470588235294118,0.4583333333333333,0.4078863876111513,0.47800667019685383,0.4670523937612651,0.4864864864864865,0.2
3,"        // TODO: rewrite tests with async/await once node 6 support is dropped

                return produce(base, d => {

                    return Promise.resolve().then(() => {

                        d.b = 1

                    })
","                return produce(base, async d => {

                    await Promise.resolve()

                    d.b = 1
","async function produce(base) {

d.b = 1

}",0.38759702319950534,0.04992898872603337,0.07188767550055941,0.42857142857142855,1.0,0.3709806629576039,0.04129045950128635,0.08548933518627205,0.35714285714285715,0.0,0.4110655500769509,0.1073525213116119,0.09246523455174717,0.4444444444444444,0.0
4,"  var errors = [];

  var results = Promise.all(_.map(collection, function (...args) {

    return new Promise(function (resolve, reject) {

      Fiber(function () {

        try {

          resolve(callback.apply(context, args));

        } catch (err) {

          reject(err);

        }

      }).run();

    }).catch(function (error) {
","  const errors = [];

  const results = Promise.all(_.map(collection, (...args) => {

    async function run() {

      return callback.apply(context, args);

    }



    return run().catch(error => {
","async function () {
  var errors = [];

  try {
    const results = await Promise.all(
      collection.map((args) => {
        return new Promise((resolve, reject) => {
          Fiber(() => {
            try {
              resolve(callback.apply(context, args));
            } catch (err) {
              reject(err);
            }
          }).run();
        });
      })
    );
  } catch (error) {
    errors.push(error);
  }
}",0.2022078675963893,0.05481883852816072,0.05671533456009915,0.2972972972972973,0.4,0.5666102553016814,0.34569079801776526,0.4991286015673386,0.6216216216216216,0.8,0.4124317791858638,0.04761298946116124,0.10211412728229412,0.5,1.0
5,"    let lastSendMessagePromise = Promise.resolve();

    function sendMessageAsync(message) {

      // Keep the messages strictly ordered, one after the last.

      return lastSendMessagePromise =

        lastSendMessagePromise.then(both, both);



      function both() {

        return new Promise((resolve, reject) => {

          appProcess.proc.send(message, error => {

            error ? reject(error) : resolve();

          });

        });

      }

    }



    function refreshClient(arch) {

        sendMessageAsync({

          ""package"": ""webapp"",

          ""method"": ""generateClientProgram"",

          ""args"": [arch],

      return sendMessageAsync({
","    async function refreshClient(arch) {

        await appProcess.proc.sendMessage(""webapp"", {

          method: ""generateClientProgram"",

          args: [arch],

      await appProcess.proc.sendMessage(""autoupdate"", {
","let lastSendMessagePromise = Promise.resolve();

async function sendMessageAsync(message) {
  try {
    await lastSendMessagePromise;
    const result = await both();
    return result;
  } catch (error) {
    console.error(error);
  }
}

function refreshClient(arch) {
  sendMessageAsync({
    ""package"": ""webapp"",
    ""method"": ""generateClientProgram"",
    ""args"": [arch],
  }).then((result) => {
    // handle result
  }).catch((error) => {
    console.error(error);
  });
}",0.11205651862338592,0.004349979731748814,0.019963051283534008,0.25,0.17391304347826086,0.42255928856590486,0.2991045853896187,0.30145865583052245,0.4375,0.6521739130434783,0.29859615747238644,0.030421991288759425,0.11850809314624089,0.5454545454545454,0.5
6,"        postStartupCallbacks.push(({

          // Build and write the target in one step.

          writeClientTarget(makeClientTarget(app, arch, { minifiers }));

          return refreshClient(arch).then(() => {

            runLog.log(`Finished delayed build of ${arch} in ${

              new Date - start

            }ms`, { arrow: true });

          });
","        postStartupCallbacks.push(async ({

          pauseClient,

          // Build the target first.

          const target = makeClientTarget(app, arch, { minifiers });



          // Tell the webapp package to pause responding to requests from

          // clients that use this arch, because we're about to write a

          // new version of this bundle to disk.

          await pauseClient(arch);



          // Now write the target to disk. Note that we are rewriting the

          // bundle in place, so this work is not atomic by any means,

          // which is why we needed to pause the client.

          writeClientTarget(target);



          // Refresh and unpause the client, now that writing is finished.

          await refreshClient(arch);

          runLog.log(`Finished delayed build of ${arch} in ${

            new Date - start

          }ms`, { arrow: true });
","async function postStartupCallback() {
    // Build and write the target in one step.
    const clientTarget = makeClientTarget(app, arch, { minifiers });
    await refreshClient(arch);
    runLog.log(`Finished delayed build of ${arch} in ${new Date - start}ms`, { arrow: true });
  }",0.4878685593411639,0.16130190044369655,0.5309130776616999,0.5925925925925926,0.6666666666666666,0.6332201505451962,0.4445030852400686,0.4587478873110866,0.6296296296296297,1.0,0.37889583443017905,0.05707128368513317,0.14369723922076827,0.8148148148148148,0.5
7,"    const f = new Future();

    CssTools.minifyCssAsync(cssText)

      .then((res) => f.return(res))

      .catch((error) => f.throw(error));

    // Since this function has always returned an array, we'll wrap the

    // minified css string in an array before returning, even though we're

    // only ever returning one minified css string in that array (maintaining

    // backwards compatibility).

    return f.wait();
","    return Promise.await(CssTools.minifyCssAsync(cssText));
","const f = new Future();
async function minifyCssAsync(cssText) {
  try {
    const res = await CssTools.minifyCssAsync(cssText);
    return [res];
  } catch (error) {
    throw error;
  }
}",0.33736814560820766,1.2596016258905822e-12,0.004644996224674396,0.3448275862068966,0.0,0.34740415176189304,0.052073419335934394,0.08466962449324705,0.5862068965517241,0.6666666666666666,0.41929257056017066,0.0072658577559704465,0.1699044244847123,0.5,0.0
8,"  (test, onComplete) => {

    Promise.all(promises).then(() => onComplete());
","  async (test) => {

    return Promise.all(promises);
","async (test, onComplete) => {

    await Promise.all(promises);
    onComplete();

}",0.3326083939028692,0.07308015504567583,0.06985342056580097,0.1875,0.0,0.5211520516253755,0.2984745896009823,0.41113361690051975,0.375,1.0,0.37100019682459884,0.06030725360407769,0.09036020036098448,0.3333333333333333,0.0
9,"  return hashPassword(newPlaintextPassword).then(hash => {

    const update = {

      $unset: {

        'services.password.reset': 1

      },

      $set: {'services.password.bcrypt': hash}

    };

    if (options.logout) {

      update.$unset['services.resume.loginTokens'] = 1;

    }

    Meteor.users.update({_id: user._id}, update);

  });
","  const update = {

    $unset: {

      'services.password.reset': 1

    },

    $set: {'services.password.bcrypt': await hashPassword(newPlaintextPassword)}

  };

  if (options.logout) {

    update.$unset['services.resume.loginTokens'] = 1;

  }

  Meteor.users.update({_id: user._id}, update);

};



/**

 * @summary Forcibly change the password for a user.

 * @locus Server

 * @param {String} userId The id of the user to update.

 * @param {String} newPassword A new password for the user.

 * @param {Object} [options]

 * @param {Object} options.logout Logout all current connections with this userId (default: true)

 * @importFromPackage accounts-base

 */

Accounts.setPassword = (userId, newPlaintextPassword, options) => {

  return Promise.await(Accounts.setPasswordAsync(userId, newPlaintextPassword, options));
","async function updateUser(user) {
  const hash = await hashPassword(newPlaintextPassword);
  const update = {
    $unset: {
      'services.password.reset': 1,
    },
    $set: {
      'services.password.bcrypt': hash,
    }
  };
  if (options.logout) {
    update.$unset['services.resume.loginTokens'] = 1;
  }
  Meteor.users.update({ _id: user._id }, update);
}",0.5641878585578122,0.22034276891730753,0.7513963803016561,0.6486486486486487,0.6363636363636364,0.5525984736512648,0.3652642912887372,0.48886424705096554,0.8108108108108109,0.5454545454545454,0.32040640642293455,0.08553574549938771,0.15034519934128668,0.5957446808510638,0.45
10,"      promise.then((result) => {

      }, (exception) => {

      });
","      try {

        const result = Promise.await(promise);

      } catch (exception) {

      }
","async function promise() {
  try {
    const result = await promise;
    // do something with result
  } catch (exception) {
    // handle exception
  }
}",0.33352280250360644,0.024808415001701823,0.03655552228545124,0.2727272727272727,0.0,0.3070859817745444,0.009970222994544455,0.03655552228545124,0.18181818181818182,0.0,0.32591043117296464,0.2425056620207466,0.611136062671112,0.2,0.25
11,"  _doneQuerying: function () {

    const afterCaughtUp = () => {

      if (self._stopped)

        return;

      if (self._phase !== PHASE.QUERYING)

        throw Error(""Phase unexpectedly "" + self._phase);



      Meteor._noYieldsAllowed(function () {

        if (self._requeryWhenDoneThisQuery) {

          self._requeryWhenDoneThisQuery = false;

          self._pollQuery();

        } else if (self._needToFetch.empty()) {

          self._beSteady();

        } else {

          self._fetchModifiedDocuments();

        }

      });

    };

    if (Meteor._isFibersEnabled) {

      self._mongoHandle._oplogHandle.waitUntilCaughtUp();  // yields

      return afterCaughtUp();

    }

    // TODO -> Should we wait? This doesn't make much sense without Fibers.

    return self._mongoHandle._oplogHandle.waitUntilCaughtUp().then(afterCaughtUp);
","  _doneQuerying: async function () {

    await self._mongoHandle._oplogHandle.waitUntilCaughtUp();

    if (self._stopped)

      return;

    if (self._phase !== PHASE.QUERYING)

      throw Error(""Phase unexpectedly "" + self._phase);

    await Meteor._noYieldsAllowed(async function () {

      if (self._requeryWhenDoneThisQuery) {

        self._requeryWhenDoneThisQuery = false;

        self._pollQuery();

      } else if (self._needToFetch.empty()) {

        await self._beSteady();

      } else {

        self._fetchModifiedDocuments();

      }

    });
","_doneQuerying: async function () {
    const afterCaughtUp = await self._mongoHandle._oplogHandle.waitUntilCaughtUp();
    if (self._stopped) return;
    if (self._phase !== PHASE.QUERYING) throw Error(""Phase unexpectedly "" + self._phase);
    Meteor._noYieldsAllowed(function () {
      if (self._requeryWhenDoneThisQuery) {
        self._requeryWhenDoneThisQuery = false;
        self._pollQuery();
      } else if (self._needToFetch.empty()) {
        self._beSteady();
      } else {
        self._fetchModifiedDocuments();
      }
    });
  },",0.3988494279476597,0.4100706552063641,0.46259280159195526,0.6904761904761905,0.03225806451612903,0.4998917306393864,0.5121408442155846,0.5726795345631595,0.7857142857142857,0.12903225806451613,0.596728485973902,0.7802818594780947,0.7793593571447858,0.7272727272727273,0.1
12,"    // Build the output from scratch

    if (resetBuildPath) {

      files.rm_recursive(this.buildPath).then(() => {

        files.mkdir_p(this.buildPath, 0o755);

        this.watchSet = new WatchSet();

      });

    }
","    this.resetBuildPath = resetBuildPath;

  async init() {

    // Build the output from scratch

    if (this.resetBuildPath) {

      await files.rm_recursive(this.buildPath);

      files.mkdir_p(this.buildPath, 0o755);

      this.watchSet = new WatchSet();

    }

  }


","// Build the output from scratch

if (resetBuildPath) {

  await files.rm_recursive(this.buildPath);
  files.mkdir_p(this.buildPath, 0o755);
  this.watchSet = new WatchSet();

}",0.6506302605639551,0.4371574283724135,0.5653636138834072,0.6,1.0,0.7277877475360424,0.651158213392685,0.6599927767514843,0.6,1.0,0.5893816895056101,0.5689755298265016,0.6099797996245104,0.6785714285714286,0.5
13,"        Promise.resolve().then(() => {

          try {

            files.rm_recursive(wildcardCacheFilename);

          } finally {

            files.writeFileAtomically(cacheFilename, retAsJSON);

          }

        });
","        try {

          await files.rm_recursive(wildcardCacheFilename);

        } finally {

          await files.writeFileAtomically(cacheFilename, retAsJSON);

        }
","async function () {
  try {
    files.rm_recursive(wildcardCacheFilename);
    await files.writeFileAtomically(cacheFilename, retAsJSON);
  } finally {}
}",0.4859488188534169,0.31530788046040353,0.32413956886630757,0.30434782608695654,1.0,0.500501285224277,0.2865612242047131,0.32413956886630757,0.391304347826087,1.0,0.5283742278407739,0.25400289715190977,0.3261606808778524,0.5333333333333333,1.0
14,"    function startMongo(tries = 3) {

      self._startMongoAsync().then(

        ok => unblockAppRunner(),

        error => {

          --tries;

          const left = tries + (tries === 1 ? "" try"" : "" tries"");

          Console.error(

          );



          if (tries > 0) {

            self.mongoRunner.stop();

            setTimeout(() => startMongo(tries), 1000);

          } else {

            self.mongoRunner._fail();

          }

      );

    startMongo();

      self.updater.start();

      self.hmrServer.start();
","    async function startMongo(tries = 3) {

      try {

        await self._startMongoAsync();

        await unblockAppRunner();

      } catch (error) {

        --tries;

        const left = tries + (tries === 1 ? "" try"" : "" tries"");

        Console.error(

        );



        if (tries > 0) {

          await self.mongoRunner.stop();

          await setTimeout(() => startMongo(tries), 1000);

        } else {

          await self.mongoRunner._fail();



      }

    await startMongo();

      await self.updater.start();

      await self.hmrServer.start();
","async function startMongo(tries = 3) {
    let ok;
    try {
        const res = await self._startMongoAsync();
        if (res) {
            unblockAppRunner();
        } else {
            --tries;
            const left = tries + (tries === 1 ? "" try"" : "" tries"");
            Console.error(left + "" left."");
            if (tries > 0) {
                self.mongoRunner.stop();
                setTimeout(() => startMongo(tries), 1000);
            } else {
                self.mongoRunner._fail();
            }
        }
    } catch (e) {
        --tries;
        const left = tries + (tries === 1 ? "" try"" : "" tries"");
        Console.error(left + "" left."");
        if (tries > 0) {
            self.mongoRunner.stop();
            setTimeout(() => startMongo(tries), 1000);
        } else {
            self.mongoRunner._fail();
        }
    }
}
startMongo();
self.updater.start();
self.hmrServer.start();",0.7554129619015302,0.5727465114485696,0.6908408200285192,0.7580645161290323,1.0,0.6670006071214558,0.3340451128206799,0.7164457949278159,0.9032258064516129,0.7142857142857143,0.5472042368348704,0.31621482839725407,0.5316497379898466,0.6266666666666667,0.7142857142857143
15,"  findMongoPids = function(dbDir_unused, port) {

    return new Promise((resolve, reject) => {

      child_process.exec('tasklist /fi ""IMAGENAME eq mongod.exe""', function(

        error,

        stdout,

        stderr

      ) {

        if (error) {

          var additionalInfo = JSON.stringify(error);

          if (error.code === 'ENOENT') {

            additionalInfo =

              ""tasklist wasn't found on your system, it usually can be found at C:\\Windows\\System32\\."";

          reject(

            new Error(""Couldn't run tasklist.exe: "" + additionalInfo)

          );

          return;

        } else {

          // Find the pids of all mongod processes

          var mongo_pids = [];

          stdout.split('\n')

            .forEach(function(line) {

              var m = line.match(/^mongod.exe\s+(\d+) /);

              if (m) {

                mongo_pids[m[1]] = true;

              }

            });



          // Now get the corresponding port numbers

          child_process.exec(

            'netstat -ano',

            { maxBuffer: 1024 * 1024 * 10 },

            function(error, stdout, stderr) {

              if (error) {

                promise.reject(

                  new Error(""Couldn't run netstat -ano: "" + JSON.stringify(error))

                return;

              } else {

                var pids = [];

                stdout.split('\n')

                  .forEach(function(line) {

                    var m = line.match(

                      /^\s*TCP\s+\S+:(\d+)\s+\S+\s+LISTENING\s+(\d+)/

                    );

                    if (m) {

                      var found_pid = parseInt(m[2], 10);

                      var found_port = parseInt(m[1], 10);



                      // We can't check the path app_dir so assume it always matches

                      if (mongo_pids[found_pid] && (!port || port === found_port)) {

                        // Note that if the mongo rest interface is enabled the

                        // initial port + 1000 is also likely to be open.

                        // So remove the pid so we only match it once.

                        delete mongo_pids[found_pid];

                        pids.push({

                          pid: found_pid,

                          port: found_port,

                          app_dir: null,

                        });

                      }

                    }

                  });



                resolve(pids);

              }

          );

        }

      });

  findMongoPids = function(dbDir, port) {

    return new Promise((resolve, reject) => {



      // 'ps ax' should be standard across all MacOS and Linux.

      // However, ps on OS X corrupts some non-ASCII characters in arguments,

      // such as т (CYRILLIC SMALL LETTER TE), leading to this function

      // failing to properly match pathnames with those characters.  #3999

      //

      // pgrep appears to do a better job (and has output that is roughly

      // similar; it lacks a few fields that we don't care about).  Plus,

      // it can do some of the grepping for us.

      //

      // However, 'pgrep' only started shipping with OS X 10.8 (and may be less

      // common on Linux too), so we check to see if it exists and fall back to

      // 'ps' if we can't find it.

      //

      // We avoid using pgrep on Linux, because some versions of Linux pgrep

      // require you to pass -a/--list-full to include the arguments in the

      // output, and other versions fail if you pass that option. We have not

      // observed the Unicode corruption on Linux, so using ps ax there is fine.

      var psScript = 'ps ax';

      if (process.platform === 'darwin') {

        psScript =

          'if type pgrep >/dev/null 2>&1; then ' +

          // -lf means to display and match against full argument lists.

          // pgrep exits 1 if no processes match the argument; we're OK

          // considering this as a success, but we don't want other errors

          // to be ignored.  Note that this is sh not bash, so we can't use

          // [[.

          'pgrep -lf mongod; test ""$?"" -eq 0 -o ""$?"" -eq 1;' +

          'else ps ax; fi';

      }



      // If the child process output includes unicode, make sure it's

      // handled properly.

      const {

        LANG = 'en_US.UTF-8',

        LC_ALL = LANG,

        LANGUAGE = LANG,

        // Remainder of process.env without above properties.

        ...env

      } = process.env;



      // Make sure all three properties are set to the same value, which

      // defaults to ""en_US.UTF-8"" or whatever LANG was already set to.

      Object.assign(env, {

        LANG,

        LC_ALL,

        LANGUAGE

      });

      child_process.exec(

        psScript,

        {

          env,

          // we don't want this to randomly fail just because you're running

          // lots of processes. 10MB should be more than ps ax will ever

          // spit out; the default is 200K, which at least one person hit

          // (#2158).

          maxBuffer: 1024 * 1024 * 10,

        },

        function(error, stdout, stderr) {

          if (error) {

            reject(

              new Error(

                ""Couldn't run ps ax: "" +

              )

            );

            return;

          var ret = [];

          stdout.split('\n')

            .forEach(function(line) {

              // Matches mongos we start. Note that this matches

              // 'fake-mongod' (our mongod stub for automated tests) as well

              // as 'mongod'.

              var m = line.match(

                /^\s*(\d+).+mongod .+--port (\d+) --dbpath (.+(?:\/|\\)db)/

              );

              if (m && m.length === 4) {

                var foundPid = parseInt(m[1], 10);

                var foundPort = parseInt(m[2], 10);

                var foundPath = m[3];



                if (

                  (!port || port === foundPort) &&

                  (!dbDir || dbDir === foundPath)

                ) {

                  ret.push({

                    pid: foundPid,

                    port: foundPort,

                    dbDir: foundPath,

                  });

                }

              }

            });

          resolve(ret);

        }

      );

    });
","  findMongoPids = async function(dbDir_unused, port) {

    var promise = fiberHelpers.makeFulfillablePromise();

    child_process.exec('tasklist /fi ""IMAGENAME eq mongod.exe""', function(

      error,

      stdout,

      stderr

    ) {

      if (error) {

        var additionalInfo = JSON.stringify(error);

        if (error.code === 'ENOENT') {

          additionalInfo =

            ""tasklist wasn't found on your system, it usually can be found at C:\\Windows\\System32\\."";

        }

        promise.reject(

          new Error(""Couldn't run tasklist.exe: "" + additionalInfo)

        );

        return;

      } else {

        // Find the pids of all mongod processes

        var mongo_pids = [];

        stdout.split('\n').forEach(function(line) {

          var m = line.match(/^mongod.exe\s+(\d+) /);

          if (m) {

            mongo_pids[m[1]] = true;

        });



        // Now get the corresponding port numbers

        child_process.exec(

          'netstat -ano',

          { maxBuffer: 1024 * 1024 * 10 },

          function(error, stdout, stderr) {

            if (error) {

              promise.reject(

                new Error(""Couldn't run netstat -ano: "" + JSON.stringify(error))

              );

              return;

            } else {

              var pids = [];

              stdout.split('\n').forEach(function(line) {

                var m = line.match(

                  /^\s*TCP\s+\S+:(\d+)\s+\S+\s+LISTENING\s+(\d+)/

                if (m) {

                  var found_pid = parseInt(m[2], 10);

                  var found_port = parseInt(m[1], 10);



                  // We can't check the path app_dir so assume it always matches

                  if (mongo_pids[found_pid] && (!port || port === found_port)) {

                    // Note that if the mongo rest interface is enabled the

                    // initial port + 1000 is also likely to be open.

                    // So remove the pid so we only match it once.

                    delete mongo_pids[found_pid];

                    pids.push({

                      pid: found_pid,

                      port: found_port,

                      app_dir: null,

                    });

                  }

                }

              });



              promise.resolve(pids);

          }

        );

      }



    return await promise;

  findMongoPids = async function(dbDir, port) {

    var promise = fiberHelpers.makeFulfillablePromise();



    // 'ps ax' should be standard across all MacOS and Linux.

    // However, ps on OS X corrupts some non-ASCII characters in arguments,

    // such as т (CYRILLIC SMALL LETTER TE), leading to this function

    // failing to properly match pathnames with those characters.  #3999

    //

    // pgrep appears to do a better job (and has output that is roughly

    // similar; it lacks a few fields that we don't care about).  Plus,

    // it can do some of the grepping for us.

    //

    // However, 'pgrep' only started shipping with OS X 10.8 (and may be less

    // common on Linux too), so we check to see if it exists and fall back to

    // 'ps' if we can't find it.

    //

    // We avoid using pgrep on Linux, because some versions of Linux pgrep

    // require you to pass -a/--list-full to include the arguments in the

    // output, and other versions fail if you pass that option. We have not

    // observed the Unicode corruption on Linux, so using ps ax there is fine.

    var psScript = 'ps ax';

    if (process.platform === 'darwin') {

      psScript =

        'if type pgrep >/dev/null 2>&1; then ' +

        // -lf means to display and match against full argument lists.

        // pgrep exits 1 if no processes match the argument; we're OK

        // considering this as a success, but we don't want other errors

        // to be ignored.  Note that this is sh not bash, so we can't use

        // [[.

        'pgrep -lf mongod; test ""$?"" -eq 0 -o ""$?"" -eq 1;' +

        'else ps ax; fi';

    }

    // If the child process output includes unicode, make sure it's

    // handled properly.

    const {

      LANG = 'en_US.UTF-8',

      LC_ALL = LANG,

      LANGUAGE = LANG,

      // Remainder of process.env without above properties.

      ...env

    } = process.env;



    // Make sure all three properties are set to the same value, which

    // defaults to ""en_US.UTF-8"" or whatever LANG was already set to.

    Object.assign(env, { LANG, LC_ALL, LANGUAGE });



    child_process.exec(

      psScript,

      {

        env,

        // we don't want this to randomly fail just because you're running

        // lots of processes. 10MB should be more than ps ax will ever

        // spit out; the default is 200K, which at least one person hit

        // (#2158).

        maxBuffer: 1024 * 1024 * 10,

      },

      function(error, stdout, stderr) {

        if (error) {

          promise.reject(

            new Error(

              ""Couldn't run ps ax: "" +

            )

          );

          return;

        }



        var ret = [];

        stdout.split('\n').forEach(function(line) {

          // Matches mongos we start. Note that this matches

          // 'fake-mongod' (our mongod stub for automated tests) as well

          // as 'mongod'.

          var m = line.match(

            /^\s*(\d+).+mongod .+--port (\d+) --dbpath (.+(?:\/|\\)db)/

          );

          if (m && m.length === 4) {

            var foundPid = parseInt(m[1], 10);

            var foundPort = parseInt(m[2], 10);

            var foundPath = m[3];



            if (

              (!port || port === foundPort) &&

              (!dbDir || dbDir === foundPath)

            ) {

              ret.push({

                pid: foundPid,

                port: foundPort,

                dbDir: foundPath,

              });

            }

        });

        promise.resolve(ret);

      }

    );

    return await promise;
","findMongoPids = async function(dbDir_unused, port) {
  try {
    const childProcess = require('child_process');
    let mongoPids = [];
    await new Promise((resolve, reject) => {
      childProcess.exec('tasklist /fi ""IMAGENAME eq mongod.exe""', (error, stdout, stderr) => {
        if (error) {
          const additionalInfo = JSON.stringify(error);
          if (error.code === 'ENOENT') {
            additionalInfo = 'tasklist wasn\'t found on your system, it usually can be found at C:\\Windows\\System32\\.';
            reject(new Error(`Couldn't run tasklist.exe: ${additionalInfo}`));
          } else {
            // Find the pids of all mongod processes
            stdout.split('\n').forEach((line) => {
              const m = line.match(/^mongod.exe\s+(\d+) /);
              if (m) {
                mongoPids[m[1]] = true;
              }
            });
          }
        }
        resolve();
      });
    });
    await new Promise((resolve, reject) => {
      childProcess.exec('netstat -ano', { maxBuffer: 1024 * 1024 * 10 }, (error, stdout, stderr) => {
        if (error) {
          promise.reject(new Error(`Couldn't run netstat -ano: ${JSON.stringify(error)}`));
        } else {
          const pids = [];
          stdout.split('\n').forEach((line) => {
            const m = line.match(/^\s*TCP\s+\S+:(\d+)\s+\S+\s+LISTENING\s+(\d+)/);
            if (m) {
              const foundPid = parseInt(m[2], 10);
              const foundPort = parseInt(m[1], 10);
              // We can't check the path app_dir so assume it always matches
              if (mongoPids[foundPid] && (!port || port === foundPort)) {
                delete mongoPids[foundPid];
                pids.push({ pid: foundPid, port: foundPort, app_dir: null });
              }
            }
          });
          resolve(pids);
        }
      });
    });
  } catch (error) {
    throw error;
  }
}",0.8410140174727907,0.931453924602071,0.9311096079756586,0.8,0.7014925373134329,0.2670075682443556,0.034064354821098514,0.13230116499903347,0.5807692307692308,0.3208955223880597,0.25243653312977843,0.03169683232814544,0.12384233694145182,0.5492424242424242,0.3049645390070922
16,"  // Collect the data for this package, including looking up any specific

  // package version that we care about.

  return new Promise(resolve => {

    console.log('init .....');

    if (options.version) {

      var versionRecord = self._getVersionRecord(options.version);

      if (versionRecord.local) {

        self._getLocalVersion(versionRecord).then(res => {

          self.data = res;

          console.log('init .....', {res});

          resolve();

        });

      } else {

        self.data = self._getOfficialVersion(versionRecord);

      }



      self.data = self._collectPackageData();

      resolve();

  });

};



Object.assign(PackageQuery.prototype, {

  _getVersionRecord: function (version) {

    var versionRecord = self.localCatalog.getLatestVersion(self.name);
","  self.version = options.version;

};

Object.assign(PackageQuery.prototype, {

  init: async function() {

    const self = this;

    // Collect the data for this package, including looking up any specific

    // package version that we care about.

    if (self.version) {

      var versionRecord = await self._getVersionRecord(self.version);

      self.data = versionRecord.local ?

          await self._getLocalVersion(versionRecord) :

          await self._getOfficialVersion(versionRecord);

      self.data = await self._collectPackageData();

  },

  _getVersionRecord: async function (version) {

    var versionRecord = await self.localCatalog.getLatestVersion(self.name);
","async function getData() {
  console.log('init .....');
  try {
    const versionRecord = self._getVersionRecord(options.version);
    if (versionRecord.local) {
      self.data = await self._getLocalVersion(versionRecord);
      console.log('init .....', { res });
    } else {
      self.data = self._getOfficialVersion(versionRecord);
    }
    self.data = self._collectPackageData();
    return self.data;
  } catch (err) {
    console.error(err);
  }
}",0.3700809344702598,0.40911375059965405,0.41098010222391385,0.4533333333333333,0.20689655172413793,0.3475844441516948,0.22627733272312806,0.2537156162974444,0.6,0.3103448275862069,0.22084972856616464,0.02619801361939237,0.028899013852813255,0.5283018867924528,0.3
17,"  function (test, expect) {

    // var id1 = await ;

    // var id2 = await collection.insert({y: 2});

    Promise.all([collection.insert({x: 1}), collection.insert({y: 2})]).then(([id1, id2]) => {

      console.trace({id1, id2});

    });

    //

    // var fetcher = new DocFetcher(

    //   MongoInternals.defaultRemoteCollectionDriver().mongo);

    //

    // // Test basic operation.

    // const fakeOp1 = {};

    // const fakeOp2 = {};
","  async function (test, expect) {

    var id1 = await collection.insert({x: 1});

    var id2 = await collection.insert({y: 2});



    var fetcher = new DocFetcher(

      MongoInternals.defaultRemoteCollectionDriver().mongo);



    // Test basic operation.

    const fakeOp1 = {};

    const fakeOp2 = {};
","async function (test, expect) {

  // var id1 = await ;

  // var id2 = await collection.insert({y: 2});

  try {
    const [id1, id2] = await Promise.all([collection.insert({x: 1}), collection.insert({y: 2})]);

    console.trace({id1, id2});

  } catch (error) {
    console.error(error);
  }

  //

  // var fetcher = new DocFetcher(

  //   MongoInternals.defaultRemoteCollectionDriver().mongo);

  //

  // // Test basic operation.

  // const fakeOp1 = {};

  // const fakeOp2 = {};

}",0.4571122410884989,0.3528896923555703,0.40264260533175866,0.40625,0.6666666666666666,0.6628321155320787,0.6709897239480331,0.8240887381802813,0.65625,0.5,0.4543326896330332,0.33016785513649355,0.6109724272051632,0.34285714285714286,0.5333333333333333
18,"    Promise.resolve(

      Meteor.isServer &&

        collection.rawCollection().createIndex({ a: 1 })

    ).then(() => {

        collection.find({}, {

        }).count().then((count => {

            test.equal(count , 1);

            done();

        }));

    }).catch(error => test.fail(error.message));
","    if (Meteor.isServer) {

        await collection.rawCollection().createIndex({ a: 1 });

        const count = await collection.find({}, {

        }).count();

        test.equal(count , 1);

        done();

    }
","async function() {

  try{

    await Meteor.isServer && collection.rawCollection().createIndex({ a: 1 });

    const count = await collection.find({}, { }).count();

    test.equal(count, 1);

    done();

  }catch (error) {

      test.fail(error.message);

  }

}",0.37393318211933124,0.1707252267552746,0.17059573701616795,0.5294117647058824,0.625,0.4615268160927579,0.17510627354150773,0.20776569671187678,0.5882352941176471,0.875,0.7012960896913982,0.41647525275434744,0.5705272878294273,0.8181818181818182,1.0
19,"  LocalCollection.prototype[methodNameAsync] = function(...args) {

    return new Promise((resolve, reject) => self[methodName](...args,(err, result) => {

      if (err) {

        reject(err);

      } else {

        resolve(result);

      }

    }));
","  LocalCollection.prototype[methodNameAsync] = async function(...args) {

    return self[methodName](...args);
","LocalCollection.prototype[methodNameAsync] = async function(...args) {
  const result = await self[methodName](...args);
  return result;
};",0.11063582366254544,0.020906430630927734,0.05231868220107224,0.1875,0.18181818181818182,0.1728492202649178,0.022766590747557918,0.026584835766658776,0.1875,0.45454545454545453,0.6386812238093251,0.31455601883230705,0.668740304976422,0.5714285714285714,1.0
20,"runWebAppServer()

  .then(_ => _)

  .catch(e => {

    

  console.error(e.stack);

  process.exit(1);

})
","await runWebAppServer()


","async function runWebAppServer() {
  try {
    _ = await _; // use await to replace .then() callbacks
  } catch (e) {
    console.error(e.stack);
    process.exit(1);
  }
}",0.2786883145924798,0.002738826828955665,0.021105340631872645,0.09090909090909091,0.0,0.4017699703306725,0.04028998029112094,0.1122444464861146,0.45454545454545453,1.0,0.2967092636195499,0.009009113474307318,0.1778279410038923,0.0,0.0
21,"  it('get an empty list of roles for an empty user', function () {

    assert.sameMembers(Roles.getRolesForUser(undefined), [])

    assert.sameMembers(Roles.getRolesForUser(null), [])

    assert.sameMembers(Roles.getRolesForUser({}), [])

  })



  it('get an empty list of roles for non-existant user', function () {

    assert.sameMembers(Roles.getRolesForUser('1'), [])

    assert.sameMembers(Roles.getRolesForUser('1', 'scope1'), [])

  })



  it('can get all roles for user', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    const userId = users.eve

    let userObj



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj), [])



    Roles.addUsersToRoles(userId, ['admin', 'user'])



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId), ['admin', 'user'])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj), ['admin', 'user'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: null,

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }]

    }])

  })



  it('can get all roles for user by scope', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    const userId = users.eve

    let userObj



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), [])



    // add roles

    Roles.addUsersToRoles(userId, ['admin', 'user'], 'scope1')

    Roles.addUsersToRoles(userId, ['admin'], 'scope2')



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), ['admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope2'), ['admin'])

    assert.sameMembers(Roles.getRolesForUser(userId), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), ['admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope2'), ['admin'])

    assert.sameMembers(Roles.getRolesForUser(userObj), [])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }]

    }])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope2' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, anyScope: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }]

    }, {

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    Roles.createRole('PERMISSION')

    Roles.addRolesToParent('PERMISSION', 'user')



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope2' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope1' }), ['admin', 'user', 'PERMISSION'])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope2' }), ['admin'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, anyScope: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }, {

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { anyScope: true }), ['admin', 'user', 'PERMISSION'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope1', onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope2', onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope1', onlyAssigned: true }), ['admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope2', onlyAssigned: true }), ['admin'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, anyScope: true, onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }, {

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { anyScope: true, onlyAssigned: true }), ['admin', 'user'])

  })



  it('can get only scoped roles for user', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    const userId = users.eve



    // add roles

    Roles.addUsersToRoles(userId, ['user'], 'scope1')

    Roles.addUsersToRoles(userId, ['admin'])



    Roles.createRole('PERMISSION')

    Roles.addRolesToParent('PERMISSION', 'user')



    assert.sameMembers(Roles.getRolesForUser(userId, { onlyScoped: true, scope: 'scope1' }), ['user', 'PERMISSION'])

    assert.sameMembers(Roles.getRolesForUser(userId, { onlyScoped: true, onlyAssigned: true, scope: 'scope1' }), ['user'])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { onlyScoped: true, fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }])

  })



  it('can get all roles for user by scope with periods in name', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, ['admin'], 'example.k12.va.us')



    assert.sameMembers(Roles.getRolesForUser(users.joe, 'example.k12.va.us'), ['admin'])

  })



  it('can get all roles for user by scope including Roles.GLOBAL_SCOPE', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], Roles.GLOBAL_SCOPE)

    Roles.addUsersToRoles([users.eve], ['admin', 'user'], 'scope1')



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), ['editor', 'admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userId), ['editor'])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), ['editor', 'admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userObj), ['editor'])

  })



  it('getRolesForUser should not return null entries if user has no roles for scope', function () {

    Roles.createRole('editor')



    const userId = users.eve

    let userObj



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), [])

    assert.sameMembers(Roles.getRolesForUser(userId), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), [])

    assert.sameMembers(Roles.getRolesForUser(userObj), [])



    Roles.addUsersToRoles([users.eve], ['editor'], Roles.GLOBAL_SCOPE)



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), ['editor'])

    assert.sameMembers(Roles.getRolesForUser(userId), ['editor'])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), ['editor'])

    assert.sameMembers(Roles.getRolesForUser(userObj), ['editor'])

  })



  it('getRolesForUser should not fail during a call of addUsersToRoles', function () {

    Roles.createRole('editor')



    const userId = users.eve

    const promises = []

    const interval = setInterval(() => {

      promises.push(Promise.resolve().then(() => { Roles.getRolesForUser(userId) }))

    }, 0)



    Roles.addUsersToRoles([users.eve], ['editor'], Roles.GLOBAL_SCOPE)

    clearInterval(interval)



    return Promise.all(promises)

  })



  it('returns an empty list of scopes for null as user-id', function () {

    assert.sameMembers(Roles.getScopesForUser(undefined), [])

    assert.sameMembers(Roles.getScopesForUser(null), [])

    assert.sameMembers(Roles.getScopesForUser('foo'), [])

    assert.sameMembers(Roles.getScopesForUser({}), [])

    assert.sameMembers(Roles.getScopesForUser({ _id: 'foo' }), [])

  })



  it('can get all scopes for user', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], 'scope1')

    Roles.addUsersToRoles([users.eve], ['admin', 'user'], 'scope2')



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId), ['scope1', 'scope2'])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj), ['scope1', 'scope2'])

  })



  it('can get all scopes for user by role', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], 'scope1')

    Roles.addUsersToRoles([users.eve], ['editor', 'user'], 'scope2')



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'admin'), [])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'admin'), [])

  })



  it('getScopesForUser returns [] when not using scopes', function () {

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor', 'user'])



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId), [])

    assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'user']), [])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'user']), [])

  })



  it('can get all groups for user by role array', function () {

    const userId = users.eve



    Roles.createRole('user')

    Roles.createRole('editor')

    Roles.createRole('moderator')

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.eve], ['editor'], 'group1')

    Roles.addUsersToRoles([users.eve], ['editor', 'user'], 'group2')

    Roles.addUsersToRoles([users.eve], ['moderator'], 'group3')



    // by userId, one role

    assert.sameMembers(Roles.getScopesForUser(userId, ['user']), ['group2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['admin']), [])



    // by userId, multiple roles

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'user']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'moderator']), ['group1', 'group2', 'group3'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['user', 'moderator']), ['group2', 'group3'])



    // by user object, one role

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user']), ['group2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['admin']), [])



    // by user object, multiple roles

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'user']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'moderator']), ['group1', 'group2', 'group3'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user', 'moderator']), ['group2', 'group3'])

  })



  it('getting all scopes for user does not include GLOBAL_SCOPE', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], 'scope1')

    Roles.addUsersToRoles([users.eve], ['editor', 'user'], 'scope2')

    Roles.addUsersToRoles([users.eve], ['editor', 'user', 'admin'], Roles.GLOBAL_SCOPE)



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'admin'), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['user']), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['admin']), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['user', 'editor', 'admin']), ['scope1', 'scope2'])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'admin'), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user']), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['admin']), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user', 'editor', 'admin']), ['scope1', 'scope2'])

  })



  it('can get all users in role', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    Roles.addUsersToRoles([users.eve, users.joe], ['admin', 'user'])

    Roles.addUsersToRoles([users.bob, users.joe], ['editor'])



    const expected = [users.eve, users.joe]

    const actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)

  })



  it('can get all users in role by scope', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    Roles.addUsersToRoles([users.eve, users.joe], ['admin', 'user'], 'scope1')

    Roles.addUsersToRoles([users.bob, users.joe], ['admin'], 'scope2')



    let expected = [users.eve, users.joe]

    let actual = Roles.getUsersInRole('admin', 'scope1').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve, users.joe]

    actual = Roles.getUsersInRole('admin', { scope: 'scope1' }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob, users.joe]

    actual = Roles.getUsersInRole('admin', { anyScope: true }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

    assert.sameMembers(actual, [])

  })



  it('can get all users in role by scope including Roles.GLOBAL_SCOPE', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    Roles.addUsersToRoles([users.eve], ['admin', 'user'], Roles.GLOBAL_SCOPE)

    Roles.addUsersToRoles([users.bob, users.joe], ['admin'], 'scope2')



    let expected = [users.eve]

    let actual = Roles.getUsersInRole('admin', 'scope1').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob, users.joe]

    actual = Roles.getUsersInRole('admin', 'scope2').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve]

    actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob, users.joe]

    actual = Roles.getUsersInRole('admin', { anyScope: true }).fetch().map(r => r._id)



    assert.sameMembers(actual, expected)

  })



  it('can get all users in role by scope excluding Roles.GLOBAL_SCOPE', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.eve], ['admin'], Roles.GLOBAL_SCOPE)

    Roles.addUsersToRoles([users.bob], ['admin'], 'scope1')



    let expected = [users.eve]

    let actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob]

    actual = Roles.getUsersInRole('admin', { scope: 'scope1' }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    expected = [users.bob]

    actual = Roles.getUsersInRole('admin', { scope: 'scope1', onlyScoped: true }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)

  })



  it('can get all users in role by scope and passes through mongo query arguments', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    Roles.addUsersToRoles([users.eve, users.joe], ['admin', 'user'], 'scope1')

    Roles.addUsersToRoles([users.bob, users.joe], ['admin'], 'scope2')



    const results = Roles.getUsersInRole('admin', 'scope1', { fields: { username: 0 }, limit: 1 }).fetch()

  it('can use Roles.GLOBAL_SCOPE to assign blanket roles', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.joe, users.bob], ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', ['admin'], 'scope2')

    testUser('joe', ['admin'], 'scope1')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')



    Roles.removeUsersFromRoles(users.joe, ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', [], 'scope2')

    testUser('joe', [], 'scope1')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')

  })



  it('Roles.GLOBAL_SCOPE is independent of other scopes', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.joe, users.bob], ['admin'], 'scope5')

    Roles.addUsersToRoles([users.joe, users.bob], ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', ['admin'], 'scope5')

    testUser('joe', ['admin'], 'scope2')

    testUser('joe', ['admin'], 'scope1')

    testUser('bob', ['admin'], 'scope5')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')



    Roles.removeUsersFromRoles(users.joe, ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', ['admin'], 'scope5')

    testUser('joe', [], 'scope2')

    testUser('joe', [], 'scope1')

    testUser('bob', ['admin'], 'scope5')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')

  })



  it('Roles.GLOBAL_SCOPE also checked when scope not specified', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, 'admin', Roles.GLOBAL_SCOPE)



    testUser('joe', ['admin'])



    Roles.removeUsersFromRoles(users.joe, 'admin', Roles.GLOBAL_SCOPE)



    testUser('joe', [])

  })



  it('can use \'.\' in scope name', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, ['admin'], 'example.com')

    testUser('joe', ['admin'], 'example.com')

  })



  it('can use multiple periods in scope name', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, ['admin'], 'example.k12.va.us')

    testUser('joe', ['admin'], 'example.k12.va.us')

  })



  it('renaming of roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    Roles.setUserRoles([users.eve, users.bob], ['editor', 'user'], 'scope1')

    Roles.setUserRoles([users.bob, users.joe], ['user', 'admin'], 'scope2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'editor', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'editor', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.joe, 'admin', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'admin', 'scope2'))



    assert.isTrue(Roles.userIsInRole(users.eve, 'user', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.joe, 'user', 'scope1'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'user', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user2', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'user2', 'scope2'))



    Roles.renameRole('user', 'user2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'editor', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'editor', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.joe, 'admin', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'admin', 'scope2'))



    assert.isTrue(Roles.userIsInRole(users.eve, 'user2', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user2', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.joe, 'user2', 'scope1'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user2', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user2', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'user2', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'user', 'scope2'))

  })



  it('migration without global groups (to v2)', function () {

    assert.isOk(Meteor.roles.insert({ name: 'admin' }))

    assert.isOk(Meteor.roles.insert({ name: 'editor' }))

    assert.isOk(Meteor.roles.insert({ name: 'user' }))



    assert.isOk(Meteor.users.update(users.eve, { $set: { roles: ['admin', 'editor'] } }))

    assert.isOk(Meteor.users.update(users.bob, { $set: { roles: [] } }))

    assert.isOk(Meteor.users.update(users.joe, { $set: { roles: ['user'] } }))



    Roles._forwardMigrate()



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'admin',

        scope: null,

        assigned: true

      }, {

        _id: 'editor',

        scope: null,

        assigned: true

      }]

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'user',

        scope: null,

        assigned: true

      }]

    })



    assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

      _id: 'admin',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

      _id: 'editor',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

      _id: 'user',

      children: []

    })



    Roles._backwardMigrate(null, null, false)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: ['admin', 'editor']

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: ['user']

    })



    assert.deepEqual(Meteor.roles.findOne({ name: 'admin' }, { fields: { _id: 0 } }), {

      name: 'admin'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'editor' }, { fields: { _id: 0 } }), {

      name: 'editor'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'user' }, { fields: { _id: 0 } }), {

      name: 'user'

    })

  })



  it('migration without global groups (to v3)')



  it('migration with global groups (to v2)', function () {

    assert.isOk(Meteor.roles.insert({ name: 'admin' }))

    assert.isOk(Meteor.roles.insert({ name: 'editor' }))

    assert.isOk(Meteor.roles.insert({ name: 'user' }))



    assert.isOk(Meteor.users.update(users.eve, { $set: { roles: { __global_roles__: ['admin', 'editor'], foo_bla: ['user'] } } }))

    assert.isOk(Meteor.users.update(users.bob, { $set: { roles: { } } }))

    assert.isOk(Meteor.users.update(users.joe, { $set: { roles: { __global_roles__: ['user'], foo_bla: ['user'] } } }))



    Roles._forwardMigrate(null, null, false)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'admin',

        scope: null,

        assigned: true

      }, {

        _id: 'editor',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo_bla',

        assigned: true

      }]

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'user',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo_bla',

        assigned: true

      }]

    })



    assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

      _id: 'admin',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

      _id: 'editor',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

      _id: 'user',

      children: []

    })



    Roles._backwardMigrate(null, null, true)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: {

        __global_roles__: ['admin', 'editor'],

        foo_bla: ['user']

      }

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: {}

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: {

        __global_roles__: ['user'],

        foo_bla: ['user']

      }

    })



    assert.deepEqual(Meteor.roles.findOne({ name: 'admin' }, { fields: { _id: 0 } }), {

      name: 'admin'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'editor' }, { fields: { _id: 0 } }), {

      name: 'editor'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'user' }, { fields: { _id: 0 } }), {

      name: 'user'

    })



    Roles._forwardMigrate(null, null, true)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'admin',

        scope: null,

        assigned: true

      }, {

        _id: 'editor',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo.bla',

        assigned: true

      }]

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'user',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo.bla',

        assigned: true

      }]

    })



    assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

      _id: 'admin',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

      _id: 'editor',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

      _id: 'user',

      children: []

    })

  })



  it('migration with global groups (to v3)')



  it('_addUserToRole', function () {

    Roles.createRole('admin')



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])



    assert.include(

      Object.keys(Roles._addUserToRole(users.eve, 'admin', { scope: null, ifExists: false })),

      'insertedId'

    )



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    assert.notInclude(

      Object.keys(Roles._addUserToRole(users.eve, 'admin', { scope: null, ifExists: false })),

      'insertedId'

    )



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'admin' }]

    }])

  })



  it('_removeUserFromRole', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.eve, 'admin')



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    Roles._removeUserFromRole(users.eve, 'admin', { scope: null })



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])

  })



  it('keep assigned roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('ALL_PERMISSIONS')

    Roles.createRole('VIEW_PERMISSION')

    Roles.createRole('EDIT_PERMISSION')

    Roles.createRole('DELETE_PERMISSION')

    Roles.addRolesToParent('ALL_PERMISSIONS', 'user')

    Roles.addRolesToParent('EDIT_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('VIEW_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('DELETE_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, ['user'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.addUsersToRoles(users.eve, 'VIEW_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }, {

      role: { _id: 'VIEW_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, 'user')



    assert.isTrue(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'VIEW_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, 'VIEW_PERMISSION')



    assert.isFalse(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])

  })



  it('adds children of the added role to the assignments', function () {

    Roles.createRole('admin')

    Roles.createRole('ALBUM.ADMIN')

    Roles.createRole('ALBUM.VIEW')

    Roles.createRole('TRACK.ADMIN')

    Roles.createRole('TRACK.VIEW')



    Roles.addRolesToParent('ALBUM.VIEW', 'ALBUM.ADMIN')

    Roles.addRolesToParent('TRACK.VIEW', 'TRACK.ADMIN')



    Roles.addRolesToParent('ALBUM.ADMIN', 'admin')



    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isFalse(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))



    Roles.addRolesToParent('TRACK.ADMIN', 'admin')



    assert.isTrue(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))

  })



  it('removes children of the removed role from the assignments', function () {

    Roles.createRole('admin')

    Roles.createRole('ALBUM.ADMIN')

    Roles.createRole('ALBUM.VIEW')

    Roles.createRole('TRACK.ADMIN')

    Roles.createRole('TRACK.VIEW')



    Roles.addRolesToParent('ALBUM.VIEW', 'ALBUM.ADMIN')

    Roles.addRolesToParent('TRACK.VIEW', 'TRACK.ADMIN')



    Roles.addRolesToParent('ALBUM.ADMIN', 'admin')

    Roles.addRolesToParent('TRACK.ADMIN', 'admin')



    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))



    Roles.removeRolesFromParent('TRACK.ADMIN', 'admin')



    assert.isFalse(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))

  })



  it('modify assigned hierarchical roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('ALL_PERMISSIONS')

    Roles.createRole('VIEW_PERMISSION')

    Roles.createRole('EDIT_PERMISSION')

    Roles.createRole('DELETE_PERMISSION')

    Roles.addRolesToParent('ALL_PERMISSIONS', 'user')

    Roles.addRolesToParent('EDIT_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('VIEW_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('DELETE_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, ['user'])

    Roles.addUsersToRoles(users.eve, ['ALL_PERMISSIONS'], 'scope')



    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.createRole('MODERATE_PERMISSION')



    Roles.addRolesToParent('MODERATE_PERMISSION', 'ALL_PERMISSIONS')



    assert.isTrue(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }])



    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }, {

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'admin' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }])



    Roles.addRolesToParent('DELETE_PERMISSION', 'ALL_PERMISSIONS')



    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }, {

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'admin' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, ['admin'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }])



    Roles.deleteRole('ALL_PERMISSIONS')



    assert.isFalse(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' }

      ]

    }])

  })



  it('delete role with overlapping hierarchical roles', function () {

    Roles.createRole('role1')

    Roles.createRole('role2')

    Roles.createRole('COMMON_PERMISSION_1')

    Roles.createRole('COMMON_PERMISSION_2')

    Roles.createRole('COMMON_PERMISSION_3')

    Roles.createRole('EXTRA_PERMISSION_ROLE_1')

    Roles.createRole('EXTRA_PERMISSION_ROLE_2')



    Roles.addRolesToParent('COMMON_PERMISSION_1', 'role1')

    Roles.addRolesToParent('COMMON_PERMISSION_2', 'role1')

    Roles.addRolesToParent('COMMON_PERMISSION_3', 'role1')

    Roles.addRolesToParent('EXTRA_PERMISSION_ROLE_1', 'role1')



    Roles.addRolesToParent('COMMON_PERMISSION_1', 'role2')

    Roles.addRolesToParent('COMMON_PERMISSION_2', 'role2')

    Roles.addRolesToParent('COMMON_PERMISSION_3', 'role2')

    Roles.addRolesToParent('EXTRA_PERMISSION_ROLE_2', 'role2')



    Roles.addUsersToRoles(users.eve, 'role1')

    Roles.addUsersToRoles(users.eve, 'role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }, {

      role: { _id: 'role2' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role2' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_2' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, 'role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }])



    Roles.addUsersToRoles(users.eve, 'role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }, {

      role: { _id: 'role2' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role2' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_2' }

      ]

    }])



    Roles.deleteRole('role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }])

  })



  it('set parent on assigned role', function () {

    Roles.createRole('admin')

    Roles.createRole('EDIT_PERMISSION')



    Roles.addUsersToRoles(users.eve, 'EDIT_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.addRolesToParent('EDIT_PERMISSION', 'admin')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])

  })



  it('remove parent on assigned role', function () {

    Roles.createRole('admin')

    Roles.createRole('EDIT_PERMISSION')



    Roles.addRolesToParent('EDIT_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, 'EDIT_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.removeRolesFromParent('EDIT_PERMISSION', 'admin')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])

  })



  it('adding and removing extra role parents', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('EDIT_PERMISSION')



    Roles.addRolesToParent('EDIT_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, 'EDIT_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.addRolesToParent('EDIT_PERMISSION', 'user')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.removeRolesFromParent('EDIT_PERMISSION', 'user')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])

  })



  it('cyclic roles', function () {

    Roles.createRole('admin')

    Roles.createRole('editor')

    Roles.createRole('user')



    Roles.addRolesToParent('editor', 'admin')

    Roles.addRolesToParent('user', 'editor')



    assert.throws(function () {

      Roles.addRolesToParent('admin', 'user')

    }, /form a cycle/)

  })



  it('userIsInRole returns false for unknown roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')

    Roles.addUsersToRoles(users.eve, ['admin', 'user'])

    Roles.addUsersToRoles(users.eve, ['editor'])



    assert.isFalse(Roles.userIsInRole(users.eve, 'unknown'))

    assert.isFalse(Roles.userIsInRole(users.eve, []))

    assert.isFalse(Roles.userIsInRole(users.eve, null))

    assert.isFalse(Roles.userIsInRole(users.eve, undefined))



    assert.isFalse(Roles.userIsInRole(users.eve, 'unknown', { anyScope: true }))

    assert.isFalse(Roles.userIsInRole(users.eve, [], { anyScope: true }))

    assert.isFalse(Roles.userIsInRole(users.eve, null, { anyScope: true }))

    assert.isFalse(Roles.userIsInRole(users.eve, undefined, { anyScope: true }))



    assert.isFalse(Roles.userIsInRole(users.eve, ['Role1', 'Role2', undefined], 'GroupName'))

  })



  it('userIsInRole returns false if user is a function', function () {

    Roles.createRole('admin')

    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isFalse(Roles.userIsInRole(() => {}, 'admin'))

  })



  describe('isParentOf', function () {

    it('returns false for unknown roles', function () {

      Roles.createRole('admin')



      assert.isFalse(Roles.isParentOf('admin', 'unknown'))

      assert.isFalse(Roles.isParentOf('admin', null))

      assert.isFalse(Roles.isParentOf('admin', undefined))



      assert.isFalse(Roles.isParentOf('unknown', 'admin'))

      assert.isFalse(Roles.isParentOf(null, 'admin'))

      assert.isFalse(Roles.isParentOf(undefined, 'admin'))

    })



    it('returns false if role is not parent of', function () {

      Roles.createRole('admin')

      Roles.createRole('editor')

      Roles.createRole('user')

      Roles.addRolesToParent(['editor'], 'admin')

      Roles.addRolesToParent(['user'], 'editor')



      assert.isFalse(Roles.isParentOf('user', 'admin'))

      assert.isFalse(Roles.isParentOf('editor', 'admin'))

    })



    it('returns true if role is parent of the demanded role', function () {

      Roles.createRole('admin')

      Roles.createRole('editor')

      Roles.createRole('user')

      Roles.addRolesToParent(['editor'], 'admin')

      Roles.addRolesToParent(['user'], 'editor')



      assert.isTrue(Roles.isParentOf('admin', 'user'))

      assert.isTrue(Roles.isParentOf('editor', 'user'))

      assert.isTrue(Roles.isParentOf('admin', 'editor'))



      assert.isTrue(Roles.isParentOf('admin', 'admin'))

      assert.isTrue(Roles.isParentOf('editor', 'editor'))

      assert.isTrue(Roles.isParentOf('user', 'user'))

    })

  })
","  it('get an empty list of roles for an empty user', async function () {

    assert.sameMembers(await Roles.getRolesForUserAsync(undefined), [])

    assert.sameMembers(await Roles.getRolesForUserAsync(null), [])

    assert.sameMembers(await Roles.getRolesForUserAsync({}), [])

  })



  it('get an empty list of roles for non-existant user', async function () {

    assert.sameMembers(await Roles.getRolesForUserAsync('1'), [])

    assert.sameMembers(await Roles.getRolesForUserAsync('1', 'scope1'), [])

  })



  // it('can get all roles for user', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //

  //   const userId = users.eve

  //   let userObj

  //

  //   // by userId

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId), [])

  //

  //   // by user object

  //   userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj), [])

  //

  //   Roles.addUsersToRolesAsync(userId, ['admin', 'user'])

  //

  //   // by userId

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId), ['admin', 'user'])

  //

  //   // by user object

  //   userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj), ['admin', 'user'])

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: null,

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }, {

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }]

  //   }])

  // })

  //

  // it('can get all roles for user by scope', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //

  //   const userId = users.eve

  //   let userObj

  //

  //   // by userId

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, 'scope1'), [])

  //

  //   // by user object

  //   userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj, 'scope1'), [])

  //

  //   // add roles

  //   Roles.addUsersToRolesAsync(userId, ['admin', 'user'], 'scope1')

  //   Roles.addUsersToRolesAsync(userId, ['admin'], 'scope2')

  //

  //   // by userId

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, 'scope1'), ['admin', 'user'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, 'scope2'), ['admin'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId), [])

  //

  //   // by user object

  //   userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj, 'scope1'), ['admin', 'user'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj, 'scope2'), ['admin'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj), [])

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }, {

  //     role: { _id: 'user' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }]

  //   }])

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, scope: 'scope2' }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope2',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, anyScope: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }, {

  //     role: { _id: 'user' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }]

  //   }, {

  //     role: { _id: 'admin' },

  //     scope: 'scope2',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //

  //   Roles.createRoleAsync('PERMISSION')

  //   Roles.addRolesToParent('PERMISSION', 'user')

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }, {

  //     role: { _id: 'user' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

  //   }])

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, scope: 'scope2' }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope2',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { scope: 'scope1' }), ['admin', 'user', 'PERMISSION'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { scope: 'scope2' }), ['admin'])

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, anyScope: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }, {

  //     role: { _id: 'user' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

  //   }, {

  //     role: { _id: 'admin' },

  //     scope: 'scope2',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { anyScope: true }), ['admin', 'user', 'PERMISSION'])

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, scope: 'scope1', onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }, {

  //     role: { _id: 'user' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

  //   }])

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, scope: 'scope2', onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope2',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { scope: 'scope1', onlyAssigned: true }), ['admin', 'user'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { scope: 'scope2', onlyAssigned: true }), ['admin'])

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { fullObjects: true, anyScope: true, onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }, {

  //     role: { _id: 'user' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

  //   }, {

  //     role: { _id: 'admin' },

  //     scope: 'scope2',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { anyScope: true, onlyAssigned: true }), ['admin', 'user'])

  // })

  //

  // it('can get only scoped roles for user', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //

  //   const userId = users.eve

  //

  //   // add roles

  //   Roles.addUsersToRolesAsync(userId, ['user'], 'scope1')

  //   Roles.addUsersToRolesAsync(userId, ['admin'])

  //

  //   Roles.createRoleAsync('PERMISSION')

  //   Roles.addRolesToParent('PERMISSION', 'user')

  //

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { onlyScoped: true, scope: 'scope1' }), ['user', 'PERMISSION'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, { onlyScoped: true, onlyAssigned: true, scope: 'scope1' }), ['user'])

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(userId, { onlyScoped: true, fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: 'scope1',

  //     user: { _id: userId },

  //     inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

  //   }])

  // })

  //

  // it('can get all roles for user by scope with periods in name', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync(users.joe, ['admin'], 'example.k12.va.us')

  //

  //   assert.sameMembers(await Roles.getRolesForUserAsync(users.joe, 'example.k12.va.us'), ['admin'])

  // })

  //

  // it('can get all roles for user by scope including Roles.GLOBAL_SCOPE', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //

  //   const userId = users.eve

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor'], Roles.GLOBAL_SCOPE)

  //   Roles.addUsersToRolesAsync([users.eve], ['admin', 'user'], 'scope1')

  //

  //   // by userId

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, 'scope1'), ['editor', 'admin', 'user'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId), ['editor'])

  //

  //   // by user object

  //   const userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj, 'scope1'), ['editor', 'admin', 'user'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj), ['editor'])

  // })

  //

  // it('getRolesForUser should not return null entries if user has no roles for scope', function () {

  //   Roles.createRoleAsync('editor')

  //

  //   const userId = users.eve

  //   let userObj

  //

  //   // by userId

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, 'scope1'), [])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId), [])

  //

  //   // by user object

  //   userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj, 'scope1'), [])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj), [])

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor'], Roles.GLOBAL_SCOPE)

  //

  //   // by userId

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId, 'scope1'), ['editor'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userId), ['editor'])

  //

  //   // by user object

  //   userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj, 'scope1'), ['editor'])

  //   assert.sameMembers(await Roles.getRolesForUserAsync(userObj), ['editor'])

  // })

  //

  // it('getRolesForUser should not fail during a call of addUsersToRoles', function () {

  //   Roles.createRoleAsync('editor')

  //

  //   const userId = users.eve

  //   const promises = []

  //   const interval = setInterval(() => {

  //     promises.push(Promise.resolve().then(() => { await Roles.getRolesForUserAsync(userId) }))

  //   }, 0)

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor'], Roles.GLOBAL_SCOPE)

  //   clearInterval(interval)

  //

  //   return Promise.all(promises)

  // })

  //

  // it('returns an empty list of scopes for null as user-id', function () {

  //   assert.sameMembers(Roles.getScopesForUser(undefined), [])

  //   assert.sameMembers(Roles.getScopesForUser(null), [])

  //   assert.sameMembers(Roles.getScopesForUser('foo'), [])

  //   assert.sameMembers(Roles.getScopesForUser({}), [])

  //   assert.sameMembers(Roles.getScopesForUser({ _id: 'foo' }), [])

  // })

  //

  // it('can get all scopes for user', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //

  //   const userId = users.eve

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor'], 'scope1')

  //   Roles.addUsersToRolesAsync([users.eve], ['admin', 'user'], 'scope2')

  //

  //   // by userId

  //   assert.sameMembers(Roles.getScopesForUser(userId), ['scope1', 'scope2'])

  //

  //   // by user object

  //   const userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(Roles.getScopesForUser(userObj), ['scope1', 'scope2'])

  // })

  //

  // it('can get all scopes for user by role', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //

  //   const userId = users.eve

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor'], 'scope1')

  //   Roles.addUsersToRolesAsync([users.eve], ['editor', 'user'], 'scope2')

  //

  //   // by userId

  //   assert.sameMembers(Roles.getScopesForUser(userId, 'user'), ['scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), ['scope1', 'scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, 'admin'), [])

  //

  //   // by user object

  //   const userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(Roles.getScopesForUser(userObj, 'user'), ['scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), ['scope1', 'scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, 'admin'), [])

  // })

  //

  // it('getScopesForUser returns [] when not using scopes', function () {

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //

  //   const userId = users.eve

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor', 'user'])

  //

  //   // by userId

  //   assert.sameMembers(Roles.getScopesForUser(userId), [])

  //   assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), [])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), [])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'user']), [])

  //

  //   // by user object

  //   const userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(Roles.getScopesForUser(userObj), [])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), [])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), [])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'user']), [])

  // })

  //

  // it('can get all groups for user by role array', function () {

  //   const userId = users.eve

  //

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //   Roles.createRoleAsync('moderator')

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor'], 'group1')

  //   Roles.addUsersToRolesAsync([users.eve], ['editor', 'user'], 'group2')

  //   Roles.addUsersToRolesAsync([users.eve], ['moderator'], 'group3')

  //

  //   // by userId, one role

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['user']), ['group2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), ['group1', 'group2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['admin']), [])

  //

  //   // by userId, multiple roles

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'user']), ['group1', 'group2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'moderator']), ['group1', 'group2', 'group3'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['user', 'moderator']), ['group2', 'group3'])

  //

  //   // by user object, one role

  //   const userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['user']), ['group2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), ['group1', 'group2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['admin']), [])

  //

  //   // by user object, multiple roles

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'user']), ['group1', 'group2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'moderator']), ['group1', 'group2', 'group3'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['user', 'moderator']), ['group2', 'group3'])

  // })

  //

  // it('getting all scopes for user does not include GLOBAL_SCOPE', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //

  //   const userId = users.eve

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['editor'], 'scope1')

  //   Roles.addUsersToRolesAsync([users.eve], ['editor', 'user'], 'scope2')

  //   Roles.addUsersToRolesAsync([users.eve], ['editor', 'user', 'admin'], Roles.GLOBAL_SCOPE)

  //

  //   // by userId

  //   assert.sameMembers(Roles.getScopesForUser(userId, 'user'), ['scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), ['scope1', 'scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, 'admin'), [])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['user']), ['scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), ['scope1', 'scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['admin']), [])

  //   assert.sameMembers(Roles.getScopesForUser(userId, ['user', 'editor', 'admin']), ['scope1', 'scope2'])

  //

  //   // by user object

  //   const userObj = Meteor.users.findOneAsync({ _id: userId })

  //   assert.sameMembers(Roles.getScopesForUser(userObj, 'user'), ['scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), ['scope1', 'scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, 'admin'), [])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['user']), ['scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), ['scope1', 'scope2'])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['admin']), [])

  //   assert.sameMembers(Roles.getScopesForUser(userObj, ['user', 'editor', 'admin']), ['scope1', 'scope2'])

  // })

  //

  // it('can get all users in role', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //

  //   Roles.addUsersToRolesAsync([users.eve, users.joe], ['admin', 'user'])

  //   Roles.addUsersToRolesAsync([users.bob, users.joe], ['editor'])

  //

  //   const expected = [users.eve, users.joe]

  //   const actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

  //

  //   assert.sameMembers(actual, expected)

  // })

  //

  // it('can get all users in role by scope', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //

  //   Roles.addUsersToRolesAsync([users.eve, users.joe], ['admin', 'user'], 'scope1')

  //   Roles.addUsersToRolesAsync([users.bob, users.joe], ['admin'], 'scope2')

  //

  //   let expected = [users.eve, users.joe]

  //   let actual = Roles.getUsersInRole('admin', 'scope1').fetch().map(r => r._id)

  //

  //   assert.sameMembers(actual, expected)

  //

  //   expected = [users.eve, users.joe]

  //   actual = Roles.getUsersInRole('admin', { scope: 'scope1' }).fetch().map(r => r._id)

  //   assert.sameMembers(actual, expected)

  //

  //   expected = [users.eve, users.bob, users.joe]

  //   actual = Roles.getUsersInRole('admin', { anyScope: true }).fetch().map(r => r._id)

  //   assert.sameMembers(actual, expected)

  //

  //   actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

  //   assert.sameMembers(actual, [])

  // })

  //

  // it('can get all users in role by scope including Roles.GLOBAL_SCOPE', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['admin', 'user'], Roles.GLOBAL_SCOPE)

  //   Roles.addUsersToRolesAsync([users.bob, users.joe], ['admin'], 'scope2')

  //

  //   let expected = [users.eve]

  //   let actual = Roles.getUsersInRole('admin', 'scope1').fetch().map(r => r._id)

  //

  //   assert.sameMembers(actual, expected)

  //

  //   expected = [users.eve, users.bob, users.joe]

  //   actual = Roles.getUsersInRole('admin', 'scope2').fetch().map(r => r._id)

  //

  //   assert.sameMembers(actual, expected)

  //

  //   expected = [users.eve]

  //   actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

  //

  //   assert.sameMembers(actual, expected)

  //

  //   expected = [users.eve, users.bob, users.joe]

  //   actual = Roles.getUsersInRole('admin', { anyScope: true }).fetch().map(r => r._id)

  //

  //   assert.sameMembers(actual, expected)

  // })

  //

  // it('can get all users in role by scope excluding Roles.GLOBAL_SCOPE', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync([users.eve], ['admin'], Roles.GLOBAL_SCOPE)

  //   Roles.addUsersToRolesAsync([users.bob], ['admin'], 'scope1')

  //

  //   let expected = [users.eve]

  //   let actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

  //   assert.sameMembers(actual, expected)

  //

  //   expected = [users.eve, users.bob]

  //   actual = Roles.getUsersInRole('admin', { scope: 'scope1' }).fetch().map(r => r._id)

  //   assert.sameMembers(actual, expected)

  //

  //   expected = [users.bob]

  //   actual = Roles.getUsersInRole('admin', { scope: 'scope1', onlyScoped: true }).fetch().map(r => r._id)

  //   assert.sameMembers(actual, expected)

  // })



  it('can get all users in role by scope and passes through mongo query arguments', async function () {

    await Roles.createRoleAsync('admin')

    await Roles.createRoleAsync('user')



    await Roles.addUsersToRolesAsync([users.eve, users.joe], ['admin', 'user'], 'scope1')

    await Roles.addUsersToRolesAsync([users.bob, users.joe], ['admin'], 'scope2')



    const results = await Roles.getUsersInRole('admin', 'scope1', { fields: { username: 0 }, limit: 1 }).fetch()

  // it('can use Roles.GLOBAL_SCOPE to assign blanket roles', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync([users.joe, users.bob], ['admin'], Roles.GLOBAL_SCOPE)

  //

  //   testUser('eve', [], 'scope1')

  //   testUser('joe', ['admin'], 'scope2')

  //   testUser('joe', ['admin'], 'scope1')

  //   testUser('bob', ['admin'], 'scope2')

  //   testUser('bob', ['admin'], 'scope1')

  //

  //   Roles.removeUsersFromRolesAsync(users.joe, ['admin'], Roles.GLOBAL_SCOPE)

  //

  //   testUser('eve', [], 'scope1')

  //   testUser('joe', [], 'scope2')

  //   testUser('joe', [], 'scope1')

  //   testUser('bob', ['admin'], 'scope2')

  //   testUser('bob', ['admin'], 'scope1')

  // })

  //

  // it('Roles.GLOBAL_SCOPE is independent of other scopes', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync([users.joe, users.bob], ['admin'], 'scope5')

  //   Roles.addUsersToRolesAsync([users.joe, users.bob], ['admin'], Roles.GLOBAL_SCOPE)

  //

  //   testUser('eve', [], 'scope1')

  //   testUser('joe', ['admin'], 'scope5')

  //   testUser('joe', ['admin'], 'scope2')

  //   testUser('joe', ['admin'], 'scope1')

  //   testUser('bob', ['admin'], 'scope5')

  //   testUser('bob', ['admin'], 'scope2')

  //   testUser('bob', ['admin'], 'scope1')

  //

  //   Roles.removeUsersFromRolesAsync(users.joe, ['admin'], Roles.GLOBAL_SCOPE)

  //

  //   testUser('eve', [], 'scope1')

  //   testUser('joe', ['admin'], 'scope5')

  //   testUser('joe', [], 'scope2')

  //   testUser('joe', [], 'scope1')

  //   testUser('bob', ['admin'], 'scope5')

  //   testUser('bob', ['admin'], 'scope2')

  //   testUser('bob', ['admin'], 'scope1')

  // })

  //

  // it('Roles.GLOBAL_SCOPE also checked when scope not specified', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync(users.joe, 'admin', Roles.GLOBAL_SCOPE)

  //

  //   testUser('joe', ['admin'])

  //

  //   Roles.removeUsersFromRolesAsync(users.joe, 'admin', Roles.GLOBAL_SCOPE)

  //

  //   testUser('joe', [])

  // })

  //

  // it('can use \'.\' in scope name', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync(users.joe, ['admin'], 'example.com')

  //   testUser('joe', ['admin'], 'example.com')

  // })

  //

  // it('can use multiple periods in scope name', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync(users.joe, ['admin'], 'example.k12.va.us')

  //   testUser('joe', ['admin'], 'example.k12.va.us')

  // })

  //

  // it('renaming of roles', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //

  //   await Roles.setUserRolesAsync([users.eve, users.bob], ['editor', 'user'], 'scope1')

  //   await Roles.setUserRolesAsync([users.bob, users.joe], ['user', 'admin'], 'scope2')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'editor', 'scope1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'editor', 'scope2'))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.joe, 'admin', 'scope1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.joe, 'admin', 'scope2'))

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'user', 'scope1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.bob, 'user', 'scope1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.joe, 'user', 'scope1'))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'user', 'scope2'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.bob, 'user', 'scope2'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.joe, 'user', 'scope2'))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'user2', 'scope1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'user2', 'scope2'))

  //

  //   Roles.renameRole('user', 'user2')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'editor', 'scope1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'editor', 'scope2'))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.joe, 'admin', 'scope1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.joe, 'admin', 'scope2'))

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'user2', 'scope1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.bob, 'user2', 'scope1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.joe, 'user2', 'scope1'))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'user2', 'scope2'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.bob, 'user2', 'scope2'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.joe, 'user2', 'scope2'))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'user', 'scope1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'user', 'scope2'))

  // })

  //

  // it('migration without global groups (to v2)', function () {

  //   assert.isOk(Meteor.roles.insert({ name: 'admin' }))

  //   assert.isOk(Meteor.roles.insert({ name: 'editor' }))

  //   assert.isOk(Meteor.roles.insert({ name: 'user' }))

  //

  //   assert.isOk(Meteor.users.update(users.eve, { $set: { roles: ['admin', 'editor'] } }))

  //   assert.isOk(Meteor.users.update(users.bob, { $set: { roles: [] } }))

  //   assert.isOk(Meteor.users.update(users.joe, { $set: { roles: ['user'] } }))

  //

  //   Roles._forwardMigrate()

  //

  //   assert.deepEqual(Meteor.users.findOneAsync(users.eve, { fields: { roles: 1, _id: 0 } }), {

  //     roles: [{

  //       _id: 'admin',

  //       scope: null,

  //       assigned: true

  //     }, {

  //       _id: 'editor',

  //       scope: null,

  //       assigned: true

  //     }]

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.bob, { fields: { roles: 1, _id: 0 } }), {

  //     roles: []

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.joe, { fields: { roles: 1, _id: 0 } }), {

  //     roles: [{

  //       _id: 'user',

  //       scope: null,

  //       assigned: true

  //     }]

  //   })

  //

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

  //     _id: 'admin',

  //     children: []

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

  //     _id: 'editor',

  //     children: []

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

  //     _id: 'user',

  //     children: []

  //   })

  //

  //   Roles._backwardMigrate(null, null, false)

  //

  //   assert.deepEqual(Meteor.users.findOneAsync(users.eve, { fields: { roles: 1, _id: 0 } }), {

  //     roles: ['admin', 'editor']

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.bob, { fields: { roles: 1, _id: 0 } }), {

  //     roles: []

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.joe, { fields: { roles: 1, _id: 0 } }), {

  //     roles: ['user']

  //   })

  //

  //   assert.deepEqual(Meteor.roles.findOne({ name: 'admin' }, { fields: { _id: 0 } }), {

  //     name: 'admin'

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ name: 'editor' }, { fields: { _id: 0 } }), {

  //     name: 'editor'

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ name: 'user' }, { fields: { _id: 0 } }), {

  //     name: 'user'

  //   })

  // })

  //

  // it('migration without global groups (to v3)')

  //

  // it('migration with global groups (to v2)', function () {

  //   assert.isOk(Meteor.roles.insert({ name: 'admin' }))

  //   assert.isOk(Meteor.roles.insert({ name: 'editor' }))

  //   assert.isOk(Meteor.roles.insert({ name: 'user' }))

  //

  //   assert.isOk(Meteor.users.update(users.eve, { $set: { roles: { __global_roles__: ['admin', 'editor'], foo_bla: ['user'] } } }))

  //   assert.isOk(Meteor.users.update(users.bob, { $set: { roles: { } } }))

  //   assert.isOk(Meteor.users.update(users.joe, { $set: { roles: { __global_roles__: ['user'], foo_bla: ['user'] } } }))

  //

  //   Roles._forwardMigrate(null, null, false)

  //

  //   assert.deepEqual(Meteor.users.findOneAsync(users.eve, { fields: { roles: 1, _id: 0 } }), {

  //     roles: [{

  //       _id: 'admin',

  //       scope: null,

  //       assigned: true

  //     }, {

  //       _id: 'editor',

  //       scope: null,

  //       assigned: true

  //     }, {

  //       _id: 'user',

  //       scope: 'foo_bla',

  //       assigned: true

  //     }]

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.bob, { fields: { roles: 1, _id: 0 } }), {

  //     roles: []

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.joe, { fields: { roles: 1, _id: 0 } }), {

  //     roles: [{

  //       _id: 'user',

  //       scope: null,

  //       assigned: true

  //     }, {

  //       _id: 'user',

  //       scope: 'foo_bla',

  //       assigned: true

  //     }]

  //   })

  //

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

  //     _id: 'admin',

  //     children: []

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

  //     _id: 'editor',

  //     children: []

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

  //     _id: 'user',

  //     children: []

  //   })

  //

  //   Roles._backwardMigrate(null, null, true)

  //

  //   assert.deepEqual(Meteor.users.findOneAsync(users.eve, { fields: { roles: 1, _id: 0 } }), {

  //     roles: {

  //       __global_roles__: ['admin', 'editor'],

  //       foo_bla: ['user']

  //     }

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.bob, { fields: { roles: 1, _id: 0 } }), {

  //     roles: {}

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.joe, { fields: { roles: 1, _id: 0 } }), {

  //     roles: {

  //       __global_roles__: ['user'],

  //       foo_bla: ['user']

  //     }

  //   })

  //

  //   assert.deepEqual(Meteor.roles.findOne({ name: 'admin' }, { fields: { _id: 0 } }), {

  //     name: 'admin'

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ name: 'editor' }, { fields: { _id: 0 } }), {

  //     name: 'editor'

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ name: 'user' }, { fields: { _id: 0 } }), {

  //     name: 'user'

  //   })

  //

  //   Roles._forwardMigrate(null, null, true)

  //

  //   assert.deepEqual(Meteor.users.findOneAsync(users.eve, { fields: { roles: 1, _id: 0 } }), {

  //     roles: [{

  //       _id: 'admin',

  //       scope: null,

  //       assigned: true

  //     }, {

  //       _id: 'editor',

  //       scope: null,

  //       assigned: true

  //     }, {

  //       _id: 'user',

  //       scope: 'foo.bla',

  //       assigned: true

  //     }]

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.bob, { fields: { roles: 1, _id: 0 } }), {

  //     roles: []

  //   })

  //   assert.deepEqual(Meteor.users.findOneAsync(users.joe, { fields: { roles: 1, _id: 0 } }), {

  //     roles: [{

  //       _id: 'user',

  //       scope: null,

  //       assigned: true

  //     }, {

  //       _id: 'user',

  //       scope: 'foo.bla',

  //       assigned: true

  //     }]

  //   })

  //

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

  //     _id: 'admin',

  //     children: []

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

  //     _id: 'editor',

  //     children: []

  //   })

  //   assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

  //     _id: 'user',

  //     children: []

  //   })

  // })

  //

  // it('migration with global groups (to v3)')

  //

  // it('_addUserToRole', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])

  //

  //   assert.include(

  //     Object.keys(Roles._addUserToRole(users.eve, 'admin', { scope: null, ifExists: false })),

  //     'insertedId'

  //   )

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //

  //   assert.notInclude(

  //     Object.keys(Roles._addUserToRole(users.eve, 'admin', { scope: null, ifExists: false })),

  //     'insertedId'

  //   )

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  // })

  //

  // it('_removeUserFromRole', function () {

  //   Roles.createRoleAsync('admin')

  //

  //   Roles.addUsersToRolesAsync(users.eve, 'admin')

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'admin' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'admin' }]

  //   }])

  //

  //   Roles._removeUserFromRole(users.eve, 'admin', { scope: null })

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])

  // })

  //

  // it('keep assigned roles', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('ALL_PERMISSIONS')

  //   Roles.createRoleAsync('VIEW_PERMISSION')

  //   Roles.createRoleAsync('EDIT_PERMISSION')

  //   Roles.createRoleAsync('DELETE_PERMISSION')

  //   Roles.addRolesToParent('ALL_PERMISSIONS', 'user')

  //   Roles.addRolesToParent('EDIT_PERMISSION', 'ALL_PERMISSIONS')

  //   Roles.addRolesToParent('VIEW_PERMISSION', 'ALL_PERMISSIONS')

  //   Roles.addRolesToParent('DELETE_PERMISSION', 'admin')

  //

  //   Roles.addUsersToRolesAsync(users.eve, ['user'])

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'VIEW_PERMISSION'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' },

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.addUsersToRolesAsync(users.eve, 'VIEW_PERMISSION')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'VIEW_PERMISSION'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' },

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'VIEW_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'VIEW_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.removeUsersFromRolesAsync(users.eve, 'user')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'VIEW_PERMISSION'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'VIEW_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'VIEW_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.removeUsersFromRolesAsync(users.eve, 'VIEW_PERMISSION')

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'VIEW_PERMISSION'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])

  // })

  //

  // it('adds children of the added role to the assignments', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('ALBUM.ADMIN')

  //   Roles.createRoleAsync('ALBUM.VIEW')

  //   Roles.createRoleAsync('TRACK.ADMIN')

  //   Roles.createRoleAsync('TRACK.VIEW')

  //

  //   Roles.addRolesToParent('ALBUM.VIEW', 'ALBUM.ADMIN')

  //   Roles.addRolesToParent('TRACK.VIEW', 'TRACK.ADMIN')

  //

  //   Roles.addRolesToParent('ALBUM.ADMIN', 'admin')

  //

  //   Roles.addUsersToRolesAsync(users.eve, ['admin'])

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'TRACK.VIEW'))

  //

  //   Roles.addRolesToParent('TRACK.ADMIN', 'admin')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'TRACK.VIEW'))

  // })

  //

  // it('removes children of the removed role from the assignments', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('ALBUM.ADMIN')

  //   Roles.createRoleAsync('ALBUM.VIEW')

  //   Roles.createRoleAsync('TRACK.ADMIN')

  //   Roles.createRoleAsync('TRACK.VIEW')

  //

  //   Roles.addRolesToParent('ALBUM.VIEW', 'ALBUM.ADMIN')

  //   Roles.addRolesToParent('TRACK.VIEW', 'TRACK.ADMIN')

  //

  //   Roles.addRolesToParent('ALBUM.ADMIN', 'admin')

  //   Roles.addRolesToParent('TRACK.ADMIN', 'admin')

  //

  //   Roles.addUsersToRolesAsync(users.eve, ['admin'])

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'TRACK.VIEW'))

  //

  //   Roles.removeRolesFromParent('TRACK.ADMIN', 'admin')

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'TRACK.VIEW'))

  // })

  //

  // it('modify assigned hierarchical roles', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('ALL_PERMISSIONS')

  //   Roles.createRoleAsync('VIEW_PERMISSION')

  //   Roles.createRoleAsync('EDIT_PERMISSION')

  //   Roles.createRoleAsync('DELETE_PERMISSION')

  //   Roles.addRolesToParent('ALL_PERMISSIONS', 'user')

  //   Roles.addRolesToParent('EDIT_PERMISSION', 'ALL_PERMISSIONS')

  //   Roles.addRolesToParent('VIEW_PERMISSION', 'ALL_PERMISSIONS')

  //   Roles.addRolesToParent('DELETE_PERMISSION', 'admin')

  //

  //   Roles.addUsersToRolesAsync(users.eve, ['user'])

  //   Roles.addUsersToRolesAsync(users.eve, ['ALL_PERMISSIONS'], 'scope')

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'MODERATE_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'MODERATE_PERMISSION', 'scope'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' },

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'ALL_PERMISSIONS' },

  //     scope: 'scope',

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.createRoleAsync('MODERATE_PERMISSION')

  //

  //   Roles.addRolesToParent('MODERATE_PERMISSION', 'ALL_PERMISSIONS')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'MODERATE_PERMISSION'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'MODERATE_PERMISSION', 'scope'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' },

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'ALL_PERMISSIONS' },

  //     scope: 'scope',

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.addUsersToRolesAsync(users.eve, ['admin'])

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION', 'scope'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' },

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'ALL_PERMISSIONS' },

  //     scope: 'scope',

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'admin' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'admin' },

  //       { _id: 'DELETE_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.addRolesToParent('DELETE_PERMISSION', 'ALL_PERMISSIONS')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION', 'scope'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' },

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' },

  //       { _id: 'DELETE_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'ALL_PERMISSIONS' },

  //     scope: 'scope',

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' },

  //       { _id: 'DELETE_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'admin' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'admin' },

  //       { _id: 'DELETE_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.removeUsersFromRolesAsync(users.eve, ['admin'])

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION', 'scope'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' },

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' },

  //       { _id: 'DELETE_PERMISSION' }

  //     ]

  //   }, {

  //     role: { _id: 'ALL_PERMISSIONS' },

  //     scope: 'scope',

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'ALL_PERMISSIONS' },

  //       { _id: 'EDIT_PERMISSION' },

  //       { _id: 'VIEW_PERMISSION' },

  //       { _id: 'MODERATE_PERMISSION' },

  //       { _id: 'DELETE_PERMISSION' }

  //     ]

  //   }])

  //

  //   Roles.deleteRole('ALL_PERMISSIONS')

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'DELETE_PERMISSION', 'scope'))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'MODERATE_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'MODERATE_PERMISSION', 'scope'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'user' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'user' }

  //     ]

  //   }])

  // })

  //

  // it('delete role with overlapping hierarchical roles', function () {

  //   Roles.createRoleAsync('role1')

  //   Roles.createRoleAsync('role2')

  //   Roles.createRoleAsync('COMMON_PERMISSION_1')

  //   Roles.createRoleAsync('COMMON_PERMISSION_2')

  //   Roles.createRoleAsync('COMMON_PERMISSION_3')

  //   Roles.createRoleAsync('EXTRA_PERMISSION_ROLE_1')

  //   Roles.createRoleAsync('EXTRA_PERMISSION_ROLE_2')

  //

  //   Roles.addRolesToParent('COMMON_PERMISSION_1', 'role1')

  //   Roles.addRolesToParent('COMMON_PERMISSION_2', 'role1')

  //   Roles.addRolesToParent('COMMON_PERMISSION_3', 'role1')

  //   Roles.addRolesToParent('EXTRA_PERMISSION_ROLE_1', 'role1')

  //

  //   Roles.addRolesToParent('COMMON_PERMISSION_1', 'role2')

  //   Roles.addRolesToParent('COMMON_PERMISSION_2', 'role2')

  //   Roles.addRolesToParent('COMMON_PERMISSION_3', 'role2')

  //   Roles.addRolesToParent('EXTRA_PERMISSION_ROLE_2', 'role2')

  //

  //   Roles.addUsersToRolesAsync(users.eve, 'role1')

  //   Roles.addUsersToRolesAsync(users.eve, 'role2')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'COMMON_PERMISSION_1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_2'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'role1' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'role1' },

  //       { _id: 'COMMON_PERMISSION_1' },

  //       { _id: 'COMMON_PERMISSION_2' },

  //       { _id: 'COMMON_PERMISSION_3' },

  //       { _id: 'EXTRA_PERMISSION_ROLE_1' }

  //     ]

  //   }, {

  //     role: { _id: 'role2' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'role2' },

  //       { _id: 'COMMON_PERMISSION_1' },

  //       { _id: 'COMMON_PERMISSION_2' },

  //       { _id: 'COMMON_PERMISSION_3' },

  //       { _id: 'EXTRA_PERMISSION_ROLE_2' }

  //     ]

  //   }])

  //

  //   Roles.removeUsersFromRolesAsync(users.eve, 'role2')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'COMMON_PERMISSION_1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_2'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'role1' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'role1' },

  //       { _id: 'COMMON_PERMISSION_1' },

  //       { _id: 'COMMON_PERMISSION_2' },

  //       { _id: 'COMMON_PERMISSION_3' },

  //       { _id: 'EXTRA_PERMISSION_ROLE_1' }

  //     ]

  //   }])

  //

  //   Roles.addUsersToRolesAsync(users.eve, 'role2')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'COMMON_PERMISSION_1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_2'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'role1' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'role1' },

  //       { _id: 'COMMON_PERMISSION_1' },

  //       { _id: 'COMMON_PERMISSION_2' },

  //       { _id: 'COMMON_PERMISSION_3' },

  //       { _id: 'EXTRA_PERMISSION_ROLE_1' }

  //     ]

  //   }, {

  //     role: { _id: 'role2' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'role2' },

  //       { _id: 'COMMON_PERMISSION_1' },

  //       { _id: 'COMMON_PERMISSION_2' },

  //       { _id: 'COMMON_PERMISSION_3' },

  //       { _id: 'EXTRA_PERMISSION_ROLE_2' }

  //     ]

  //   }])

  //

  //   Roles.deleteRole('role2')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'COMMON_PERMISSION_1'))

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'EXTRA_PERMISSION_ROLE_2'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'role1' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [

  //       { _id: 'role1' },

  //       { _id: 'COMMON_PERMISSION_1' },

  //       { _id: 'COMMON_PERMISSION_2' },

  //       { _id: 'COMMON_PERMISSION_3' },

  //       { _id: 'EXTRA_PERMISSION_ROLE_1' }

  //     ]

  //   }])

  // })

  //

  // it('set parent on assigned role', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('EDIT_PERMISSION')

  //

  //   Roles.addUsersToRolesAsync(users.eve, 'EDIT_PERMISSION')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EDIT_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'admin'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'EDIT_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

  //   }])

  //

  //   Roles.addRolesToParent('EDIT_PERMISSION', 'admin')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EDIT_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'admin'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'EDIT_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

  //   }])

  // })

  //

  // it('remove parent on assigned role', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('EDIT_PERMISSION')

  //

  //   Roles.addRolesToParent('EDIT_PERMISSION', 'admin')

  //

  //   Roles.addUsersToRolesAsync(users.eve, 'EDIT_PERMISSION')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EDIT_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'admin'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'EDIT_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

  //   }])

  //

  //   Roles.removeRolesFromParent('EDIT_PERMISSION', 'admin')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EDIT_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'admin'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'EDIT_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

  //   }])

  // })

  //

  // it('adding and removing extra role parents', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('EDIT_PERMISSION')

  //

  //   Roles.addRolesToParent('EDIT_PERMISSION', 'admin')

  //

  //   Roles.addUsersToRolesAsync(users.eve, 'EDIT_PERMISSION')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EDIT_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'admin'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'EDIT_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

  //   }])

  //

  //   Roles.addRolesToParent('EDIT_PERMISSION', 'user')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EDIT_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'admin'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'EDIT_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

  //   }])

  //

  //   Roles.removeRolesFromParent('EDIT_PERMISSION', 'user')

  //

  //   assert.isTrue(Roles.userIsInRoleAsync(users.eve, 'EDIT_PERMISSION'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'admin'))

  //

  //   assert.sameDeepMembers(await Roles.getRolesForUserAsync(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

  //     role: { _id: 'EDIT_PERMISSION' },

  //     scope: null,

  //     user: { _id: users.eve },

  //     inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

  //   }])

  // })

  //

  // it('cyclic roles', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('editor')

  //   Roles.createRoleAsync('user')

  //

  //   Roles.addRolesToParent('editor', 'admin')

  //   Roles.addRolesToParent('user', 'editor')

  //

  //   assert.throws(function () {

  //     Roles.addRolesToParent('admin', 'user')

  //   }, /form a cycle/)

  // })

  //

  // it('userIsInRole returns false for unknown roles', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.createRoleAsync('user')

  //   Roles.createRoleAsync('editor')

  //   Roles.addUsersToRolesAsync(users.eve, ['admin', 'user'])

  //   Roles.addUsersToRolesAsync(users.eve, ['editor'])

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'unknown'))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, []))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, null))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, undefined))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, 'unknown', { anyScope: true }))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, [], { anyScope: true }))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, null, { anyScope: true }))

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, undefined, { anyScope: true }))

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(users.eve, ['Role1', 'Role2', undefined], 'GroupName'))

  // })

  //

  // it('userIsInRole returns false if user is a function', function () {

  //   Roles.createRoleAsync('admin')

  //   Roles.addUsersToRolesAsync(users.eve, ['admin'])

  //

  //   assert.isFalse(Roles.userIsInRoleAsync(() => {}, 'admin'))

  // })

  //

  // describe('isParentOf', function () {

  //   it('returns false for unknown roles', function () {

  //     Roles.createRoleAsync('admin')

  //

  //     assert.isFalse(Roles.isParentOf('admin', 'unknown'))

  //     assert.isFalse(Roles.isParentOf('admin', null))

  //     assert.isFalse(Roles.isParentOf('admin', undefined))

  //

  //     assert.isFalse(Roles.isParentOf('unknown', 'admin'))

  //     assert.isFalse(Roles.isParentOf(null, 'admin'))

  //     assert.isFalse(Roles.isParentOf(undefined, 'admin'))

  //   })

  //

  //   it('returns false if role is not parent of', function () {

  //     Roles.createRoleAsync('admin')

  //     Roles.createRoleAsync('editor')

  //     Roles.createRoleAsync('user')

  //     Roles.addRolesToParent(['editor'], 'admin')

  //     Roles.addRolesToParent(['user'], 'editor')

  //

  //     assert.isFalse(Roles.isParentOf('user', 'admin'))

  //     assert.isFalse(Roles.isParentOf('editor', 'admin'))

  //   })

  //

  //   it('returns true if role is parent of the demanded role', function () {

  //     Roles.createRoleAsync('admin')

  //     Roles.createRoleAsync('editor')

  //     Roles.createRoleAsync('user')

  //     Roles.addRolesToParent(['editor'], 'admin')

  //     Roles.addRolesToParent(['user'], 'editor')

  //

  //     assert.isTrue(Roles.isParentOf('admin', 'user'))

  //     assert.isTrue(Roles.isParentOf('editor', 'user'))

  //     assert.isTrue(Roles.isParentOf('admin', 'editor'))

  //

  //     assert.isTrue(Roles.isParentOf('admin', 'admin'))

  //     assert.isTrue(Roles.isParentOf('editor', 'editor'))

  //     assert.isTrue(Roles.isParentOf('user', 'user'))

  //   })

  // })
",The output of your `migrateRoles` method should be the following object:,0.35871812233082195,0.4226694432090298,0.5704653180269492,0.42261726919629516,0.019120458891013385,0.25001253878085516,4.744890562585487e-179,5.015512342063697e-05,0.0,0.0,0.2500093971460033,3.021242382148021e-240,3.758858401312332e-05,0.0,0.0
22,"    const isThenable =

      Promise.resolve(resultOrThenable).then(

        (...args) => self._publishHandlerResult.bind(self)(...args),

        e => self.error(e)

      );


","    const isThenable =  

      try {

        self._publishHandlerResult(await resultOrThenable);

      } catch(e) {

        self.error(e)

      }
","const isThenable = async () => {
    try {
        const resultOrThenable = await Promise.resolve(resultOrThenable);
        return self._publishHandlerResult.bind(self)(...args);
    } catch (e) {
        self.error(e);
    }
}",0.1871846602568238,0.09058752341587764,0.11032503065489578,0.34782608695652173,0.2,0.3798975129631042,0.044047629893173255,0.11032503065489578,0.5652173913043478,0.8,0.2736285920898144,0.05796994103455468,0.12477972144235003,0.4117647058823529,0.5
23,"      // TODO [FIBERS]: this is a big workaround. The Tracker is now receiving promises,

        // so it's finishing before time. Hopefully this PR will fix this behavior

        // https://github.com/meteor/meteor/pull/12294

      let resolve;

      const promise = new Promise(res => resolve = res);

      Meteor.setTimeout(() => {

        test.equal(Meteor.user(), { _id: Meteor.userId() });

        resolve();

      }, 100);

      return promise;
","      test.equal(await Meteor.userAsync(), { _id: Meteor.userId() });
","async function waitForUser() {
  const user = Meteor.user();
  await new Promise((resolve) => {
    setTimeout(() => {
      test.equal(user, { _id: Meteor.userId() });
      resolve();
    }, 100);
  });
}",0.14110814178199088,0.00020137416084357838,0.03866301114893818,0.34375,0.18181818181818182,0.27878612373971084,0.09447276418215159,0.1286262762312373,0.4375,0.45454545454545453,0.5603563872020778,0.09043565779655338,0.5081327481546147,0.6428571428571429,1.0
24,"    return files.rm_recursive_async(

    ).then(() => {

      Console.info(""Project reset."");

    });
","    await files.rm_recursive_async(

    );

    Console.info(""Project reset."");

    return;
","async function rm_recursive() {
  try {
    await files.rm_recursive();
    console.info(""Project reset."");
  } catch (error) {
    console.error(error);
  }
}",0.40679998963865993,0.06846046760764757,0.05873949094699214,0.5,0.0,0.40150666277080505,0.013679192123121896,0.029847458960098227,0.5625,0.0,0.4758116644938726,0.013679192123121896,0.056234132519034905,0.8333333333333334,0.0
25,"  console.log(""-> allRemovePromises"", allRemovePromises);



  Promise.all(allRemovePromises).then(() => {

    Console.info(""Project reset."");

  });
","  await Promise.all(allRemovePromises);

  Console.info(""Project reset."");
","console.log(""-> allRemovePromises"", allRemovePromises);

async function removeProjects() {
  try {
    await Promise.all(allRemovePromises).then(() => {
      console.info(""Project reset."");
    });
  } catch (error) {
    console.error(error);
  }
}",0.39389526554564547,0.04867843262263999,0.050712153369465586,0.47619047619047616,0.0,0.5524706356252475,0.07832899330004497,0.2267916444390401,0.9047619047619048,1.0,0.46071480077141813,0.009849349468888718,0.10573712634405641,0.7272727272727273,0.0
26,"var devBundleBinCommand = process.argv[2];

var args = process.argv.slice(3);

function getChildProcess() {

  var helpers = require(""./dev-bundle-bin-helpers.js"");

  return Promise.all([

    helpers.getDevBundle(),

    helpers.getEnv()

  ]).then(function (devBundleAndEnv) {

    var devBundleDir = devBundleAndEnv[0];

    var cmd = helpers.getCommand(devBundleBinCommand, devBundleDir);

    if (! cmd) {

      return null;

    }

    var env = devBundleAndEnv[1];

    var child = require(""child_process"").spawn(cmd, args, {

      stdio: ""inherit"",

      env: env

    });



    require(""./flush-buffers-on-exit-in-windows.js"");

    child.on(""error"", function (error) {

      console.log(error.stack || error);

    });

    child.on(""exit"", function (exitCode) {

      process.exit(exitCode);

    });

    return child;

module.exports = getChildProcess();
","const { getDevBundleDir, DEFAULT_DEV_BUNDLE_DIR } = require('./dev-bundle');

const { getEnv } = require('./dev-bundle-bin-helpers');

const devBundleBinCommand = process.argv[2];

const args = process.argv.slice(3);

async function getChildProcess({ isFirstTry }) {

  const helpers = require(""./dev-bundle-bin-helpers"");

  const [devBundleDir, env] = await Promise.all([

    getDevBundleDir(),

    getEnv()

  ]);

  if (isFirstTry && devBundleDir === DEFAULT_DEV_BUNDLE_DIR) {

    return null

  }

  const cmd = helpers.getCommand(devBundleBinCommand, devBundleDir);

  if (!cmd) {

    return null;

  }

  const child = require(""child_process"").spawn(cmd, args, {

    stdio: ""inherit"",

    env: env

  require(""./flush-buffers-on-exit-in-windows"");

  child.on(""error"", function (error) {

    console.log(error.stack || error);

  });

  child.on(""exit"", function (exitCode) {

    process.exit(exitCode);

  });

  return child;

module.exports = {

  getChildProcess

}
","const devBundleBinCommand = process.argv[2];

async function getChildProcess() {
  const helpers = require(""./dev-bundle-bin-helpers.js"");
  try {
    const [devBundleDir, env] = await Promise.all([
      helpers.getDevBundle(),
      helpers.getEnv(),
    ]);
    const cmd = helpers.getCommand(devBundleBinCommand, devBundleDir);
    if (!cmd) return null;
    const child = require(""child_process"").spawn(cmd, process.argv.slice(3), {
      stdio: ""inherit"",
      env,
    });
    require(""./flush-buffers-on-exit-in-windows.js"");
    child.on(""error"", (error) => console.log(error.stack || error));
    child.on(""exit"", (exitCode) => process.exit(exitCode));
    return child;
  } catch (err) {
    console.log(err);
    return null;
  }
}
module.exports = getChildProcess();",0.4912268466885648,0.37496930827791114,0.4635391318009037,0.6774193548387096,0.4489795918367347,0.4097513511015608,0.16856984653537196,0.16146035488645175,0.6559139784946236,0.6530612244897959,0.39789391257790985,0.22878841786039847,0.2449315795517832,0.6276595744680851,0.49019607843137253
27,"exports.getEnv = function (options) {

  var devBundle = options && options.devBundle;

  var devBundlePromise = typeof devBundle === ""string""

    ? Promise.resolve(convertToOSPath(devBundle))

    : getDevBundle();

  return devBundlePromise.then(function (devBundleDir) {

    var paths = [

      // When npm looks for node, it must find dev_bundle/bin/node.

      path.join(devBundleDir, ""bin""),

      // When npm looks for meteor, it should find dev_bundle/../meteor.

      path.dirname(devBundleDir),

      // Also make available any scripts installed by packages in

      // dev_bundle/lib/node_modules, such as node-gyp.

      path.join(devBundleDir, ""lib"", ""node_modules"", "".bin"")

    ];

    var env = Object.create(process.env);

    // Make sure notifications to update npm aren't presented to the user.

    env.NO_UPDATE_NOTIFIER = true;

    // Make sure `meteor npm install --global ...` installs into

    // dev_bundle/lib/node_modules by default.

    if (! env.NPM_CONFIG_PREFIX) {

      env.NPM_CONFIG_PREFIX = devBundleDir;

    }

    if (env.METEOR_ALLOW_SUPERUSER) {

      // Note that env.METEOR_ALLOW_SUPERUSER could be ""0"" or ""false"", which

      // should propagate falsy semantics to NPM_CONFIG_UNSAFE_PERM.

      env.NPM_CONFIG_UNSAFE_PERM = env.METEOR_ALLOW_SUPERUSER;

    }

    // This allows node-gyp to find Node headers and libraries in

    // dev_bundle/include/node.

    env.NPM_CONFIG_NODEDIR = devBundleDir;

    var PATH = env.PATH || env.Path;

    if (PATH) {

      paths.push(PATH);

    }

    env.PATH = paths.join(path.delimiter);

    if (process.platform === ""win32"") {

      return addWindowsVariables(devBundleDir, env);

    }

    return env;

  });

};

var cachedMSVSVersion;
","async function getEnv(options) {

  const devBundle = options && options.devBundle;

  /**

   * @type string

   */

  const devBundleDir = typeof devBundle === ""string""

    ? await convertToOSPath(devBundle)

    : await getDevBundleDir();

  const paths = [

    // When npm looks for node, it must find dev_bundle/bin/node.

    path.join(devBundleDir, ""bin""),

    // When npm looks for meteor, it should find dev_bundle/../meteor.

    path.dirname(devBundleDir),

    // Also make available any scripts installed by packages in

    // dev_bundle/lib/node_modules, such as node-gyp.

    path.join(devBundleDir, ""lib"", ""node_modules"", "".bin"")

  ];

  const env = Object.create(process.env);

  env.NO_UPDATE_NOTIFIER = true;

  if (!env.NPM_CONFIG_PREFIX) {

    env.NPM_CONFIG_PREFIX = devBundleDir;

  }

  if (env.METEOR_ALLOW_SUPERUSER) {

    // Note that env.METEOR_ALLOW_SUPERUSER could be ""0"" or ""false"", which

    // should propagate falsy semantics to NPM_CONFIG_UNSAFE_PERM.

    env.NPM_CONFIG_UNSAFE_PERM = env.METEOR_ALLOW_SUPERUSER;

  }

  env.NPM_CONFIG_NODEDIR = devBundleDir;

  const PATH = env.PATH || env.Path;



  if (PATH) {

    paths.push(PATH);

  }

  env.PATH = paths.join(path.delimiter);

  if (process.platform === ""win32"") {

    return addWindowsVariables(devBundleDir, env);

  }

  return env;

}

let cachedMSVSVersion;
","exports.getEnv = async function (options) {
  var devBundle = options && options.devBundle;
  var devBundlePromise = typeof devBundle === ""string"" ? Promise.resolve(convertToOSPath(devBundle)) : getDevBundle();
  
  try {
    const devBundleDir = await devBundlePromise;
    const paths = [
      path.join(devBundleDir, ""bin""),
      path.dirname(devBundleDir),
      path.join(devBundleDir, ""lib"", ""node_modules"", "".bin"")
    ];
  
    var env = Object.create(process.env);
    
    // Make sure notifications to update npm aren't presented to the user.
    env.NO_UPDATE_NOTIFIER = true;
    
    // Make sure `meteor npm install --global ...` installs into dev_bundle/lib/node_modules by default.
    if (!env.NPM_CONFIG_PREFIX) {
      env.NPM_CONFIG_PREFIX = devBundleDir;
    }
  
    if (env.METEOR_ALLOW_SUPERUSER) {
      // Note that env.METEOR_ALLOW_SUPERUSER could be ""0"" or ""false"", which should propagate falsy semantics to NPM_CONFIG_UNSAFE_PERM.
      env.NPM_CONFIG_UNSAFE_PERM = env.METEOR_ALLOW_SUPERUSER;
    }
  
    // This allows node-gyp to find Node headers and libraries in dev_bundle/include/node.
    env.NPM_CONFIG_NODEDIR = devBundleDir;
  
    const PATH = env.PATH || env.Path;
    if (PATH) {
      paths.push(PATH);
    }
  
    env.PATH = paths.join(path.delimiter);
  
    if (process.platform === ""win32"") {
      return addWindowsVariables(devBundleDir, env);
    }
  
    return env;
  } catch (error) {
    console.log(""Error:"", error);
  }
};

var cachedMSVSVersion;",0.5912242850244005,0.5766382602231981,0.5871076166828465,0.8113207547169812,0.3898305084745763,0.7915718155466577,0.6456878435159704,0.6507561183828444,0.8867924528301887,0.9830508474576272,0.5781069697435532,0.49785817683784916,0.5303591758205742,0.8842105263157894,0.4
28,"var fs = require(""fs"");

var path = require(""path"");

var links = require(""./dev-bundle-links.js"");

var rootDir = path.resolve(__dirname, "".."", "".."");

var defaultDevBundlePromise =

  Promise.resolve(path.join(rootDir, ""dev_bundle""));



function getDevBundleDir() {

  var releaseFile = find(

    return defaultDevBundlePromise;

  var localDir = path.join(path.dirname(releaseFile), ""local"");

      return defaultDevBundlePromise;

  var devBundleLink = path.join(localDir, ""dev_bundle"");

  var devBundleStat = statOrNull(devBundleLink);

  var release = fs.readFileSync(

    return defaultDevBundlePromise;

  return Promise.resolve(

    getDevBundleForRelease(release)

  ).then(function (devBundleDir) {

    if (devBundleDir) {

      links.makeLink(devBundleDir, devBundleLink);

      return devBundleDir;

    }

    return defaultDevBundlePromise;

  });

  var parts = release.split(""@"");

  var track = parts[0];

  var version = parts.slice(1).join(""@"");

  var packageMetadataDir = find(
","const fs = require(""fs"");

const path = require(""path"");

const links = require(""./dev-bundle-links.js"");

const rootDir = path.resolve(__dirname, "".."", "".."");



const DEFAULT_DEV_BUNDLE_DIR = path.join(rootDir, ""dev_bundle"");



async function getDevBundleDir() {

  const releaseFile = find(

    return DEFAULT_DEV_BUNDLE_DIR;

  const localDir = path.join(path.dirname(releaseFile), ""local"");

      return DEFAULT_DEV_BUNDLE_DIR;

  const devBundleLink = path.join(localDir, ""dev_bundle"");

  const devBundleStat = statOrNull(devBundleLink);

  const release = fs.readFileSync(

    return DEFAULT_DEV_BUNDLE_DIR;

  const devBundleDir = await getDevBundleForRelease(release);

  if (devBundleDir) {

    links.makeLink(devBundleDir, devBundleLink);

    return devBundleDir;

  }



  return DEFAULT_DEV_BUNDLE_DIR;

  const parts = release.split(""@"");

  const track = parts[0];

  const version = parts.slice(1).join(""@"");

  const packageMetadataDir = find(
","var fs = require(""fs"");

var path = require(""path"");

var links = require(""./dev-bundle-links.js"");

var rootDir = path.resolve(__dirname, "".."", "".."");

var defaultDevBundlePromise = Promise.resolve(path.join(rootDir, ""dev_bundle""));

async function getDevBundleDir() {
  try {
    var releaseFile = find(function (file) {
      return fs.statSync(file).isFile();
    });
    if (!releaseFile) {
      return defaultDevBundlePromise;
    }
    var localDir = path.join(path.dirname(releaseFile), ""local"");
    var devBundleLink = path.join(localDir, ""dev_bundle"");
    var devBundleStat = statOrNull(devBundleLink);
    if (devBundleStat && devBundleStat.isDirectory()) {
      links.makeLink(devBundleLink, devBundleLink);
      return Promise.resolve(devBundleLink);
    }
    var release = fs.readFileSync(releaseFile).toString();
    var parts = release.split(""@"");
    var track = parts[0];
    var version = parts.slice(1).join(""@"");
    var packageMetadataDir = find(function (dir) {
      return dir && dir.isDirectory();
    });
    if (!packageMetadataDir) {
      return defaultDevBundlePromise;
    }
    return getDevBundleForRelease(release);
  } catch (error) {
    console.error(""Error getting dev bundle directory:"", error);
    return Promise.reject(error);
  }
}",0.4973613107340168,0.36264929542941143,0.33551627774401366,0.7254901960784313,0.5657894736842105,0.6409347723570339,0.4703519583826244,0.6478246955449952,0.7745098039215687,0.6710526315789473,0.4116633295342072,0.16772161208049957,0.21185096071471446,0.6956521739130435,0.5714285714285714
29,"      this._publishCursorPromise = res._publishCursor(self).then(() => {

        // _publishCursor only returns after the initial added callbacks have run.

        // mark subscription as ready.

        self.ready();

      }).catch((e) => self.error(e));
","      try {

        await res._publishCursor(self);

      } catch (e) {

        self.error(e);

        return;

      }

      // _publishCursor only returns after the initial added callbacks have run.

      // mark subscription as ready.

      self.ready();
","async function publishCursor() {
      try {
        const res = await self._publishCursorPromise();
        // mark subscription as ready
        self.ready();
      } catch (e) {
        self.error(e);
      }
    }",0.6650954549684801,0.5923033072023249,0.6680785126715956,0.4,1.0,0.36427806704583277,0.10866043914193523,0.10845182904139568,0.44,0.8,0.46957578273376716,0.24115687276685477,0.25819888974716115,0.5789473684210527,0.8
30,"      this._publishCursorPromise = Promise.all(

        res.map(c => c._publishCursor(self))

      )

        .then(() => {

          self.ready();

        })

        .catch((e) => self.error(e));
","      try {

        for (const cur of res) {

          await cur._publishCursor(self);

        }

      } catch (e) {

        self.error(e);

        return;

      }

      self.ready();
","async function publishCursor() {
  try {
    const res = await Promise.all(
      this._publishCursorPromise.map((c) => c._publishCursor(self))
    );
    self.ready();
  } catch (e) {
    self.error(e);
  }
}",0.3507069725973658,0.012109013026441871,0.015718877363021206,0.375,1.0,0.29062927563860397,0.023050898626566643,0.03678763249927775,0.53125,0.5714285714285714,0.39351112215448153,0.21233470585998823,0.26647168751984257,0.5238095238095238,0.5714285714285714
31,"      new Promise((resolve, reject) => {

        object[methodName](...args, (err, res) => {

          err ? reject(err) : resolve(res);

        });

      }),
","      (async () => {

        try {

          return await object[methodName](...args);

        } catch (e) {

          throw e;

        }

      })(),
","async function() {

    try {

       const res = await object[methodName](...args);

     } catch (err) {

       reject(err);

     }

   }

  }",0.09247902724798952,0.026920508809559315,0.025535282722081352,0.09523809523809523,0.2222222222222222,0.16121728053971573,0.01284618972676772,0.012975313384476253,0.2857142857142857,0.3333333333333333,0.3118024599508773,0.20706193828327604,0.22435842783602272,0.3157894736842105,0.5
32,"	private _doValidate(resource: Uri): void {

		this._worker(resource).then(worker => {

			if (!monaco.editor.getModel(resource)) {

				// model was disposed in the meantime

				return null;

			}

			const promises: Promise<ts.Diagnostic[]>[] = [];

			const { noSyntaxValidation, noSemanticValidation, noSuggestionDiagnostics } = this._defaults.getDiagnosticsOptions();

			if (!noSyntaxValidation) {

				promises.push(worker.getSyntacticDiagnostics(resource.toString()));

			}

			if (!noSemanticValidation) {

				promises.push(worker.getSemanticDiagnostics(resource.toString()));

			}

			if (!noSuggestionDiagnostics) {

				promises.push(worker.getSuggestionDiagnostics(resource.toString()));

			}

			return Promise.all(promises);

		}).then(diagnostics => {

			if (!diagnostics || !monaco.editor.getModel(resource)) {

				// model was disposed in the meantime

				return null;

			}

			const markers = diagnostics

				.reduce((p, c) => c.concat(p), [])

				.filter(d => (this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(d.code) === -1)

				.map(d => this._convertDiagnostics(resource, d));



			monaco.editor.setModelMarkers(monaco.editor.getModel(resource), this._selector, markers);

		}).then(undefined, err => {

			console.error(err);

		});

	private _convertDiagnostics(resource: Uri, diag: ts.Diagnostic): monaco.editor.IMarkerData {

		const { lineNumber: startLineNumber, column: startColumn } = this._offsetToPosition(resource, diag.start);

		const { lineNumber: endLineNumber, column: endColumn } = this._offsetToPosition(resource, diag.start + diag.length);
","	private async _doValidate(model: monaco.editor.ITextModel): Promise<void> {

		const worker = await this._worker(model.uri);



		if (model.isDisposed()) {

			// model was disposed in the meantime

			return;

		}



		const promises: Promise<ts.Diagnostic[]>[] = [];

		const { noSyntaxValidation, noSemanticValidation, noSuggestionDiagnostics } = this._defaults.getDiagnosticsOptions();

		if (!noSyntaxValidation) {

			promises.push(worker.getSyntacticDiagnostics(model.uri.toString()));

		}

		if (!noSemanticValidation) {

			promises.push(worker.getSemanticDiagnostics(model.uri.toString()));

		}

		if (!noSuggestionDiagnostics) {

			promises.push(worker.getSuggestionDiagnostics(model.uri.toString()));

		}



		const diagnostics = await Promise.all(promises);



		if (!diagnostics || model.isDisposed()) {

			// model was disposed in the meantime

			return;

		}



		const markers = diagnostics

			.reduce((p, c) => c.concat(p), [])

			.filter(d => (this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(d.code) === -1)

			.map(d => this._convertDiagnostics(model, d));



		monaco.editor.setModelMarkers(model, this._selector, markers);

	private _convertDiagnostics(model: monaco.editor.ITextModel, diag: ts.Diagnostic): monaco.editor.IMarkerData {

		const diagStart = diag.start || 0;

		const diagLength = diag.length || 1;

		const { lineNumber: startLineNumber, column: startColumn } = model.getPositionAt(diagStart);

		const { lineNumber: endLineNumber, column: endColumn } = model.getPositionAt(diagStart + diagLength);
","private async _doValidate(resource: Uri): Promise<void> {
  try {
    const worker = await this._worker(resource);

    if (!monaco.editor.getModel(resource)) {
      return null;
    }

    const promises = [];

    const { noSyntaxValidation, noSemanticValidation, noSuggestionDiagnostics } = this._defaults.getDiagnosticsOptions();

    if (!noSyntaxValidation) {
      promises.push(worker.getSyntacticDiagnostics(resource.toString()));
    }

    if (!noSemanticValidation) {
      promises.push(worker.getSemanticDiagnostics(resource.toString()));
    }

    if (!noSuggestionDiagnostics) {
      promises.push(worker.getSuggestionDiagnostics(resource.toString()));
    }

    const diagnostics = await Promise.all(promises);

    if (diagnostics && monaco.editor.getModel(resource)) {
      const markers = diagnostics
        .reduce((p, c) => c.concat(p), [])
        .filter(d => (this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(d.code) === -1)
        .map(d => this._convertDiagnostics(resource, d));
      monaco.editor.setModelMarkers(monaco.editor.getModel(resource), this._selector, markers);
    } else {
      console.error(err);
    }
  } catch (err) {
    console.error(err);
  }
}

private _convertDiagnostics(resource: Uri, diag: ts.Diagnostic): monaco.editor.IMarkerData {
  const { lineNumber: startLineNumber, column: startColumn } = this._offsetToPosition(resource, diag.start);
  const { lineNumber: endLineNumber, column: endColumn } = this._offsetToPosition(resource, diag.start + diag.length);
  return {
    severity: monaco.MarkerSeverity.Error,
    startLineNumber,
    startColumn,
    endLineNumber,
    endColumn,
    message: diag.messageText,
  };
}",0.5789667416519877,0.5383889531860518,0.5623966617322872,0.5797872340425532,0.6352941176470588,0.6592420734725188,0.6117472516583855,0.6371734827823783,0.8351063829787234,0.5529411764705883,0.517189353713275,0.4687597451986843,0.4785287431007435,0.6214689265536724,0.5
33,"	provideCompletionItems(model: monaco.editor.IReadOnlyModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Thenable<monaco.languages.CompletionList> {

		const offset = this._positionToOffset(resource, position);

		return this._worker(resource).then(worker => {

			return worker.getCompletionsAtPosition(resource.toString(), offset);

		}).then(info => {

			if (!info) {

				return;

			}

			let suggestions: MyCompletionItem[] = info.entries.map(entry => {

				let range = wordRange;

				if (entry.replacementSpan) {

					const p1 = model.getPositionAt(entry.replacementSpan.start);

					const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);

					range = new Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);

				}

				return {

					uri: resource,

					position: position,

					range: range,

					label: entry.name,

					insertText: entry.name,

					sortText: entry.sortText,

					kind: SuggestAdapter.convertKind(entry.kind)

				};

			});

				suggestions

	resolveCompletionItem(_model: monaco.editor.IReadOnlyModel, _position: Position, item: monaco.languages.CompletionItem, token: CancellationToken): Thenable<monaco.languages.CompletionItem> {

		let myItem = <MyCompletionItem>item;

		return this._worker(resource).then(worker => {

			return worker.getCompletionEntryDetails(resource.toString(),

				this._positionToOffset(resource, position),

				myItem.label);



		}).then(details => {

			if (!details) {

				return myItem;

			return <MyCompletionItem>{

				uri: resource,

				position: position,

				label: details.name,

				kind: SuggestAdapter.convertKind(details.kind),

				detail: displayPartsToString(details.displayParts),

				documentation: {

					value: displayPartsToString(details.documentation)

				}

			};

		});
","	public async provideCompletionItems(model: monaco.editor.ITextModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Promise<monaco.languages.CompletionList | undefined> {

		const offset = model.getOffsetAt(position);

		const worker = await this._worker(resource);

		const info = await worker.getCompletionsAtPosition(resource.toString(), offset);

		if (!info || model.isDisposed()) {

			return;

		}



		const suggestions: MyCompletionItem[] = info.entries.map(entry => {

			let range = wordRange;

			if (entry.replacementSpan) {

				const p1 = model.getPositionAt(entry.replacementSpan.start);

				const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);

				range = new Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);

			}

				uri: resource,

				position: position,

				range: range,

				label: entry.name,

				insertText: entry.name,

				sortText: entry.sortText,

				kind: SuggestAdapter.convertKind(entry.kind)



		return {

			suggestions

		};

	public async resolveCompletionItem(model: monaco.editor.ITextModel, _position: Position, item: monaco.languages.CompletionItem, token: CancellationToken): Promise<monaco.languages.CompletionItem> {

		const myItem = <MyCompletionItem>item;

		const offset = model.getOffsetAt(position);

		const worker = await this._worker(resource);

		const details = await worker.getCompletionEntryDetails(resource.toString(), offset, myItem.label);

		if (!details || model.isDisposed()) {

			return myItem;

		}

		return <MyCompletionItem>{

			uri: resource,

			position: position,

			label: details.name,

			kind: SuggestAdapter.convertKind(details.kind),

			detail: displayPartsToString(details.displayParts),

			documentation: {

				value: displayPartsToString(details.documentation)

		};
","provideCompletionItems(model: monaco.editor.IReadOnlyModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Thenable<monaco.languages.CompletionList> {
  const offset = this._positionToOffset(resource, position);
  
  return async function() {
    try {
      const worker = await this._worker(resource);
      
      const info = await worker.getCompletionsAtPosition(resource.toString(), offset);
      
      if (!info) {
        return;
      }
      
      let suggestions: MyCompletionItem[] = info.entries.map(entry => {
        let range = wordRange;
        
        if (entry.replacementSpan) {
          const p1 = model.getPositionAt(entry.replacementSpan.start);
          
          const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);
          
          range = new Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);
        }
        
        return {
          uri: resource,
          position: position,
          range: range,
          label: entry.name,
          insertText: entry.name,
          sortText: entry.sortText,
          kind: SuggestAdapter.convertKind(entry.kind)
        };
      });
      
      return suggestions;
    } catch (error) {
      console.log('Error occurred while getting completion items', error);
      return [];
    }
  };
}",0.5643437875770845,0.5319488144143285,0.5735276017167942,0.6518987341772152,0.5,0.5698055791961261,0.5336153168388784,0.5527898083059438,0.7974683544303798,0.3953488372093023,0.48936532030766144,0.4292810803457063,0.4516873815349773,0.7703703703703704,0.30612244897959184
34,"	provideSignatureHelp(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.SignatureHelpResult> {

		let resource = model.uri;

		return this._worker(resource).then(worker => worker.getSignatureHelpItems(resource.toString(), this._positionToOffset(resource, position))).then(info => {

			if (!info) {

				return;

			}

			let ret: monaco.languages.SignatureHelp = {

				activeSignature: info.selectedItemIndex,

				activeParameter: info.argumentIndex,

				signatures: []

			};

			info.items.forEach(item => {

				let signature: monaco.languages.SignatureInformation = {

					label: '',

					parameters: []

				};

				signature.documentation = displayPartsToString(item.documentation);

				signature.label += displayPartsToString(item.prefixDisplayParts);

				item.parameters.forEach((p, i, a) => {

					let label = displayPartsToString(p.displayParts);

					let parameter: monaco.languages.ParameterInformation = {

						label: label,

						documentation: displayPartsToString(p.documentation)

					};

					signature.label += label;

					signature.parameters.push(parameter);

					if (i < a.length - 1) {

						signature.label += displayPartsToString(item.separatorDisplayParts);

					}

				});

				signature.label += displayPartsToString(item.suffixDisplayParts);

				ret.signatures.push(signature);



			return {

				value: ret,

				dispose() { }

			};
","	public async provideSignatureHelp(model: monaco.editor.ITextModel, position: Position, token: CancellationToken): Promise<monaco.languages.SignatureHelpResult | undefined> {

		const resource = model.uri;

		const offset = model.getOffsetAt(position);

		const worker = await this._worker(resource);

		const info = await worker.getSignatureHelpItems(resource.toString(), offset);

		if (!info || model.isDisposed()) {

			return;

		}

		const ret: monaco.languages.SignatureHelp = {

			activeSignature: info.selectedItemIndex,

			activeParameter: info.argumentIndex,

			signatures: []

		};

		info.items.forEach(item => {

			const signature: monaco.languages.SignatureInformation = {

				label: '',

				parameters: []

			};

			signature.documentation = displayPartsToString(item.documentation);

			signature.label += displayPartsToString(item.prefixDisplayParts);

			item.parameters.forEach((p, i, a) => {

				const label = displayPartsToString(p.displayParts);

				const parameter: monaco.languages.ParameterInformation = {

					label: label,

					documentation: displayPartsToString(p.documentation)

				};

				signature.label += label;

				signature.parameters.push(parameter);

				if (i < a.length - 1) {

					signature.label += displayPartsToString(item.separatorDisplayParts);

				}

			signature.label += displayPartsToString(item.suffixDisplayParts);

			ret.signatures.push(signature);



		return {

			value: ret,

			dispose() { }

		};
","async function provideSignatureHelp(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Promise<monaco.languages.SignatureHelpResult> {
  let resource = model.uri;

  try {
    const worker = await this._worker(resource);
    const info = await worker.getSignatureHelpItems(resource.toString(), this._positionToOffset(resource, position));

    if (!info) {
      return;
    }

    let ret: monaco.languages.SignatureHelp = {
      activeSignature: info.selectedItemIndex,
      activeParameter: info.argumentIndex,
      signatures: []
    };

    info.items.forEach(item => {
      let signature: monaco.languages.SignatureInformation = {
        label: '',
        parameters: []
      };

      signature.documentation = displayPartsToString(item.documentation);

      signature.label += displayPartsToString(item.prefixDisplayParts);

      item.parameters.forEach((p, i, a) => {
        let label = displayPartsToString(p.displayParts);

        let parameter: monaco.languages.ParameterInformation = {
          label: label,
          documentation: displayPartsToString(p.documentation)
        };

        signature.label += label;

        signature.parameters.push(parameter);

        if (i < a.length - 1) {
          signature.label += displayPartsToString(item.separatorDisplayParts);
        }
      });

      signature.label += displayPartsToString(item.suffixDisplayParts);

      ret.signatures.push(signature);
    });

    return {
      value: ret,
      dispose() {}
    };
  } catch (err) {
    console.error(err);
  }
}",0.6240924312686785,0.6279167136914363,0.6728553836460514,0.7737226277372263,0.421875,0.7588100691718251,0.7424786548673115,0.8491028626959013,0.9124087591240876,0.53125,0.622528681512236,0.6506097783451958,0.644335001371011,0.823076923076923,0.37209302325581395
35,"	provideHover(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.Hover> {

		let resource = model.uri;

		return this._worker(resource).then(worker => {

			return worker.getQuickInfoAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(info => {

			if (!info) {

				return;

			let documentation = displayPartsToString(info.documentation);

			let tags = info.tags ? info.tags.map(tag => {

				const label = `*@${tag.name}*`;

				if (!tag.text) {

					return label;

				}

				return label + (tag.text.match(/\r\n|\n/g) ? ' \n' + tag.text : ` - ${tag.text}`);

			})

				.join('  \n\n') : '';

			let contents = displayPartsToString(info.displayParts);

			return {

				range: this._textSpanToRange(resource, info.textSpan),

				contents: [{

					value: '```js\n' + contents + '\n```\n'

				}, {

					value: documentation + (tags ? '\n\n' + tags : '')

				}]

			};

		});
","	public async provideHover(model: monaco.editor.ITextModel, position: Position, token: CancellationToken): Promise<monaco.languages.Hover | undefined> {

		const resource = model.uri;

		const offset = model.getOffsetAt(position);

		const worker = await this._worker(resource);

		const info = await worker.getQuickInfoAtPosition(resource.toString(), offset);

		if (!info || model.isDisposed()) {

			return;

		}



		const documentation = displayPartsToString(info.documentation);

		const tags = info.tags ? info.tags.map(tag => {

			const label = `*@${tag.name}*`;

			if (!tag.text) {

				return label;

			return label + (tag.text.match(/\r\n|\n/g) ? ' \n' + tag.text : ` - ${tag.text}`);

		}).join('  \n\n') : '';

		const contents = displayPartsToString(info.displayParts);

		return {

			range: this._textSpanToRange(model, info.textSpan),

			contents: [{

				value: '```js\n' + contents + '\n```\n'

			}, {

				value: documentation + (tags ? '\n\n' + tags : '')

			}]

		};
","\n',
      }, {
        value: documentation + (tags ? '\n\n' + tags : ''),
      }],
    };
  } catch (error) {
    console.log('Error in provideHover: ', error);
  }
}",0.5793513793417595,0.5681404497048069,0.5955436232996664,0.7130434782608696,0.4406779661016949,0.10292317920410855,0.024705107519031513,0.09310404260617207,0.22608695652173913,0.06779661016949153,0.0958957292692139,0.018161749319717587,0.08447612410022998,0.22033898305084745,0.06060606060606061
36,"	public provideDocumentHighlights(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.DocumentHighlight[]> {

		return this._worker(resource).then(worker => {

			return worker.getOccurrencesAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(entries => {

			if (!entries) {

				return;

			}

			return entries.map(entry => {

				return <monaco.languages.DocumentHighlight>{

					range: this._textSpanToRange(resource, entry.textSpan),

					kind: entry.isWriteAccess ? monaco.languages.DocumentHighlightKind.Write : monaco.languages.DocumentHighlightKind.Text

				};

			});
","	public async provideDocumentHighlights(model: monaco.editor.ITextModel, position: Position, token: CancellationToken): Promise<monaco.languages.DocumentHighlight[] | undefined> {

		const offset = model.getOffsetAt(position)

		const worker = await this._worker(resource);

		const entries = await worker.getOccurrencesAtPosition(resource.toString(), offset);

		if (!entries || model.isDisposed()) {

			return;

		}



		return entries.map(entry => {

			return <monaco.languages.DocumentHighlight>{

				range: this._textSpanToRange(model, entry.textSpan),

				kind: entry.isWriteAccess ? monaco.languages.DocumentHighlightKind.Write : monaco.languages.DocumentHighlightKind.Text

			};
","async provideDocumentHighlights(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken) {
    const resource = this._worker(model);
    const entries = await worker.getOccurrencesAtPosition(resource.toString(), this._positionToOffset(resource, position));

    if (!entries) {
        return;
    }

    return entries.map((entry) => {
        return <monaco.languages.DocumentHighlight>{
            range: this._textSpanToRange(resource, entry.textSpan),
            kind: entry.isWriteAccess ? monaco.languages.DocumentHighlightKind.Write : monaco.languages.DocumentHighlightKind.Text,
        };
    });
}",0.5516610016566256,0.3727510539581277,0.44792804038767287,0.6491228070175439,0.7368421052631579,0.553826818723052,0.5001406535841676,0.4870964458694438,0.7017543859649122,0.5263157894736842,0.4739280621453969,0.3226888450119459,0.32969007023630836,0.6833333333333333,0.56
37,"	public provideDefinition(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.Definition> {

		return this._worker(resource).then(worker => {

			return worker.getDefinitionAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(entries => {

			if (!entries) {

				return;

			}

			const result: monaco.languages.Location[] = [];

			for (let entry of entries) {

				const uri = Uri.parse(entry.fileName);

				if (monaco.editor.getModel(uri)) {

					result.push({

						uri: uri,

						range: this._textSpanToRange(uri, entry.textSpan)

					});

				}

			return result;

		});
","	public async provideDefinition(model: monaco.editor.ITextModel, position: Position, token: CancellationToken): Promise<monaco.languages.Definition | undefined> {

		const offset = model.getOffsetAt(position);

		const worker = await this._worker(resource);

		const entries = await worker.getDefinitionAtPosition(resource.toString(), offset);

		if (!entries || model.isDisposed()) {

			return;

		}



		const result: monaco.languages.Location[] = [];

		for (let entry of entries) {

			const uri = Uri.parse(entry.fileName);

			const refModel = monaco.editor.getModel(uri);

			if (refModel) {

				result.push({

					uri: uri,

					range: this._textSpanToRange(refModel, entry.textSpan)

				});

		}

		return result;
","public async provideDefinition(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Promise<monaco.languages.Definition> {
    try {
        const worker = await this._worker(resource);
        const entries = await worker.getDefinitionAtPosition(resource.toString(), this._positionToOffset(resource, position));
        if (!entries) {
            return;
        }
        const result: monaco.languages.Location[] = [];
        for (let entry of entries) {
            const uri = Uri.parse(entry.fileName);
            if (monaco.editor.getModel(uri)) {
                result.push({
                    uri: uri,
                    range: this._textSpanToRange(uri, entry.textSpan),
                });
            }
        }
        return result;
    } catch (error) {
        console.log(error);
    }
}",0.5339202437772912,0.41452551012608113,0.5145917584193771,0.6351351351351351,0.5714285714285714,0.6316214005730285,0.5504579767058693,0.6613558109144304,0.7432432432432432,0.5714285714285714,0.5920572691965073,0.5354614329840173,0.5461009771353452,0.7866666666666666,0.5
38,"	provideReferences(model: monaco.editor.IReadOnlyModel, position: Position, context: monaco.languages.ReferenceContext, token: CancellationToken): Thenable<monaco.languages.Location[]> {

		return this._worker(resource).then(worker => {

			return worker.getReferencesAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(entries => {

			if (!entries) {

				return;

			}

			const result: monaco.languages.Location[] = [];

			for (let entry of entries) {

				const uri = Uri.parse(entry.fileName);

				if (monaco.editor.getModel(uri)) {

					result.push({

						uri: uri,

						range: this._textSpanToRange(uri, entry.textSpan)

					});

				}

			return result;

		});
","	public async provideReferences(model: monaco.editor.ITextModel, position: Position, context: monaco.languages.ReferenceContext, token: CancellationToken): Promise<monaco.languages.Location[] | undefined> {

		const offset = model.getOffsetAt(position);

		const worker = await this._worker(resource);

		const entries = await worker.getReferencesAtPosition(resource.toString(), offset);

		if (!entries || model.isDisposed()) {

			return;

		}



		const result: monaco.languages.Location[] = [];

		for (let entry of entries) {

			const uri = Uri.parse(entry.fileName);

			const refModel = monaco.editor.getModel(uri);

			if (refModel) {

				result.push({

					uri: uri,

					range: this._textSpanToRange(refModel, entry.textSpan)

				});

		}

		return result;
","provideReferences(model: monaco.editor.IReadOnlyModel, position: Position, context: monaco.languages.ReferenceContext, token: CancellationToken): async Task<monaco.languages.Location[]> {

	try {

		const worker = await this._worker(resource);

		const entries = await worker.getReferencesAtPosition(resource.toString(), this._positionToOffset(resource, position));

		if (!entries) {

			return;

		}

		const result: monaco.languages.Location[] = [];

		for (let entry of entries) {

			const uri = Uri.parse(entry.fileName);

			if (monaco.editor.getModel(uri)) {

				result.push({

					uri: uri,

					range: this._textSpanToRange(uri, entry.textSpan)

				});

			}

		return result;

	} catch (error) {

		console.error(error);

	}

};",0.5505508531691329,0.43016514782061865,0.5375469497194365,0.6538461538461539,0.5806451612903226,0.6882627082655531,0.6301978925476207,0.7394782506882891,0.5769230769230769,0.8064516129032258,0.5308543045760743,0.5607670582530279,0.5648113209033843,0.6075949367088608,0.3902439024390244
39,"	public provideDocumentSymbols(model: monaco.editor.IReadOnlyModel, token: CancellationToken): Thenable<monaco.languages.DocumentSymbol[]> {

		return this._worker(resource).then(worker => worker.getNavigationBarItems(resource.toString())).then(items => {

			if (!items) {

				return;

			}

			const convert = (bucket: monaco.languages.DocumentSymbol[], item: ts.NavigationBarItem, containerLabel?: string): void => {

				let result: monaco.languages.DocumentSymbol = {

					name: item.text,

					detail: '',

					kind: <monaco.languages.SymbolKind>(outlineTypeTable[item.kind] || monaco.languages.SymbolKind.Variable),

					range: this._textSpanToRange(resource, item.spans[0]),

					selectionRange: this._textSpanToRange(resource, item.spans[0]),

					tags: [],

					containerName: containerLabel

				};

				if (item.childItems && item.childItems.length > 0) {

					for (let child of item.childItems) {

						convert(bucket, child, result.name);

					}



				bucket.push(result);

			let result: monaco.languages.DocumentSymbol[] = [];

			items.forEach(item => convert(result, item));

			return result;

		});
","	public async provideDocumentSymbols(model: monaco.editor.ITextModel, token: CancellationToken): Promise<monaco.languages.DocumentSymbol[] | undefined> {

		const worker = await this._worker(resource);

		const items = await worker.getNavigationBarItems(resource.toString());

		if (!items || model.isDisposed()) {

			return;

		}

		const convert = (bucket: monaco.languages.DocumentSymbol[], item: ts.NavigationBarItem, containerLabel?: string): void => {

			let result: monaco.languages.DocumentSymbol = {

				name: item.text,

				detail: '',

				kind: <monaco.languages.SymbolKind>(outlineTypeTable[item.kind] || monaco.languages.SymbolKind.Variable),

				range: this._textSpanToRange(model, item.spans[0]),

				selectionRange: this._textSpanToRange(model, item.spans[0]),

				tags: [],

				containerName: containerLabel

			};

			if (item.childItems && item.childItems.length > 0) {

				for (let child of item.childItems) {

					convert(bucket, child, result.name);

			bucket.push(result);

		}



		let result: monaco.languages.DocumentSymbol[] = [];

		items.forEach(item => convert(result, item));

		return result;
","async function provideDocumentSymbols(model: monaco.editor.IReadOnlyModel, token: CancellationToken): Promise<monaco.languages.DocumentSymbol[]> {
	const worker = await this._worker(resource);
	try {
		const items = await worker.getNavigationBarItems(resource.toString());
		if (!items) return;

		const result: monaco.languages.DocumentSymbol[] = [];
		items.forEach((item) => convert(result, item));
		return result;
	} catch (err) {
		console.error(""Error getting navigation bar items:"", err);
	}
}",0.6787306753322913,0.6639970089973483,0.7313153843494157,0.7790697674418605,0.5405405405405406,0.2908890601084813,0.09124364231937383,0.11285313865509192,0.5,0.4594594594594595,0.29064207164296185,0.13218667053509442,0.1854891429184735,0.5698924731182796,0.275
40,"	protected _convertTextChanges(uri: Uri, change: ts.TextChange): monaco.editor.ISingleEditOperation {

		return <monaco.editor.ISingleEditOperation>{

			range: this._textSpanToRange(uri, change.span)

	provideDocumentRangeFormattingEdits(model: monaco.editor.IReadOnlyModel, range: Range, options: monaco.languages.FormattingOptions, token: CancellationToken): Thenable<monaco.editor.ISingleEditOperation[]> {

		return this._worker(resource).then(worker => {

			return worker.getFormattingEditsForRange(resource.toString(),

				this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn }),

				this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn }),

				FormatHelper._convertOptions(options));

		}).then(edits => {

			if (edits) {

				return edits.map(edit => this._convertTextChanges(resource, edit));

			}

		});
","	protected _convertTextChanges(model: monaco.editor.ITextModel, change: ts.TextChange): monaco.languages.TextEdit {

		return {

			range: this._textSpanToRange(model, change.span)

	public async provideDocumentRangeFormattingEdits(model: monaco.editor.ITextModel, range: Range, options: monaco.languages.FormattingOptions, token: CancellationToken): Promise<monaco.languages.TextEdit[] | undefined> {

		const startOffset = model.getOffsetAt({ lineNumber: range.startLineNumber, column: range.startColumn });

		const endOffset = model.getOffsetAt({ lineNumber: range.endLineNumber, column: range.endColumn });

		const worker = await this._worker(resource);

		const edits = await worker.getFormattingEditsForRange(resource.toString(), startOffset, endOffset, FormatHelper._convertOptions(options));

		if (!edits || model.isDisposed()) {

			return;

		}



		return edits.map(edit => this._convertTextChanges(model, edit));
","protected async _convertTextChanges(uri: Uri, change: ts.TextChange): Promise<monaco.editor.ISingleEditOperation> {
	try {
		const edits = await this._worker(resource).then((worker) => {
			return worker.getFormattingEditsForRange(
				resource.toString(),
				this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn }),
				this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn }),
				FormatHelper._convertOptions(options)
			);
		});
		if (edits) {
			return edits.map((edit) => this._convertTextChanges(resource, edit));
		}
	} catch (error) {}
}",0.4464951510590285,0.18236919750590208,0.22752958139582952,0.6341463414634146,0.7419354838709677,0.4668458108815572,0.3924907623973572,0.39700105705334027,0.6585365853658537,0.41935483870967744,0.3284732785410558,0.12407366156892927,0.13418515068175738,0.6144578313253012,0.4411764705882353
41,"	provideOnTypeFormattingEdits(model: monaco.editor.IReadOnlyModel, position: Position, ch: string, options: monaco.languages.FormattingOptions, token: CancellationToken): Thenable<monaco.editor.ISingleEditOperation[]> {

		return this._worker(resource).then(worker => {

			return worker.getFormattingEditsAfterKeystroke(resource.toString(),

				this._positionToOffset(resource, position),

				ch, FormatHelper._convertOptions(options));

		}).then(edits => {

			if (edits) {

				return edits.map(edit => this._convertTextChanges(resource, edit));

			}

		});
","	public async provideOnTypeFormattingEdits(model: monaco.editor.ITextModel, position: Position, ch: string, options: monaco.languages.FormattingOptions, token: CancellationToken): Promise<monaco.languages.TextEdit[] | undefined> {

		const offset = model.getOffsetAt(position);

		const worker = await this._worker(resource);

		const edits = await worker.getFormattingEditsAfterKeystroke(resource.toString(), offset, ch, FormatHelper._convertOptions(options));

		if (!edits || model.isDisposed()) {

			return;

		}



		return edits.map(edit => this._convertTextChanges(model, edit));
","async function provideOnTypeFormattingEdits(model: monaco.editor.IReadOnlyModel, position: Position, ch: string, options: monaco.languages.FormattingOptions, token: CancellationToken): Promise<monaco.editor.ISingleEditOperation[]> {
	const worker = await this._worker(resource);
	const edits = await worker.getFormattingEditsAfterKeystroke(resource.toString(), this._positionToOffset(resource, position), ch, FormatHelper._convertOptions(options));
	if (edits) {
		return edits.map(edit => this._convertTextChanges(resource, edit));
	}
}",0.45949047749454097,0.21034334495492102,0.2704757078803857,0.6071428571428571,0.75,0.6394886867782152,0.5318532291918212,0.5653872322067542,0.6607142857142857,0.8,0.5377134841415838,0.42517709763247297,0.43432345547521545,0.6842105263157895,0.6071428571428571
42,"	public provideCodeActions(model: monaco.editor.ITextModel, range: Range, context: monaco.languages.CodeActionContext, token: CancellationToken): Promise<monaco.languages.CodeActionList> {

		return this._worker(resource).then(worker => {

			const start = this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn });

			const end = this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn });



			const formatOptions = FormatHelper._convertOptions(model.getOptions());

			const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);



			return worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions);



		}).then(codeFixes => {

			return codeFixes.filter(fix => {

				// Removes any 'make a new file'-type code fix

				return fix.changes.filter(change => change.isNewFile).length === 0;

			}).map(fix => {

				return this._tsCodeFixActionToMonacoCodeAction(model, context, fix);

			})

		}).then(result => {

			return {

				actions: result,

				dispose: () => { }

			};
","	public async provideCodeActions(model: monaco.editor.ITextModel, range: Range, context: monaco.languages.CodeActionContext, token: CancellationToken): Promise<monaco.languages.CodeActionList | undefined> {

		const start = model.getOffsetAt({ lineNumber: range.startLineNumber, column: range.startColumn });

		const end = model.getOffsetAt({ lineNumber: range.endLineNumber, column: range.endColumn });

		const formatOptions = FormatHelper._convertOptions(model.getOptions());

		const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);

		const worker = await this._worker(resource);

		const codeFixes = await worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions);

		if (!codeFixes || model.isDisposed()) {

			return;

		}

		const actions = codeFixes.filter(fix => {

			// Removes any 'make a new file'-type code fix

			return fix.changes.filter(change => change.isNewFile).length === 0;

		}).map(fix => {

			return this._tsCodeFixActionToMonacoCodeAction(model, context, fix);



		return {

			actions: actions,

			dispose: () => { }

		};
","public provideCodeActions(model: monaco.editor.ITextModel, range: Range, context: monaco.languages.CodeActionContext, token: CancellationToken): Promise<monaco.languages.CodeActionList> {
  return async (async () => {
    const worker = await this._worker(resource);
    const start = this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn });
    const end = this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn });
    const formatOptions = FormatHelper._convertOptions(model.getOptions());
    const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);
    const codeFixes = await worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions);
    const filteredCodeFixes = codeFixes.filter(fix => {
      return fix.changes.filter(change => change.isNewFile).length === 0;
    });
    const actions = filteredCodeFixes.map(fix => this._tsCodeFixActionToMonacoCodeAction(model, context, fix));
    return {
      actions: actions,
      dispose: () => {}
    };
  })();
}",0.665050385553092,0.6284197632910443,0.6706066637139505,0.7321428571428571,0.6290322580645161,0.6351596432985657,0.5932408488770783,0.5882387381420692,0.7946428571428571,0.5645161290322581,0.6297365304416933,0.5801833690069584,0.5867895475756006,0.8440366972477065,0.5079365079365079
43,"'use strict';



import Thenable = monaco.Thenable;

import IWorkerContext = monaco.worker.IWorkerContext;

class PromiseAdapter<T> implements jsonService.Thenable<T> {

	private wrapped: Promise<T>;



	constructor(executor: (resolve: (value?: T | jsonService.Thenable<T>) => void, reject: (reason?: any) => void) => void) {

		this.wrapped = new Promise<T>(executor);

	}

	public then<TResult>(onfulfilled?: (value: T) => TResult | jsonService.Thenable<TResult>, onrejected?: (reason: any) => void): jsonService.Thenable<TResult> {

		let thenable: jsonService.Thenable<T> = this.wrapped;

		return thenable.then(onfulfilled, onrejected);

	}

	public getWrapped(): monaco.Thenable<T> {

		return this.wrapped;

	}

	public static resolve<T>(v: T | Thenable<T>): jsonService.Thenable<T> {

		return <monaco.Thenable<T>>Promise.resolve(v);

	}

	public static reject<T>(v: T): jsonService.Thenable<T> {

		return Promise.reject(<any>v);

	}

	public static all<T>(values: jsonService.Thenable<T>[]): jsonService.Thenable<T[]> {

		return Promise.all(values);

	}

}



	private _ctx: IWorkerContext;

	constructor(ctx: IWorkerContext, createData: ICreateData) {

			schemaRequestService: createData.enableSchemaRequest && defaultSchemaRequestService,

			promiseConstructor: PromiseAdapter

	doValidation(uri: string): Thenable<jsonService.Diagnostic[]> {
","import type { worker } from './fillers/monaco-editor-core'

	private _ctx: worker.IWorkerContext;

	constructor(ctx: worker.IWorkerContext, createData: ICreateData) {

			schemaRequestService: createData.enableSchemaRequest && defaultSchemaRequestService

	async doValidation(uri: string): Promise<jsonService.Diagnostic[]> {
","const jsonService = require('monaco-editor');

class PromiseAdapter<T> implements jsonService.Thenable<T> {
  private wrapped: Promise<T>;

  constructor(executor: (resolve: (value?: T | jsonService.Thenable<T>) => void, reject: (reason?: any) => void) => void) {
    this.wrapped = new Promise<T>(executor);
  }

  public then<TResult>(onfulfilled?: (value: T) => TResult | jsonService.Thenable<TResult>, onrejected?: (reason: any) => void): jsonService.Thenable<TResult> {
    let thenable: jsonService.Thenable<T> = this.wrapped;
    return thenable.then(onfulfilled, onrejected);
  }

  public getWrapped(): monaco.Thenable<T> {
    return this.wrapped;
  }

  public static resolve<T>(v: T | Thenable<T>): jsonService.Thenable<T> {
    return <monaco.Thenable<T>>Promise.resolve(v);
  }

  public static reject<T>(v: T): jsonService.Thenable<T> {
    return Promise.reject(<any>v);
  }

  public static all<T>(values: jsonService.Thenable<T>[]): jsonService.Thenable<T[]> {
    return Promise.all(values);
  }
}",0.07770029586425915,0.00527789385985922,0.049754058827946646,0.2076923076923077,0.04807692307692308,0.7221561894313913,0.7432152767403966,0.7704094809851684,0.8846153846153846,0.49038461538461536,0.21105034987598928,0.0028749645610954347,0.012755006371433137,0.42857142857142855,0.4
44,"languages.onLanguage(htmlLanguageId, () => {

	getMode().then((mode) => mode.setupMode(htmlDefaults));

});

languages.onLanguage(handlebarsLanguageId, () => {

	getMode().then((mode) => mode.setupMode(handlebarDefaults));

});

languages.onLanguage(razorLanguageId, () => {

	getMode().then((mode) => mode.setupMode(razorDefaults));

});
","export interface LanguageServiceRegistration extends IDisposable {

	readonly defaults: LanguageServiceDefaults;

}



/**

 * Registers a new HTML language service for the languageId.

 * Note: 'html', 'handlebar' and 'razor' are registered by default.

 *

 * Use this method to register additional language ids with a HTML service.

 * The language server has to be registered before an editor model is opened.

 */

export function registerHTMLLanguageService(

	languageId: string,

	options: Options,

	modeConfiguration: ModeConfiguration

): LanguageServiceRegistration {

	const defaults = new LanguageServiceDefaultsImpl(languageId, options, modeConfiguration);

	let mode: IDisposable | undefined;



	// delay the initalization of the mode until the language is accessed the first time

	const onLanguageListener = languages.onLanguage(languageId, async () => {

		mode = (await getMode()).setupMode(defaults);

	});

	return {

		defaults,

		dispose() {

			onLanguageListener.dispose();

			mode?.dispose();

			mode = undefined;

		}

	};

}
","async function setupModes() {
	try {
		await languages.onLanguage(htmlLanguageId, async () => {
			const mode = await getMode();
			mode.setupMode(htmlDefaults);
		});

		await languages.onLanguage(handlebarsLanguageId, async () => {
			const mode = await getMode();
			mode.setupMode(handlebarDefaults);
		});

		await languages.onLanguage(razorLanguageId, async () => {
			const mode = await getMode();
			mode.setupMode(razorDefaults);
		});
	} catch (error) {
		// Error handling
	}
}",0.24141397111014726,0.008475125762821382,0.04657469807170698,0.32727272727272727,0.5833333333333334,0.3191710115949714,0.0434290324373239,0.10143683212438005,0.38181818181818183,0.75,0.11974570298218462,0.020621648294843035,0.0331759784487103,0.18518518518518517,0.24
45,"	test(mainLanguage + ' tokenization', (t: test.Test) => {

		Promise.all(languages.map((l) => loadLanguage(l)))

			.then(() => {

				// clean stack

				setTimeout(() => {

					runTests(t, mainLanguage, tests);

					t.end();

				});

			})

			.then(null, () => t.end());
","	test(mainLanguage + ' tokenization', async (t: test.Test) => {

		await Promise.all(languages.map((l) => loadLanguage(l)));

		await timeout(0);

		runTests(t, mainLanguage, tests);
","async function test(mainLanguage + ' tokenization', (t: test.Test) => {

	await Promise.all(languages.map((l) => loadLanguage(l)));

	// clean stack

	setTimeout(() => {

		runTests(t, mainLanguage, tests);

		t.end();

	});
})",0.4105796941144954,0.18240370007617487,0.20536962183635218,0.45454545454545453,0.8,0.6908570508097202,0.6128136505863147,0.6142509162889299,0.6363636363636364,0.9,0.6508772348811883,0.4122974402951816,0.5912114992295717,0.6,1.0
46,"	languages.setMonarchTokensProvider(

		languageId,

		lazyLanguageLoader.whenLoaded().then((mod) => mod.language)

	);

	languages.onLanguage(languageId, () => {

		lazyLanguageLoader.load().then((mod) => {

			languages.setLanguageConfiguration(languageId, mod.conf);

		});
","	languages.registerTokensProviderFactory(languageId, {

		create: async (): Promise<languages.IMonarchLanguage> => {

			const mod = await lazyLanguageLoader.load();

			return mod.language;

		}

	});

	languages.onLanguage(languageId, async () => {

		const mod = await lazyLanguageLoader.load();

		languages.setLanguageConfiguration(languageId, mod.conf);
","async function migrate(languageId) {
  try {
    const mod = await lazyLanguageLoader.whenLoaded();
    languages.setMonarchTokensProvider(languageId, mod.language);
  } catch (err) {
    console.error(err);
  }
}",0.36565388560029255,0.050130535041617,0.09528070628428419,0.4838709677419355,0.8333333333333334,0.2397189400103641,0.011451997463067555,0.014628063653657535,0.5161290322580645,0.4166666666666667,0.3011024496181407,0.1323746013285873,0.14346376857254692,0.5,0.42857142857142855
47,"			this._worker = editor.createWebWorker<TypeScriptWorker>({

				// module that exports the create() method and returns a `TypeScriptWorker` instance

				moduleId: 'vs/language/typescript/tsWorker',



				label: this._modeId,

				keepIdleModels: true,



				// passed in to the create() method

				createData: {

					compilerOptions: this._defaults.getCompilerOptions(),

					extraLibs: this._defaults.getExtraLibs(),

					customWorkerPath: this._defaults.workerOptions.customWorkerPath,

					inlayHintsOptions: this._defaults.inlayHintsOptions

				}

			});

			let p = <Promise<TypeScriptWorker>>this._worker.getProxy();

			if (this._defaults.getEagerModelSync()) {

				p = p.then((worker) => {

					if (this._worker) {

						return this._worker.withSyncedResources(

							editor

								.getModels()

								.filter((model) => model.getLanguageId() === this._modeId)

								.map((model) => model.uri)

						);

					return worker;

			}

			this._client = p;

	getLanguageServiceWorker(...resources: Uri[]): Promise<TypeScriptWorker> {

		let _client: TypeScriptWorker;

		return this._getClient()

			.then((client) => {

				_client = client;

			})

			.then((_) => {

				if (this._worker) {

					return this._worker.withSyncedResources(resources);

				}

			})

			.then((_) => _client);
","			this._client = (async () => {

				this._worker = editor.createWebWorker<TypeScriptWorker>({

					// module that exports the create() method and returns a `TypeScriptWorker` instance

					moduleId: 'vs/language/typescript/tsWorker',

					label: this._modeId,

					keepIdleModels: true,

					// passed in to the create() method

					createData: {

						compilerOptions: this._defaults.getCompilerOptions(),

						extraLibs: this._defaults.getExtraLibs(),

						customWorkerPath: this._defaults.workerOptions.customWorkerPath,

						inlayHintsOptions: this._defaults.inlayHintsOptions

				if (this._defaults.getEagerModelSync()) {

					return await this._worker.withSyncedResources(

						editor

							.getModels()

							.filter((model) => model.getLanguageId() === this._modeId)

							.map((model) => model.uri)

					);

				}



				return await this._worker.getProxy();

			})();

	async getLanguageServiceWorker(...resources: Uri[]): Promise<TypeScriptWorker> {

		const client = await this._getClient();

		if (this._worker) {

			await this._worker.withSyncedResources(resources);

		}

		return client;
","Code to be migrated:
			this._worker = editor.createWebWorker<TypeScriptWorker>({

				// module that exports the create() method and returns a `TypeScriptWorker` instance

				moduleId: 'vs/language/typescript/tsWorker',



				label: this._modeId,

				keepIdleModels: true,



				// passed in to the create() method

				createData: {

					compilerOptions: this._defaults.getCompilerOptions(),

					extraLibs: this._defaults.getExtraLibs(),

					customWorkerPath: this._defaults.workerOptions.customWorkerPath,

					inlayHintsOptions: this._defaults.inlayHintsOptions

				}

			});

			let p = <Promise<TypeScriptWorker>>this._worker.getProxy();

			if (this._defaults.getEagerModelSync()) {

				p = p.then((worker) => {

					if (this._worker) {

						return this._worker.withSyncedResources(

							editor

								.getModels()

								.filter((model) => model.getLanguageId() === this._modeId)

								.map((model) => model.uri)

					);

					return worker;

			}

			this._client = p;

async getLanguageServiceWorker(...resources: Uri[]): Promise<TypeScriptWorker> {

	let _client: TypeScriptWorker;

	await this._getClient()

		.then((client) => {

			_client = client;

		})

		.then((_) => {

			if (this._worker) {

				return this._worker.withSyncedResources(resources);

			}

		})

		.then((_) => _client);",0.49397741259052513,0.5375816283546541,0.5423280220074462,0.616,0.28,0.9472252550224332,0.9150013031921256,0.953899716897607,0.92,1.0,0.6231236139656534,0.5334602572969038,0.6716192325793154,0.7040816326530612,0.5833333333333334
48,"  var self = this;

  var finalPromise = new Promise(fn);



  // Jank to be able to use mpromise.prototype.all()

  var p0 = new Promise;

  p0.fulfill();



  // Call save hooks on subdocs

  var p1 = p0.all(function () {

    var subDocs = self.$__getAllSubdocs();

    return subDocs.map(function (d) {return d.save();});

  });



  // Handle save and resaults

  p1

    .then(this.$__handleSave.bind(this, options))

    .then(function (result) {

      self.$__reset();

      self.$__storeShard();



      var numAffected = 0;

      if (result) {

        if (Array.isArray(result)) {

          numAffected = result.length;

        } else if (result.result && result.result.n !== undefined) {

          numAffected = result.result.n;

        } else if (result.result && result.result.nModified !== undefined) {

          numAffected = result.result.nModified;

        } else {

          numAffected = result;

      }



      // was this an update that required a version bump?

      if (self.$__.version && !self.$__.inserting) {

        var doIncrement = VERSION_INC === (VERSION_INC & self.$__.version);

        self.$__.version = undefined;

        if (numAffected <= 0) {

          // the update failed. pass an error back

          return finalPromise.reject(new VersionError);

        // increment version if was successful

        if (doIncrement) {

          var key = self.schema.options.versionKey;

          var version = self.getValue(key) | 0;

          self.setValue(key, version + 1);

        }

      }

      self.emit('save', self, numAffected);

      return finalPromise.fulfill(self, numAffected);

    }

    , function (err) {

      // If the initial insert fails provide a second chance.

      // (If we did this all the time we would break updates)

      if (self.$__.inserting) {

        self.isNew = true;

        self.emit('isNew', true);

      }

      finalPromise.reject(err);

    })

    .end();

  return finalPromise;
","  var _this = this;

  var promise = new Promise.ES6(function(resolve, reject) {

    async.each(

      _this.$__getAllSubdocs(),

      function(subdoc, cb) {

        subdoc.save(cb);

      },

      function(error) {

        if (error) {

          reject(error);

          return;

        resolve();

      });

  });

  return promise.

    then(this.$__handleSave.bind(this, options)).

    then(

      function(result) {

        _this.$__reset();

        _this.$__storeShard();



        var numAffected = 0;

        if (result) {

          if (Array.isArray(result)) {

            numAffected = result.length;

          } else if (result.result && result.result.n !== undefined) {

            numAffected = result.result.n;

          } else if (result.result && result.result.nModified !== undefined) {

            numAffected = result.result.nModified;

          } else {

            numAffected = result;

          }

        return new Promise.ES6(function(resolve, reject) {

          // was this an update that required a version bump?

          if (_this.$__.version && !_this.$__.inserting) {

            var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);

            _this.$__.version = undefined;



            if (numAffected <= 0) {

              // the update failed. pass an error back

              var err = new VersionError();

              fn && fn(err);

              reject(err);

              return;

            }

            // increment version if was successful

            if (doIncrement) {

              var key = _this.schema.options.versionKey;

              var version = _this.getValue(key) | 0;

              _this.setValue(key, version + 1);

            }

          }

          _this.emit('save', _this, numAffected);

          fn && fn(null, _this, numAffected);

          resolve(_this, numAffected);

        });

      },

      function(err) {

        fn && fn(err);

        return new Promise.ES6(function(resolve, reject) {

          reject(err);

        });

      });
","const self = this;

async function save(options) {
  try {
    const subDocs = self.$__getAllSubdocs();
    const promises = subDocs.map((d) => d.save());
    await Promise.all(promises);
    self.$__handleSave(options);
    self.$__reset();
    self.$__storeShard();
    let numAffected;
    if (result) {
      if (Array.isArray(result)) {
        numAffected = result.length;
      } else if (result.result && result.result.n !== undefined) {
        numAffected = result.result.n;
      } else if (result.result && result.result.nModified !== undefined) {
        numAffected = result.result.nModified;
      } else {
        numAffected = result;
      }
    }
    // was this an update that required a version bump?
    if (self.$__.version && !self.$__.inserting) {
      const doIncrement = VERSION_INC === (VERSION_INC & self.$__.version);
      self.$__.version = undefined;
      if (numAffected <= 0) {
        // the update failed. pass an error back
        return Promise.reject(new VersionError());
      }
      // increment version if was successful
      if (doIncrement) {
        const key = self.schema.options.versionKey;
        const version = self.getValue(key) | 0;
        self.setValue(key, version + 1);
      }
    }
    self.emit('save', self, numAffected);
    return Promise.resolve(self, numAffected);
  } catch (err) {
    // If the initial insert fails provide a second chance.
    // (If we did this all the time we would break updates)
    if (self.$__.inserting) {
      self.isNew = true;
      self.emit('isNew', true);
    }
    return Promise.reject(err);
  }
}",0.5315553539987282,0.4338483957508175,0.45466810221130827,0.7377049180327869,0.5,0.549078996942739,0.6170033027497073,0.6182970912587535,0.7049180327868853,0.25609756097560976,0.47256565469219236,0.45462410546056387,0.45477619202035247,0.5978835978835979,0.3829787234042553
49," *     product.save(function (err, product) {

 *       if (err) ..

 *     })

 * The callback will receive two parameters

 * 1. `err` if an error occurred

 * 2. `product` which is the saved `product`

 *

 * As an extra measure of flow control, save will return a Promise.

 *     product.save().then(function(product) {

 *        ...

 *     });
"," *     product = await product.save();

 * If save is successful, the returned promise will fulfill with the document

 * saved.

 *

 *     const newProduct = await product.save();

 *     newProduct === product; // true

 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).
","async function saveProduct() {
    try {
        const product = await Product.save();
        // Handle product
    } catch (err) {
        // Handle error
    }
}",0.1929521899632423,0.010976126088636868,0.010435177484523031,0.16216216216216217,0.5882352941176471,0.0448252627159076,0.0030430676968646784,0.004556870289182265,0.05405405405405406,0.11764705882352941,0.12040649070792347,0.012638018443944746,0.022463880216626157,0.2647058823529412,0.18181818181818182
50," *     product.save(function (err, product) {

 *       if (err) ..

 *     })

 *

 * The callback will receive two parameters

 * 1. `err` if an error occurred

 * 2. `product` which is the saved `product`

 * As an extra measure of flow control, save will return a Promise.

 *     product.save().then(function(product) {

 *        ...

 *     });
"," *     product = await product.save();

 * If save is successful, the returned promise will fulfill with the document

 * saved.

 *

 *     const newProduct = await product.save();

 *     newProduct === product; // true

 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).
","async function saveProduct() {
   try {
      const product = await product.save();
      return product;
   } catch (err) {
      // handle error
   }
}",0.1929521899632423,0.010976126088636868,0.010435177484523031,0.16216216216216217,0.5882352941176471,0.05978477081269766,0.0030334374451697742,0.00558100351627269,0.05405405405405406,0.17647058823529413,0.15557808565841835,0.030391037276503923,0.05448815027695557,0.2647058823529412,0.2727272727272727
51," *     product.save(function (err, product) {

 *       if (err) ..

 *     })

 *

 * The callback will receive two parameters

 * 1. `err` if an error occurred

 * 2. `product` which is the saved `product`

 * As an extra measure of flow control, save will return a Promise.

 *     product.save().then(function(product) {

 *        ...

 *     });

 * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)
"," *     product = await product.save();

 * If save is successful, the returned promise will fulfill with the document

 * saved.

 *

 *     const newProduct = await product.save();

 *     newProduct === product; // true

 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).

 * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.

 * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)

 * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)

 * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).

 * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)

 * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.

 * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).
","async function saveProduct(product) {
  try {
    const savedProduct = await product.save();
    // ...
  } catch (err) {
    // ...
  }
}",0.38116454906243735,0.043349111541611696,0.1521476328933692,0.44680851063829785,0.8823529411764706,0.06681017103712718,0.0017482646850640038,0.003915448249427192,0.0851063829787234,0.17647058823529413,0.03386343784456899,5.2397197045444545e-06,0.0055385280251835246,0.10106382978723404,0.028846153846153848
52," *     // populates a single object

 *     User.findById(id, function (err, user) {

 *       var opts = [

 *         { path: 'company', match: { x: 1 }, select: 'name' },

 *         { path: 'notes', options: { limit: 10 }, model: 'override' }

 *       ];

 *

 *       User.populate(user, opts, function (err, user) {

 *         console.log(user);

 *       });

 *     });

 *     // populates an array of objects

 *     User.find(match, function (err, users) {

 *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }];

 *

 *       var promise = User.populate(users, opts);

 *       promise.then(console.log).end();

 *     })

 *

 *     // imagine a Weapon model exists with two saved documents:

 *     //   { _id: 389, name: 'whip' }

 *     //   { _id: 8921, name: 'boomerang' }

 *     // and this schema:

 *     // new Schema({

 *     //   name: String,

 *     //   weapon: { type: ObjectId, ref: 'Weapon' }

 *     // });

 *

 *     var user = { name: 'Indiana Jones', weapon: 389 };

 *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {

 *       console.log(user.weapon.name); // whip

 *     })

 *     var users = [{ name: 'Indiana Jones', weapon: 389 }]

 *     users.push({ name: 'Batman', weapon: 8921 })

 *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {

 *       users.forEach(function (user) {

 *         console.log('%s uses a %s', users.name, user.weapon.name)

 *         // Indiana Jones uses a whip

 *         // Batman uses a boomerang

 *       });

 *     });

 *     // Note that we didn't need to specify the Weapon model because

 *     // it is in the schema's ref
"," * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.

 *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));

 *     const Person = mongoose.model('Person', new Schema({

 *       name: String,

 *       pet: { type: mongoose.ObjectId, ref: 'Dog' }

 *     }));

 *     const pets = await Pet.create([

 *       { name: 'Daisy', breed: 'Beagle' },

 *       { name: 'Einstein', breed: 'Catalan Sheepdog' }

 *     ]);

 *     const users = [

 *       { name: 'John Wick', dog: pets[0]._id },

 *       { name: 'Doc Brown', dog: pets[1]._id }

 *     ];

 *     await User.populate(users, { path: 'dog', select: 'name' });

 *     users[0].dog.name; // 'Daisy'

 *     users[0].dog.breed; // undefined because of `select`
","// populates a single object
async function populateUser(id) {
  try {
    const user = await User.findById(id);
    const opts = [
      { path: 'company', match: { x: 1 }, select: 'name' },
      { path: 'notes', options: { limit: 10 }, model: 'override' }
    ];
    const populatedUser = await User.populate(user, opts);
    console.log(populatedUser);
  } catch (err) {
    console.error(err);
  }
}

// populates an array of objects
async function populateUsers() {
  try {
    const match = {};
    const users = await User.find(match);
    const opts = [{ path: 'company', match: { x: 1 }, select: 'name' }];
    const populatedUsers = await User.populate(users, opts);
    return populatedUsers;
  } catch (err) {
    console.error(err);
  }
}

// imagine a Weapon model exists with two saved documents:
//   { _id: 389, name: 'whip' }
//   { _id: 8921, name: 'boomerang' }
// and this schema:
// new Schema({
//   name: String,
//   weapon: { type: ObjectId, ref: 'Weapon' }
// });

async function populateUserWithWeapon(user) {
  try {
    const populatedUser = await Weapon.populate(user, { path: 'weapon', model: 'Weapon' });
    console.log(populatedUser.weapon.name); // whip
    return populatedUser;
  } catch (err) {
    console.error(err);
  }
}

async function populateUsersWithWeapons() {
  try {
    const users = [{ name: 'Indiana Jones', weapon: 389 }];
    const opts = [{ path: 'weapon' }];
    const populatedUsers = await Weapon.populate(users, opts);
    populatedUsers.forEach(user => console.log(`${user.name} uses a ${user.weapon.name}`));
    return populatedUsers;
  } catch (err) {
    console.error(err);
  }
}",0.17804921905594023,0.029671687507800047,0.04430403486980703,0.40384615384615385,0.234375,0.41175931448574743,0.33984472640166447,0.34204830077209436,0.4807692307692308,0.484375,0.20762694665939702,0.011372905533747818,0.023722896085113625,0.33707865168539325,0.4583333333333333
53," *     // pass a spread of docs and a callback

 *     Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {

 *       if (err) // ...

 *     });

 *

 *     // pass an array of docs

 *     var array = [{ type: 'jelly bean' }, { type: 'snickers' }];

 *     Candy.create(array, function (err, candies) {

 *       if (err) // ...

 *

 *       var jellybean = candies[0];

 *       var snickers = candies[1];

 *       // ...

 *     });

 *

 *     // callback is optional; use the returned promise if you like:

 *     var promise = Candy.create({ type: 'jawbreaker' });

 *     promise.then(function (jawbreaker) {

 *       // ...

 *     })
"," *     // Insert one new `Character` document

 *     await Character.create({ name: 'Jean-Luc Picard' });

 * 

 *     // Insert multiple new `Character` documents

 *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);

 * 

 *     // Create a new character within a transaction. Note that you **must**

 *     // pass an array as the first parameter to `create()` if you want to

 *     // specify options.

 *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });
","module.exports = {

    create: async (docs, callback) => {

        if (!Array.isArray(docs)) {
            return Promise.reject(new Error('The first argument to the Candy create method must be an array of documents'));
        }

        try {
            const result = await Candy.create(docs);
            if (callback) {
                callback(null, result[0]);
            }
            return result[0];
        } catch (error) {
            if (callback) {
                callback(error);
            } else {
                throw error;
            }
        }
    },
};",0.17718188871836715,0.07763685613068975,0.07988122885085915,0.44776119402985076,0.10344827586206896,0.15165794891919887,0.009907875465006115,0.013090363855639124,0.23880597014925373,0.3448275862068966,0.30528466565345225,0.00727187526212205,0.007984434410510551,0.20588235294117646,1.0
54," * This function does not trigger any middleware.

 *     Character.deleteOne({ name: 'Eddard Stark' }).then(next);
"," * This function triggers `deleteOne` middleware.

 *     await Character.deleteOne({ name: 'Eddard Stark' });

 *

 *     // Using callbacks:
","async function deleteOneCharacter() {
  try {
    const result = await Character.deleteOne({ name: 'Eddard Stark' });
    return result;
  } catch (error) {
    console.log(error);
  }
}",0.46126876757272245,0.21671830063791614,0.29502343631964045,0.3333333333333333,0.0,0.41048939946384555,0.10414419091986513,0.20448007360218384,0.3333333333333333,0.0,0.5108517338477622,0.20144990145560465,0.30349549547390564,0.5384615384615384,0.0
55," * This function does not trigger any middleware

 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)

 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)
"," * This function triggers `deleteMany` middleware.

 *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });

 *

 *     // Using callbacks:

 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback);
","// Wrapped in an async function to enable await usage
async function deleteManyCharacters() {
  try {
    // Replace .then() with await assignment
    const result = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });
    console.log(result);
  } catch (error) {
    console.error(error);
  } finally {
    next(); // callback
  }
}",0.5525666823286467,0.5190452321716889,0.6003124062338072,0.5909090909090909,0.5,0.3752209902725515,0.14599223028360678,0.2639826398975083,0.5909090909090909,0.5,0.4139004282366877,0.19300403619224038,0.3087515229083567,0.6538461538461539,0.5
56,"  it('eachAsync() with parallel > numDocs (gh-8422)', function() {

    return co(function*() {

      yield Movie.deleteMany({});

      yield Movie.create([

        { name: 'Kickboxer' },

        { name: 'Ip Man' },

        { name: 'Enter the Dragon' }

      ]);

      let numDone = 0;

      const test = co.wrap(function*() {

        yield new Promise((resolve) => setTimeout(resolve, 100));

        ++numDone;

      });

      yield Movie.find().cursor().eachAsync(test, { parallel: 4 });

      assert.equal(numDone, 3);

    });

  it('eachAsync() with sort, parallel, and sync function (gh-8557)', function() {

    return co(function*() {

      yield User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);

      const cursor = User.aggregate([{ $sort: { order: 1 } }]).

        cursor();

      const docs = [];

      yield cursor.eachAsync((doc) => docs.push(doc), { parallel: 3 });

      assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);

    });
","  it('eachAsync() with parallel > numDocs (gh-8422)', async function() {

    await Movie.deleteMany({});

    await Movie.create([

      { name: 'Kickboxer' },

      { name: 'Ip Man' },

      { name: 'Enter the Dragon' }

    ]);

    let numDone = 0;

    await delay(100);

    ++numDone;

    await Movie.find().cursor().eachAsync(test, { parallel: 4 });

    assert.equal(numDone, 3);

  it('eachAsync() with sort, parallel, and sync function (gh-8557)', async function() {

    await User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);

    const cursor = User.aggregate([{ $sort: { order: 1 } }]).

      cursor();

    const docs = [];

    await cursor.eachAsync((doc) => docs.push(doc), { parallel: 3 });

    assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);
","it('eachAsync() with parallel > numDocs (gh-8422)', async function() {

  await Movie.deleteMany({});

  await Movie.create([

    { name: 'Kickboxer' },

    { name: 'Ip Man' },

    { name: 'Enter the Dragon' }

  ]);

  let numDone = 0;

  const test = async () => {

    await new Promise((resolve) => setTimeout(resolve, 100));

    ++numDone;

  };

  await Movie.find().cursor().eachAsync(test, { parallel: 4 });

  assert.equal(numDone, 3);

});

it('eachAsync() with sort, parallel, and sync function (gh-8557)', async function() {

  await User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);

  const cursor = User.aggregate([{ $sort: { order: 1 } }]).

    cursor();

  const docs = [];

  await cursor.eachAsync((doc) => docs.push(doc), { parallel: 3 });

  assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);

});",0.6227027285713466,0.6612322277466378,0.6341192270792888,0.736,0.4594594594594595,0.7095715129546403,0.767231218232706,0.7354872660182876,0.768,0.5675675675675675,0.8611815129146225,0.8211302970068247,0.9423314743774842,0.9504950495049505,0.7307692307692307
57,"    return Movie.findOneAndUpdate(query, update, options).then(doc => {

      doc.genre; // 'Action', Mongoose set a default value.

      // acquit:ignore:start

      assert.equal(doc.title, 'The Terminator');

      assert.equal(doc.genre, 'Action');

      // acquit:ignore:end

      return doc;

    });
","    let doc = await Movie.findOneAndUpdate(query, update, options).lean();

    doc.genre; // 'Action', Mongoose set a default value.

    // acquit:ignore:start

    assert.equal(doc.title, 'The Terminator');

    assert.equal(doc.genre, 'Action');

    // acquit:ignore:end



    await Movie.deleteMany({});



    doc = await Movie.findOneAndUpdate(query, update, { ...options, setDefaultsOnInsert: false }).lean();

    doc.genre; // undefined, Mongoose did not set a default value

    // acquit:ignore:start

    assert.equal(doc.title, 'The Terminator');

    assert.equal(doc.genre, void 0);

    // acquit:ignore:end
","async function updateMovie() {
    const query = { name: 'The Terminator' };
    const update = { $set: { genre: 'Action' } };
    const options = { new: true };
  
    try {
      const doc = await Movie.findOneAndUpdate(query, update, options);
      assert.equal(doc.title, 'The Terminator');
      assert.equal(doc.genre, 'Action');
      return doc;
    } catch (error) {
      console.log('Error occurred while updating movie', error);
    }
  }",0.5568008574810014,0.2999987647185985,0.6357760937768357,0.72,0.5714285714285714,0.3050717915904262,0.07850020523574738,0.17607267541167174,0.68,0.2857142857142857,0.2594421496983111,0.12738148638291735,0.12389642918051333,0.48214285714285715,0.30434782608695654
58,"  before(function() {

    return db.asPromise().

      then(() => {

        // Skip if not a repl set

        if (db.client.topology.constructor.name !== 'ReplSet' &&

            !db.client.topology.s.description.type.includes('ReplicaSet')) {

          _skipped = true;

          this.skip();

          throw new Error('skip');

        }

      }).

      then(() => new Promise((resolve, reject) => {

        start.mongodVersion(function(err, version) {

          if (err) {

            return reject(err);

          }

          resolve(version);

        });

      })).

      then(version => {

        if (version[0] < 4) {

          _skipped = true;

          this.skip();

        }

      }).

      catch(() => {

      });
","  before(async function() {

    try {

      await db.asPromise();

      // Skip if not a repl set

      const isNotAReplicaSet = db.client.topology.constructor.name !== 'ReplSet' &&

                               !db.client.topology.s.description.type.includes('ReplicaSet');

      if (isNotAReplicaSet) {

        _skipped = true;

        this.skip();

        throw new Error('Skip');

      }

      const version = await start.promisifiedMongodVersion();

      if (version[0] < 4) {

      }

    } catch (err) {

      _skipped = true;

      this.skip();

    }
","async function before() {
  try {
    const db = await db.asPromise();
    if (db.client.topology.constructor.name !== 'ReplSet' && !db.client.topology.s.description.type.includes('ReplicaSet')) {
      _skipped = true;
      this.skip();
      throw new Error('skip');
    }
    const version = await new Promise((resolve, reject) => {
      start.mongodVersion(function (err, version) {
        if (err) {
          return reject(err);
        }
        resolve(version);
      });
    })
    if (version[0] < 4) {
      _skipped = true;
      this.skip();
    }
  } catch (error) {}
}",0.4167201992094509,0.3117470542989883,0.321800409205482,0.5333333333333333,0.5,0.6293862850173638,0.5206997465711088,0.5315676157205688,0.7777777777777778,0.6875,0.5375555583916903,0.3475122027554271,0.4309709003765518,0.85,0.5217391304347826
59,"  before(function() {



    return db.asPromise().

      then(() => {

        // Skip if not a repl set

        if (db.client.topology.constructor.name !== 'ReplSet' &&

            !db.client.topology.s.description.type.includes('ReplicaSet')) {

          _skipped = true;

          this.skip();

          throw new Error('skip');

        }

      }).

      then(() => new Promise((resolve, reject) => {

        start.mongodVersion(function(err, version) {

          if (err) {

            return reject(err);

          }

          resolve(version);

        });

      })).

      then(version => {

        if (version[0] < 4) {

          _skipped = true;

          this.skip();

        }

      }).

      catch(() => {

      });
","  before(async function() {

    try {

      await db.asPromise();

      // Skip if not a repl set

      if (db.client.topology.constructor.name !== 'ReplSet' &&

      !db.client.topology.s.description.type.includes('ReplicaSet')) {

        _skipped = true;

        this.skip();

        throw new Error('skip');

      }



      const version = await start.promisifiedMongodVersion();



      if (version[0] < 4) {

      }

    } catch (err) {

      _skipped = true;

      this.skip();

    }
","before(async function() {



    await db.asPromise();


      // Skip if not a repl set

      const topology = db.client.topology;

      if (topology.constructor.name !== 'ReplSet' && !topology.s.description.type.includes('ReplicaSet')) {

        _skipped = true;

        this.skip();

        throw new Error('skip');

      }


    await new Promise((resolve, reject) => {

      start.mongodVersion(function(err, version) {

        if (err) {

          return reject(err);

        }

        resolve(version);

      });

    });

    const version = await new Promise((resolve, reject) => {

      start.mongodVersion(function(err, version) {

        if (err) {

          return reject(err);

        }

        resolve(version);

      });

    });


    if (version[0] < 4) {

      _skipped = true;

      this.skip();

    }



  })",0.4803115425026858,0.42822755153854775,0.4485741740277513,0.5444444444444444,0.5,0.6497547621681035,0.4947766902426899,0.6139645806519463,0.6777777777777778,0.8125,0.6201203910340952,0.36884207846205985,0.6097237768620607,0.7241379310344828,0.7777777777777778
60,"      bootMongo.promise.then(function(_conn) {

        assert.equal(_conn, conn);

        done();

      }).catch(done);
","      const _conn = await bootMongo.promise;

      assert.equal(_conn, conn);
","async function bootMongo() {
     let conn;
     try {
       conn = await mongo.connect();
       assert.equal(conn, conn);
      } catch (err) {
        console.error(""Error connecting to MongoDB"", err);
        return;
      } finally {
        // Clean up resources here
      }
      done();
    }",0.22983632935992204,0.06985342056580097,0.08633400213704504,0.2631578947368421,0.5,0.3704427837246142,0.006990006728332351,0.05372849659117709,0.42105263157894735,1.0,0.28673867356805227,0.012430185041026947,0.07896895367562645,0.5555555555555556,0.5
61,"    MR.mapReduce(o).then(function(results, stats) {

      assert.equal(typeof stats, 'undefined');

      done();

    });
","    const { stats } = await MR.mapReduce(o);

    assert.equal(typeof stats, 'undefined');
","async function mapReduce(o) {
  try {
    const results = await MR.mapReduce(o);
    assert.equal(typeof stats, 'undefined');
  } catch (err) {
    console.error(err);
  } finally {
    done();
  }
}",0.3024916114011817,0.1122444464861146,0.1477219991186121,0.45,0.5,0.44969961605260766,0.042601467364417965,0.1561969968460128,0.6,1.0,0.5246775117752173,0.20536337741589902,0.5790609553992555,0.7142857142857143,0.6
62,"    it('when return promise', function(done) {

      A.aggregate([group, project]).then(function(res) {

        assert.ok(res);

        assert.equal(1, res.length);

        assert.ok('maxAge' in res[0]);

        assert.equal(maxAge, res[0].maxAge);

        done();

      });

    it('with arrays', function(done) {

      A.aggregate([group, project], function(err, res) {

        assert.ifError(err);

        assert.ok(res);

        assert.equal(res.length, 1);

        assert.ok('maxAge' in res[0]);

        assert.equal(res[0].maxAge, maxAge);

        done();

      });

    it('with Aggregate syntax', function(done) {

      A.aggregate()

        .exec(function(err, res) {

          assert.ifError(err);

          assert.ok(res);

          assert.equal(res.length, 1);

          assert.ok('maxAge' in res[0]);

          assert.equal(res[0].maxAge, maxAge);

          done();

        });

    it('with Aggregate syntax if callback not provided', function(done) {

      promise.then(function(res) {

        assert.ok(promise instanceof mongoose.Promise);

        assert.ok(res);

        assert.equal(res.length, 1);

        assert.ok('maxAge' in res[0]);

        assert.equal(maxAge, res[0].maxAge);

        done();

      });
","    it('when return promise', async function() {

      const res = await A.aggregate([group, project]);



      assert.ok(res);

      assert.equal(1, res.length);

      assert.ok('maxAge' in res[0]);

      assert.equal(maxAge, res[0].maxAge);

    it('with arrays', async function() {

      const res = await A.aggregate([group, project]);



      assert.ok(res);

      assert.equal(res.length, 1);

      assert.ok('maxAge' in res[0]);

      assert.equal(res[0].maxAge, maxAge);

    it('with Aggregate syntax', async function() {

      const res = await A.aggregate()

        .exec();



      assert.ok(res);

      assert.equal(res.length, 1);

      assert.ok('maxAge' in res[0]);

      assert.equal(res[0].maxAge, maxAge);

    it('with Aggregate syntax if callback not provided', async function() {

      const res = await promise;



      assert.ok(promise instanceof mongoose.Promise);

      assert.ok(res);

      assert.equal(res.length, 1);

      assert.ok('maxAge' in res[0]);

      assert.equal(maxAge, res[0].maxAge);
","it('when return promise', async () => {
  const res = await A.aggregate([group, project]);
  assert.ok(res);
  assert.equal(1, res.length);
  assert.ok('maxAge' in res[0]);
  assert.equal(maxAge, res[0].maxAge);
});

it('with arrays', async () => {
  const [err, res] = await A.aggregate([group, project], (err, res) => ({ err, res }));
  assert.ifError(err);
  assert.ok(res);
  assert.equal(res.length, 1);
  assert.ok('maxAge' in res[0]);
  assert.equal(res[0].maxAge, maxAge);
});

it('with Aggregate syntax', async () => {
  const [err, res] = await A.aggregate().exec((err, res) => ({ err, res }));
  assert.ifError(err);
  assert.ok(res);
  assert.equal(res.length, 1);
  assert.ok('maxAge' in res[0]);
  assert.equal(res[0].maxAge, maxAge);
});

it('with Aggregate syntax if callback not provided', async () => {
  const res = await promise;
  assert.ok(promise instanceof mongoose.Promise);
  assert.ok(res);
  assert.equal(res.length, 1);
  assert.ok('maxAge' in res[0]);
  assert.equal(maxAge, res[0].maxAge);
});",0.6227757428466472,0.46115207558843024,0.4911668287122044,0.7610062893081762,0.7777777777777778,0.6537412329979413,0.4099777140948839,0.556402312236504,0.7735849056603774,0.875,0.7832674024493561,0.5377143415996921,0.6986310871524709,0.9612403100775194,0.9354838709677419
63,"      return Promise.all([

      ]).then(() => Base.listIndexes()).

        then(indexes => indexes.find(i => i.key.other)).

        then(index => {

          assert.deepEqual(index.key, { other: 1 });

          assert.deepEqual(index.partialFilterExpression, { kind: 'Device' });

        });
","      await Promise.all([

      ]);

      const indexes = await Base.listIndexes();

      const index = indexes.find(i => i.key.other);

      assert.deepEqual(index.key, { other: 1 });

      assert.deepEqual(index.partialFilterExpression, { kind: 'Device' });
","async function test() {
    const indexes = await Promise.all([]).then(() => Base.listIndexes());
    const otherIndex = indexes.find((i) => i.key.other);
  
    assert.deepEqual(otherIndex.key, { other: 1 });
    assert.deepEqual(otherIndex.partialFilterExpression, { kind: 'Device' });
  }
  test();",0.4718388479662597,0.4110433074789492,0.39550400357800874,0.6363636363636364,0.4444444444444444,0.4042690772969017,0.17445571267319096,0.20524685914067836,0.6818181818181818,0.5555555555555556,0.447760752630178,0.2666090188234886,0.32998954725277907,0.6944444444444444,0.5
64,"import { createConnection, Schema, Connection } from 'mongoose';

conn.model('Test', new Schema({ name: { type: String } }));

conn.openUri('mongodb://localhost:27017/test').then(() => console.log('Connected!'));

createConnection('mongodb://localhost:27017/test').asPromise().then((conn: Connection) => {

  conn.host;

});

createConnection('mongodb://localhost:27017/test').close();

conn.db.collection('Test').findOne({ name: String }).then(doc => console.log(doc));

conn.collection('Test').findOne({ name: String }).then(doc => console.log(doc));

conn.syncIndexes({ continueOnError: true }).then(result => {

  result['User'].forEach((index) => {

    index.includes('name');

  });

  result['Order'].message;

  result['Order'].code;

});

conn.syncIndexes({ continueOnError: false, background: true }).then().catch(err => {

  err.errors['Order'].code;

});
","import { createConnection, Schema, Collection, Connection, ConnectionSyncIndexesResult, Model } from 'mongoose';

import * as mongodb from 'mongodb';

import { expectError, expectType } from 'tsd';



expectType<Connection>(createConnection());

expectType<Connection>(createConnection('mongodb://localhost:27017/test'));

expectType<Connection>(createConnection('mongodb://localhost:27017/test', { appName: 'mongoose' }));

expectType<void>(createConnection('mongodb://localhost:27017/test', { appName: 'mongoose' }, (err, res) => (expectType<Connection>(res))));

expectType<Model<{ name: string }, any, any, any>>(conn.model('Test', new Schema<{ name: string }>({ name: { type: String } })));

expectType<Model<{ name: string }>>(conn.model<{ name: string }>('Test', new Schema({ name: { type: String } })));



expectType<Promise<Connection>>(conn.openUri('mongodb://localhost:27017/test'));

expectType<Promise<Connection>>(conn.openUri('mongodb://localhost:27017/test', { bufferCommands: true }));

expectType<Connection>(conn.openUri('mongodb://localhost:27017/test', { bufferCommands: true }, (err, value) => { expectType<Connection>(value); }));



conn.readyState === 0;

conn.readyState === 99;



expectError(conn.readyState = 0);



expectType<Connection>(new Connection());

expectType<Promise<Connection>>(new Connection().asPromise());



expectType<Promise<mongodb.Collection<{ [key: string]: any }>>>(conn.createCollection('some'));

expectType<void>(conn.createCollection('some', (err, res) => {

  expectType<mongodb.Collection<{ [key: string]: any }>>(res);

}));



expectType<Promise<void>>(conn.dropCollection('some'));

expectType<void>(conn.dropCollection('some', () => {

  // do nothing

}));



expectError(conn.deleteModel());

expectType<Connection>(conn.deleteModel('something'));



expectType<Array<string>>(conn.modelNames());



expectType<Promise<void>>(createConnection('mongodb://localhost:27017/test').close());

expectType<Promise<void>>(createConnection('mongodb://localhost:27017/test').close(true));

expectType<void>(createConnection('mongodb://localhost:27017/test').close(() => {

  // do nothing.

}));

expectType<void>(createConnection('mongodb://localhost:27017/test').close(true, () => {

  // do nothing.

}));

expectType<void>(createConnection('mongodb://localhost:27017/test').close(false, () => {

  // do nothing.

}));



expectType<mongodb.Db>(conn.db);



expectType<mongodb.MongoClient>(conn.getClient());

expectType<Connection>(conn.setClient(new mongodb.MongoClient('mongodb://localhost:27017/test')));



expectType<Promise<string>>(conn.transaction<string>(async(res) => {

  expectType<mongodb.ClientSession>(res);

  return 'a';

}));



expectError(conn.user = 'invalid');

expectError(conn.pass = 'invalid');

expectError(conn.host = 'invalid');

expectError(conn.port = 'invalid');



expectType<Collection>(conn.collection('test'));

expectType<mongodb.Collection>(conn.db.collection('test'));

expectType<Promise<mongodb.ClientSession>>(conn.startSession());

expectType<Promise<mongodb.ClientSession>>(conn.startSession({ causalConsistency: true }));

expectType<void>(conn.startSession((err, res) => { expectType<mongodb.ClientSession>(res); }));

expectType<void>(conn.startSession(undefined, (err, res) => { expectType<mongodb.ClientSession>(res); }));

expectType<void>(conn.startSession(null, (err, res) => { expectType<mongodb.ClientSession>(res); }));

expectType<void>(conn.startSession({}, (err, res) => { expectType<mongodb.ClientSession>(res); }));

expectType<Promise<ConnectionSyncIndexesResult>>(conn.syncIndexes());

expectType<Promise<ConnectionSyncIndexesResult>>(conn.syncIndexes({ continueOnError: true }));

expectType<Promise<ConnectionSyncIndexesResult>>(conn.syncIndexes({ background: true }));

expectType<void>(conn.syncIndexes(undefined, (err, value) => { expectType<ConnectionSyncIndexesResult>(value); }));

expectType<void>(conn.syncIndexes(null, (err, value) => { expectType<ConnectionSyncIndexesResult>(value); }));

expectType<void>(conn.syncIndexes({ continueOnError: true }, (err, value) => { expectType<ConnectionSyncIndexesResult>(value); }));

expectType<void>(conn.syncIndexes({ background: true }, (err, value) => { expectType<ConnectionSyncIndexesResult>(value); }));

expectType<Connection>(conn.useDb('test'));

expectType<Connection>(conn.useDb('test', {}));

expectType<Connection>(conn.useDb('test', { noListener: true }));

expectType<Connection>(conn.useDb('test', { useCache: true }));
","import { createConnection, Schema, Connection } from 'mongoose';

async function connect() {
  try {
    const conn = await createConnection('mongodb://localhost:27017/test').asPromise();
    console.log('Connected!');
    return conn;
  } catch (error) {
    console.error(error);
  }
}

async function retrieveDoc() {
  try {
    const doc = await conn.db.collection('Test').findOne({ name: String }).asPromise();
    console.log(doc);
    return doc;
  } catch (error) {
    console.error(error);
  }
}

async function syncIndexes() {
  try {
    const result = await conn.syncIndexes({ continueOnError: true }).asPromise();
    if (result['User'].includes('name')) {
      console.log('Indexes synced successfully');
    } else {
      console.error(result);
    }
  } catch (error) {
    console.error(error);
  }
}

connect();
retrieveDoc();
syncIndexes();",0.43087748803263415,0.04609745663416015,0.2051902732741541,0.4722222222222222,1.0,0.3560328578773428,0.11198009783795539,0.16000486902495115,0.5763888888888888,0.5757575757575758,0.1185578988242354,0.0070659899219728236,0.018344125563532022,0.2975609756097561,0.15126050420168066
65," *     product.remove(function (err, product) {

 *       if (err) return handleError(err);

 *       Product.findById(product._id, function (err, product) {

 *         console.log(product) // null

 *       })

 *     })

 *

 *

 * As an extra measure of flow control, remove will return a Promise (bound to `fn` if passed) so it could be chained, or hooked to receive errors

 *

 * #### Example:

 *

 *     product.remove().then(function (product) {

 *        ...

 *     }).catch(function (err) {

 *        assert.ok(err)

 *     })
"," *     const product = await product.remove().catch(function (err) {

 *        assert.ok(err);

 *     });

 *     const foundProduct = await Product.findById(product._id);

 *     console.log(foundProduct) // null
","async function removeProduct() {
  try {
    const product = await Product.remove();
    return product;
  } catch (err) {
    handleError(err);
  }
}

module.exports = removeProduct;",0.15777286713685354,0.0061653959998291255,0.018308425488761482,0.3125,0.29411764705882354,0.12311253866776811,0.0027246211233052857,0.008107886488943648,0.1875,0.29411764705882354,0.2415659174588552,0.12740810460323607,0.13755686393348354,0.2727272727272727,0.42857142857142855
66," *     const promise = aggregate.exec();

 *     promise.then(..);

 * @see Promise #promise_Promise

 * @return {Promise}
"," *     const result = await aggregate.exec();

 * @return {Promise} Returns a Promise if no ""callback"" is given.
",`const promise = await aggregate.exec();`,0.41065257868864136,0.08651480732019924,0.11165106298992156,0.6111111111111112,0.8333333333333334,0.2617870901352544,0.01878157980529131,0.028366780735726415,0.0,0.0,0.2595800385765834,0.01030754954137245,0.02801260476496127,0.0,0.0
67,"  return new Promise((resolve, reject) => {

    const db = module.exports();





    db.on('error', reject);



    db.on('open', function() {

      const admin = db.db.admin();

      admin.serverStatus(function(err, info) {

        if (err) {

          return reject(err);

        }

        const version = info.version.split('.').map(function(n) {

          return parseInt(n, 10);

        });

        db.close(function() {

          resolve(version);

        });

      });

    });
","  const db = await module.exports();



  const admin = db.client.db().admin();



  const info = await admin.serverStatus();

  const version = info.version.split('.').map(function(n) {

    return parseInt(n, 10);

  await db.close();

  return version;
","async function getMongoDbVersion(module) {

const db = module.exports();

db.on('error', reject);

try {

 const admin = await db.db.admin();

 await admin.serverStatus((err, info) => {

if (err) {

return reject(err);

}

const version = info.version.split('.').map(n => parseInt(n, 10));

await db.close();

resolve(version);

});

 } catch (err) {

reject(err);

 }

}",0.26046494831508304,0.19463380794942237,0.23531531533572367,0.35384615384615387,0.25806451612903225,0.48608110170931784,0.40053665229742624,0.4276587222817805,0.6,0.5161290322580645,0.4001054487511061,0.058510027469328506,0.10916322952339982,0.7105263157894737,0.7222222222222222
68,"Connection.prototype.openUri = function openUri(uri, options, callback) {

  if (typeof options === 'function') {

    callback = options;

    options = null;

  if (['string', 'number'].indexOf(typeof options) !== -1) {

    throw new MongooseError('Mongoose 5.x no longer supports ' +

      '`mongoose.connect(host, dbname, port)` or ' +

      '`mongoose.createConnection(host, dbname, port)`. See ' +

      'https://mongoosejs.com/docs/connections.html for supported connection syntax');

  if (callback != null && typeof callback !== 'function') {

    throw new MongooseError('3rd parameter to `mongoose.connect()` or ' +

      '`mongoose.createConnection()` must be a function, got ""' +

      typeof callback + '""');

  }



  if (this._destroyCalled) {

    const error = 'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +

    'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.';

    if (typeof callback === 'function') {

      callback(error);

      return;

    }

    else {

      throw new MongooseError(error);

    }

  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {

    if (this._connectionString !== uri) {



    if (typeof callback === 'function') {

      this.$initialConnection = this.$initialConnection.then(

        () => callback(null, this),

        err => callback(err)

      );

    }

    return this;

  this._connectionString = uri;

  this.readyState = STATES.connecting;

  this._closeCalled = false;



  const _this = this;


","Connection.prototype.openUri = async function openUri(uri, options) {

  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {

    if (this._connectionString === uri) {

      return this;

    }

  this._closeCalled = false;



  // Internal option to skip `await this.$initialConnection` in

  // this function for `createConnection()`. Because otherwise

  // `createConnection()` would have an uncatchable error.

  let _fireAndForget = false;

  if (options && '_fireAndForget' in options) {

    _fireAndForget = options._fireAndForget;

    delete options._fireAndForget;

  const promise = _createMongoClient(this, uri, options);



  this.$initialConnection = promise.

    then(() => this).

    catch(err => {

      this.readyState = STATES.disconnected;

      if (this.listeners('error').length > 0) {

        immediate(() => this.emit('error', err));

      }

      throw err;

    });



  for (const model of Object.values(this.models)) {

    // Errors handled internally, so safe to ignore error

    model.init(function $modelInitNoop() {});

  }



  // `createConnection()` calls this `openUri()` function without

  // awaiting on the result, so we set this option to rely on

  // `asPromise()` to handle any errors.

  if (_fireAndForget) {

    return this;

  }



  try {

    await this.$initialConnection;

  } catch (err) {

    throw _handleConnectionErrors(err);

  }



  return this;

};



/*!

 * ignore

 */



function _handleConnectionErrors(err) {

  if (err?.name === 'MongoServerSelectionError') {

    const originalError = err;

    err = new ServerSelectionError();

    err.assimilateError(originalError);

  }



  return err;

}



/*!

 * ignore

 */



async function _createMongoClient(conn, uri, options) {

  if (conn._destroyCalled) {

    throw new MongooseError(

      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +

      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'

    );

  if (conn.readyState === STATES.connecting || conn.readyState === STATES.connected) {

    if (conn._connectionString !== uri) {
","async function openUri(uri, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!['string', 'number'].includes(typeof options)) {
    throw new MongooseError('Mongoose 5.x no longer supports `mongoose.connect(host, dbname, port)` or `mongoose.createConnection(host, dbname, port)`. See https://mongoosejs.com/docs/connections.html for supported connection syntax');
  }
  if (callback != null && typeof callback !== 'function') {
    throw new MongooseError('3rd parameter to `mongoose.connect()` or `mongoose.createConnection()` must be a function, got ""' + typeof callback + '""');
  }
  if (this._destroyCalled) {
    const error = 'Connection has been closed and destroyed, and cannot be used for re-opening the connection. Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.';
    if (typeof callback === 'function') {
      return callback(error);
    } else {
      throw new MongooseError(error);
    }
  }
  this._connectionString = uri;
  this.readyState = STATES.connecting;
  this._closeCalled = false;
  try {
    const result = await this.$initialConnection;
    return callback(null, this);
  } catch (error) {
    return callback(error);
  }
}",0.4009126343995265,0.19334685231908957,0.2768974523648558,0.423728813559322,0.7096774193548387,0.5991461195890547,0.5631754171522803,0.5865528556271209,0.6016949152542372,0.6451612903225806,0.22345943807467988,0.10756154221168068,0.13290741576079776,0.2916666666666667,0.3617021276595745
69,"  const promise = new Promise((resolve, reject) => {

    let client;

    try {

      client = new mongodb.MongoClient(uri, options);

    } catch (error) {

      _this.readyState = STATES.disconnected;

      return reject(error);

    }

    _this.client = client;



    client.setMaxListeners(0);

    client.connect().then(() => {

      _setClient(_this, client, options, dbName);

      for (const db of this.otherDbs) {

        _setClient(db, client, {}, db.name);

      }



      resolve(_this);

    }).catch(reject);

  });



  const serverSelectionError = new ServerSelectionError();

  this.$initialConnection = promise.

    then(() => this).

    catch(err => {

      this.readyState = STATES.disconnected;

      if (err != null && err.name === 'MongoServerSelectionError') {

        err = serverSelectionError.assimilateError(err);

      }

      if (this.listeners('error').length > 0) {

        immediate(() => this.emit('error', err));

      }

      throw err;

    });

  if (callback != null) {

    this.$initialConnection = this.$initialConnection.then(

      () => { callback(null, this); return this; },

      err => callback(err)

    );

  }

  for (const model of Object.values(this.models)) {

    // Errors handled internally, so safe to ignore error

    model.init(function $modelInitNoop() {});



  return this.$initialConnection;

};
","  conn.readyState = STATES.connecting;

  conn._connectionString = uri;

  let client;

  try {

    client = new mongodb.MongoClient(uri, options);

  } catch (error) {

    conn.readyState = STATES.disconnected;

    throw error;

  }

  conn.client = client;

  client.setMaxListeners(0);

  await client.connect();

  _setClient(conn, client, options, dbName);

  for (const db of conn.otherDbs) {

    _setClient(db, client, {}, db.name);

  return conn;

}
","const promise = new Promise((resolve, reject) => {
  let client;
  try {
    client = new mongodb.MongoClient(uri, options);
  } catch (error) {
    _this.readyState = STATES.disconnected;
    return reject(error);
  }
  _this.client = client;
  client.setMaxListeners(0);
  client.connect().then(() => {
    _setClient(_this, client, options, dbName);
    for (const db of this.otherDbs) {
      _setClient(db, client, {}, db.name);
    }
    resolve(_this);
  }).catch(reject);
});",0.18462766728018587,0.0780308629578137,0.1776382761082849,0.25333333333333335,0.22950819672131148,0.45038388705751164,0.19502736740185433,0.37798359066425774,0.54,0.6885245901639344,0.5595318073593336,0.4523320127136175,0.49412855005705014,0.7916666666666666,0.5
70,"  it('should buffer commands until connection is established', function(done) {

    let connected = false;

    let insertedId = undefined;

    let pending = 2;



    function finish() {

      if (--pending) {

        return;

      }

      assert.ok(connected);

      assert.ok(insertedId !== undefined);

      collection.findOne({ _id: insertedId }).then(doc => {

        assert.strictEqual(doc.foo, 'bar');

        db.close();

        done();

      });

    }

    collection.insertOne({ foo: 'bar' }, {}, function(err, result) {

      assert.ok(connected);

      insertedId = result.insertedId;

      finish();

    });

    db.openUri(process.env.MONGOOSE_TEST_URI || uri, function(err) {

      connected = !err;

      finish();

    });

  it('returns a promise if buffering and no callback (gh-7676)', function(done) {
","  it('should buffer commands until connection is established', async function() {

    const op = collection.insertOne({ foo: 'bar' }, {});

    await db.openUri(process.env.MONGOOSE_TEST_URI || uri);



    const res = await op;

    assert.ok(res.insertedId);

    const doc = await collection.findOne({ _id: res.insertedId });

    assert.strictEqual(doc.foo, 'bar');

    await db.close();

  it('returns a promise if buffering and no callback (gh-7676)', async function() {
","it('should buffer commands until connection is established', async () => {
  let connected = false;
  let insertedId;
  let pending = 2;

  function finish() {
    if (--pending) {
      return;
    }
    assert.ok(connected);
    assert.ok(insertedId !== undefined);
    const doc = await collection.findOne({ _id: insertedId });
    assert.strictEqual(doc.foo, 'bar');
    db.close();
    done();
  }
  try {
    await collection.insertOne({ foo: 'bar' }, {});
    insertedId = (await result).insertedId;
    finish();
  } catch (err) {
    console.log(err);
  }
  try {
    connected = !(await db.openUri(process.env.MONGOOSE_TEST_URI || uri));
    finish();
  } catch (err) {
    console.log(err);
  }
});
it('returns a promise if buffering and no callback (gh-7676)', async () => {
  let pending = 2;
  function finish() {
    if (--pending) {
      return;
    }
    assert.ok(connected);
    const doc = await collection.findOne({ _id: insertedId });
    assert.strictEqual(doc.foo, 'bar');
    db.close();
    done();
  }
  try {
    await collection.insertOne({ foo: 'bar' }, {});
    insertedId = (await result).insertedId;
    finish();
  } catch (err) {
    console.log(err);
  }
  try {
    connected = !(await db.openUri(process.env.MONGOOSE_TEST_URI || uri));
    finish();
  } catch (err) {
    console.log(err);
  }
});",0.30907981226175796,0.20640983572285151,0.21921823184648206,0.3258426966292135,0.48484848484848486,0.5967731026702764,0.2843245521467894,0.5610586314318307,0.6629213483146067,0.8787878787878788,0.49934144567026295,0.17025020929411624,0.5204489067202691,0.64,0.6666666666666666
71,"    db.openUri(start.uri, function(err) {

      assert.ifError(err);

      promise.then(() => done(), done);

    });
","    await db.openUri(start.uri);



    await promise;
","async function openUri(uri) {
  try {
    const result = await db.openUri(uri);
    return result;
  } catch (error) {
    throw error;
  }
}",0.2976190476190476,0.0,0.0,0.19047619047619047,0.0,0.34161201344043124,0.00913442366656447,0.023980296761827107,0.3333333333333333,1.0,0.3306609347015786,0.00913442366656447,0.09128709291752769,0.2222222222222222,0.0
72,"  it('throws a MongooseServerSelectionError on server selection timeout (gh-8451)', function() {

    return mongoose.createConnection(uri, opts).asPromise().then(() => assert.ok(false), err => {

      assert.equal(err.name, 'MongooseServerSelectionError');

    });
","  it('throws a MongooseServerSelectionError on server selection timeout (gh-8451)', async function() {

    const err = await mongoose.createConnection(uri, opts).

      asPromise().

      then(() => null, err => err);

    assert.ok(err);

    assert.equal(err.name, 'MongooseServerSelectionError');
","it('throws a MongooseServerSelectionError on server selection timeout (gh-8451)', async function() {

  try {
    await mongoose.createConnection(uri, opts);
    assert.ok(false);
  } catch (err) {
    assert.equal(err.name, 'MongooseServerSelectionError');
  }
});",0.4724734923959223,0.3267294026204632,0.40931841311707223,0.6538461538461539,0.5,0.5991517600862154,0.3626305461419687,0.4185918788182776,0.6153846153846154,1.0,0.36353409364604883,0.41959687978655347,0.4164076266657736,0.4642857142857143,0.15384615384615385
73,"  const cb = (err, docs) => {

    if (err) {

      return callback(err);

    }

    if (docs.length === 0) {

      return callback(null, docs);

    }

    if (this.options.explain) {

      return callback(null, docs);

    }

    if (!mongooseOptions.populate) {

      const versionKey = _this.schema.options.versionKey;

      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {

        docs.forEach((doc) => {

          if (versionKey in doc) {

            delete doc[versionKey];

          }

        });

      }

      return mongooseOptions.lean ?

      // call _completeManyLean here?

        _completeManyLean(_this.model.schema, docs, null, completeManyOptions, callback) :

        // callback(null, docs) :

        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);

    }

    const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);

    if (mongooseOptions.lean) {

      return _this.model.populate(docs, pop, callback);

    completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, (err, docs) => {

      if (err != null) {

        return callback(err);

      }

      _this.model.populate(docs, pop, callback);

    });

  };

  const options = this._optionsForExec();

  options.projection = this._fieldsForExec();

  const filter = this._conditions;

  this._collection.collection.find(filter, options, (err, cursor) => {

    if (err != null) {

      return cb(err);

    }

    if (options.explain) {

      return cursor.explain().then(res => cb(null, res), err => cb(err));

    }

    try {

      return cursor.toArray().then(res => cb(null, res), err => cb(err));

    } catch (err) {

      return cb(err);

    }

  });

});
","  const options = this._optionsForExec();

  options.projection = this._fieldsForExec();

  const filter = this._conditions;

  const cursor = await this._collection.collection.find(filter, options);

  if (options.explain) {

    return cursor.explain();

  }

  let docs = await cursor.toArray();

  if (docs.length === 0) {

    return docs;

  }

  if (!mongooseOptions.populate) {

    const versionKey = _this.schema.options.versionKey;

    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {

      docs.forEach((doc) => {

        if (versionKey in doc) {

          delete doc[versionKey];

        }

      });

    return mongooseOptions.lean ?

      _completeManyLean(_this.model.schema, docs, null, completeManyOptions) :

      completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);

  }

  const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);

  if (mongooseOptions.lean) {

    return _this.model.populate(docs, pop);

  }

  docs = await completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);

  await this.model.populate(docs, pop);

  return docs;

};
","const cb = async (err, docs) => {

    if (err) {

      return callback(err);

    }

    if (docs.length === 0) {

      return callback(null, docs);

    }

    if (this.options.explain) {

      return callback(null, docs);

    }

    if (!mongooseOptions.populate) {

      const versionKey = _this.schema.options.versionKey;

      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {

        docs.forEach((doc) => {

          if (versionKey in doc) {

            delete doc[versionKey];

          }

        });

      }

      return mongooseOptions.lean ?

        // call _completeManyLean here?

        _completeManyLean(_this.model.schema, docs, null, completeManyOptions, callback) :

        // callback(null, docs) :

        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);

    }

    const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);

    if (mongooseOptions.lean) {

      return _this.model.populate(docs, pop, callback);

  };

  const options = this._optionsForExec();

  options.projection = this._fieldsForExec();

  const filter = this._conditions;

  try {

    const cursor = await this._collection.collection.find(filter, options);

    if (options.explain) {

      return cursor.explain().then(res => cb(null, res), err => cb(err));

    }

    const docs = await cursor.toArray();

    return cb(null, docs);

  } catch (err) {

    return cb(err);

  }

};",0.329808131032932,0.3199148781808052,0.3811494989515337,0.4393063583815029,0.17886178861788618,0.7535645610966812,0.6853118214810401,0.7068777166694896,0.8497109826589595,0.7723577235772358,0.553705466185823,0.4859631198159756,0.6745563222038409,0.7368421052631579,0.31746031746031744
74,"  if (!callback) {

    return Query.base.deleteOne.call(this);

  }



  this.exec.call(this, callback);

 * @param {Function} callback

Query.prototype._deleteOne = wrapThunk(function(callback) {

    callback(this.error());

    return this;

  callback = _wrapThunkCallback(this, callback);



  this._collection.collection.deleteOne(this._conditions, options).then(

    res => { callback(null, res); },

    err => { callback(err); }

  );

});
","  Query.base.deleteOne.call(this);

 *

Query.prototype._deleteOne = async function _deleteOne() {

    throw this.error();

  return this._collection.collection.deleteOne(this._conditions, options);

};
","Query.prototype._deleteOne = async function(callback) {
  if (!callback) {
    return Query.base.deleteOne.call(this);
  }
  this.exec.call(this, callback);
  try {
    const res = await this._collection.collection.deleteOne(this._conditions, options);
    callback(null, res);
  } catch (err) {
    callback(err);
  }
}",0.11264868088258331,0.007440606788008845,0.01473881619587629,0.29508196721311475,0.13333333333333333,0.36342562496361985,0.25194199118913346,0.26077690210796906,0.5409836065573771,0.4,0.4192361725490629,0.04370614964591188,0.09477700208880134,0.5384615384615384,1.0
75,"Query.prototype._deleteMany = wrapThunk(function(callback) {

    callback(this.error());

    return this;

  callback = _wrapThunkCallback(this, callback);

  this._collection.collection.deleteMany(this._conditions, options).then(

    res => { callback(null, res); },

    err => { callback(err); }

  );

});
","Query.prototype._deleteMany = async function _deleteMany() {

    throw this.error();

  return this._collection.collection.deleteMany(this._conditions, options);

};
","Query.prototype._deleteMany = async function(callback) {
    callback = _wrapThunkCallback(this, callback);
    this._collection.collection.deleteMany(this._conditions, options).then(
        res => { await callback(null, res); },
        err => { await callback(err); }
    );
}",0.3259975462242364,0.01410462341907171,0.02159287855104448,0.2682926829268293,0.0,0.6178656960945051,0.5639331823461216,0.5441149678855576,0.4634146341463415,0.9,0.39877202379153065,0.04085892079136996,0.08054496384843701,0.47368421052631576,0.0
76,"    const p1 = Temp.create({ nested: { nums: [1, 2, 3, 4, 5] } });

    p1.then(function(t) {

      t.nested.nums.pull(1);

      t.nested.nums.pull(2);

      assert.equal(t.$__.activePaths.paths['nested.nums'], 'modify');

      done();

    }).catch(done);

  it('$pull should affect what you see in an array before a save', function(done) {
","    const t = await Temp.create({ nested: { nums: [1, 2, 3, 4, 5] } });

    t.nested.nums.pull(1);

    t.nested.nums.pull(2);

    assert.equal(t.$__.activePaths.paths['nested.nums'], 'modify');

  it('$pull should affect what you see in an array before a save', async function() {
","// Define an async function to wrap the logic
async function run() {
  // Create a new Temp document
  const p1 = await Temp.create({ nested: { nums: [1, 2, 3, 4, 5] } });

  // Use await to assign the resolved value of the promise to a variable
  let t = await p1;

  // Modify the nested.nums array by pulling elements 1 and 2
  t.nested.nums.pull(1);
  t.nested.nums.pull(2);

  // Assert that the activePaths has been modified correctly
  assert.equal(t.$__.activePaths.paths['nested.nums'], 'modify');
}
// Call the async function and handle any errors that may occur
run().catch(err => console.error(err));",0.6522853435332382,0.6630300431665526,0.6683335531886223,0.6666666666666666,0.6111111111111112,0.47326871393033576,0.13693721986395122,0.3603043025240588,0.7291666666666666,0.6666666666666666,0.5660862132928082,0.15757316826093912,0.44224177038037904,0.9722222222222222,0.6923076923076923
77,"    it('updateOne()', function(done) {

      BlogPost.create({ title: 'interoperable update as promise' }, function(err) {

        assert.ifError(err);

        const query = BlogPost.updateOne({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });

        query.exec(function(err, res) {

          assert.ifError(err);

          assert.equal(res.matchedCount, 1);

          assert.equal(res.modifiedCount, 1);

          BlogPost.count({ title: 'interoperable update as promise delta' }, function(err, count) {

            assert.ifError(err);

            assert.equal(count, 1);

            done();

          });

        });

      });

    it('findOne()', function(done) {

      BlogPost.create({ title: 'interoperable findOne as promise' }, function(err, created) {

        assert.ifError(err);

        const query = BlogPost.findOne({ title: 'interoperable findOne as promise' });

        query.exec(function(err, found) {

          assert.ifError(err);

          assert.equal(found.id, created.id);

          done();

        });

      });

    it('find()', function(done) {

      BlogPost.create(

        { title: 'interoperable find as promise' },

        function(err, createdOne, createdTwo) {

          assert.ifError(err);

          const query = BlogPost.find({ title: 'interoperable find as promise' }).sort('_id');

          query.exec(function(err, found) {

            assert.ifError(err);

            assert.equal(found.length, 2);

            const ids = {};

            ids[String(found[0]._id)] = 1;

            ids[String(found[1]._id)] = 1;

            assert.ok(String(createdOne._id) in ids);

            assert.ok(String(createdTwo._id) in ids);

            done();

          });

        });

    it('op can be changed', function(done) {

      BlogPost.create({ title: title }, function(err, created) {

        assert.ifError(err);

        const query = BlogPost.count({ title: title });

        query.exec('findOne', function(err, found) {

          assert.ifError(err);

          assert.equal(found.id, created.id);

          done();

        });

      });

      it.skip('count()', function(done) {

        BlogPost.create({ title: 'interoperable count as promise 2' }, function(err) {

          assert.ifError(err);

          const query = BlogPost.count({ title: 'interoperable count as promise 2' });

          const promise = query.exec();

          promise.then(function(count) {

            assert.equal(count, 1);

            done();

          }).catch(done);

        });

      });



      it.skip('update()', function(done) {

        BlogPost.create({ title: 'interoperable update as promise 2' }, function(err) {

          assert.ifError(err);

          const query = BlogPost.update({ title: 'interoperable update as promise 2' }, { title: 'interoperable update as promise delta 2' });

          const promise = query.exec();

          promise.then(function() {

            BlogPost.count({ title: 'interoperable update as promise delta 2' }, function(err, count) {

              assert.ifError(err);

              assert.equal(count, 1);

              done();

            });

          });

        });

      });


","    it('updateOne()', async function() {

      await BlogPost.create({ title: 'interoperable update as promise' });

      const query = BlogPost.updateOne({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });

      const res = await query.exec();

      assert.equal(res.matchedCount, 1);

      assert.equal(res.modifiedCount, 1);

      const count = await BlogPost.countDocuments({ title: 'interoperable update as promise delta' });

      assert.equal(count, 1);

    it('findOne()', async function() {

      const created = await BlogPost.create({ title: 'interoperable findOne as promise' });

      const query = BlogPost.findOne({ title: 'interoperable findOne as promise' });

      const found = await query.exec();

      assert.equal(found.id, created.id);

    it('find()', async function() {

      const [createdOne, createdTwo] = await BlogPost.create([

        { title: 'interoperable find as promise' }

      ]);



      const query = BlogPost.find({ title: 'interoperable find as promise' }).sort('_id');

      const found = await query.exec();

      assert.equal(found.length, 2);

      const ids = {};

      ids[String(found[0]._id)] = 1;

      ids[String(found[1]._id)] = 1;

      assert.ok(String(createdOne._id) in ids);

      assert.ok(String(createdTwo._id) in ids);

    it('op can be changed', async function() {

      const created = await BlogPost.create({ title: title });

      const query = BlogPost.count({ title: title });

      const found = await query.exec('findOne');

      assert.equal(found.id, created.id);
","// Tests for asynchronous queries
describe('Asynchronous Queries', () => {
  it('updateOne()', async function() {
    const created = await BlogPost.create({ title: 'interoperable update as promise' });
    const query = BlogPost.updateOne({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });
    const res = await query.exec();
    assert.equal(res.matchedCount, 1);
    assert.equal(res.modifiedCount, 1);
    const count = await BlogPost.count({ title: 'interoperable update as promise delta' });
    assert.equal(count, 1);
  });

  it('findOne()', async function() {
    const created = await BlogPost.create({ title: 'interoperable findOne as promise' });
    const query = BlogPost.findOne({ title: 'interoperable findOne as promise' });
    const found = await query.exec();
    assert.equal(found.id, created.id);
  });

  it('find()', async function() {
    const createdOne = await BlogPost.create({ title: 'interoperable find as promise' });
    const createdTwo = await BlogPost.create({ title: 'interoperable find as promise' });
    const query = BlogPost.find({ title: 'interoperable find as promise' }).sort('_id');
    const found = await query.exec();
    assert.equal(found.length, 2);
    const ids = {};
    ids[String(found[0]._id)] = 1;
    ids[String(found[1]._id)] = 1;
    assert.ok(String(createdOne._id) in ids);
    assert.ok(String(createdTwo._id) in ids);
  });

  it('op can be changed', async function() {
    const created = await BlogPost.create({ title: 'interoperable count as promise 2' });
    const query = BlogPost.count({ title: 'interoperable count as promise 2' });
    const count = await query.exec();
    assert.equal(count, 1);
  });
});",0.3572401013671255,0.2773410183504757,0.3303774702077596,0.5633802816901409,0.2578616352201258,0.4084585085706645,0.3532359128336457,0.3812624849887413,0.5408450704225352,0.3584905660377358,0.6626175617749748,0.68050913325727,0.8278932369681226,0.856353591160221,0.2857142857142857
78,"      it('find()', function(done) {

        BlogPost.create(

          { title: 'interoperable find as promise 2' },

          function(err, createdOne, createdTwo) {

            assert.ifError(err);

            const query = BlogPost.find({ title: 'interoperable find as promise 2' }).sort('_id');

            const promise = query.exec();

            promise.then(function(found) {

              assert.ifError(err);

              assert.equal(found.length, 2);

              assert.equal(found[0].id, createdOne.id);

              assert.equal(found[1].id, createdTwo.id);

              done();

            }).catch(done);

          });

      });



      it.skip('remove()', function() {

        return BlogPost.create({ title: 'interoperable remove as promise 2' }).

          then(() => {

            return BlogPost.remove({ title: 'interoperable remove as promise 2' });

          }).

          then(() => {

            return BlogPost.count({ title: 'interoperable remove as promise 2' });

          }).

          then(count => {

            assert.equal(count, 0);

          });

      });

      it('are thenable', function(done) {

        const peopleSchema = new Schema({ name: String, likes: ['ObjectId'] });

        const P = db.model('Test', peopleSchema);

        BlogPost.create(

          { title: 'then promise 1' },

          { title: 'then promise 2' },

          { title: 'then promise 3' },

          function(err, d1, d2, d3) {

            assert.ifError(err);



            P.create(

              { name: 'brandon', likes: [d1] },

              { name: 'ben', likes: [d2] },

              { name: 'bernie', likes: [d3] },

              function(err) {

                assert.ifError(err);



                const promise = BlogPost.find({ title: /^then promise/ }).select('_id').exec();

                promise.then(function(blogs) {

                  const ids = blogs.map(function(m) {

                    return m._id;

                  });

                  return P.where('likes').in(ids).exec();

                }).then(function(people) {

                  assert.equal(people.length, 3);

                  return people;

                }).then(function() {

                  done();

                }, function(err) {

                  done(new Error(err));

                });

              });

          });

    it('hides private props', function(done) {
","      it('find()', async function() {

        const [createdOne, createdTwo] = await BlogPost.create(

          { title: 'interoperable find as promise 2' }

        );

        const query = BlogPost.find({ title: 'interoperable find as promise 2' }).sort('_id');

        const found = await query.exec();

        assert.equal(found.length, 2);

        assert.equal(found[0].id, createdOne.id);

        assert.equal(found[1].id, createdTwo.id);

    it('hides private props', function() {
","const { Schema } = require('mongoose');
  const BlogPost = new Schema({ title: String });
  
  it('find()', async () => {
    try {
      await BlogPost.create(
        { title: 'interoperable find as promise 2' },
        function (err, createdOne, createdTwo) {
          assert.ifError(err);
    
          const query = BlogPost.find({ title: 'interoperable find as promise 2' }).sort('_id');
    
          await query.exec().then((found) => {
            assert.ifError(err);
            assert.equal(found.length, 2);
            assert.equal(found[0].id, createdOne.id);
            assert.equal(found[1].id, createdTwo.id);
          });
        }
      );
    } catch (error) {
      done(new Error(error));
    }
  });
  
  it.skip('remove()', async () => {
    try {
      await BlogPost.create({ title: 'interoperable remove as promise 2' }).then(() => {
        return BlogPost.remove({ title: 'interoperable remove as promise 2' });
      }).then(() => {
        return BlogPost.count({ title: 'interoperable remove as promise 2' });
      }).then((count) => {
        assert.equal(count, 0);
      });
    } catch (error) {
      done(new Error(error));
    }
  });
  
  it('are thenable', async () => {
    try {
      const peopleSchema = new Schema({ name: String, likes: ['ObjectId'] });
      const P = db.model('Test', peopleSchema);
    
      await BlogPost.create(
        { title: 'then promise 1' },
        { title: 'then promise 2' },
        { title: 'then promise 3' },
        function (err, d1, d2, d3) {
          assert.ifError(err);
    
          await P.create(
            { name: 'brandon', likes: [d1] },
            { name: 'ben', likes: [d2] },
            { name: 'bernie', likes: [d3] }
          );
        }
      );
    
      const promise = BlogPost.find({ title: /^then promise/ }).select('_id').exec();
    
      await promise.then((blogs) => {
        const ids = blogs.map(function (m) {
          return m._id;
        });
    
        return P.where('likes').in(ids).exec();
      }).then((people) => {
        assert.equal(people.length, 3);
        return people;
      }).then(() => {
        done();
      }, (err) => {
        done(new Error(err));
      });
    } catch (error) {
      done(new Error(error));
    }
  });
  
  it('hides private props', async () => {
    try {
      const promise = BlogPost.find({ title: /^then promise/ }).select('_id').exec();
    
      await promise.then((blogs) => {
        const ids = blogs.map(function (m) {
          return m._id;
        });
    
        return P.where('likes').in(ids).exec();
      }).then((people) => {
        assert.equal(people.length, 3);
        return people;
      }).then(() => {
        done();
      }, (err) => {
        done(new Error(err));
      });
    } catch (error) {
      done(new Error(error));
    }
  });",0.18185968076472675,0.02017323415708021,0.12784369257244568,0.4198473282442748,0.1595744680851064,0.5914692520828218,0.447502851062067,0.6913155248183509,0.8015267175572519,0.425531914893617,0.5038668865810296,0.08512322467865642,0.584190475491616,0.8461538461538461,0.5
79,"      savePromise.then(function() {

        assert.ok(!doc.$__.$versionError);

        assert.ok(!doc.$__.saveOptions);

        done();

      }).catch(done);

    it('should overwrite arrays when directly set (gh-1126)', function(done) {

      BlogPost.create({ title: 'gh-1126', numbers: [1, 2] }, function(err, b) {

        assert.ifError(err);

        BlogPost.findById(b._id, function(err, b) {

          assert.ifError(err);

          assert.deepEqual([1, 2].join(), b.numbers.join());



          b.numbers = [];

          b.numbers.push(3);



          const d = b.$__delta()[1];

          assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));

          assert.ok(Array.isArray(d.$set.numbers));

          assert.equal(d.$set.numbers.length, 1);

          assert.equal(d.$set.numbers[0], 3);



          b.save(function(err) {

            assert.ifError(err);



            BlogPost.findById(b._id, function(err, b) {

              assert.ifError(err);

              assert.ok(Array.isArray(b.numbers));

              assert.equal(b.numbers.length, 1);

              assert.equal(b.numbers[0], 3);



              b.numbers = [3];

              const d = b.$__delta();

              assert.ok(!d);



              b.numbers = [4];

              b.numbers.push(5);

              b.save(function(err) {

                assert.ifError(err);

                BlogPost.findById(b._id, function(err, b) {

                  assert.ifError(err);

                  assert.ok(Array.isArray(b.numbers));

                  assert.equal(b.numbers.length, 2);

                  assert.equal(b.numbers[0], 4);

                  assert.equal(b.numbers[1], 5);

                  done();

                });

              });

            });

          });

        });

      });

    it('should use $set when subdoc changed before pulling (gh-1303)', function(done) {

      B.create(

        { title: 'gh-1303', comments: [{ body: 'a' }, { body: 'b' }, { body: 'c' }] },

        function(err, b) {

          assert.ifError(err);

          B.findById(b._id, function(err, b) {

            assert.ifError(err);



            b.comments[2].body = 'changed';

            b.comments.pull(b.comments[1]);



            assert.equal(b.comments.length, 2);

            assert.equal(b.comments[0].body, 'a');

            assert.equal(b.comments[1].body, 'changed');



            const d = b.$__delta()[1];

            assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));

            assert.ok(Array.isArray(d.$set.comments));

            assert.equal(d.$set.comments.length, 2);



            b.save(function(err) {

              assert.ifError(err);



              B.findById(b._id, function(err, b) {

                assert.ifError(err);

                assert.ok(Array.isArray(b.comments));

                assert.equal(b.comments.length, 2);

                assert.equal(b.comments[0].body, 'a');

                assert.equal(b.comments[1].body, 'changed');

                done();

              });

            });

          });

        });

    it('with conflicted data in db', function(done) {

      m.save(function(err) {

        assert.strictEqual(err, null);

        assert.strictEqual('GI', m.namey.first);

        assert.strictEqual('Joe', m.namey.last);

        done();

      });

    it('with positional notation on path not existing in schema (gh-1048)', function(done) {
","      await savePromise;

      assert.ok(!doc.$__.$versionError);

      assert.ok(!doc.$__.saveOptions);

    it('should overwrite arrays when directly set (gh-1126)', async function() {

      let b = await BlogPost.create({ title: 'gh-1126', numbers: [1, 2] });

      b = await BlogPost.findById(b._id);

      assert.deepEqual([1, 2].join(), b.numbers.join());



      b.numbers = [];

      b.numbers.push(3);



      let d = b.$__delta()[1];

      assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));

      assert.ok(Array.isArray(d.$set.numbers));

      assert.equal(d.$set.numbers.length, 1);

      assert.equal(d.$set.numbers[0], 3);



      await b.save();

      b = await BlogPost.findById(b._id);

      assert.ok(Array.isArray(b.numbers));

      assert.equal(b.numbers.length, 1);

      assert.equal(b.numbers[0], 3);



      b.numbers = [3];

      d = b.$__delta();

      assert.ok(!d);



      b.numbers = [4];

      b.numbers.push(5);

      await b.save();

      b = await BlogPost.findById(b._id);

      assert.ok(Array.isArray(b.numbers));

      assert.equal(b.numbers.length, 2);

      assert.equal(b.numbers[0], 4);

      assert.equal(b.numbers[1], 5);

    it('should use $set when subdoc changed before pulling (gh-1303)', async function() {

      let b = await B.create(

        { title: 'gh-1303', comments: [{ body: 'a' }, { body: 'b' }, { body: 'c' }] }

      );



      b = await B.findById(b._id);

      b.comments[2].body = 'changed';

      b.comments.pull(b.comments[1]);



      assert.equal(b.comments.length, 2);

      assert.equal(b.comments[0].body, 'a');

      assert.equal(b.comments[1].body, 'changed');



      const d = b.$__delta()[1];

      assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));

      assert.ok(Array.isArray(d.$set.comments));

      assert.equal(d.$set.comments.length, 2);



      await b.save();

      b = await B.findById(b._id);

      assert.ok(Array.isArray(b.comments));

      assert.equal(b.comments.length, 2);

      assert.equal(b.comments[0].body, 'a');

      assert.equal(b.comments[1].body, 'changed');

    it('with conflicted data in db', async function() {

      await m.save();

      assert.strictEqual('GI', m.namey.first);

      assert.strictEqual('Joe', m.namey.last);

    it('with positional notation on path not existing in schema (gh-1048)', async function() {
","savePromise.then(() => {
  assert.ok(!doc.$__.$versionError);
  assert.ok(!doc.$__.saveOptions);
  done();
}).catch(done);

it('should overwrite arrays when directly set (gh-1126)', async () => {
  const b = await BlogPost.create({ title: 'gh-1126', numbers: [1, 2] });
  assert.deepEqual([1, 2].join(), b.numbers.join());
  b.numbers = [];
  b.numbers.push(3);
  const d = b.$__delta()[1];
  assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));
  assert.ok(Array.isArray(d.$set.numbers));
  assert.equal(d.$set.numbers.length, 1);
  assert.equal(d.$set.numbers[0], 3);
  await b.save();
  const newB = await BlogPost.findById(b._id);
  assert.ok(Array.isArray(newB.numbers));
  assert.equal(newB.numbers.length, 1);
  assert.equal(newB.numbers[0], 3);
  done();
});

it('should use $set when subdoc changed before pulling (gh-1303)', async () => {
  const b = await BlogPost.create({ title: 'gh-1303', comments: [{ body: 'a' }, { body: 'b' }, { body: 'c' }] });
  b.comments[2].body = 'changed';
  b.comments.pull(b.comments[1]);
  assert.equal(b.comments.length, 2);
  assert.equal(b.comments[0].body, 'a');
  assert.equal(b.comments[1].body, 'changed');
  const d = b.$__delta()[1];
  assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));
  assert.ok(Array.isArray(d.$set.comments));
  assert.equal(d.$set.comments.length, 2);
  await b.save();
  const newB = await BlogPost.findById(b._id);
  assert.ok(Array.isArray(newB.numbers));
  assert.equal(newB.comments.length, 2);
  assert.equal(newB.comments[0].body, 'a');
  assert.equal(newB.comments[1].body, 'changed');
  done();
});

it('with conflicted data in db', async () => {
  await m.save((err) => {
    assert.strictEqual(err, null);
    assert.strictEqual('GI', m.namey.first);
    assert.strictEqual('Joe', m.namey.last);
    done();
  });
});

it('with positional notation on path not existing in schema (gh-1048)', async () => {
  const b = await BlogPost.create({ title: 'gh-1048', numbers: [1, 2] });
  b.numbers.$[1].set(3);
  const d = b.$__delta()[1];
  assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));
  await b.save();
  const newB = await BlogPost.findById(b._id);
  assert.ok(Array.isArray(newB.numbers));
  assert.equal(newB.numbers[1], 3);
  done();
});",0.544227279642883,0.5411252255515862,0.5450768780579638,0.7662037037037037,0.32450331125827814,0.5471484658267523,0.5222145659517524,0.5303417697614378,0.7916666666666666,0.3443708609271523,0.6202628305985494,0.5244604863592967,0.5838639786831693,0.9291784702549575,0.4435483870967742
80,"      Movie.insertMany(movies, function(error, docs) {

        assert.ifError(error);

        assert.equal(docs.length, 1);

        Movie.findOne({ name: 'Predator' }, function(error, doc) {

          assert.ifError(error);

          assert.equal(doc.leadActor.toHexString(), arnold._id.toHexString());

          done();

        });

      });

    });



    it('insertMany() with promises (gh-4237)', function(done) {

      const schema = new Schema({

        name: String

      });

      const Movie = db.model('Movie', schema);



      const arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];

      Movie.insertMany(arr).then(function(docs) {

        assert.equal(docs.length, 2);

        assert.ok(!docs[0].isNew);

        assert.ok(!docs[1].isNew);

        Movie.find({}, function(error, docs) {

          assert.ifError(error);

          assert.equal(docs.length, 2);

          done();

        });

      });
","      const docs = await Movie.insertMany(movies);

      assert.equal(docs.length, 1);

      const doc = await Movie.findOne({ name: 'Predator' });

      assert.equal(doc.leadActor.toHexString(), arnold._id.toHexString());
","async function test() {
  const schema = new Schema({
    name: String,
  });
  const Movie = db.model('Movie', schema);

  const arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];
  try {
    const docs = await Movie.insertMany(arr);
    assert.equal(docs.length, 2);
    assert.ok(!docs[0].isNew);
    assert.ok(!docs[1].isNew);
    const foundDocs = await Movie.find({});
    assert.equal(foundDocs.length, 2);
    done();
  } catch (error) {
    assert.ifError(error);
  }
}",0.18071014988494097,0.003995669984729917,0.02274563877489219,0.48333333333333334,0.2127659574468085,0.44706994459683763,0.40715604997529997,0.4258045794758805,0.7,0.2553191489361702,0.37062572008132194,0.05294306808178317,0.2081145907982831,0.6060606060606061,0.6153846153846154
81,"    it('should have fields when create', function(done) {

      cat.save(function(err, doc) {

        assert.ok(doc.createdAt);

        assert.ok(doc.updatedAt);

        assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

        done();

      });

    it('sets timestamps on findOneAndUpdate', function(done) {

      Cat.findOneAndUpdate({ name: 'notexistname' }, { $set: {} }, { upsert: true, new: true }, function(err, doc) {

        assert.ok(doc.createdAt);

        assert.ok(doc.updatedAt);

        assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

        done();

      });

    it('sets timestamps on findOneAndReplace (gh-9951)', function() {

      return Cat.findOneAndReplace({ name: 'notexistname' }, {}, { upsert: true, new: true }).then(doc => {

        assert.ok(doc.createdAt);

        assert.ok(doc.updatedAt);

        assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

      });

    it('should change updatedAt when save', function(done) {

      Cat.findOne({ name: 'newcat' }, function(err, doc) {

        const old = doc.updatedAt;

        doc.hobby = 'coding';

        doc.save(function(err, doc) {

          assert.ok(doc.updatedAt.getTime() > old.getTime());

          done();

        });

      });

    it('should not change updatedAt when save with no modifications', function(done) {

      Cat.findOne({ name: 'newcat' }, function(err, doc) {

        const old = doc.updatedAt;

        doc.save(function(err, doc) {

          assert.ok(doc.updatedAt.getTime() === old.getTime());

          done();

        });

      });
","    it('should have fields when create', async function() {

      const doc = await cat.save();

      assert.ok(doc.createdAt);

      assert.ok(doc.updatedAt);

      assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

    it('sets timestamps on findOneAndUpdate', async function() {

      const doc = await Cat.findOneAndUpdate({ name: 'notexistname' }, { $set: {} }, { upsert: true, new: true });

      assert.ok(doc.createdAt);

      assert.ok(doc.updatedAt);

      assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

    it('sets timestamps on findOneAndReplace (gh-9951)', async function() {

      const doc = await Cat.findOneAndReplace({ name: 'notexistname' }, {}, { upsert: true, new: true });

      assert.ok(doc.createdAt);

      assert.ok(doc.updatedAt);

      assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

    it('should change updatedAt when save', async function() {

      const doc = await Cat.findOne({ name: 'newcat' });

      const old = doc.updatedAt;

      doc.hobby = 'coding';

      await doc.save();

      assert.ok(doc.updatedAt.getTime() > old.getTime());

    it('should not change updatedAt when save with no modifications', async function() {

      const doc = await Cat.findOne({ name: 'newcat' });

      const old = doc.updatedAt;

      await doc.save();

      assert.ok(doc.updatedAt.getTime() === old.getTime());
","it('should have fields when create', async function () {
  const doc = await cat.save();
  assert.ok(doc.createdAt);
  assert.ok(doc.updatedAt);
  assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());
});

it('sets timestamps on findOneAndUpdate', async function () {
  const doc = await Cat.findOneAndUpdate({ name: 'notexistname' }, { $set: {} }, { upsert: true, new: true });
  assert.ok(doc.createdAt);
  assert.ok(doc.updatedAt);
  assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());
});

it('sets timestamps on findOneAndReplace (gh-9951)', async function () {
  const doc = await Cat.findOneAndReplace({ name: 'notexistname' }, {}, { upsert: true, new: true });
  assert.ok(doc.createdAt);
  assert.ok(doc.updatedAt);
  assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());
});

it('should change updatedAt when save', async function () {
  const old = await Cat.findOne({ name: 'newcat' }, function (err, doc) {
    doc.hobby = 'coding';
    return doc.save();
  });
  assert.ok(doc.updatedAt.getTime() > old.getTime());
});

it('should not change updatedAt when save with no modifications', async function () {
  const old = await Cat.findOne({ name: 'newcat' }, function (err, doc) {
    return doc.save();
  });
  assert.ok(doc.updatedAt.getTime() === old.getTime());
});",0.5826140102229609,0.48510536274695,0.4853689513289961,0.7236180904522613,0.6363636363636364,0.6009425065105997,0.4963646131817276,0.5373734347884923,0.7336683417085427,0.6363636363636364,0.7802609778622369,0.635322476950814,0.6837616189513614,0.9034090909090909,0.8985507246376812
82,"      instance.save(function(error) {

        assert.ifError(error);

        const query = { _id: instance._id };

        const update = { $set: { name: value } };

        const ok = function() {

          done();

        };

        Model.updateOne(query, update).then(ok, done);

      });

    it('versioning with setDefaultsOnInsert (gh-2593)', function(done) {
","      await instance.save();



      const query = { _id: instance._id };

      const update = { $set: { name: value } };



      return Model.updateOne(query, update);

    it('versioning with setDefaultsOnInsert (gh-2593)', async function() {
","async function () {
  try {
    await instance.save();
    const query = { _id: instance._id };
    const update = { $set: { name: value } };
    await Model.updateOne(query, update);
    done();
  } catch (error) {
    assert.ifError(error);
  }
}",0.4569124334063134,0.5166146228660157,0.5332573329814603,0.5,0.2777777777777778,0.47016745095404955,0.47746817208174264,0.4698682984011223,0.6,0.3333333333333333,0.7665873430159766,0.5384826747017084,0.658301479970894,0.8695652173913043,1.0
83,"      Model.updateOne(q, u, o).then(function() {

        done();

      }).catch(done);
","      await Model.updateOne(q, u, o);
","Model.updateOne(q, u, o).then(async () => {
  await done();
});",0.3414642082607867,0.10305224267080783,0.08633400213704504,0.17647058823529413,0.0,0.3936852422736162,0.06030725360407769,0.10266900960803409,0.4117647058823529,0.0,0.43788501491590814,0.056122223243057295,0.19541783642057514,0.5,0.0
84,"      ModelA.create({ name: 'model-A' }, function(error, toyA) {

        assert.ifError(error);

        ModelB.create({ name: 'model-B' }, function(error, toyB) {

          assert.ifError(error);

          Parent.create({

            children: [

              {

                name: 'Child 1',

                toy: { kind: 'Test1', value: toyA._id }

              },

              {

                name: 'Child 2'

              },

              {

                name: 'Child 3',

                toy: { kind: 'Test2', value: toyB._id }

              }

            ]

          }, function(error, doc) {

            assert.ifError(error);

            test(doc._id);

          });

        });

      function test(id) {

        Parent.findById(id, function(error, doc) {

          assert.ifError(error);

          doc.populate('children.toy.value').then(function(doc) {

            assert.equal(doc.children[0].toy.value.name, 'model-A');

            assert.equal(doc.children[1].toy.value, null);

            assert.equal(doc.children[2].toy.value.name, 'model-B');

            done();

          }).catch(done);

        });

      }
","      const toyA = await ModelA.create({ name: 'model-A' });

      const toyB = await ModelB.create({ name: 'model-B' });

      let doc = await Parent.create({

        children: [

          {

            name: 'Child 1',

            toy: { kind: 'Test1', value: toyA._id }

          },

          {

            name: 'Child 2'

          },

          {

            name: 'Child 3',

            toy: { kind: 'Test2', value: toyB._id }

          }

        ]



      doc = await Parent.findById(doc._id);

      await doc.populate('children.toy.value');

      assert.equal(doc.children[0].toy.value.name, 'model-A');

      assert.equal(doc.children[1].toy.value, null);

      assert.equal(doc.children[2].toy.value.name, 'model-B');


","async function test(id) {
  try {
    const doc = await Parent.findById(id).populate('children.toy.value');
    assert.equal(doc.children[0].toy.value.name, 'model-A');
    assert.equal(doc.children[1].toy.value, null);
    assert.equal(doc.children[2].toy.value.name, 'model-B');
  } catch (error) {
    done();
  }
}",0.45681510096311095,0.5128796995273065,0.5122729759879006,0.5163934426229508,0.2857142857142857,0.23822792519157,0.03184973931716109,0.09038280454045378,0.5163934426229508,0.3142857142857143,0.1894399623811333,0.053365465728986795,0.10439438379554636,0.4,0.2
85,"QueryCursor.prototype.close = function(callback) {

  return promiseOrCallback(callback, cb => {

    this.cursor.close().then(

      () => {

        this.emit('close');

        cb(null);

      },

      error => {

        cb(error);

        this.listeners('error').length > 0 && this.emit('error', error);

      }

    );

  }, this.model.events);
","QueryCursor.prototype.close = async function close() {

  if (typeof arguments[0] === 'function') {

    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');

  }

  try {

    await this.cursor.close();

    this.emit('close');

  } catch (error) {

    this.listeners('error').length > 0 && this.emit('error', error);

    throw error;

  }
","async function close(callback) {
  try {
    const result = await this.cursor.close();
    this.emit('close');
    return null;
  } catch (error) {
    cb(error);
    this.listeners('error').length > 0 && this.emit('error', error);
  }
}",0.3692226887689258,0.15032355087026303,0.19176328263681264,0.5098039215686274,0.625,0.3787606836961881,0.290897370262504,0.30012575667911107,0.5490196078431373,0.375,0.4012772689937404,0.2306735411430753,0.24252064121486488,0.5319148936170213,0.6
86,"  callback = this.$handleCallbackError(callback);



  return this.db.base._promiseOrCallback(callback, cb => {

    cb = this.$wrapCallback(cb);

    this.db.createCollection(this.$__collection.collectionName, options).then(

      () => cb(null, this.$__collection),

      err => {

        if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {

          return cb(err);

        }

        return cb(null, this.$__collection);

      }

    );

  }, this.events);
","  try {

    await this.db.createCollection(this.$__collection.collectionName, options);

  } catch (err) {

    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {

      throw err;

    }

  }

  return this.$__collection;
","callback = this.$handleCallbackError(callback);

return await this.db.base._promiseOrCallback(callback, async (cb) => {
  cb = this.$wrapCallback(cb);
  try {
    const collectionName = this.$__collection.collectionName;
    const options = {};
    const db = await this.db.createCollection(collectionName, options);
    if (db == null || db.code !== 48) {
      cb(err);
    }
  } catch (error) {
    console.error(error);
  }
});",0.31663800576657636,0.30258496568895543,0.33896705737734995,0.4107142857142857,0.21428571428571427,0.3396852585300881,0.1519159912628718,0.1711107571431948,0.4642857142857143,0.5714285714285714,0.24311661234658083,0.01800623477761378,0.03303164318013808,0.32142857142857145,0.6
87," *     Event.init().then(function(Event) {

 *       // You can also use `Event.on('index')` if you prefer event emitters

 *       // over promises.

 *       console.log('Indexes are done building!');

 *     });
"," *     await Event.init();

 *     console.log('Indexes are done building!');
","async function initEvent() {
  try {
    const Event = await Event.init();
    console.log('Indexes are done building!');
  } catch (error) {
    console.error(error);
  }
}

initEvent();",0.44313559373122646,0.05702965158245928,0.13656535492139385,0.5789473684210527,0.0,0.40224696101292934,0.09567164811723765,0.0922635643555325,0.42105263157894735,1.0,0.5592515011329273,0.12259149958656422,0.42210681263745264,0.6923076923076923,0.0
88,"      TestModel.diffIndexes().then((diff) => {

        assert.deepEqual(diff, { toCreate: [{ age: 1, title: 'text', description: 'text' }], toDrop: [] });

        TestModel.syncIndexes().then(() => {

          TestModel.diffIndexes().then((diff2) => {

            assert.deepEqual(diff2, { toCreate: [], toDrop: [] });

            done();

          });

        });

      });
","      await TestModel.init();

      const diff = await TestModel.diffIndexes();

      assert.deepEqual(diff, { toCreate: [{ age: 1, title: 'text', description: 'text' }], toDrop: [] });

      await TestModel.syncIndexes();



      const diff2 = await TestModel.diffIndexes();

      assert.deepEqual(diff2, { toCreate: [], toDrop: [] });
","async function migration() {
  
    try {
        const diff = await TestModel.diffIndexes();
        assert.deepEqual(diff, { toCreate: [{ age: 1, title: 'text', description: 'text' }], toDrop: [] });
        
        await TestModel.syncIndexes();
        
        const diff2 = await TestModel.diffIndexes();
        assert.deepEqual(diff2, { toCreate: [], toDrop: [] });
    } catch (error) {
        console.log(error);
    } finally {
        done();
    }
}",0.6118180918375143,0.533427681593061,0.5498600114274944,0.5862068965517241,0.7777777777777778,0.5937048647859099,0.3847531220750969,0.5743575248080063,0.6379310344827587,0.7777777777777778,0.8683895364565883,0.6492477029598201,0.9289203719445475,0.9787234042553191,0.9166666666666666
89,"        doc.save().then();
","        await doc.save();
","async function saveDoc() {
    try {
        await doc.save();
    } catch (e) {
        // handle error
    }
}",0.375,0.0,0.0,0.5,0.0,0.375,0.0,0.0,0.5,0.0,0.5434716312621715,0.02432542569851428,0.316227766016838,0.8333333333333334,0.0
90,"      it('should allow setting values to a given property gh-13510', function() {

        doc.save().then();
","      it('should allow setting values to a given property gh-13510', async function() {

        await m.connect('mongodb://127.0.0.1:27017/gh13510');

        await Test.deleteMany({});

        await doc.save();
","it('should allow setting values to a given property gh-13510', async function() {

    await doc.save();

  });",0.714239063061145,0.4877956849311217,0.7691605673134586,0.6,0.0,0.741509496219227,0.5968774175634496,0.7691605673134586,0.6,0.0,0.725267940886448,0.723887618816062,0.6771841447297298,0.5,0.0
91,"  console.log(`Processing ~${files.length} files`);

  Promise.all([pugifyAllFiles(), copyAllRequiredFiles()]).then(() => {

    console.log(""Done Processing"");

  })
","  (async function main() {

    console.log(`Processing ~${files.length} files`);



    await deleteAllHtmlFiles();

    await pugifyAllFiles();

    await copyAllRequiredFiles();

    if (process.env.DOCS_DEPLOY) {

      await moveDocsToTemp();

    }



    console.log('Done Processing');

  })();
","console.log(`Processing ~${files.length} files`);

  async function runAsync() {
    try {
      await pugifyAllFiles();
      await copyAllRequiredFiles();
      console.log(""Done Processing"");
    } catch (error) {
      // handle error here
    }
  }",0.4503260390383221,0.04620256681003074,0.1122444464861146,0.6428571428571429,1.0,0.45741822494080453,0.04934494673001858,0.13747081017605653,0.6428571428571429,1.0,0.5247898650459145,0.15980518115118314,0.1832567180568652,0.7560975609756098,1.0
92,"  // data that should persist across subPopulate calls

  const cache = {};

  return new Promise((resolve, reject) => {

    _populate(_this, docs, paths, cache, (err, res) => {

      if (err) {

        return reject(err);

      }

      resolve(res);

    });

  });
","  await _populate(_this, docs, paths);

  return docs;
","async function populateData() {

const cache = {};
try {
   const res = await _populate(_this, docs, paths, cache);
   return res;
} catch (err) {
  console.error(err);
}
}",0.05362047943598724,0.0007605270976598064,0.013721390646289147,0.0,0.2,0.20794525812107972,0.11415686333112618,0.11762416915319267,0.2,0.4,0.23374692927749474,0.03712362748517272,0.23119742295813958,0.16666666666666666,0.5
93,"render(process.argv[2] || '/')

  .then(html => console.log(html))

  .catch((err) => {

    console.error(err)

    process.exit(1)

  })
","const debug = (label, ...args) => console.debug(`> ${label}:`, ...args)



async function main () {

  const url = process.argv[2] || '/'

  debug('URL', url)



  const { html, status, headers } = await render(url)



  debug('Status', status)

  for (const header in headers) {

    debug(header, headers[header])

  }



  console.log('\n', html)

}



main().catch((err) => {

  console.error(err)

  process.exit(1)

})
","async function renderHtml() {
try{
 const html = await render(process.argv[2] || '/');
 console.log(html);
}catch(err){
 console.error(err)
 process.exit(1)
}
}",0.4869417077325893,0.07274999134192134,0.3448444257953326,0.6551724137931034,0.875,0.3334283094795888,0.0341599190576228,0.053863663688318665,0.6206896551724138,0.625,0.1421749819846224,0.0073610330518345595,0.01650835005611019,0.30158730158730157,0.24324324324324326
94,"module.exports = (req, res) => {

  const start = process.hrtime()

  render(req.url).then((html) => {

    const end = process.hrtime(start)

    const time = ((end[0] * 1e9) + end[1]) / 1e6

    // @ts-ignore

    res.setHeader('X-Nuxt-Coldstart', global._coldstart + 'ms')

    res.setHeader('X-Nuxt-Responsetime', time + 'ms')



  }).catch((err) => {

    console.error(err)

    res.end('Error: ' + err)

  })
","module.exports = async (req, res) => {

  try {

    const { html, status, headers } = await render(req.url, { req, res })

    for (const header in headers) {

      res.setHeadeer(header, headers[header])

    }

    res.status(status)

  } catch (error) {

    console.error(error)

    res.status(500)

    res.end('Internal Error: ' + error)

  }
","async function (req, res) {
  const start = process.hrtime()
  try {
    const html = await render(req.url)
    const end = process.hrtime(start)
    const time = ((end[0] * 1e9) + end[1]) / 1e6
    res.setHeader('X-Nuxt-Coldstart', global._coldstart + 'ms')
    res.setHeader('X-Nuxt-Responsetime', time + 'ms')
    return html
  } catch (err) {
    console.error(err)
    res.end('Error: ' + err)
  }
}",0.2594669971118986,0.07948806437093005,0.08017096885278355,0.3582089552238806,0.52,0.6357754105566727,0.5629065548114563,0.6339264306988166,0.746268656716418,0.6,0.24350002792052503,0.03611234314459881,0.044531125180857924,0.4318181818181818,0.46153846153846156
95,"const getPluginMode = (src) => {

  return mode

export function resolvePlugins (builder: Builder, app: NuxtApp) {

  return resolveFiles(builder, 'plugins/**/*.{js,ts}', app.dir)

    .then(plugins => plugins.map((src) => {

      return {

        src,

        mode: getPluginMode(src)

      }

    }))
","const getPluginMode = (src: string) => {

  return mode as NuxtPlugin['mode']

export async function resolvePlugins (builder: Builder, app: NuxtApp) {

  const plugins = await resolveFiles(builder, 'plugins/**/*.{js,ts}', app.dir)



  return plugins.map(src => ({

    src,

    mode: getPluginMode(src)

  })

  )
","async function resolvePlugins(builder, app) {
  try {
    const plugins = await resolveFiles(builder, 'plugins/**/*.{js,ts}', app.dir);
    return plugins.map((src) => ({
      src,
      mode: getPluginMode(src),
    }));
  } catch (error) {
    console.error(error);
  }
}",0.45434764770579855,0.3323582199820518,0.38226557242217024,0.36363636363636365,0.7391304347826086,0.2053355457370928,0.026418735200591636,0.026807505718794124,0.3333333333333333,0.43478260869565216,0.3047846942566621,0.243353074797144,0.25632868865484376,0.4117647058823529,0.3076923076923077
96,"import { CreateOptions } from '#app'

const entry = process.server

  ? (ctx?: CreateOptions['ssrContext']) => import('#app/bootstrap').then(m => m.default(ctx))

  : () => import('#app/bootstrap').then(m => m.default)

  entry()

export default entry
","import { createSSRApp, createApp, nextTick } from 'vue'

import { createNuxtApp, applyPlugins, normalizePlugins, CreateOptions } from '#app'

import '#build/css'

// @ts-ignore

import _plugins from '#build/plugins'

// @ts-ignore

import RootComponent from '#build/root-component.mjs'

// @ts-ignore

import AppComponent from '#build/app-component.mjs'

let entry: Function



const plugins = normalizePlugins(_plugins)



if (process.server) {

  entry = async function createNuxtAppServer (ssrContext: CreateOptions['ssrContext'] = {}) {

    const vueApp = createApp(RootComponent)

    vueApp.component('App', AppComponent)



    const nuxt = createNuxtApp({ vueApp, ssrContext })



    await applyPlugins(nuxt, plugins)



    await nuxt.hooks.callHook('app:created', vueApp)



    return vueApp

  }

}

  // TODO: temporary webpack 5 HMR fix

  // https://github.com/webpack-contrib/webpack-hot-middleware/issues/390

  // @ts-ignore

  if (process.dev && import.meta.webpackHot) {

    // @ts-ignore

    import.meta.webpackHot.accept()

  }



  entry = async function initApp () {

    const isSSR = Boolean(window.__NUXT__?.serverRendered)

    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent)

    vueApp.component('App', AppComponent)



    const nuxt = createNuxtApp({ vueApp })



    await applyPlugins(nuxt, plugins)



    await nuxt.hooks.callHook('app:created', vueApp)

    await nuxt.hooks.callHook('app:beforeMount', vueApp)



    nuxt.hooks.hookOnce('app:suspense:resolve', () => {

      nuxt.isHydrating = false

    })



    vueApp.mount('#__nuxt')



    await nuxt.hooks.callHook('app:mounted', vueApp)

    await nextTick()

  }



  entry().catch((error) => {

    console.error('Error while mounting app:', error) // eslint-disable-line no-console

  })

export default (ctx?: CreateOptions['ssrContext']) => entry(ctx)
","import { CreateOptions } from '#app'

const entry = process.server
  ? (ctx?: CreateOptions['ssrContext']) => import('#app/bootstrap').then(m => m.default(ctx))
  : () => import('#app/bootstrap').then(m => m.default)

async function runEntry() {
  await entry()
}

export default async function entry() {
  try {
    const result = await runEntry()
  } catch (err) {
    // handle error
  }
}",0.3407927093768929,0.028780166597471964,0.19510495662438518,0.425,0.7142857142857143,0.8125712088825614,0.4434071762191716,0.8818776593110743,0.925,1.0,0.14426444228975988,0.013017885953780898,0.0388508720517292,0.30601092896174864,0.2191780821917808
97,"    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {

      const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath)

      const redirect = () => nuxtApp.callHook('app:redirected')

        .then(() => sendRedirect(nuxtApp.ssrContext!.event, redirectLocation, options?.redirectCode || 302))

        .then(() => inMiddleware ? /* abort route navigation */ false : undefined)

      // We wait to perform the redirect in case any other middleware will intercept the redirect

      // and redirect further.

        router.beforeEach(final => (final.fullPath === fullPath) ? redirect() : undefined)
","    if (nuxtApp.ssrContext) {

      const location = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath)



      async function redirect () {

        // TODO: consider deprecating in favour of `app:rendered` and removing

        await nuxtApp.callHook('app:redirected')

        const encodedLoc = location.replace(/""/g, '%22')

        nuxtApp.ssrContext!._renderResponse = {

          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),

          body: `<!DOCTYPE html><html><head><meta http-equiv=""refresh"" content=""0; url=${encodedLoc}""></head></html>`,

          headers: { location }

        }

        return inMiddleware ? /* abort route navigation */ false : undefined

      }

      // We wait to perform the redirect last in case any other middleware will intercept the redirect

      // and redirect somewhere else instead.

        router.afterEach(final => (final.fullPath === fullPath) ? redirect() : undefined)
","async function handleRedirect(nuxtApp, isExternal, toPath, options) {
  const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath);

  try {
    await nuxtApp.callHook('app:redirected');
    return sendRedirect(nuxtApp.ssrContext!.event, redirectLocation, options?.redirectCode || 302);
  } catch (error) {
    console.log(error);
  } finally {
    if (!inMiddleware) return false;
  }
}

router.beforeEach((final) => final.fullPath === fullPath ? handleRedirect() : undefined);",0.5620121973730564,0.387446171586691,0.5672931794348061,0.6481481481481481,0.6451612903225806,0.30798436443961713,0.1510178496465343,0.16156476940225675,0.5,0.41935483870967744,0.28156030184629277,0.054779244428069265,0.07688569177066125,0.4745762711864407,0.52
98,"    this.fetchBuiltInCMap = (name) => {

        return Promise.resolve(this.builtInCMapCache.get(name));

      return this.handler.sendWithPromise('FetchBuiltInCMap', {

        name,

      }).then((data) => {

        if (data.compressionType !== CMapCompressionType.NONE) {

          // Given the size of uncompressed CMaps, only cache compressed ones.

          this.builtInCMapCache.set(name, data);

        }

        return data;

      });
","    this.fetchBuiltInCMap = async (name) => {

        return this.builtInCMapCache.get(name);

      const data = await this.handler.sendWithPromise('FetchBuiltInCMap',

                                                      { name, });

      if (data.compressionType !== CMapCompressionType.NONE) {

        // Given the size of uncompressed CMaps, only cache compressed ones.

        this.builtInCMapCache.set(name, data);

      }

      return data;
","this.fetchBuiltInCMap = async (name) => {
  try {
    const data = await this.handler.sendWithPromise('FetchBuiltInCMap', { name });
    if (data.compressionType !== CMapCompressionType.NONE) {
      // Given the size of uncompressed CMaps, only cache compressed ones.
      this.builtInCMapCache.set(name, data);
    }
    return data;
  } catch (error) {
    console.error(error);
  }
};",0.6614114750174944,0.6789925893528312,0.6916533107171463,0.65,0.625,0.5723294589008883,0.531092513544467,0.6332253220590863,0.625,0.5,0.8008124968381749,0.689836378159368,0.8164439122236349,0.7878787878787878,0.9090909090909091
99,"    fetchIfRefAsync: function XRef_fetchIfRefAsync(obj, suppressEncryption) {

        return Promise.resolve(obj);

    fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {

      var streamManager = this.stream.manager;

      var xref = this;

      return new Promise(function tryFetch(resolve, reject) {

        try {

          resolve(xref.fetch(ref, suppressEncryption));

        } catch (e) {

          if (e instanceof MissingDataException) {

            streamManager.requestRange(e.begin, e.end).then(function () {

              tryFetch(resolve, reject);

            }, reject);

            return;

          }

          reject(e);

      });
","    async fetchIfRefAsync(obj, suppressEncryption) {

        return obj;

    async fetchAsync(ref, suppressEncryption) {

      try {

        return this.fetch(ref, suppressEncryption);

      } catch (ex) {

        if (!(ex instanceof MissingDataException)) {

          throw ex;

        await this.pdfManager.requestRange(ex.begin, ex.end);

        return this.fetchAsync(ref, suppressEncryption);

      }
","async function XRef_fetchIfRefAsync(obj, suppressEncryption) {
    return Promise.resolve(obj);
}

async function XRef_fetchAsync(ref, suppressEncryption) {
    const streamManager = this.stream.manager;
    const xref = this;

    try {
        resolve(xref.fetch(ref, suppressEncryption));
    } catch (e) {
        if (e instanceof MissingDataException) {
            await streamManager.requestRange(e.begin, e.end);
            XRef_fetchAsync(ref, suppressEncryption);
        } else {
            reject(e);
        }
    }
}",0.17211777798438266,0.03941215732887353,0.04701813828212647,0.24489795918367346,0.35714285714285715,0.5259684699416971,0.43198922378439314,0.4320887376150485,0.6326530612244898,0.6071428571428571,0.24818835033837794,0.04235159460939835,0.061512917855224475,0.3333333333333333,0.5555555555555556
100,"  ensure(obj, prop, args) {

    return new Promise(function(resolve) {

      const value = obj[prop];

      if (typeof value === 'function') {

        resolve(value.apply(obj, args));

      } else {

        resolve(value);

      }

    });
","  async ensure(obj, prop, args) {

    const value = obj[prop];

    if (typeof value === 'function') {

      return value.apply(obj, args);

    }

    return value;
","ensure(obj, prop, args) {

    return new Promise(function(resolve) {

      const value = obj[prop];

      if (typeof value === 'function') {

        resolve(value.apply(obj, args));

      } else {

        resolve(value);

      }

    });",0.4972415326927174,0.49402452134160046,0.49724575689470707,0.3548387096774194,0.6428571428571429,1.0,1.0,1.0,1.0,1.0,0.6231399138212586,0.49860622311449404,0.6257716139887219,0.55,0.8181818181818182
101,"  ensure(obj, prop, args) {

    return new Promise((resolve, reject) => {

      let ensureHelper = () => {

        try {

          const value = obj[prop];

          let result;

          if (typeof value === 'function') {

            result = value.apply(obj, args);

          } else {

            result = value;

          }

          resolve(result);

        } catch (ex) {

          if (!(ex instanceof MissingDataException)) {

            reject(ex);

            return;

          }

          this.streamManager.requestRange(ex.begin, ex.end)

            .then(ensureHelper, reject);

        }

      };



      ensureHelper();

    });
","  async ensure(obj, prop, args) {

    try {

      const value = obj[prop];

      if (typeof value === 'function') {

        return value.apply(obj, args);

      }

      return value;

    } catch (ex) {

      if (!(ex instanceof MissingDataException)) {

        throw ex;

      }

      await this.requestRange(ex.begin, ex.end);

      return this.ensure(obj, prop, args);

    }
","async function ensure(obj, prop, args) {
    try {
        const value = obj[prop];
        let result;
        if (typeof value === 'function') {
            result = value.apply(obj, args);
        } else {
            result = value;
        }
        return result;
    } catch (ex) {
        if (!(ex instanceof MissingDataException)) {
            throw ex;
        }
        this.streamManager.requestRange(ex.begin, ex.end)
            .then(ensureHelper, reject);
    }
}",0.32790476834125665,0.336095950972815,0.36693726380635305,0.30303030303030304,0.3055555555555556,0.5320558766461341,0.6309751787053528,0.648763479394335,0.5151515151515151,0.3333333333333333,0.6111347841265431,0.5214858098606938,0.6135295171216688,0.5476190476190477,0.7619047619047619
102,"  read() {

    return this._headersCapability.promise.then(() => {

      return this._reader.read().then(({ value, done, }) => {

        if (done) {

          return Promise.resolve({ value, done, });

        }

        this._loaded += value.byteLength;

        if (this.onProgress) {

          this.onProgress({

            loaded: this._loaded,

            total: this._contentLength,

          });

        }

        let buffer = new Uint8Array(value).buffer;

        return Promise.resolve({ value: buffer, done: false, });

    });
","  async read() {

    await this._headersCapability.promise;

    const { value, done, } = await this._reader.read();

    if (done) {

      return { value, done, };

    }

    this._loaded += value.byteLength;

    if (this.onProgress) {

      this.onProgress({

        loaded: this._loaded,

        total: this._contentLength,

    }

    let buffer = new Uint8Array(value).buffer;

    return { value: buffer, done: false, };
","async read() {
  try {
    const value = await this._headersCapability.promise;

    return await this._reader.read().then(({ value, done }) => {
      if (done) {
        return Promise.resolve({ value, done });
      }

      this._loaded += value.byteLength;

      if (this.onProgress) {
        this.onProgress({
          loaded: this._loaded,
          total: this._contentLength,
        });
      }

      const buffer = new Uint8Array(value).buffer;

      return Promise.resolve({ value: buffer, done: false });
    });
  } catch (error) {
    console.log(error);
  }
}",0.5114500451668931,0.4856980109352951,0.48683075590358793,0.543859649122807,0.5294117647058824,0.6684389879192,0.5231686031046007,0.6500713527001659,0.9122807017543859,0.5882352941176471,0.49390145814894426,0.35739623756638106,0.47237626169606267,0.6458333333333334,0.5
103,"  read() {

    return this._readCapability.promise.then(() => {

      return this._reader.read().then(({ value, done, }) => {

        if (done) {

          return Promise.resolve({ value, done, });

        }

        this._loaded += value.byteLength;

        if (this.onProgress) {

          this.onProgress({ loaded: this._loaded, });

        }

        let buffer = new Uint8Array(value).buffer;

        return Promise.resolve({ value: buffer, done: false, });

      });

    });
","  async read() {

    await this._readCapability.promise;

    const { value, done, } = await this._reader.read();

    if (done) {

      return { value, done, };

    }

    this._loaded += value.byteLength;

    if (this.onProgress) {

      this.onProgress({ loaded: this._loaded, });

    }

    let buffer = new Uint8Array(value).buffer;

    return { value: buffer, done: false, };
","async read() {
  try {
    await this._readCapability.promise;
    let result = await this._reader.read();
    if (result.done) {
      return Promise.resolve({ value: result.value, done: true });
    } else {
      this._loaded += result.value.byteLength;
      if (this.onProgress) {
        this.onProgress({ loaded: this._loaded, });
      }
      let buffer = new Uint8Array(result.value).buffer;
      return Promise.resolve({ value: buffer, done: false });
    }
  } catch (err) {
    console.error(""Error reading file"", err);
  }
}",0.5672297497603214,0.5150330329119099,0.5166632081737341,0.5901639344262295,0.6470588235294118,0.409797078877163,0.3032719689262262,0.3899182752227343,0.47540983606557374,0.47058823529411764,0.48372331235310273,0.31835559896024535,0.4288946298571998,0.6086956521739131,0.5789473684210527
104,"  read() {

    return this._readCapability.promise.then(() => {

      if (this._done) {

        return Promise.resolve({ value: undefined, done: true, });

      }

      if (this._storedError) {

        return Promise.reject(this._storedError);

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({

          loaded: this._loaded,

          total: this._contentLength,

        });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return Promise.resolve({ value: buffer, done: false, });

    });
","  async read() {

    await this._readCapability.promise;

    if (this._done) {

      return { value: undefined, done: true, };

    }

    if (this._storedError) {

      throw this._storedError;

    }

    let chunk = this._readableStream.read();

    if (chunk === null) {

      this._readCapability = createPromiseCapability();

      return this.read();

    }

    this._loaded += chunk.length;

    if (this.onProgress) {

      this.onProgress({

        loaded: this._loaded,

        total: this._contentLength,

      });

    }

    // Ensure that `read()` method returns ArrayBuffer.

    let buffer = new Uint8Array(chunk).buffer;

    return { value: buffer, done: false, };
","async read() {
  try {
    await this._readCapability.promise;
  } catch (error) {
    if (!this._done && !this._storedError) {
      return Promise.reject(error);
    } else {
      return Promise.resolve({ value: undefined, done: true });
    }
  }
  const chunk = this._readableStream.read();
  if (chunk === null) {
    this._readCapability = createPromiseCapability();
    return await this.read();
  }
  this._loaded += chunk.length;
  if (this.onProgress) {
    this.onProgress({
      loaded: this._loaded,
      total: this._contentLength,
    });
  }
  const buffer = new Uint8Array(chunk).buffer;
  return Promise.resolve({ value: buffer, done: false });
}",0.6192615975875675,0.7349806249644687,0.7325806705348531,0.7317073170731707,0.2777777777777778,0.5670712549197434,0.5480607585628604,0.5508475673491753,0.7804878048780488,0.3888888888888889,0.6178293534169009,0.4824099112045441,0.49871142403168706,0.8235294117647058,0.6666666666666666
105,"  read() {

    return this._readCapability.promise.then(() => {

      if (this._done) {

        return Promise.resolve({ value: undefined, done: true, });

      }

      if (this._storedError) {

        return Promise.reject(this._storedError);

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({ loaded: this._loaded, });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return Promise.resolve({ value: buffer, done: false, });

    });
","  async read() {

    await this._readCapability.promise;

    if (this._done) {

      return { value: undefined, done: true, };

    }

    if (this._storedError) {

      throw this._storedError;

    }

    let chunk = this._readableStream.read();

    if (chunk === null) {

      this._readCapability = createPromiseCapability();

      return this.read();

    }

    this._loaded += chunk.length;

    if (this.onProgress) {

      this.onProgress({ loaded: this._loaded, });

    }

    // Ensure that `read()` method returns ArrayBuffer.

    let buffer = new Uint8Array(chunk).buffer;

    return { value: buffer, done: false, };
","async read() {

    try {

      let capability = await this._readCapability;

      if (this._done) {

        return { value: undefined, done: true };

      }

      if (this._storedError) {

        throw this._storedError;

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return await this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({ loaded: this._loaded });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return { value: buffer, done: false };

    } catch (err) {

      return Promise.reject(err);

    }

  }",0.6136115188155618,0.7268708111713782,0.7247974863130912,0.725,0.2777777777777778,0.5375032751576284,0.5407648999989738,0.643970422853762,0.6875,0.2777777777777778,0.7315988491298401,0.6747454599891256,0.8243772092575075,0.8939393939393939,0.5333333333333333
106,"function resolveCall(fn, args, thisArg = null) {

    return Promise.resolve(undefined);

  return new Promise((resolve, reject) => {

    resolve(fn.apply(thisArg, args));

  });
","async function resolveCall(fn, args, thisArg = null) {

    return;

  return fn.apply(thisArg, args);
","async function resolveCall(fn, args = [], thisArg = null) {
  return Promise.resolve(undefined);
}",0.37366561403046394,0.3233824575540097,0.3429971702850177,0.2727272727272727,0.5555555555555556,0.4664924596408649,0.29136673058142054,0.30187583525476624,0.2727272727272727,0.0,0.45070110385645834,0.2891784933232572,0.33180774028439425,0.18181818181818182,0.0
107,"  getLanguage() {

    return this._ready.then((l10n) => {

      return l10n.getLanguage();

    });

  getDirection() {

    return this._ready.then((l10n) => {

      return l10n.getDirection();

    });

  get(property, args, fallback) {

    return this._ready.then((l10n) => {

      return l10n.get(property, args, fallback);

    });

  translate(element) {

    return this._ready.then((l10n) => {

      return l10n.translate(element);

    });
","  async getLanguage() {

    const l10n = await this._ready;

    return l10n.getLanguage();

  async getDirection() {

    const l10n = await this._ready;

    return l10n.getDirection();

  async get(property, args, fallback) {

    const l10n = await this._ready;

    return l10n.get(property, args, fallback);

  async translate(element) {

    const l10n = await this._ready;

    return l10n.translate(element);
","async getLanguage() {
  try {
    const l10n = await this._ready;
    return l10n.getLanguage();
  } catch (error) {
    // Handle error
  }
}

async getDirection() {
  try {
    const l10n = await this._ready;
    return l10n.getDirection();
  } catch (error) {
    // Handle error
  }
}

async get(property, args, fallback) {
  try {
    const l10n = await this._ready;
    return l10n.get(property, args, fallback);
  } catch (error) {
    // Handle error
  }
}

async translate(element) {
  try {
    const l10n = await this._ready;
    return l10n.translate(element);
  } catch (error) {
    // Handle error
  }
}",0.340928007444943,0.1558069181645299,0.17200767571780617,0.36923076923076925,0.6666666666666666,0.3231493849096382,0.08010152663184639,0.17659857710927052,0.36923076923076925,0.6666666666666666,0.7746862994130076,0.394219993577828,0.8025644197604771,0.9019607843137255,1.0
108,"  register(name, element, callerCloseMethod = null, canForceClose = false) {

    return new Promise((resolve) => {

      let container;

      if (!name || !element || !(container = element.parentNode)) {

        throw new Error('Not enough parameters.');

      } else if (this._overlays[name]) {

        throw new Error('The overlay is already registered.');

      }

      this._overlays[name] = {

        element,

        container,

        callerCloseMethod,

        canForceClose,

      };

      resolve();

    });
","  async register(name, element, callerCloseMethod = null,

                 canForceClose = false) {

    let container;

    if (!name || !element || !(container = element.parentNode)) {

      throw new Error('Not enough parameters.');

    } else if (this._overlays[name]) {

      throw new Error('The overlay is already registered.');

    }

    this._overlays[name] = {

      element,

      container,

      callerCloseMethod,

      canForceClose,

    };
","register(name, element, callerCloseMethod = null, canForceClose = false) {

    return new Promise((resolve) => {

      let container;

      if (!name || !element || !(container = element.parentNode)) {

        throw new Error('Not enough parameters.');

      } else if (this._overlays[name]) {

        throw new Error('The overlay is already registered.');

      }

      this._overlays[name] = {

        element,

        container,

        callerCloseMethod,

        canForceClose,

      };

      resolve();

    });

  async function() {

    let container;

    if (!name || !element || !(container = element.parentNode)) {

      throw new Error('Not enough parameters.');

    } else if (this._overlays[name]) {

      throw new Error('The overlay is already registered.');

    }

    this._overlays[name] = {

      element,

      container,

      callerCloseMethod,

      canForceClose,

    };

    resolve();

  });

  ```

The migrated code uses `async/await` syntax instead of `Promise` chain. The first step is to identify the promise chains using `.then()` and `.catch()`, or `.finally()`. In this case, there are two promise chains: one for the `new Promise()` statement and another for the `throw new Error()` statements.

The next step is to replace the `.then()` callbacks with `await`. This involves assigning the resolved value of the promise to a variable using the `await` keyword. In this case, we assign the resolved value to the `container` variable.

After replacing the `.then()` and `.catch()` or `.finally()` calls with `await`, we wrap the logic in an `async function`. This allows us to use `await` within the function.

Finally, we implement error handling by replacing the `.catch()` method with a `try...catch` block. This enables us to handle potential errors and prevent them from propagating to the caller.",0.8146647168036628,0.8457336209798119,0.841653316410278,0.7291666666666666,0.8421052631578947,0.7937816821038459,0.21679339508205023,1.0,0.9583333333333334,1.0,0.7627749367915033,0.185025620468915,0.9660741266970981,0.9,1.0
109,"  unregister(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (this._active === name) {

        throw new Error('The overlay cannot be removed while it is active.');

      }

      delete this._overlays[name];

      resolve();

    });
","  async unregister(name) {

    if (!this._overlays[name]) {

      throw new Error('The overlay does not exist.');

    } else if (this._active === name) {

      throw new Error('The overlay cannot be removed while it is active.');

    }

    delete this._overlays[name];
","async function unregister(name) {
  try {
    if (!this._overlays[name]) {
      throw new Error('The overlay does not exist.');
    } else if (this._active === name) {
      throw new Error('The overlay cannot be removed while it is active.');
    }
    delete this._overlays[name];
  } catch (error) {
    console.log(error);
  } finally {
    return;
  }
}",0.7526191170154337,0.7989681330138033,0.8036135982058263,0.6578947368421053,0.75,0.790425058288329,0.6709801568488221,0.8065095499887044,0.6842105263157895,1.0,0.866155570385197,0.6709801568488221,0.9603087913586323,0.8333333333333334,1.0
110,"  open(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (this._active) {

        if (this._overlays[name].canForceClose) {

          this._closeThroughCaller();

        } else if (this._active === name) {

          throw new Error('The overlay is already active.');

        } else {

          throw new Error('Another overlay is currently active.');

        }

      this._active = name;

      this._overlays[this._active].element.classList.remove('hidden');

      this._overlays[this._active].container.classList.remove('hidden');

      window.addEventListener('keydown', this._keyDownBound);

      resolve();

    });
","  async open(name) {

    if (!this._overlays[name]) {

      throw new Error('The overlay does not exist.');

    } else if (this._active) {

      if (this._overlays[name].canForceClose) {

        this._closeThroughCaller();

      } else if (this._active === name) {

        throw new Error('The overlay is already active.');

      } else {

        throw new Error('Another overlay is currently active.');

    }

    this._active = name;

    this._overlays[this._active].element.classList.remove('hidden');

    this._overlays[this._active].container.classList.remove('hidden');

    window.addEventListener('keydown', this._keyDownBound);
","async open(name) {

  if (!this._overlays[name]) {

    throw new Error('The overlay does not exist.');

  } else if (this._active) {

    if (this._overlays[name].canForceClose) {

      this._closeThroughCaller();

    } else if (this._active === name) {

      throw new Error('The overlay is already active.');

    } else {

      throw new Error('Another overlay is currently active.');

    }

  this._active = name;

  this._overlays[this._active].element.classList.remove('hidden');

  this._overlays[this._active].container.classList.remove('hidden');

  window.addEventListener('keydown', this._keyDownBound);

  return;

}",0.82213094276149,0.8690516624282618,0.8694721086176979,0.85,0.7,0.8226265752286981,0.8710341922970944,0.8694721086176979,0.85,0.7,0.9677954350343312,0.9632870032952194,1.0,0.9078947368421053,1.0
111,"  close(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (!this._active) {

        throw new Error('The overlay is currently not active.');

      } else if (this._active !== name) {

        throw new Error('Another overlay is currently active.');

      }

      this._overlays[this._active].container.classList.add('hidden');

      this._overlays[this._active].element.classList.add('hidden');

      this._active = null;

      window.removeEventListener('keydown', this._keyDownBound);

      resolve();

    });
","  async close(name) {

    if (!this._overlays[name]) {

      throw new Error('The overlay does not exist.');

    } else if (!this._active) {

      throw new Error('The overlay is currently not active.');

    } else if (this._active !== name) {

      throw new Error('Another overlay is currently active.');

    }

    this._overlays[this._active].container.classList.add('hidden');

    this._overlays[this._active].element.classList.add('hidden');

    this._active = null;

    window.removeEventListener('keydown', this._keyDownBound);
","async function close(name) {
  if (!this._overlays[name]) {
    throw new Error('The overlay does not exist.');
  } else if (!this._active) {
    throw new Error('The overlay is currently not active.');
  } else if (this._active !== name) {
    throw new Error('Another overlay is currently active.');
  }

  this._overlays[this._active].container.classList.add('hidden');
  this._overlays[this._active].element.classList.add('hidden');
  this._active = null;
  window.removeEventListener('keydown', this._keyDownBound);
}",0.7886338811509583,0.8537486598957507,0.8538690564889043,0.821917808219178,0.625,0.7892462866186698,0.856198281766597,0.8538690564889043,0.821917808219178,0.625,0.9585997475565178,0.9430609669970194,0.9836457155367442,0.9076923076923077,1.0
112,"  _writeToStorage(prefObj) {

    return new Promise(function(resolve) {

      localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));

      resolve();

    });

  _readFromStorage(prefObj) {

    return new Promise(function(resolve) {

      let readPrefs = JSON.parse(localStorage.getItem('pdfjs.preferences'));

      resolve(readPrefs);

    });
","  async _writeToStorage(prefObj) {

    localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));

  async _readFromStorage(prefObj) {

    return JSON.parse(localStorage.getItem('pdfjs.preferences'));
","async function writeToStorage(prefObj) {
    try {
        await localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));
    } catch (error) {
        // Handle error
    }
}

async function readFromStorage() {
    let prefObj;
    try {
        prefObj = JSON.parse(localStorage.getItem('pdfjs.preferences'));
    } catch (error) {
        // Handle error
    }
    return prefObj;
}",0.24775205654596014,0.06011896349510332,0.07735390915338367,0.4090909090909091,0.4444444444444444,0.24666918208760383,0.019231042777837725,0.03562750375439575,0.4318181818181818,0.5,0.38987972580965297,0.013819585494830136,0.06421783626230033,0.5925925925925926,0.8888888888888888
113,"  reset() {

    return this._initializedPromise.then(() => {

      this.prefs = Object.assign(Object.create(null), this.defaults);

      return this._writeToStorage(this.defaults);

    });
","  async reset() {

    await this._initializedPromise;

    this.prefs = Object.assign(Object.create(null), this.defaults);

    return this._writeToStorage(this.defaults);
","async reset() {

     try {
       await this._initializedPromise;

       this.prefs = Object.assign(Object.create(null), this.defaults);

       return this._writeToStorage(this.defaults);

     } catch (error) {
       console.log('Error:', error.message);
     }
   }",0.6206946068835405,0.43297387492488815,0.42017492297964415,0.6296296296296297,1.0,0.5793653404989023,0.2591641360720012,0.4286675962939782,0.6296296296296297,1.0,0.8136274691179002,0.4378643946008864,0.9036020036098449,0.9130434782608695,1.0
114,"  set(name, value) {

    return this._initializedPromise.then(() => {

      if (this.defaults[name] === undefined) {

        throw new Error(`Set preference: ""${name}"" is undefined.`);

      } else if (value === undefined) {

        throw new Error('Set preference: no value is specified.');

      }

      let valueType = typeof value;

      let defaultType = typeof this.defaults[name];

      if (valueType !== defaultType) {

        if (valueType === 'number' && defaultType === 'string') {

          value = value.toString();

        } else {

          throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                          `expected a ${defaultType}.`);

        }

        if (valueType === 'number' && !Number.isInteger(value)) {

          throw new Error(`Set preference: ""${value}"" must be an integer.`);

        }

      this.prefs[name] = value;

      return this._writeToStorage(this.prefs);

    });
","  async set(name, value) {

    await this._initializedPromise;

    let defaultValue = this.defaults[name];

    if (defaultValue === undefined) {

      throw new Error(`Set preference: ""${name}"" is undefined.`);

    } else if (value === undefined) {

      throw new Error('Set preference: no value is specified.');

    }

    let valueType = typeof value;

    let defaultType = typeof defaultValue;



    if (valueType !== defaultType) {

      if (valueType === 'number' && defaultType === 'string') {

        value = value.toString();

        throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                        `expected a ${defaultType}.`);

    } else {

      if (valueType === 'number' && !Number.isInteger(value)) {

        throw new Error(`Set preference: ""${value}"" must be an integer.`);

      }

    }

    this.prefs[name] = value;

    return this._writeToStorage(this.prefs);
","async function set(name, value) {
    await this._initializedPromise;
    if (this.defaults[name] === undefined) {
      throw new Error(`Set preference: ""${name}"" is undefined.`);
    } else if (value === undefined) {
      throw new Error('Set preference: no value is specified.');
    }
    let valueType = typeof value;
    let defaultType = typeof this.defaults[name];
    if (valueType !== defaultType) {
      if (valueType === 'number' && defaultType === 'string') {
        value = value.toString();
      } else {
        throw new Error(
          `Set preference: ""${value}"" is a ${valueType}, expected a ${defaultType}.`
        );
      }
      if (valueType === 'number' && !Number.isInteger(value)) {
        throw new Error(`Set preference: ""${value}"" must be an integer.`);
      }
    }
    this.prefs[name] = value;
    return await this._writeToStorage(this.prefs);
  }
}",0.7962482679125819,0.8276745338301842,0.8452800145456647,0.797752808988764,0.7142857142857143,0.860362293249389,0.8072001124468962,0.8364962515618957,0.797752808988764,1.0,0.7487128656551136,0.7702187137368236,0.7826851833405601,0.7752808988764045,0.6666666666666666
115,"  get(name) {

    return this._initializedPromise.then(() => {

      let defaultValue = this.defaults[name];

      if (defaultValue === undefined) {

        throw new Error(`Get preference: ""${name}"" is undefined.`);

      } else {

        let prefValue = this.prefs[name];

        if (prefValue !== undefined) {

          return prefValue;

        }

      return defaultValue;

    });
","  async get(name) {

    await this._initializedPromise;

    let defaultValue = this.defaults[name];

    if (defaultValue === undefined) {

      throw new Error(`Get preference: ""${name}"" is undefined.`);

    } else {

      let prefValue = this.prefs[name];

      if (prefValue !== undefined) {

        return prefValue;

    }

    return defaultValue;
","get(name) {
  async function getPreference() {
    try {
      await this._initializedPromise;
      const defaultValue = this.defaults[name];
      if (defaultValue === undefined) {
        throw new Error(`Get preference: ""${name}"" is undefined.`);
      } else {
        const prefValue = this.prefs[name];
        return prefValue !== undefined ? prefValue : defaultValue;
      }
    } catch (err) {
      console.error(err);
      throw err;
    }
  }
  return getPreference();
}",0.8529978525024551,0.8371815764946097,0.8395157158681515,0.7352941176470589,1.0,0.49531632403645826,0.38142521102852595,0.5067028302153462,0.6764705882352942,0.4166666666666667,0.5079385242369049,0.40225329230338447,0.5657753144481568,0.6470588235294118,0.4166666666666667
116,"  getAll() {

    return this._initializedPromise.then(() => {

      return Object.assign(Object.create(null), this.defaults, this.prefs);

    });
","  async getAll() {

    await this._initializedPromise;

    return Object.assign(Object.create(null), this.defaults, this.prefs);
","getAll() {

  return this._initializedPromise.then(() => {
    return Object.assign(Object.create(null), this.defaults, this.prefs);
  });
}

async getAll() {

  try {
    await this._initializedPromise;
    const result = Object.assign(Object.create(null), this.defaults, this.prefs);
    return result;
  } catch (error) {
    console.log('Error in getAll:', error);
  }
}",0.5211413249108231,0.2842202242491899,0.2765355515845788,0.5238095238095238,1.0,0.7926578481322546,0.26586948776711355,1.0,0.9047619047619048,1.0,0.63114349952138,0.112289032173749,0.537284965911771,0.875,1.0
117,"  _writeToStorage() {

    return new Promise((resolve) => {

      let databaseStr = JSON.stringify(this.database);

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        sessionStorage.setItem('pdfjs.history', databaseStr);

      } else {

        localStorage.setItem('pdfjs.history', databaseStr);

      }

      resolve();

    });

  _readFromStorage() {

    return new Promise(function(resolve) {

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        resolve(sessionStorage.getItem('pdfjs.history'));

      } else {

        resolve(localStorage.getItem('pdfjs.history'));

      }

    });

  set(name, val) {

    return this._initializedPromise.then(() => {

      this.file[name] = val;

      return this._writeToStorage();

    });

  setMultiple(properties) {

    return this._initializedPromise.then(() => {

      for (let name in properties) {

        this.file[name] = properties[name];

      }

      return this._writeToStorage();

    });

  get(name, defaultValue) {

    return this._initializedPromise.then(() => {

      let val = this.file[name];

      return val !== undefined ? val : defaultValue;

    });

  getMultiple(properties) {

    return this._initializedPromise.then(() => {

      let values = Object.create(null);

      for (let name in properties) {

        let val = this.file[name];

        values[name] = val !== undefined ? val : properties[name];

      }

      return values;

    });
","  async _writeToStorage() {

    let databaseStr = JSON.stringify(this.database);

    if (typeof PDFJSDev !== 'undefined' &&

        PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

      sessionStorage.setItem('pdfjs.history', databaseStr);

      return;

    }

    localStorage.setItem('pdfjs.history', databaseStr);

  async _readFromStorage() {

    if (typeof PDFJSDev !== 'undefined' &&

        PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

      return sessionStorage.getItem('pdfjs.history');

    }

    return localStorage.getItem('pdfjs.history');

  async set(name, val) {

    await this._initializedPromise;

    this.file[name] = val;

    return this._writeToStorage();

  async setMultiple(properties) {

    await this._initializedPromise;

    for (let name in properties) {

      this.file[name] = properties[name];

    }

    return this._writeToStorage();

  async get(name, defaultValue) {

    await this._initializedPromise;

    let val = this.file[name];

    return val !== undefined ? val : defaultValue;

  async getMultiple(properties) {

    await this._initializedPromise;

    let values = Object.create(null);

    for (let name in properties) {

      let val = this.file[name];

      values[name] = val !== undefined ? val : properties[name];

    }

    return values;
","_writeToStorage() {

    return new Promise(async (resolve) => {

      let databaseStr = JSON.stringify(this.database);

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        sessionStorage.setItem('pdfjs.history', databaseStr);

      } else {

        localStorage.setItem('pdfjs.history', databaseStr);

      }

      resolve();

    });

  _readFromStorage() {

    return new Promise(async (resolve) => {

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        resolve(sessionStorage.getItem('pdfjs.history'));

      } else {

        resolve(localStorage.getItem('pdfjs.history'));

      }

    });

  set(name, val) {

    return this._initializedPromise.then(() => {

      this.file[name] = val;

      return this._writeToStorage();

    });

  setMultiple(properties) {

    return this._initializedPromise.then(() => {

      for (let name in properties) {

        this.file[name] = properties[name];

      }

      return this._writeToStorage();

    });

  get(name, defaultValue) {

    return this._initializedPromise.then(() => {

      let val = this.file[name];

      return val !== undefined ? val : defaultValue;

    });

  getMultiple(properties) {

    return this._initializedPromise.then(() => {

      let values = Object.create(null);

      for (let name in properties) {

        let val = this.file[name];

        values[name] = val !== undefined ? val : properties[name];

      }

      return values;

    });",0.5782359520010818,0.5773292884258467,0.5794397000115196,0.5872093023255814,0.5689655172413793,0.9667207113253895,0.9427880832862559,0.964792436433907,0.9593023255813954,1.0,0.6420559494956575,0.5719481209846546,0.6851854514340655,0.7218045112781954,0.5892857142857143
118,"    return this.preferences.getAll().then(function(prefs) {

    }, function(reason) { });

  _parseHashParameters() {

    if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION') ||

        AppOptions.get('pdfBugEnabled')) {

      // Special debugging flags in the hash section of the URL.

      let hash = document.location.hash.substring(1);

      let hashParams = parseQueryString(hash);

      if ('disableworker' in hashParams &&

          hashParams['disableworker'] === 'true') {

        waitOn.push(loadFakeWorker());

      }

      if ('disablerange' in hashParams) {

        AppOptions.set('disableRange', hashParams['disablerange'] === 'true');

      }

      if ('disablestream' in hashParams) {

        AppOptions.set('disableStream', hashParams['disablestream'] === 'true');

      }

      if ('disableautofetch' in hashParams) {

        AppOptions.set('disableAutoFetch',

                       hashParams['disableautofetch'] === 'true');

      }

      if ('disablefontface' in hashParams) {

        AppOptions.set('disableFontFace',

                       hashParams['disablefontface'] === 'true');

      }

      if ('disablehistory' in hashParams) {

        AppOptions.set('disableHistory',

                       hashParams['disablehistory'] === 'true');

      }

      if ('webgl' in hashParams) {

        AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');

      }

      if ('useonlycsszoom' in hashParams) {

        AppOptions.set('useOnlyCssZoom',

                       hashParams['useonlycsszoom'] === 'true');

      }

      if ('verbosity' in hashParams) {

        AppOptions.set('verbosity', hashParams['verbosity'] | 0);

      }

      if ((typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) &&

          hashParams['disablebcmaps'] === 'true') {

        AppOptions.set('cMapUrl', '../external/cmaps/');

        AppOptions.set('cMapPacked', false);

      }

      if ('textlayer' in hashParams) {

        switch (hashParams['textlayer']) {

          case 'off':

            AppOptions.set('textLayerMode', TextLayerMode.DISABLE);

            break;

          case 'visible':

          case 'shadow':

          case 'hover':

            let viewer = this.appConfig.viewerContainer;

            viewer.classList.add('textLayer-' + hashParams['textlayer']);

            break;

        }

      }

      if ('pdfbug' in hashParams) {

        AppOptions.set('pdfBug', true);

        let enabled = hashParams['pdfbug'].split(',');

        waitOn.push(loadAndEnablePDFBug(enabled));

      }

      // It is not possible to change locale for the (various) extension builds.

      if ((typeof PDFJSDev === 'undefined' ||

           PDFJSDev.test('!PRODUCTION || GENERIC')) && 'locale' in hashParams) {

        AppOptions.set('locale', hashParams['locale']);
","    try {

      const prefs = await this.preferences.getAll();

    } catch (reason) { }

  async _parseHashParameters() {

    if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('PRODUCTION') &&

        !AppOptions.get('pdfBugEnabled')) {

      return;

    }

    // Special debugging flags in the hash section of the URL.

    let hash = document.location.hash.substring(1);

    let hashParams = parseQueryString(hash);

    if ('disableworker' in hashParams &&

        hashParams['disableworker'] === 'true') {

      waitOn.push(loadFakeWorker());

    }

    if ('disablerange' in hashParams) {

      AppOptions.set('disableRange', hashParams['disablerange'] === 'true');

    }

    if ('disablestream' in hashParams) {

      AppOptions.set('disableStream', hashParams['disablestream'] === 'true');

    }

    if ('disableautofetch' in hashParams) {

      AppOptions.set('disableAutoFetch',

                     hashParams['disableautofetch'] === 'true');

    }

    if ('disablefontface' in hashParams) {

      AppOptions.set('disableFontFace',

                     hashParams['disablefontface'] === 'true');

    }

    if ('disablehistory' in hashParams) {

      AppOptions.set('disableHistory', hashParams['disablehistory'] === 'true');

    }

    if ('webgl' in hashParams) {

      AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');

    }

    if ('useonlycsszoom' in hashParams) {

      AppOptions.set('useOnlyCssZoom', hashParams['useonlycsszoom'] === 'true');

    }

    if ('verbosity' in hashParams) {

      AppOptions.set('verbosity', hashParams['verbosity'] | 0);

    }

    if ((typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) &&

        hashParams['disablebcmaps'] === 'true') {

      AppOptions.set('cMapUrl', '../external/cmaps/');

      AppOptions.set('cMapPacked', false);

    }

    if ('textlayer' in hashParams) {

      switch (hashParams['textlayer']) {

        case 'off':

          AppOptions.set('textLayerMode', TextLayerMode.DISABLE);

          break;

        case 'visible':

        case 'shadow':

        case 'hover':

          let viewer = this.appConfig.viewerContainer;

          viewer.classList.add('textLayer-' + hashParams['textlayer']);

          break;

    if ('pdfbug' in hashParams) {

      AppOptions.set('pdfBug', true);

      let enabled = hashParams['pdfbug'].split(',');

      waitOn.push(loadAndEnablePDFBug(enabled));

    }

    // It is not possible to change locale for the (various) extension builds.

    if ((typeof PDFJSDev === 'undefined' ||

         PDFJSDev.test('!PRODUCTION || GENERIC')) && 'locale' in hashParams) {

      AppOptions.set('locale', hashParams['locale']);

    }
","async function _parseHashParameters() {
    try {
        const prefs = await this.preferences.getAll();
        if (typeof PDFJSDev !== 'undefined' && !PDFJSDev.test('PRODUCTION') && AppOptions.get('pdfBugEnabled')) {
            let hash = document.location.hash.substring(1);
            let hashParams = parseQueryString(hash);
            if ('disableworker' in hashParams && hashParams['disableworker'] === 'true') {
                await loadFakeWorker();
            }
            if ('disablerange' in hashParams) {
                AppOptions.set('disableRange', hashParams['disablerange'] === 'true');
            }
            if ('disablestream' in hashParams) {
                AppOptions.set('disableStream', hashParams['disablestream'] === 'true');
            }
            if ('disableautofetch' in hashParams) {
                AppOptions.set('disableAutoFetch', hashParams['disableautofetch'] === 'true');
            }
            if ('disablefontface' in hashParams) {
                AppOptions.set('disableFontFace', hashParams['disablefontface'] === 'true');
            }
            if ('disablehistory' in hashParams) {
                AppOptions.set('disableHistory', hashParams['disablehistory'] === 'true');
            }
            if ('webgl' in hashParams) {
                AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');
            }
            if ('useonlycsszoom' in hashParams) {
                AppOptions.set('useOnlyCssZoom', hashParams['useonlycsszoom'] === 'true');
            }
            if ('verbosity' in hashParams) {
                AppOptions.set('verbosity', hashParams['verbosity'] | 0);
            }
            if ((typeof PDFJSDev !== 'undefined' || !PDFJSDev.test('PRODUCTION')) && hashParams['disablebcmaps'] === 'true') {
                AppOptions.set('cMapUrl', '../external/cmaps/');
                AppOptions.set('cMapPacked', false);
            }
            if ('textlayer' in hashParams) {
                switch (hashParams['textlayer']) {
                    case 'off':
                        AppOptions.set('textLayerMode', TextLayerMode.DISABLE);
                        break;
                    case 'visible':
                    case 'shadow':
                    case 'hover':
                        let viewer = this.appConfig.viewerContainer;
                        viewer.classList.add('textLayer-' + hashParams['textlayer']);
                        break;
                }
            }
            if ('pdfbug' in hashParams) {
                AppOptions.set('pdfBug', true);
                let enabled = hashParams['pdfbug'].split(',');
                await loadAndEnablePDFBug(enabled);
            }
            // It is not possible to change locale for the (various) extension builds.
        }
    } catch (e) {
        console.error('Error parsing hash parameters:', e);
    }
}",0.728842526209657,0.8895457960525981,0.9203950158567371,0.9236111111111112,0.18181818181818182,0.6490991591140712,0.770650170821723,0.777135354523451,0.8819444444444444,0.16666666666666666,0.8174984422920988,0.7687692938901863,0.7780824875532099,0.8825622775800712,0.8405797101449275
119,"  _initializeL10n() {

    return this.l10n.getDirection().then((dir) => {

      document.getElementsByTagName('html')[0].dir = dir;

    });

  _initializeViewerComponents() {

    let { appConfig, } = this;



    return new Promise((resolve, reject) => {

      this.overlayManager = new OverlayManager();



      const dispatchToDOM = AppOptions.get('eventBusDispatchToDOM');

      let eventBus = appConfig.eventBus || getGlobalEventBus(dispatchToDOM);

      this.eventBus = eventBus;

      let pdfRenderingQueue = new PDFRenderingQueue();

      pdfRenderingQueue.onIdle = this.cleanup.bind(this);

      this.pdfRenderingQueue = pdfRenderingQueue;

      let pdfLinkService = new PDFLinkService({

        eventBus,

        externalLinkTarget: AppOptions.get('externalLinkTarget'),

        externalLinkRel: AppOptions.get('externalLinkRel'),

      });

      this.pdfLinkService = pdfLinkService;

      let downloadManager = this.externalServices.createDownloadManager({

        disableCreateObjectURL: AppOptions.get('disableCreateObjectURL'),

      });

      this.downloadManager = downloadManager;

      let container = appConfig.mainContainer;

      let viewer = appConfig.viewerContainer;

      this.pdfViewer = new PDFViewer({

        container,

        viewer,

        eventBus,

        renderingQueue: pdfRenderingQueue,

        linkService: pdfLinkService,

        downloadManager,

        renderer: AppOptions.get('renderer'),

        enableWebGL: AppOptions.get('enableWebGL'),

        l10n: this.l10n,

        textLayerMode: AppOptions.get('textLayerMode'),

        imageResourcesPath: AppOptions.get('imageResourcesPath'),

        renderInteractiveForms: AppOptions.get('renderInteractiveForms'),

        enablePrintAutoRotate: AppOptions.get('enablePrintAutoRotate'),

        useOnlyCssZoom: AppOptions.get('useOnlyCssZoom'),

        maxCanvasPixels: AppOptions.get('maxCanvasPixels'),

      });

      pdfRenderingQueue.setViewer(this.pdfViewer);

      pdfLinkService.setViewer(this.pdfViewer);



      let thumbnailContainer = appConfig.sidebar.thumbnailView;

      this.pdfThumbnailViewer = new PDFThumbnailViewer({

        container: thumbnailContainer,

        renderingQueue: pdfRenderingQueue,

        linkService: pdfLinkService,

        l10n: this.l10n,

      });

      pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);



      this.pdfHistory = new PDFHistory({

        linkService: pdfLinkService,

        eventBus,

      });

      pdfLinkService.setHistory(this.pdfHistory);

      this.findController = new PDFFindController({

        pdfViewer: this.pdfViewer,

        eventBus,

      });

      this.findController.onUpdateResultsCount = (matchCount) => {

        if (this.supportsIntegratedFind) {

          return;

        }

        this.findBar.updateResultsCount(matchCount);

      };

      this.findController.onUpdateState = (state, previous, matchCount) => {

        if (this.supportsIntegratedFind) {

          this.externalServices.updateFindControlState({

            result: state,

            findPrevious: previous,

          });

        } else {

          this.findBar.updateUIState(state, previous, matchCount);

        }

      };

      this.pdfViewer.setFindController(this.findController);

      // TODO: improve `PDFFindBar` constructor parameter passing

      let findBarConfig = Object.create(appConfig.findBar);

      findBarConfig.findController = this.findController;

      findBarConfig.eventBus = eventBus;

      this.findBar = new PDFFindBar(findBarConfig, this.l10n);

      this.pdfDocumentProperties =

        new PDFDocumentProperties(appConfig.documentProperties,

                                  this.overlayManager, eventBus, this.l10n);

      this.pdfCursorTools = new PDFCursorTools({

        container,

        eventBus,

        cursorToolOnLoad: AppOptions.get('cursorToolOnLoad'),

      });

      this.toolbar = new Toolbar(appConfig.toolbar, container, eventBus,

                                 this.l10n);

      this.secondaryToolbar =

        new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

      if (this.supportsFullscreen) {

        this.pdfPresentationMode = new PDFPresentationMode({

          container,

          viewer,

          pdfViewer: this.pdfViewer,

          eventBus,

          contextMenuItems: appConfig.fullscreen,

        });

      }

      this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay,

                                               this.overlayManager, this.l10n);

      this.pdfOutlineViewer = new PDFOutlineViewer({

        container: appConfig.sidebar.outlineView,

        linkService: pdfLinkService,

      this.pdfAttachmentViewer = new PDFAttachmentViewer({

        container: appConfig.sidebar.attachmentsView,

        eventBus,

        downloadManager,

      });

      // TODO: improve `PDFSidebar` constructor parameter passing

      let sidebarConfig = Object.create(appConfig.sidebar);

      sidebarConfig.pdfViewer = this.pdfViewer;

      sidebarConfig.pdfThumbnailViewer = this.pdfThumbnailViewer;

      sidebarConfig.pdfOutlineViewer = this.pdfOutlineViewer;

      sidebarConfig.eventBus = eventBus;

      this.pdfSidebar = new PDFSidebar(sidebarConfig, this.l10n);

      this.pdfSidebar.onToggled = this.forceRendering.bind(this);



      this.pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer,

                                                     eventBus, this.l10n);

      resolve(undefined);
","  async _initializeL10n() {

    const dir = await this.l10n.getDirection();

    document.getElementsByTagName('html')[0].dir = dir;

  async _initializeViewerComponents() {

    const appConfig = this.appConfig;

    this.overlayManager = new OverlayManager();

    const dispatchToDOM = AppOptions.get('eventBusDispatchToDOM');

    let eventBus = appConfig.eventBus || getGlobalEventBus(dispatchToDOM);

    this.eventBus = eventBus;

    let pdfRenderingQueue = new PDFRenderingQueue();

    pdfRenderingQueue.onIdle = this.cleanup.bind(this);

    this.pdfRenderingQueue = pdfRenderingQueue;

    let pdfLinkService = new PDFLinkService({

      eventBus,

      externalLinkTarget: AppOptions.get('externalLinkTarget'),

      externalLinkRel: AppOptions.get('externalLinkRel'),

    });

    this.pdfLinkService = pdfLinkService;

    let downloadManager = this.externalServices.createDownloadManager({

      disableCreateObjectURL: AppOptions.get('disableCreateObjectURL'),

    });

    this.downloadManager = downloadManager;



    let container = appConfig.mainContainer;

    let viewer = appConfig.viewerContainer;

    this.pdfViewer = new PDFViewer({

      container,

      viewer,

      eventBus,

      renderingQueue: pdfRenderingQueue,

      linkService: pdfLinkService,

      downloadManager,

      renderer: AppOptions.get('renderer'),

      enableWebGL: AppOptions.get('enableWebGL'),

      l10n: this.l10n,

      textLayerMode: AppOptions.get('textLayerMode'),

      imageResourcesPath: AppOptions.get('imageResourcesPath'),

      renderInteractiveForms: AppOptions.get('renderInteractiveForms'),

      enablePrintAutoRotate: AppOptions.get('enablePrintAutoRotate'),

      useOnlyCssZoom: AppOptions.get('useOnlyCssZoom'),

      maxCanvasPixels: AppOptions.get('maxCanvasPixels'),

    });

    pdfRenderingQueue.setViewer(this.pdfViewer);

    pdfLinkService.setViewer(this.pdfViewer);



    let thumbnailContainer = appConfig.sidebar.thumbnailView;

    this.pdfThumbnailViewer = new PDFThumbnailViewer({

      container: thumbnailContainer,

      renderingQueue: pdfRenderingQueue,

      linkService: pdfLinkService,

      l10n: this.l10n,

    });

    pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);

    this.pdfHistory = new PDFHistory({

      linkService: pdfLinkService,

      eventBus,

    });

    pdfLinkService.setHistory(this.pdfHistory);

    this.findController = new PDFFindController({

      pdfViewer: this.pdfViewer,

      eventBus,

    });

    this.findController.onUpdateResultsCount = (matchCount) => {

      if (this.supportsIntegratedFind) {

        return;

      }

      this.findBar.updateResultsCount(matchCount);

    };

    this.findController.onUpdateState = (state, previous, matchCount) => {

      if (this.supportsIntegratedFind) {

        this.externalServices.updateFindControlState({

          result: state,

          findPrevious: previous,

        });

      } else {

        this.findBar.updateUIState(state, previous, matchCount);

      }

    };

    this.pdfViewer.setFindController(this.findController);

    // TODO: improve `PDFFindBar` constructor parameter passing

    let findBarConfig = Object.create(appConfig.findBar);

    findBarConfig.findController = this.findController;

    findBarConfig.eventBus = eventBus;

    this.findBar = new PDFFindBar(findBarConfig, this.l10n);

    this.pdfDocumentProperties =

      new PDFDocumentProperties(appConfig.documentProperties,

                                this.overlayManager, eventBus, this.l10n);

    this.pdfCursorTools = new PDFCursorTools({

      container,

      eventBus,

      cursorToolOnLoad: AppOptions.get('cursorToolOnLoad'),

    });

    this.toolbar = new Toolbar(appConfig.toolbar, container, eventBus,

                               this.l10n);

    this.secondaryToolbar =

      new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

    if (this.supportsFullscreen) {

      this.pdfPresentationMode = new PDFPresentationMode({

        container,

        viewer,

        pdfViewer: this.pdfViewer,

        contextMenuItems: appConfig.fullscreen,

    }

    this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay,

                                             this.overlayManager, this.l10n);



    this.pdfOutlineViewer = new PDFOutlineViewer({

      container: appConfig.sidebar.outlineView,

      eventBus,

      linkService: pdfLinkService,

    });

    this.pdfAttachmentViewer = new PDFAttachmentViewer({

      container: appConfig.sidebar.attachmentsView,

      eventBus,

      downloadManager,



    // TODO: improve `PDFSidebar` constructor parameter passing

    let sidebarConfig = Object.create(appConfig.sidebar);

    sidebarConfig.pdfViewer = this.pdfViewer;

    sidebarConfig.pdfThumbnailViewer = this.pdfThumbnailViewer;

    sidebarConfig.pdfOutlineViewer = this.pdfOutlineViewer;

    sidebarConfig.eventBus = eventBus;

    this.pdfSidebar = new PDFSidebar(sidebarConfig, this.l10n);

    this.pdfSidebar.onToggled = this.forceRendering.bind(this);



    this.pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer,

                                                   eventBus, this.l10n);
","_initializeL10n() {

return this.l10n.getDirection().then((dir) => {

document.getElementsByTagName('html')[0].dir = dir;

});

}

_initializeViewerComponents() {

let { appConfig, } = this;

return new Promise((resolve, reject) => {

this.overlayManager = new OverlayManager();

const dispatchToDOM = AppOptions.get('eventBusDispatchToDOM');

let eventBus = appConfig.eventBus || getGlobalEventBus(dispatchToDOM);

this.eventBus = eventBus;

let pdfRenderingQueue = new PDFRenderingQueue();

pdfRenderingQueue.onIdle = this.cleanup.bind(this);

this.pdfRenderingQueue = pdfRenderingQueue;

let pdfLinkService = new PDFLinkService({

eventBus,

externalLinkTarget: AppOptions.get('externalLinkTarget'),

externalLinkRel: AppOptions.get('externalLinkRel'),

});

this.pdfLinkService = pdfLinkService;

let downloadManager = this.externalServices.createDownloadManager({

disableCreateObjectURL: AppOptions.get('disableCreateObjectURL'),

});

this.downloadManager = downloadManager;

let container = appConfig.mainContainer;

let viewer = appConfig.viewerContainer;

this.pdfViewer = new PDFViewer({

container,

viewer,

eventBus,

renderingQueue: pdfRenderingQueue,

linkService: pdfLinkService,

downloadManager,

renderer: AppOptions.get('renderer'),

enableWebGL: AppOptions.get('enableWebGL'),

l10n: this.l10n,

textLayerMode: AppOptions.get('textLayerMode'),

imageResourcesPath: AppOptions.get('imageResourcesPath'),

renderInteractiveForms: AppOptions.get('renderInteractiveForms'),

enablePrintAutoRotate: AppOptions.get('enablePrintAutoRotate'),

useOnlyCssZoom: AppOptions.get('useOnlyCssZoom'),

maxCanvasPixels: AppOptions.get('maxCanvasPixels'),

});

pdfRenderingQueue.setViewer(this.pdfViewer);

pdfLinkService.setViewer(this.pdfViewer);

let thumbnailContainer = appConfig.sidebar.thumbnailView;

this.pdfThumbnailViewer = new PDFThumbnailViewer({

container: thumbnailContainer,

renderingQueue: pdfRenderingQueue,

linkService: pdfLinkService,

l10n: this.l10n,

});

pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);

let pdfHistory = new PDFHistory({

linkService: pdfLinkService,

eventBus,

});

pdfLinkService.setHistory(pdfHistory);

this.findController = new PDFFindController({

pdfViewer: this.pdfViewer,

eventBus,

});

this.findController.onUpdateResultsCount = (matchCount) => {

if (this.supportsIntegratedFind) {

return;

}

this.findBar.updateResultsCount(matchCount);

};

this.findController.onUpdateState = (state, previous, matchCount) => {

if (this.supportsIntegratedFind) {

this.externalServices.updateFindControlState({

result: state,

findPrevious: previous,

});

} else {

this.findBar.updateUIState(state, previous, matchCount);

}

};

this.pdfViewer.setFindController(this.findController);

// TODO: improve `PDFFindBar` constructor parameter passing

let findBarConfig = Object.create(appConfig.findBar);

findBarConfig.findController = this.findController;

findBarConfig.eventBus = eventBus;

this.findBar = new PDFFindBar(findBarConfig, this.l10n);

this.pdfDocumentProperties =

new PDFDocumentProperties(appConfig.documentProperties,

this.overlayManager, eventBus, this.l10n);

this.pdfCursorTools = new PDFCursorTools({

container,

eventBus,

cursorToolOnLoad: AppOptions.get('cursorToolOnLoad'),

});

this.toolbar = new Toolbar(appConfig.toolbar, container, eventBus, this.l10n);

this.secondaryToolbar =

new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

if (this.supportsFullscreen) {

this.pdfPresentationMode = new PDFPresentationMode({

container,

viewer,

pdfViewer: this.pdfViewer,

eventBus,

contextMenuItems: appConfig.fullscreen,

});

}

this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay,

this.overlayManager, this.l10n);

this.pdfOutlineViewer = new PDFOutlineViewer({

container: appConfig.sidebar.outlineView,

linkService: pdfLinkService,

});

this.pdfAttachmentViewer = new PDFAttachmentViewer({

container: appConfig.sidebar.attachmentsView,

eventBus,

downloadManager,

});

// TODO: improve `PDFSidebar` constructor parameter passing

let sidebarConfig = Object.create(appConfig.sidebar);

sidebarConfig.pdfViewer = this.pdfViewer;

sidebarConfig.pdfThumbnailViewer = this.pdfThumbnailViewer;

sidebarConfig.pdfOutlineViewer = this.pdfOutlineViewer;

sidebarConfig.eventBus = eventBus;

this.pdfSidebar = new PDFSidebar(sidebarConfig, this.l10n);

this.pdfSidebar.onToggled = this.forceRendering.bind(this);

let pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);

resolve(undefined);

});

}",0.7521876162350292,0.9002311003223106,0.8963389134899866,0.9114285714285715,0.3007518796992481,0.9414353593683618,0.9484542860854723,0.9672119634180498,0.9628571428571429,0.8872180451127819,0.7304250002585477,0.8662323389950947,0.9024373590087935,0.8863636363636364,0.26666666666666666
120,"  open(file, args) {

      return this.close().then(() => {

        // ... and repeat the open() call.

        return this.open(file, args);

      });
","  async open(file, args) {

      await this.close();
","async open(file, args) {
    try {
      await this.close();
      return this.open(file, args);
    } catch (error) {
      // handle error
    }
  }",0.3479753896780583,0.02734470381093783,0.04876738121708476,0.3157894736842105,0.0,0.40381436756156547,0.09107438368292145,0.10313045498439308,0.42105263157894735,1.0,0.6730210288765848,0.16679551613797314,0.7071067811865475,0.8181818181818182,0.0
121,"        return {

          hash,

          rotation,

          sidebarView,

          scrollMode,

          spreadMode,

        };

      }).then(({ hash, rotation, sidebarView, scrollMode, spreadMode, }) => {

        initialParams.bookmark = this.initialBookmark;

        initialParams.hash = hash;



        return Promise.race([

      }).then(() => {

        // For documents with different page sizes, once all pages are resolved,

        // ensure that the correct location becomes visible on load.

        // To reduce the risk, in very large and/or slow loading documents,

        // that the location changes *after* the user has started interacting

        // with the viewer, wait for either `pagesPromise` or a timeout above.



        if (!initialParams.bookmark && !initialParams.hash) {

        this.initialBookmark = initialParams.bookmark;

        this.setInitialView(initialParams.hash);
","        // For documents with different page sizes, once all pages are resolved,

        // ensure that the correct location becomes visible on load.

        // (To reduce the risk, in very large and/or slow loading documents,

        //  that the location changes *after* the user has started interacting

        //  with the viewer, wait for either `pagesPromise` or a timeout.)

        await Promise.race([

        if (!initialBookmark && !hash) {

        this.initialBookmark = initialBookmark;

        // Re-apply the initial document location.

        this.setInitialView(hash);
","async () => {
  const { hash, rotation, sidebarView, scrollMode, spreadMode } = await Promise.resolve({
    hash: undefined,
    rotation: undefined,
    sidebarView: undefined,
    scrollMode: undefined,
    spreadMode: undefined,
  }).then(({ hash, rotation, sidebarView, scrollMode, spreadMode }) => {
    const initialParams = {
      bookmark: this.initialBookmark,
      hash: hash,
    };

    return Promise.race([initialParams.bookmark, initialParams.hash]).then(() => {
      if (!initialParams.bookmark && !initialParams.hash) {
        this.initialBookmark = initialParams.bookmark;
        this.setInitialView(initialParams.hash);
      }
    });
  });

  return { hash, rotation, sidebarView, scrollMode, spreadMode };
}",0.4480329230255564,0.5567396352258249,0.5776380461812135,0.29411764705882354,0.36363636363636365,0.40675111923871754,0.18139726129498498,0.1942703172641633,0.7058823529411765,0.5454545454545454,0.20474681976082795,0.014634390329521886,0.016852888713789944,0.1875,0.6
122,"    function renderPDF(filename) {

      var loadingTask = getDocument(filename);

      return loadingTask.promise

        .then(function(pdf) {

          pdfDocuments.push(pdf);

          return pdf.getPage(1);

        }).then(function(page) {

          var viewport = page.getViewport(1.2);

          var canvasAndCtx = CanvasFactory.create(viewport.width,

                                                  viewport.height);

          return page.render({

            canvasContext: canvasAndCtx.context,

            viewport,

          }).then(function() {

            var data = canvasAndCtx.canvas.toDataURL();

            CanvasFactory.destroy(canvasAndCtx);

            return data;

          });

        });
","    async function renderPDF(filename) {

      const loadingTask = getDocument(filename);

      const pdf = await loadingTask.promise;

      pdfDocuments.push(pdf);

      const page = await pdf.getPage(1);

      const viewport = page.getViewport(1.2);

      const canvasAndCtx = CanvasFactory.create(viewport.width,

                                                viewport.height);

      const renderTask = page.render({

        canvasContext: canvasAndCtx.context,

        viewport,

      });

      await renderTask.promise;

      const data = canvasAndCtx.canvas.toDataURL();

      CanvasFactory.destroy(canvasAndCtx);

      return data;
","async function renderPDF(filename) {
  try {
    const pdf = await getDocument(filename);
    pdfDocuments.push(pdf);
    const page = await pdf.getPage(1);
    const viewport = page.getViewport(1.2);
    const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);
    await page.render({
      canvasContext: canvasAndCtx.context,
      viewport,
    });
    const data = canvasAndCtx.canvas.toDataURL();
    CanvasFactory.destroy(canvasAndCtx);
    return data;
  } catch (error) {
    console.log('Error:', error);
  }
}",0.446992102599444,0.28714450230256167,0.28888360958775156,0.6119402985074627,0.6,0.3919961877670234,0.26225636471885205,0.27538012764277386,0.5970149253731343,0.43333333333333335,0.5816618944918686,0.6049968808502284,0.6339313988716314,0.7719298245614035,0.3157894736842105
123,"    },

    _scheduleNext: function InternalRenderTask__scheduleNext() {

      if (this.useRequestAnimationFrame && typeof window !== 'undefined') {

    },

    _next: function InternalRenderTask__next() {

      return new Promise(() => {

        if (this.cancelled) {

          return;

        }

        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,

                                          this.operatorListIdx,

                                          this._continueBound,

                                          this.stepper);

        if (this.operatorListIdx === this.operatorList.argsArray.length) {

          this.running = false;

          if (this.operatorList.lastChunk) {

            this.gfx.endDrawing();

            if (this._canvas) {

              canvasInRendering.delete(this._canvas);

            }

            this.callback();

      });

    },



  };


","    }

    _scheduleNext() {

      if (this._useRequestAnimationFrame) {

    }

    async _next() {

      if (this.cancelled) {

        return;

      }

      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,

                                                          this.operatorListIdx,

                                                          this._continueBound,

                                                          this.stepper);

      if (this.operatorListIdx === this.operatorList.argsArray.length) {

        this.running = false;

        if (this.operatorList.lastChunk) {

          this.gfx.endDrawing();

          if (this._canvas) {

            canvasInRendering.delete(this._canvas);

          this.callback();

      }

    }

  }
","async function InternalRenderTask__scheduleNext() {
  if (this.useRequestAnimationFrame && typeof window !== 'undefined') {
    // Add await here to wait for the promise to resolve
    const result = await new Promise(() => {
      if (this.cancelled) return;
      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
      if (this.operatorListIdx === this.operatorList.argsArray.length) {
        this.running = false;
        if (this.operatorList.lastChunk) {
          this.gfx.endDrawing();
          if (this._canvas) {
            canvasInRendering.delete(this._canvas);
          }
          this.callback();
      });
    };
  }
}",0.6561705766331323,0.5011037378925145,0.5110785686400148,0.6125,0.0,0.7748607214070818,0.6281916996461472,0.7087511859821802,0.7625,0.0,0.6875895603232257,0.398948428533,0.6212510826011726,0.7301587301587301,0.0
124,"    function loadDocument(recoveryMode) {

      var loadDocumentCapability = createPromiseCapability();



      var parseSuccess = function parseSuccess() {

        Promise.all([

          pdfManager.ensureDoc('numPages'),

          pdfManager.ensureDoc('fingerprint'),

        ]).then(function([numPages, fingerprint]) {

          loadDocumentCapability.resolve({

            numPages,

            fingerprint,

          });

        }, parseFailure);

      };



      var parseFailure = function parseFailure(e) {

        loadDocumentCapability.reject(e);

      };



      pdfManager.ensureDoc('checkHeader', []).then(function() {

        pdfManager.ensureDoc('parseStartXRef', []).then(function() {

          pdfManager.ensureDoc('parse', [recoveryMode]).then(

            parseSuccess, parseFailure);

        }, parseFailure);

      }, parseFailure);

      return loadDocumentCapability.promise;
","    async function loadDocument(recoveryMode) {

      await pdfManager.ensureDoc('checkHeader');

      await pdfManager.ensureDoc('parseStartXRef');

      await pdfManager.ensureDoc('parse', [recoveryMode]);



      if (!recoveryMode) {

        // Check that at least the first page can be successfully loaded,

        // since otherwise the XRef table is definitely not valid.

        await pdfManager.ensureDoc('checkFirstPage');

      }

      const [numPages, fingerprint] = await Promise.all([

        pdfManager.ensureDoc('numPages'),

        pdfManager.ensureDoc('fingerprint'),

      ]);

      return { numPages, fingerprint, };
","async function loadDocument(recoveryMode) {
    
    var loadDocumentCapability = createPromiseCapability();
    
    try {
        
        const parseSuccess = async () => {
            await Promise.all([
                pdfManager.ensureDoc('numPages'),
                pdfManager.ensureDoc('fingerprint')
            ]);
            
            loadDocumentCapability.resolve({
                numPages,
                fingerprint
            });
        };
        
        const parseFailure = async (e) => {
            loadDocumentCapability.reject(e);
        };
    
        await pdfManager.ensureDoc('checkHeader', []);
        await pdfManager.ensureDoc('parseStartXRef', []);
        await pdfManager.ensureDoc('parse', [recoveryMode]).then(parseSuccess, parseFailure);
    } catch (e) {
        loadDocumentCapability.reject(e);
    }
    
    return loadDocumentCapability.promise;
}",0.16622121938359363,0.03756878591608448,0.03996669402792858,0.3373493975903614,0.25,0.38020809431022606,0.1823388587907173,0.19625790934710788,0.6144578313253012,0.5277777777777778,0.2911440952209904,0.0846356642331394,0.09613504863462767,0.6153846153846154,0.3684210526315789
125,"        this.xref.stream.manager.requestRanges(pendingRequests).then(() => {

          for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {

            let node = nodesToRevisit[i];

            // Remove any reference nodes from the current `RefSet` so they

            // aren't skipped when we revist them.

            if (node instanceof Ref) {

              this.refSet.remove(node);

            }

          this._walk(nodesToRevisit);

        }, this.capability.reject);

        return;

      this.capability.resolve();
","        await this.xref.stream.manager.requestRanges(pendingRequests);



        for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {

          let node = nodesToRevisit[i];

          // Remove any reference nodes from the current `RefSet` so they

          // aren't skipped when we revist them.

          if (node instanceof Ref) {

            this.refSet.remove(node);

        }

        return this._walk(nodesToRevisit);

      return undefined;
","async function(){

  this.xref.stream.manager.requestRanges(pendingRequests);

    try {

      let nodesToRevisit = await this.xref.stream.manager.requestRanges(pendingRequests);

      for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {

        let node = nodesToRevisit[i];

        // Remove any reference nodes from the current `RefSet` so they

        // aren't skipped when we revist them.

        if (node instanceof Ref) {

          this.refSet.remove(node);

        }

      this._walk(nodesToRevisit);

    } catch (error) {

      console.log(error);

    }

  return;

}",0.8482169807799481,0.8402746546841887,0.8480478138901493,0.7045454545454546,1.0,0.6879451471928321,0.7053199050981492,0.8711360083485036,0.8181818181818182,0.35714285714285715,0.6992704082866624,0.7181881854135462,0.8982211788255405,0.8235294117647058,0.35714285714285715
126,"  getPageDict(pageIndex) {

    const capability = createPromiseCapability();

    function next() {

      while (nodesToVisit.length) {

        const currentNode = nodesToVisit.pop();

        if (isRef(currentNode)) {

          count = pageKidsCountCache.get(currentNode);

          // Skip nodes where the page can't be.

          if (count > 0 && currentPageIndex + count < pageIndex) {

            currentPageIndex += count;

            continue;

          }

          xref.fetchAsync(currentNode).then(function(obj) {

            if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {

              if (pageIndex === currentPageIndex) {

                // Cache the Page reference, since it can *greatly* improve

                // performance by reducing redundant lookups in long documents

                // where all nodes are found at *one* level of the tree.

                if (currentNode && !pageKidsCountCache.has(currentNode)) {

                  pageKidsCountCache.put(currentNode, 1);

                }

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            nodesToVisit.push(obj);

            next();

          }, capability.reject);

          return;

        // Must be a child page dictionary.

        if (!isDict(currentNode)) {

          capability.reject(new FormatError(

            'Page dictionary kid reference points to wrong type of object.'));

          return;

        }

        count = currentNode.get('Count');

        if (Number.isInteger(count) && count >= 0) {

          // Cache the Kids count, since it can reduce redundant lookups in

          // documents where all nodes are found at *one* level of the tree.

          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {

            pageKidsCountCache.put(objId, count);

          }

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

        const kids = currentNode.get('Kids');

        if (!Array.isArray(kids)) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          if (isName(currentNode.get('Type'), 'Page') ||

              (!currentNode.has('Type') && currentNode.has('Contents'))) {

            if (currentPageIndex === pageIndex) {

              capability.resolve([currentNode, null]);

              return;

            }

            currentPageIndex++;

            continue;



          capability.reject(new FormatError(

            'Page dictionary kids object is not an array.'));

          return;

        // Always check all `Kids` nodes, to avoid getting stuck in an empty

        // node further down in the tree (see issue5644.pdf, issue8088.pdf),

        // and to ensure that we actually find the correct `Page` dict.

        for (let last = kids.length - 1; last >= 0; last--) {

          nodesToVisit.push(kids[last]);

        }

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;
","  async getPageDict(pageIndex) {

    while (nodesToVisit.length) {

      const currentNode = nodesToVisit.pop();

      if (isRef(currentNode)) {

        count = pageKidsCountCache.get(currentNode);

        // Skip nodes where the page can't be.

        if (count > 0 && currentPageIndex + count < pageIndex) {

          currentPageIndex += count;

          continue;

        }

        const obj = await xref.fetchAsync(currentNode);

        if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {

          if (pageIndex === currentPageIndex) {

            // Cache the Page reference, since it can *greatly* improve

            // performance by reducing redundant lookups in long documents

            // where all nodes are found at *one* level of the tree.

            if (currentNode && !pageKidsCountCache.has(currentNode)) {

              pageKidsCountCache.put(currentNode, 1);

            return [obj, currentNode];

          }

          currentPageIndex++;

          continue;

        nodesToVisit.push(obj);

        continue;

      }

      // Must be a child page dictionary.

      if (!isDict(currentNode)) {

        throw new FormatError(

          'Page dictionary kid reference points to wrong type of object.');

      }

      count = currentNode.get('Count');

      if (Number.isInteger(count) && count >= 0) {

        // Cache the Kids count, since it can reduce redundant lookups in

        // documents where all nodes are found at *one* level of the tree.

        const objId = currentNode.objId;

        if (objId && !pageKidsCountCache.has(objId)) {

          pageKidsCountCache.put(objId, count);

        // Skip nodes where the page can't be.

        if (currentPageIndex + count <= pageIndex) {

          currentPageIndex += count;

          continue;

        }

      }

      const kids = currentNode.get('Kids');

      if (!Array.isArray(kids)) {

        // Prevent errors in corrupt PDF documents that violate the

        // specification by *inlining* Page dicts directly in the Kids

        // array, rather than using indirect objects (fixes issue9540.pdf).

        if (isName(currentNode.get('Type'), 'Page') ||

            (!currentNode.has('Type') && currentNode.has('Contents'))) {

          if (currentPageIndex === pageIndex) {

            return [currentNode, null];

          currentPageIndex++;

          continue;

        throw new FormatError('Page dictionary kids object is not an array.');

      }

      // Always check all `Kids` nodes, to avoid getting stuck in an empty

      // node further down in the tree (see issue5644.pdf, issue8088.pdf),

      // and to ensure that we actually find the correct `Page` dict.

      for (let last = kids.length - 1; last >= 0; last--) {

        nodesToVisit.push(kids[last]);

    throw new Error(`Page index ${pageIndex} not found.`);
","async function getPageDict(pageIndex) {

  const capability = createPromiseCapability();

  function next() {

    while (nodesToVisit.length) {

      const currentNode = nodesToVisit.pop();

      if (isRef(currentNode)) {

        count = pageKidsCountCache.get(currentNode);

        // Skip nodes where the page can't be.

        if (count > 0 && currentPageIndex + count < pageIndex) {

          currentPageIndex += count;

          continue;

        }

        try {

          const obj = await xref.fetchAsync(currentNode);

          if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {

            if (pageIndex === currentPageIndex) {

              // Cache the Page reference, since it can *greatly* improve

              // performance by reducing redundant lookups in long documents

              // where all nodes are found at *one* level of the tree.

              if (currentNode && !pageKidsCountCache.has(currentNode)) {

                pageKidsCountCache.put(currentNode, 1);

              }

              capability.resolve([obj, currentNode]);

            } else {

              currentPageIndex++;

              next();

            }

            return;

          nodesToVisit.push(obj);

          next();

        catch (e) {

          if (e instanceof FormatError && e.message.startsWith('Page dictionary kid reference points to wrong type of object.')) {

            capability.reject(new FormatError(

              'Page dictionary kid reference points to wrong type of object.'));

            return;

          }

          if (e instanceof Error && e.message.startsWith('Page index')) {

            capability.reject(new Error(`Page index ${pageIndex} not found.`));

            return;

        capability.reject(new FormatError(

          'Page dictionary kids object is not an array.'));

          return;

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;

}",0.6966807789516448,0.8333697008477288,0.835575637181073,0.7511111111111111,0.36666666666666664,0.5245846237128863,0.35221626634652037,0.43056667294946926,0.7822222222222223,0.5333333333333333,0.4367607231353303,0.3030666194191668,0.35557619011738173,0.7213114754098361,0.3670886075949367
127,"function loadFakeWorker() {

    return new Promise(function(resolve, reject) {

      if (typeof SystemJS === 'object') {

        SystemJS.import('pdfjs/core/worker').then((worker) => {

          window.pdfjsWorker = worker;

          resolve();

        }).catch(reject);

      } else {

        reject(new Error('SystemJS must be used to load fake worker.'));

      }

    });
","async function loadFakeWorker() {

    if (typeof SystemJS !== 'object') {

      throw new Error('SystemJS must be used to load fake worker.');

    }

    window.pdfjsWorker = await SystemJS.import('pdfjs/core/worker');

    return undefined;
","async function loadFakeWorker() {
  if (typeof SystemJS === 'object') {
    try {
      const worker = await SystemJS.import('pdfjs/core/worker');
      window.pdfjsWorker = worker;
    } catch (error) {
      throw new Error('SystemJS must be used to load fake worker.');
    }
  } else {
    throw new Error('SystemJS must be used to load fake worker.');
  }
}",0.27472359572776406,0.28403471088552484,0.30374856091442043,0.28888888888888886,0.2222222222222222,0.40751468790582585,0.30633280185162876,0.43483706088278573,0.3333333333333333,0.5555555555555556,0.6847099904982648,0.37110531375198796,0.7010679815744043,0.6666666666666666,1.0
128,"  _adjustScaleWidth() {

    const container = this.items.scaleSelectContainer;

    const select = this.items.scaleSelect;

    animationStarted.then(function() {

      // Adjust the width of the zoom box to fit the content.

      // Note: If the window is narrow enough that the zoom box is not

      //       visible, we temporarily show it to be able to adjust its width.

      if (container.clientWidth === 0) {

        container.setAttribute(""style"", ""display: inherit;"");

      }

      if (container.clientWidth > 0) {

        select.setAttribute(""style"", ""min-width: inherit;"");

        const width = select.clientWidth + SCALE_SELECT_CONTAINER_PADDING;

        select.setAttribute(

          ""style"",

          `min-width: ${width + SCALE_SELECT_PADDING}px;`

        );

        container.setAttribute(

          ""style"",

          `min-width: ${width}px; max-width: ${width}px;`

        );

    });
","  /**

   * Increase the width of the zoom dropdown DOM element if, and only if, it's

   * too narrow to fit the *longest* of the localized strings.

   * @private

   */

  async _adjustScaleWidth() {

    const { items, l10n } = this;

    const predefinedValuesPromise = Promise.all([

      l10n.get(""page_scale_auto"", null, ""Automatic Zoom""),

      l10n.get(""page_scale_actual"", null, ""Actual Size""),

      l10n.get(""page_scale_fit"", null, ""Page Fit""),

      l10n.get(""page_scale_width"", null, ""Page Width""),

    ]);



    // The temporary canvas is used to measure text length in the DOM.

    let canvas = document.createElement(""canvas"");

    if (

      typeof PDFJSDev === ""undefined"" ||

      PDFJSDev.test(""MOZCENTRAL || GENERIC"")

    ) {

      canvas.mozOpaque = true;

    }

    let ctx = canvas.getContext(""2d"", { alpha: false });



    await animationStarted;

    const { fontSize, fontFamily } = getComputedStyle(items.scaleSelect);

    ctx.font = `${fontSize} ${fontFamily}`;



    let maxWidth = 0;

    for (const predefinedValue of await predefinedValuesPromise) {

      const { width } = ctx.measureText(predefinedValue);

      if (width > maxWidth) {

        maxWidth = width;

    }

    const overflow = SCALE_SELECT_WIDTH - SCALE_SELECT_CONTAINER_WIDTH;

    maxWidth += 1.5 * overflow;



    if (maxWidth > SCALE_SELECT_CONTAINER_WIDTH) {

      items.scaleSelect.style.width = `${maxWidth + overflow}px`;

      items.scaleSelectContainer.style.width = `${maxWidth}px`;

    }

    // Zeroing the width and height cause Firefox to release graphics resources

    // immediately, which can greatly reduce memory consumption.

    canvas.width = 0;

    canvas.height = 0;

    canvas = ctx = null;
","async _adjustScaleWidth() {
  const container = this.items.scaleSelectContainer;
  const select = this.items.scaleSelect;
  
  try {
    await animationStarted();
    
    // Adjust the width of the zoom box to fit the content.
    if (container.clientWidth === 0) {
      container.setAttribute(""style"", ""display: inherit;"");
    }
    
    if (container.clientWidth > 0) {
      select.setAttribute(""style"", ""min-width: inherit;"");
      
      const width = select.clientWidth + SCALE_SELECT_CONTAINER_PADDING;
      
      select.setAttribute(
        ""style"",
        `min-width: ${width + SCALE_SELECT_PADDING}px;`
      );
      
      container.setAttribute(
        ""style"",
        `min-width: ${width}px; max-width: ${width}px;`
      );
    }
  } catch (error) {
    // Handle errors here
  }
}",0.2187494701656982,0.0374721370897054,0.0888869050975884,0.3275862068965517,0.42105263157894735,0.7989068916364341,0.6220241593205691,0.6425689244665469,0.9310344827586207,1.0,0.12248437083669318,0.02321166652583552,0.04696314630968066,0.30708661417322836,0.11267605633802817
129,"    pdfDocument

      .getMetadata()

      .then(({ info, metadata, contentDispositionFilename }) => {

        this.documentInfo = info;

        this.metadata = metadata;

        this.contentDispositionFilename = contentDispositionFilename;



        // Provides some basic debug information

        console.log(

          ""PDF "" +

            pdfDocument.fingerprint +

            "" ["" +

            info.PDFFormatVersion +

            "" "" +

            (info.Producer || ""-"").trim() +

            "" / "" +

            (info.Creator || ""-"").trim() +

            ""]"" +

            "" (PDF.js: "" +

            (version || ""-"") +

            (AppOptions.get(""enableWebGL"") ? "" [WebGL]"" : """") +

            "")""

        );

        let pdfTitle;

        const infoTitle = info && info[""Title""];

        if (infoTitle) {

          pdfTitle = infoTitle;

        }

        const metadataTitle = metadata && metadata.get(""dc:title"");

        if (metadataTitle) {

          // Ghostscript can produce invalid 'dc:title' Metadata entries:

          //  - The title may be ""Untitled"" (fixes bug 1031612).

          //  - The title may contain incorrectly encoded characters, which thus

          //    looks broken, hence we ignore the Metadata entry when it

          //    contains characters from the Specials Unicode block

          //    (fixes bug 1605526).

          if (

            metadataTitle !== ""Untitled"" &&

            !/[\uFFF0-\uFFFF]/g.test(metadataTitle)

          ) {

            pdfTitle = metadataTitle;

          }

        }

        if (pdfTitle) {

          this.setTitle(

            `${pdfTitle} - ${contentDispositionFilename || document.title}`

          );

        } else if (contentDispositionFilename) {

          this.setTitle(contentDispositionFilename);

        }

        if (info.IsAcroFormPresent) {

          console.warn(""Warning: AcroForm/XFA is not supported"");

          this.fallback(UNSUPPORTED_FEATURES.forms);

        }

        if (

          typeof PDFJSDev === ""undefined"" ||

          PDFJSDev.test(""MOZCENTRAL || GENERIC"")

        ) {

          // Telemetry labels must be C++ variable friendly.

          let versionId = ""other"";

          // Keep these in sync with mozilla central's Histograms.json.

          const KNOWN_VERSIONS = [

            ""1.0"",

            ""1.1"",

            ""1.2"",

            ""1.3"",

            ""1.4"",

            ""1.5"",

            ""1.6"",

            ""1.7"",

            ""1.8"",

            ""1.9"",

            ""2.0"",

            ""2.1"",

            ""2.2"",

            ""2.3"",

          ];

          if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {

            versionId = `v${info.PDFFormatVersion.replace(""."", ""_"")}`;

          }

          let generatorId = ""other"";

          // Keep these in sync with mozilla central's Histograms.json.

          const KNOWN_GENERATORS = [

            ""acrobat distiller"",

            ""acrobat pdfwriter"",

            ""adobe livecycle"",

            ""adobe pdf library"",

            ""adobe photoshop"",

            ""ghostscript"",

            ""tcpdf"",

            ""cairo"",

            ""dvipdfm"",

            ""dvips"",

            ""pdftex"",

            ""pdfkit"",

            ""itext"",

            ""prince"",

            ""quarkxpress"",

            ""mac os x"",

            ""microsoft"",

            ""openoffice"",

            ""oracle"",

            ""luradocument"",

            ""pdf-xchange"",

            ""antenna house"",

            ""aspose.cells"",

            ""fpdf"",

          ];

          if (info.Producer) {

            const producer = info.Producer.toLowerCase();

            KNOWN_GENERATORS.some(function(generator) {

              if (!producer.includes(generator)) {

                return false;

              }

              generatorId = generator.replace(/[ .\-]/g, ""_"");

              return true;

            });

          }

          let formType = null;

          if (info.IsAcroFormPresent) {

            formType = info.IsXFAPresent ? ""xfa"" : ""acroform"";

          this.externalServices.reportTelemetry({

            type: ""documentInfo"",

            version: versionId,

            generator: generatorId,

            formType,

          });

        }
","    this._initializeMetadata(pdfDocument);

  },

  /**

   * @private

   */

  async _initializeMetadata(pdfDocument) {

    const {

      info,

      metadata,

      contentDispositionFilename,

    } = await pdfDocument.getMetadata();

    if (pdfDocument !== this.pdfDocument) {

      return; // The document was closed while the metadata resolved.

    }

    this.documentInfo = info;

    this.metadata = metadata;

    this.contentDispositionFilename = contentDispositionFilename;



    // Provides some basic debug information

    console.log(

      ""PDF "" +

        pdfDocument.fingerprint +

        "" ["" +

        info.PDFFormatVersion +

        "" "" +

        (info.Producer || ""-"").trim() +

        "" / "" +

        (info.Creator || ""-"").trim() +

        ""]"" +

        "" (PDF.js: "" +

        (version || ""-"") +

        (AppOptions.get(""enableWebGL"") ? "" [WebGL]"" : """") +

        "")""

    );

    let pdfTitle;

    const infoTitle = info && info[""Title""];

    if (infoTitle) {

      pdfTitle = infoTitle;

    }

    const metadataTitle = metadata && metadata.get(""dc:title"");

    if (metadataTitle) {

      // Ghostscript can produce invalid 'dc:title' Metadata entries:

      //  - The title may be ""Untitled"" (fixes bug 1031612).

      //  - The title may contain incorrectly encoded characters, which thus

      //    looks broken, hence we ignore the Metadata entry when it

      //    contains characters from the Specials Unicode block

      //    (fixes bug 1605526).

      if (

        metadataTitle !== ""Untitled"" &&

        !/[\uFFF0-\uFFFF]/g.test(metadataTitle)

      ) {

        pdfTitle = metadataTitle;

      }

    }

    if (pdfTitle) {

      this.setTitle(

        `${pdfTitle} - ${contentDispositionFilename || document.title}`

      );

    } else if (contentDispositionFilename) {

      this.setTitle(contentDispositionFilename);

    }

    if (info.IsAcroFormPresent) {

      console.warn(""Warning: AcroForm/XFA is not supported"");

      this.fallback(UNSUPPORTED_FEATURES.forms);

    }

    if (

      typeof PDFJSDev === ""undefined"" ||

      PDFJSDev.test(""MOZCENTRAL || GENERIC"")

    ) {

      // Telemetry labels must be C++ variable friendly.

      let versionId = ""other"";

      // Keep these in sync with mozilla central's Histograms.json.

      const KNOWN_VERSIONS = [

        ""1.0"",

        ""1.1"",

        ""1.2"",

        ""1.3"",

        ""1.4"",

        ""1.5"",

        ""1.6"",

        ""1.7"",

        ""1.8"",

        ""1.9"",

        ""2.0"",

        ""2.1"",

        ""2.2"",

        ""2.3"",

      ];

      if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {

        versionId = `v${info.PDFFormatVersion.replace(""."", ""_"")}`;

      }

      let generatorId = ""other"";

      // Keep these in sync with mozilla central's Histograms.json.

      const KNOWN_GENERATORS = [

        ""acrobat distiller"",

        ""acrobat pdfwriter"",

        ""adobe livecycle"",

        ""adobe pdf library"",

        ""adobe photoshop"",

        ""ghostscript"",

        ""tcpdf"",

        ""cairo"",

        ""dvipdfm"",

        ""dvips"",

        ""pdftex"",

        ""pdfkit"",

        ""itext"",

        ""prince"",

        ""quarkxpress"",

        ""mac os x"",

        ""microsoft"",

        ""openoffice"",

        ""oracle"",

        ""luradocument"",

        ""pdf-xchange"",

        ""antenna house"",

        ""aspose.cells"",

        ""fpdf"",

      ];

      if (info.Producer) {

        const producer = info.Producer.toLowerCase();

        KNOWN_GENERATORS.some(function(generator) {

          if (!producer.includes(generator)) {

            return false;

          generatorId = generator.replace(/[ .\-]/g, ""_"");

          return true;

        });

      }



      let formType = null;

      if (info.IsAcroFormPresent) {

        formType = info.IsXFAPresent ? ""xfa"" : ""acroform"";

      }

      this.externalServices.reportTelemetry({

        type: ""documentInfo"",

        version: versionId,

        generator: generatorId,

        formType,

    }
","`
async function () {
const pdfDocument = this.docViewer.pdfDocument;
try {
const { info, metadata, contentDispositionFilename } = await pdfDocument.getMetadata();
this.documentInfo = info;
this.metadata = metadata;
this.contentDispositionFilename = contentDispositionFilename;
if (info) {
const infoTitle = info && info[""Title""];
let pdfTitle = infoTitle;
if (infoTitle) {
pdfTitle = infoTitle;
}
const metadataTitle = metadata && metadata.get(""dc:title"");
if (metadataTitle) {
// Ghostscript can produce invalid 'dc:title' Metadata entries:
//  - The title may be ""Untitled"" (fixes bug 1031612).
//  - The title may contain incorrectly encoded characters, which thus
//    looks broken, hence we ignore the Metadata entry when it
//    contains characters from the Specials Unicode block
//    (fixes bug 1605526).
if (metadataTitle !== ""Untitled"" && !/[\uFFF0-\uFFFF]/g.test(metadataTitle)) {
pdfTitle = metadataTitle;
}
}
if (pdfTitle) {
this.setTitle(`${pdfTitle} - ${contentDispositionFilename || document.title}`);
} else if (contentDispositionFilename) {
this.setTitle(contentDispositionFilename);
}
if (info.IsAcroFormPresent) {
console.warn(""Warning: AcroForm/XFA is not supported"");
this.fallback(UNSUPPORTED_FEATURES.forms);
}
if (typeof PDFJSDev === ""undefined"" || PDFJSDev.test(""MOZCENTRAL || GENERIC"")) {
// Telemetry labels must be C++ variable friendly.
let versionId = ""other"";
// Keep these in sync with mozilla central's Histograms.json.
const KNOWN_VERSIONS = [
""1.0"",
""1.1"",
""1.2"",
""1.3"",
""1.4"",
""1.5"",
""1.6"",
""1.7"",
""1.8"",
""1.9"",
""2.0"",
""2.1"",
""2.2"",
""2.3"",
];
if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {
versionId = `v${info.PDFFormatVersion.replace(""."", ""_"")}`;
}
let generatorId = ""other"";
// Keep these in sync with mozilla central's Histograms.json.
const KNOWN_GENERATORS = [
""acrobat distiller"",
""acrobat pdfwriter"",
""adobe livecycle"",
""adobe pdf library"",
""adobe photoshop"",
""ghostscript"",
""tcpdf"",
""cairo"",
""dvipdfm"",
""dvips"",
""pdftex"",
""pdfkit"",
""itext"",
""prince"",
""quarkxpress"",
""mac os x"",
""microsoft"",
""openoffice"",
""oracle"",
""luradocument"",
""pdf-xchange"",
""antenna house"",
""aspose.cells"",
""fpdf"",
];
if (info.Producer) {
const producer = info.Producer.toLowerCase();
KNOWN_GENERATORS.some(function(generator) {
if (!producer.includes(generator)) {
return false;
}
generatorId = generator.replace(/[ .\-]/g, ""_"");
return true;
});
}
let formType = null;
if (info.IsAcroFormPresent) {
formType = info.IsXFAPresent ? ""xfa"" : ""acroform"";
this.externalServices.reportTelemetry({
type: ""documentInfo"",
version: versionId,
generator: generatorId,
formType,
});
}
}
} catch (err) {
console.error(err);
}
}",0.8366117268365891,0.8978505036628338,0.9617996183792747,0.9291044776119403,0.5576923076923077,0.5145054063803732,0.7517666012019921,0.7644926821840243,0.4552238805970149,0.08653846153846154,0.4735006049647096,0.6940522814883751,0.7136268031506935,0.4336917562724014,0.05263157894736842
130,"function initializePDFJS(callback) {

  Promise.all([

    SystemJS.import(""pdfjs/core/fonts.js""),

    SystemJS.import(""pdfjs/core/stream.js""),

    SystemJS.import(""pdfjs/core/primitives.js""),

    SystemJS.import(""pdfjs/core/cmap.js""),

  ]).then(function (modules) {

    var fonts = modules[0],

      stream = modules[1],

      primitives = modules[2],

      cmap = modules[3];

    // Expose some of the PDFJS members to global scope for tests.

    window.Font = fonts.Font;

    window.ToUnicodeMap = fonts.ToUnicodeMap;

    window.Stream = stream.Stream;

    window.Name = primitives.Name;

    window.CMapFactory = cmap.CMapFactory;



    callback();

  });
","async function initializePDFJS(callback) {

  await Promise.all(

    [

      ""pdfjs-test/font/font_core_spec.js"",

      ""pdfjs-test/font/font_os2_spec.js"",

      ""pdfjs-test/font/font_post_spec.js"",

      ""pdfjs-test/font/font_fpgm_spec.js"",

    ].map(function (moduleName) {

      return SystemJS.import(moduleName);

    })

  );



  callback();
","async function initializePDFJS() {
  try {
    const modules = await Promise.all([
      SystemJS.import(""pdfjs/core/fonts.js""),
      SystemJS.import(""pdfjs/core/stream.js""),
      SystemJS.import(""pdfjs/core/primitives.js""),
      SystemJS.import(""pdfjs/core/cmap.js""),
    ]);

    const fonts = modules[0],
      stream = modules[1],
      primitives = modules[2],
      cmap = modules[3];

    // Expose some of the PDFJS members to global scope for tests.

    window.Font = fonts.Font;
    window.ToUnicodeMap = fonts.ToUnicodeMap;
    window.Stream = stream.Stream;
    window.Name = primitives.Name;
    window.CMapFactory = cmap.CMapFactory;
  } catch (error) {
    // Handle potential errors with the `async/await` syntax.
    console.error(error);
  } finally {
    // Ensure that the callback is executed no matter what.
    const callback = () => {};
  }
}",0.13596838913553033,0.009565170172808925,0.021377351886553733,0.375,0.13793103448275862,0.6082554263148687,0.4703152639239161,0.7989133378872832,0.75,0.41379310344827586,0.20536992399659665,0.005343599381004469,0.030421810891096437,0.2857142857142857,0.5
131,"    return new Promise(resolve => {

      FirefoxCom.request(""createSandbox"", data, resolve);

    }).then(success => {

      if (!success) {

        throw new Error(""Cannot create sandbox."");

      }

    });
","    const success = await FirefoxCom.requestAsync(""createSandbox"", data);

    if (!success) {

      throw new Error(""Cannot create sandbox."");

    }
","async function createSandbox(data) {
    let result;
    try {
      result = await FirefoxCom.request(""createSandbox"", data);
    } catch (e) {
      throw new Error(""Cannot create sandbox."");
    }
    if (!result) {
      throw new Error(""Cannot create sandbox."");
    }
  }",0.42110479740807366,0.3694806344312654,0.3982718885343625,0.4166666666666667,0.5,0.48579880613238374,0.19568336427344604,0.33084519358942216,0.4166666666666667,1.0,0.4957654790437789,0.19899559528447933,0.47156632089063605,0.8125,0.5
132,"    }).then(done);

  it(""performs a normal search and finds the previous result"", function (done) {

    testSearch({
","    });

  it(""performs a normal search and finds the previous result"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
","`async () => {
  try {
    const response = await testSearch({});
    done(null, response);
  } catch (error) {
    done(error);
  }
}`",0.43037251825691936,0.32558697463249553,0.6459030983951818,0.25,0.5,0.2557609415104528,0.009629943614188135,0.013413822427623097,0.0,0.0,0.2628405080272648,0.02453959599978309,0.026822436109275996,0.0,0.0
133,"    }).then(done);

  it(""performs a case sensitive search"", function (done) {

    testSearch({
","    });

  it(""performs a case sensitive search"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
","async function () => {
  try {
    const done = await testSearch({});
    return done;
  } catch (error) {
    console.log(error);
  }
}",0.3463589093535658,0.18185234853618296,0.45358328887808014,0.25,0.5,0.1973450652861923,0.010862721615727716,0.028517539529041496,0.25,0.5,0.27622155734467496,0.06746462123641898,0.07075494147561419,0.16666666666666666,0.8
134,"    }).then(done);

  it(""performs an entire word search"", function (done) {

    testSearch({
","    });

  it(""performs an entire word search"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
","async function performEntireWordSearch() {
  try {
    const result = await testSearch({
      ...
    });
    done(result);
  } catch (error) {
    console.log(error);
  }
}",0.34533259726425247,0.18185234853618296,0.4494780405208269,0.25,0.5,0.26089535575049827,0.012021577610863726,0.03155984539112946,0.5,0.5,0.2617227862491021,0.03895071723162264,0.04127376109811903,0.16666666666666666,0.8
135,"    }).then(done);

  it(""performs a multiple term (no phrase) search"", function (done) {

    testSearch({
","    });

  it(""performs a multiple term (no phrase) search"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController();



    await testSearch({

      eventBus,

      pdfFindController,
","async function testSearch() {
  try {
    const done = await search({
      type: 'terms',
      terms: ['cats', 'dogs'],
      size: 10,
    });
  } catch (error) {
    console.log(error);
  }
}",0.3956458380113602,0.2619087743398409,0.5706745777055999,0.25,0.5,0.1958622561854249,0.008640609739997756,0.024808415001701823,0.25,0.5,0.10775292437269281,0.02945288437401947,0.03489214645008509,0.16666666666666666,0.2
136,"    }).then(done);
","    });

  });



  it(""performs a normal search, where the text is normalized"", async function () {

    const { eventBus, pdfFindController } = await initPdfFindController(

      ""fraction-highlight.pdf""

    );



    await testSearch({

      eventBus,

      pdfFindController,

      parameters: {

        query: ""fraction"",

        caseSensitive: false,

        entireWord: false,

        phraseSearch: true,

        findPrevious: false,

      },

      matchesPerPage: [3],

      selectedMatch: {

        pageIndex: 0,

        matchIndex: 0,

      },

      pageMatches: [[19, 48, 66]],

      pageMatchesLength: [[8, 8, 8]],

    });
","async function done() {
  //...code
}

async function run() {
  //...logic
}

run().then(done).catch((error) => {
  console.log(error);
});",0.3,0.0,0.0,0.2,0.0,0.3,0.0,0.0,0.2,0.0,0.1343935581069733,0.00265196561297498,0.009281241173892578,0.02564102564102564,0.5
137,"      it(""should print a date according to a format"", function (done) {

        Promise.all([

          myeval(`util.printd(0, ${date})`).then(value => {

            expect(value).toEqual(""D:20070415031415"");

          }),

          myeval(`util.printd(1, ${date})`).then(value => {

            expect(value).toEqual(""2007.04.15 03:14:15"");

          }),

          myeval(`util.printd(2, ${date})`).then(value => {

            expect(value).toEqual(""4/15/07 3:14:15 am"");

          }),

          myeval(`util.printd(""mmmm mmm mm m"", ${date})`).then(value => {

            expect(value).toEqual(""April Apr 04 4"");

          }),

          myeval(`util.printd(""dddd ddd dd d"", ${date})`).then(value => {

            expect(value).toEqual(""Sunday Sun 15 15"");

          }),

        ]).then(() => done());

      it(""should parse a date according to a format"", function (done) {

        Promise.all([

          myeval(`util.scand(0, ""D:20070415031415"").toString()`).then(value => {

            expect(new Date(value)).toEqual(date);

          }),

          myeval(`util.scand(1, ""2007.04.15 03:14:15"").toString()`).then(

            value => {

              expect(new Date(value)).toEqual(date);

            }

          ),

          myeval(`util.scand(2, ""4/15/07 3:14:15 am"").toString()`).then(

            value => {

              expect(new Date(value)).toEqual(date);

            }

          ),

        ]).then(() => done());

      it(""should print some data according to a format"", function (done) {

        Promise.all([

          myeval(

            `util.printf(""Integer numbers: %d, %d,..."", 1.234, 56.789)`

          ).then(value => {

            expect(value).toEqual(""Integer numbers: 1, 56,..."");

          }),

          myeval(`util.printf(""Hex numbers: %x, %x,..."", 1234, 56789)`).then(

            value => {

              expect(value).toEqual(""Hex numbers: 4D2, DDD5,..."");

            }

          ),

          myeval(

            `util.printf(""Hex numbers with 0x: %#x, %#x,..."", 1234, 56789)`

          ).then(value => {

            expect(value).toEqual(""Hex numbers with 0x: 0x4D2, 0xDDD5,..."");

          }),

          myeval(`util.printf(""Decimal number: %,0+.3f"", 1234567.89123)`).then(

            value => {

              expect(value).toEqual(""Decimal number: +1,234,567.891"");

            }

          ),

          myeval(`util.printf(""Decimal number: %,0+8.3f"", 1.234567)`).then(

            value => {

              expect(value).toEqual(""Decimal number: +  1.235"");

            }

          ),

          myeval(`util.printf(""Decimal number: %,0.2f"", -12.34567)`).then(

            value => {

              expect(value).toEqual(""Decimal number: -12.35"");

            }

          ),

        ]).then(() => done());

      it(""should print a string with no argument"", function (done) {

        myeval(`util.printf(""hello world"")`)

          .then(value => {

            expect(value).toEqual(""hello world"");

          })

          .then(() => done());

      it(""print a string with a percent"", function (done) {

        myeval(`util.printf(""%%s"")`)

          .then(value => {

            expect(value).toEqual(""%%s"");

          })

          .then(() => done());

      it(""should print some data according to a format"", function (done) {

        myeval(`util.printx(""9 (999) 999-9999"", ""aaa14159697489zzz"")`)

          .then(value => {

            expect(value).toEqual(""1 (415) 969-7489"");

          })

          .then(() => done());

    it(""should trigger an event and modify the source"", function (done) {
","      it(""should print a date according to a format"", async () => {

        let value = await myeval(`util.printd(0, ${date})`);

        expect(value).toEqual(""D:20070415031415"");



        value = await myeval(`util.printd(1, ${date})`);

        expect(value).toEqual(""2007.04.15 03:14:15"");



        value = await myeval(`util.printd(2, ${date})`);

        expect(value).toEqual(""4/15/07 3:14:15 am"");



        value = await myeval(`util.printd(""mmmm mmm mm m"", ${date})`);

        expect(value).toEqual(""April Apr 04 4"");



        value = await myeval(`util.printd(""dddd ddd dd d"", ${date})`);

        expect(value).toEqual(""Sunday Sun 15 15"");

      it(""should parse a date according to a format"", async () => {

        let value = await myeval(

          `util.scand(0, ""D:20070415031415"").toString()`

        );

        expect(new Date(value)).toEqual(date);



        value = await myeval(`util.scand(1, ""2007.04.15 03:14:15"").toString()`);

        expect(new Date(value)).toEqual(date);



        value = await myeval(`util.scand(2, ""4/15/07 3:14:15 am"").toString()`);

        expect(new Date(value)).toEqual(date);

      it(""should print some data according to a format"", async () => {

        let value = await myeval(

          `util.printf(""Integer numbers: %d, %d,..."", 1.234, 56.789)`

        );

        expect(value).toEqual(""Integer numbers: 1, 56,..."");



        value = await myeval(

          `util.printf(""Hex numbers: %x, %x,..."", 1234, 56789)`

        );

        expect(value).toEqual(""Hex numbers: 4D2, DDD5,..."");



        value = await myeval(

          `util.printf(""Hex numbers with 0x: %#x, %#x,..."", 1234, 56789)`

        );

        expect(value).toEqual(""Hex numbers with 0x: 0x4D2, 0xDDD5,..."");



        value = await myeval(

          `util.printf(""Decimal number: %,0+.3f"", 1234567.89123)`

        );

        expect(value).toEqual(""Decimal number: +1,234,567.891"");



        value = await myeval(

          `util.printf(""Decimal number: %,0+8.3f"", 1.234567)`

        );

        expect(value).toEqual(""Decimal number: +  1.235"");



        value = await myeval(

          `util.printf(""Decimal number: %,0.2f"", -12.34567)`

        );

        expect(value).toEqual(""Decimal number: -12.35"");

      it(""should print a string with no argument"", async () => {

        const value = await myeval(`util.printf(""hello world"")`);

        expect(value).toEqual(""hello world"");

      it(""print a string with a percent"", async () => {

        const value = await myeval(`util.printf(""%%s"")`);

        expect(value).toEqual(""%%s"");

      it(""should print some data according to a format"", async () => {

        const value = await myeval(

          `util.printx(""9 (999) 999-9999"", ""aaa14159697489zzz"")`

        );

        expect(value).toEqual(""1 (415) 969-7489"");

    it(""should trigger an event and modify the source"", async () => {
","it(""should print a date according to a format"", async () => {

  const value = await myeval(`util.printd(0, ${date})`);

  expect(value).toEqual(""D:20070415031415"");

  value = await myeval(`util.printd(1, ${date})`);

  expect(value).toEqual(""2007.04.15 03:14:15"");

  value = await myeval(`util.printd(2, ${date})`);

  expect(value).toEqual(""4/15/07 3:14:15 am"");

  value = await myeval(`util.printd(""mmmm mmm mm m"", ${date})`);

  expect(value).toEqual(""April Apr 04 4"");

  value = await myeval(`util.printd(""dddd ddd dd d"", ${date})`);

  expect(value).toEqual(""Sunday Sun 15 15"");

});

it(""should parse a date according to a format"", async () => {

  const value = await myeval(`util.scand(0, ""D:20070415031415"").toString()`);

  expect(new Date(value)).toEqual(date);

  value = await myeval(`util.scand(1, ""2007.04.15 03:14:15"").toString()`);

  expect(new Date(value)).toEqual(date);

  value = await myeval(`util.scand(2, ""4/15/07 3:14:15 am"").toString()`);

  expect(new Date(value)).toEqual(date);

});

it(""should print some data according to a format"", async () => {

  const value = await myeval(`util.printf(""Integer numbers: %d, %d,..."", 1.234, 56.789)`);

  expect(value).toEqual(""Integer numbers: 1, 56,..."");

  value = await myeval(`util.printf(""Hex numbers: %x, %x,..."", 1234, 56789)`);

  expect(value).toEqual(""Hex numbers: 4D2, DDD5,..."");

  value = await myeval(`util.printf(""Hex numbers with 0x: %#x, %#x,..."", 1234, 56789)`);

  expect(value).toEqual(""Hex numbers with 0x: 0x4D2, 0xDDD5,..."");

  value = await myeval(`util.printf(""Decimal number: %,0+.3f"", 1234567.89123)`);

  expect(value).toEqual(""Decimal number: +1,234,567.891"");

  value = await myeval(`util.printf(""Decimal number: %,0+8.3f"", 1.234567)`);

  expect(value).toEqual(""Decimal number: +  1.235"");

  value = await myeval(`util.printf(""Decimal number: %,0.2f"", -12.34567)`);

  expect(value).toEqual(""Decimal number: -12.35"");

});

it(""should print a string with no argument"", async () => {

  const value = await myeval(`util.printf(""hello world"")`);

  expect(value).toEqual(""hello world"");

});

it(""print a string with a percent"", async () => {

  const value = await myeval(`util.printf(""%%s"")`);

  expect(value).toEqual(""%%s"");

});

it(""should print some data according to a format"", async () => {

  const value = await myeval(`util.printx(""9 (999) 999-9999"", ""aaa1415969748zzz"")`);

  expect(value).toEqual(""1 (415) 969-7489"");

});

it(""should trigger an event and modify the source"", async () => {


});",0.5057317188577914,0.3389965449803027,0.33452784756421744,0.5650887573964497,0.7843137254901961,0.5005651724767693,0.3282978303736532,0.3245603766467785,0.5650887573964497,0.7843137254901961,0.8617860789254406,0.7302673540873541,0.7317280104421887,0.9959016393442623,0.989247311827957
138,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: """",

          name: ""test"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""123"",

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger a Keystroke event and invalidate it"", function (done) {
","

      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: """",

        name: ""test"",

        willCommit: true,

      });



      expect(send_queue.has(refId)).toEqual(true);

      expect(send_queue.get(refId)).toEqual({

        id: refId,

        value: ""123"",

      });

    it(""should trigger a Keystroke event and invalidate it"", async () => {
","sandbox
      .dispatchEventInSandbox({
        id: refId,
        value: """",
        name: ""test"",
        willCommit: true,
      })
      .then(async () => {
        expect(send_queue.has(refId)).toEqual(true);
        const sendQueueValue = await send_queue.get(refId);
        expect(sendQueueValue).toEqual({
          id: refId,
          value: ""123"",
        });
      })
      .catch((error) => {
        done.fail(error);
      });",0.6367390922435179,0.5588450254706057,0.546552901945024,0.7142857142857143,0.7272727272727273,0.5962391035345926,0.43222816493011673,0.4202607167407212,0.7142857142857143,0.8181818181818182,0.6596183209817028,0.36426045994326806,0.409347959118678,0.8648648648648649,1.0
139,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: ""hell"",

          name: ""Keystroke"",

          willCommit: false,

          change: ""o"",

          selStart: 4,

          selEnd: 4,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""hell"",

            selRange: [4, 4],

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger a Keystroke event and change it"", function (done) {
","      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: ""hell"",

        name: ""Keystroke"",

        willCommit: false,

        change: ""o"",

        selStart: 4,

        selEnd: 4,

      });



      expect(send_queue.has(refId)).toEqual(true);

      expect(send_queue.get(refId)).toEqual({

        id: refId,

        value: ""hell"",

        selRange: [4, 4],

      });

    it(""should trigger a Keystroke event and change it"", async () => {
","sandbox
  .dispatchEventInSandbox({
    id: refId,
    value: ""hell"",
    name: ""Keystroke"",
    willCommit: false,
    change: ""o"",
    selStart: 4,
    selEnd: 4,
  })
  .then(() => {
    expect(send_queue.has(refId)).toEqual(true);
    expect(send_queue.get(refId)).toEqual({
      id: refId,
      value: ""hell"",
      selRange: [4, 4],
    });
    done();
  })
  .catch(done.fail);",0.693054542906707,0.6558559337208458,0.6436349651787097,0.7454545454545455,0.7272727272727273,0.8285700714138017,0.7165313105737893,0.7250217023541446,0.9636363636363636,0.9090909090909091,0.7653830424164125,0.5704946439478741,0.5608049675782413,0.9302325581395349,1.0
140,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: ""hell"",

          name: ""Keystroke"",

          willCommit: false,

          change: ""o"",

          selStart: 4,

          selEnd: 4,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""hella"",

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger an invalid commit Keystroke event"", function (done) {
","      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: ""hell"",

        name: ""Keystroke"",

        willCommit: false,

        change: ""o"",

        selStart: 4,

        selEnd: 4,

      });



      expect(send_queue.has(refId)).toEqual(true);

      expect(send_queue.get(refId)).toEqual({

        id: refId,

        value: ""hella"",

      });

    it(""should trigger an invalid commit Keystroke event"", async () => {
","async function testKeystrokeEvent() {
  const sandbox = new Sandbox();
  const refId = ""my-ref"";

  try {
    await sandbox.dispatchEventInSandbox({
      id: refId,
      value: ""hell"",
      name: ""Keystroke"",
      willCommit: false,
      change: ""o"",
      selStart: 4,
      selEnd: 4,
    });

    expect(send_queue.has(refId)).toEqual(true);
    expect(send_queue.get(refId)).toEqual({
      id: refId,
      value: ""hella"",
    });
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}",0.6720294587305595,0.6186897661971439,0.6063062848485935,0.7358490566037735,0.7272727272727273,0.5327419381004547,0.38854425100788786,0.49542521665979705,0.7924528301886793,0.45454545454545453,0.6285486609555107,0.4728348679732666,0.6907500197512149,0.975609756097561,0.375
141,"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: """",

          name: ""test"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(false);

          done();

        })

        .catch(done.fail);

    it(""should trigger a valid commit Keystroke event"", function (done) {
","      await sandbox.dispatchEventInSandbox({

        id: refId,

        value: """",

        name: ""test"",

        willCommit: true,

      });

      expect(send_queue.has(refId)).toEqual(false);

    it(""should trigger a valid commit Keystroke event"", async () => {
","async function test() {
  try {
    await sandbox.dispatchEventInSandbox({
      id: refId,
      value: """",
      name: ""test"",
      willCommit: true,
    });
    expect(send_queue.has(refId)).toEqual(false);
    done();
  } catch (err) {
    done.fail(err);
  }
}",0.4852949767608844,0.47097422282273144,0.4590945731096951,0.6111111111111112,0.4,0.5172886238960939,0.28276019472712227,0.29194985641280896,0.6944444444444444,0.8,0.7296592693578482,0.443330590140889,0.5169731539571706,0.9583333333333334,1.0
142,"      sandbox

        .dispatchEventInSandbox({

          id: refId1,

          value: ""hello"",

          name: ""Keystroke"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId1)).toEqual(true);

          expect(send_queue.get(refId1)).toEqual({

            id: refId1,

            value: ""world"",

            valueAsString: ""world"",

          });

          done();

        })

        .catch(done.fail);
","      await sandbox.dispatchEventInSandbox({

        id: refId1,

        value: ""hello"",

        name: ""Keystroke"",

        willCommit: true,

      });



      expect(send_queue.has(refId1)).toEqual(true);

      expect(send_queue.get(refId1)).toEqual({

        id: refId1,

        value: ""world"",

        valueAsString: ""world"",

      });
","async () => {
    const refId1 = sandbox.dispatchEventInSandbox({
      id: refId1,
      value: ""hello"",
      name: ""Keystroke"",
      willCommit: true,
    });

    try {
      expect(send_queue.has(refId1)).toEqual(true);
      expect(send_queue.get(refId1)).toEqual({
        id: refId1,
        value: ""world"",
        valueAsString: ""world"",
      });
    } catch (error) {
      done.fail(error);
    } finally {
      done();
    }
  };",0.6583203379380511,0.5543760428383842,0.5646195946281057,0.7142857142857143,0.8,0.5850043615130048,0.4124382567627842,0.6316608219422963,0.7959183673469388,0.5,0.665306745778991,0.4226405630978418,0.8196675010992033,0.918918918918919,0.5
143,"    it(""should convert RGB color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0.181]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0.1, 0.2, 0.3]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0.9, 0.8, 0.7, 0.7]);

        }),

      ]).then(() => done());

    it(""should convert CMYK color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""T"")`).then(

          value => {

            expect(round(value)).toEqual([""T""]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""G"")`).then(

          value => {

            expect(round(value)).toEqual([""G"", 0.371]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""RGB"")`).then(

          value => {

            expect(round(value)).toEqual([""RGB"", 0.5, 0.3, 0.4]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""CMYK"")`).then(

          value => {

            expect(round(value)).toEqual([""CMYK"", 0.1, 0.2, 0.3, 0.4]);

          }

        ),

      ]).then(() => done());

    it(""should convert Gray color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""G"", 0.1], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""G"", 0.1], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0.1]);

        }),

        myeval(`color.convert([""G"", 0.1], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0.1, 0.1, 0.1]);

        }),

        myeval(`color.convert([""G"", 0.1], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 0.9]);

        }),

      ]).then(() => done());

    it(""should convert Transparent color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""T""], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""T""], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0]);

        }),

        myeval(`color.convert([""T""], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0, 0, 0]);

        }),

        myeval(`color.convert([""T""], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 1]);

        }),

      ]).then(() => done());
","    it(""should convert RGB color for different color spaces"", async () => {

      let value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""T"")`);

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""G"")`);

      expect(round(value)).toEqual([""G"", 0.181]);



      value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""RGB"")`);

      expect(round(value)).toEqual([""RGB"", 0.1, 0.2, 0.3]);



      value = await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""CMYK"")`);

      expect(round(value)).toEqual([""CMYK"", 0.9, 0.8, 0.7, 0.7]);

    it(""should convert CMYK color for different color spaces"", async () => {

      let value = await myeval(

        `color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""T"")`

      );

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""G"")`);

      expect(round(value)).toEqual([""G"", 0.371]);



      value = await myeval(

        `color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""RGB"")`

      );

      expect(round(value)).toEqual([""RGB"", 0.5, 0.3, 0.4]);



      value = await myeval(

        `color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""CMYK"")`

      );

      expect(round(value)).toEqual([""CMYK"", 0.1, 0.2, 0.3, 0.4]);

    it(""should convert Gray color for different color spaces"", async () => {

      let value = await myeval(`color.convert([""G"", 0.1], ""T"")`);

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""G"", 0.1], ""G"")`);

      expect(round(value)).toEqual([""G"", 0.1]);



      value = await myeval(`color.convert([""G"", 0.1], ""RGB"")`);

      expect(round(value)).toEqual([""RGB"", 0.1, 0.1, 0.1]);



      value = await myeval(`color.convert([""G"", 0.1], ""CMYK"")`);

      expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 0.9]);

    it(""should convert Transparent color for different color spaces"", async () => {

      let value = await myeval(`color.convert([""T""], ""T"")`);

      expect(round(value)).toEqual([""T""]);



      value = await myeval(`color.convert([""T""], ""G"")`);

      expect(round(value)).toEqual([""G"", 0]);



      value = await myeval(`color.convert([""T""], ""RGB"")`);

      expect(round(value)).toEqual([""RGB"", 0, 0, 0]);



      value = await myeval(`color.convert([""T""], ""CMYK"")`);

      expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 1]);
","async function myeval() {
  // Identify Promise Chains
  const promises = [
    color.convert([""RGB"", 0.1, 0.2, 0.3], ""T"").then((value) => {
      expect(round(value)).toEqual([""T""]);
    }),
    color.convert([""RGB"", 0.1, 0.2, 0.3], ""G"").then((value) => {
      expect(round(value)).toEqual([""G"", 0.181]);
    }),
    color.convert([""RGB"", 0.1, 0.2, 0.3], ""RGB"").then((value) => {
      expect(round(value)).toEqual([""RGB"", 0.1, 0.2, 0.3]);
    }),
    color.convert([""RGB"", 0.1, 0.2, 0.3], ""CMYK"").then((value) => {
      expect(round(value)).toEqual([""CMYK"", 0.9, 0.8, 0.7, 0.7]);
    }),
  ];

  // Use await to replace .then() callbacks
  for (const promise of promises) {
    try {
      const value = await promise;
      expect(round(value)).toEqual([""T""]);
    } catch (err) {
      console.error(err);
    }
  }
}",0.4807427953072184,0.33147854739075566,0.32998901064971237,0.6260869565217392,0.6354166666666666,0.2159224275633804,0.05458245201886418,0.10675218577088923,0.5565217391304348,0.14583333333333334,0.22357805776140116,0.03250803828139829,0.057387383158717636,0.6339622641509434,0.17045454545454544
144,"    it(""should test language"", function (done) {

      Promise.all([

        myeval(`app.language`).then(value => {

          expect(value).toEqual(""ENU"");

        }),

        myeval(`app.language = ""hello""`).then(value => {

          expect(value).toEqual(""app.language is read-only"");

        }),

      ]).then(() => done());

    it(""should test platform"", function (done) {

      Promise.all([

        myeval(`app.platform`).then(value => {

          expect(value).toEqual(""UNIX"");

        }),

        myeval(`app.platform = ""hello""`).then(value => {

          expect(value).toEqual(""app.platform is read-only"");

        }),

      ]).then(() => done());
","    it(""should test language"", async () => {

      let value = await myeval(`app.language`);

      expect(value).toEqual(""ENU"");



      value = await myeval(`app.language = ""hello""`);

      expect(value).toEqual(""app.language is read-only"");

    it(""should test platform"", async () => {

      let value = await myeval(`app.platform`);

      expect(value).toEqual(""UNIX"");



      value = await myeval(`app.platform = ""hello""`);

      expect(value).toEqual(""app.platform is read-only"");
","async function testLanguage() {
  try {
    const value = await myeval('app.language');
    expect(value).toEqual('ENU');
  } catch (error) {
    console.log(error);
  }
}

async function testPlatform() {
  try {
    const value = await myeval('app.platform');
    expect(value).toEqual('UNIX');
  } catch (error) {
    console.log(error);
  }
}",0.2928241749184891,0.06889633077457276,0.06635167976080678,0.4943820224719101,0.5416666666666666,0.2240665588069461,0.006662282007747453,0.007581481309924487,0.38202247191011235,0.5,0.2854729635092864,0.03936504183889703,0.04112330342631886,0.5614035087719298,0.5
145,"    },

  };

  function processBinaryCMap(data, cMap, extend) {

    return new Promise(function (resolve, reject) {
","    }

  }

  // eslint-disable-next-line no-shadow

  class BinaryCMapReader {

    async process(data, cMap, extend) {
","async function processBinaryCMap(data, cMap, extend) {
    try {
        let result = await new Promise(function (resolve, reject) {
            // ...
        });
        return result;
    } catch (err) {
        console.error(""Error while processing binary CMap:"", err);
        return null;
    }
}",0.3881999564337249,0.08263103182212594,0.07016879391277371,0.4,0.0,0.5503558180158058,0.1965995991268291,0.6048236729363942,0.4,0.0,0.3677809966684178,0.03609623953161197,0.10169441380872592,0.3333333333333333,0.0
146,"    return Promise.resolve(cMap);

  function extendCMap(cMap, fetchBuiltInCMap, useCMap) {

    return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function (

      newCMap

    ) {

      cMap.useCMap = newCMap;

      // If there aren't any code space ranges defined clone all the parent ones

      // into this cMap.

      if (cMap.numCodespaceRanges === 0) {

        var useCodespaceRanges = cMap.useCMap.codespaceRanges;

        for (var i = 0; i < useCodespaceRanges.length; i++) {

          cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();

        }

        cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;

      // Merge the map into the current one, making sure not to override

      // any previously defined entries.

      cMap.useCMap.forEach(function (key, value) {

        if (!cMap.contains(key)) {

          cMap.mapOne(key, cMap.useCMap.lookup(key));

        }

      });



      return cMap;

  function createBuiltInCMap(name, fetchBuiltInCMap) {

      return Promise.resolve(new IdentityCMap(false, 2));

      return Promise.resolve(new IdentityCMap(true, 2));

      return Promise.reject(new Error(""Unknown CMap name: "" + name));

      return Promise.reject(

        new Error(""Built-in CMap parameters are not provided."")

      );

    return fetchBuiltInCMap(name).then(function (data) {

      var cMapData = data.cMapData,

        compressionType = data.compressionType;

      var cMap = new CMap(true);



      if (compressionType === CMapCompressionType.BINARY) {

        return new BinaryCMapReader().process(

          cMapData,

          cMap,

          function (useCMap) {

            return extendCMap(cMap, fetchBuiltInCMap, useCMap);

          }

        );

      }

      if (compressionType === CMapCompressionType.NONE) {

        var lexer = new Lexer(new Stream(cMapData));

        return parseCMap(cMap, lexer, fetchBuiltInCMap, null);

      }

      return Promise.reject(

        new Error(

          ""TODO: Only BINARY/NONE CMap compression is currently supported.""

        )

      );

    });
","    return cMap;

  async function extendCMap(cMap, fetchBuiltInCMap, useCMap) {

    cMap.useCMap = await createBuiltInCMap(useCMap, fetchBuiltInCMap);

    // If there aren't any code space ranges defined clone all the parent ones

    // into this cMap.

    if (cMap.numCodespaceRanges === 0) {

      var useCodespaceRanges = cMap.useCMap.codespaceRanges;

      for (var i = 0; i < useCodespaceRanges.length; i++) {

        cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();

      }

      cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;

    }

    // Merge the map into the current one, making sure not to override

    // any previously defined entries.

    cMap.useCMap.forEach(function (key, value) {

      if (!cMap.contains(key)) {

        cMap.mapOne(key, cMap.useCMap.lookup(key));



    return cMap;

  async function createBuiltInCMap(name, fetchBuiltInCMap) {

      return new IdentityCMap(false, 2);

      return new IdentityCMap(true, 2);

      throw new Error(""Unknown CMap name: "" + name);

      throw new Error(""Built-in CMap parameters are not provided."");

    const { cMapData, compressionType } = await fetchBuiltInCMap(name);

    var cMap = new CMap(true);



    if (compressionType === CMapCompressionType.BINARY) {

      return new BinaryCMapReader().process(cMapData, cMap, useCMap => {

        return extendCMap(cMap, fetchBuiltInCMap, useCMap);

      });

    }

    if (compressionType === CMapCompressionType.NONE) {

      var lexer = new Lexer(new Stream(cMapData));

      return parseCMap(cMap, lexer, fetchBuiltInCMap, null);

    }

    throw new Error(

      ""TODO: Only BINARY/NONE CMap compression is currently supported.""

    );
","async function createBuiltInCMap(name, fetchBuiltInCMap) {
  try {
    let data = await fetchBuiltInCMap(name);
    let cMapData = data.cMapData;
    let compressionType = data.compressionType;
    if (compressionType === CMapCompressionType.BINARY) {
      return new BinaryCMapReader().process(
        cMapData,
        function (useCMap) {
          return extendCMap(cMap, fetchBuiltInCMap, useCMap);
        }
      );
    } else if (compressionType === CMapCompressionType.NONE) {
      let lexer = new Lexer(new Stream(cMapData));
      return parseCMap(lexer, fetchBuiltInCMap, null);
    } else {
      throw new Error(`TODO: Only BINARY/NONE CMap compression is currently supported.`);
    }
  } catch (error) {
    throw new Error(`Error parsing built-in CMap '${name}': ${error}`);
  }
}",0.6209723161626655,0.6684247771265367,0.6660713969545635,0.673202614379085,0.47619047619047616,0.22697986729733055,0.1176604493660684,0.18848497687274024,0.33986928104575165,0.2619047619047619,0.22409481235968653,0.11805208933533343,0.1746031209532576,0.3220338983050847,0.28169014084507044
147,"        var cMap = new CMap();

        var lexer = new Lexer(encoding);

        return parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function (

          parsedCMap

        ) {

          if (parsedCMap.isIdentityCMap) {

            return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);

          }

          return parsedCMap;

        });
","        const parsedCMap = await parseCMap(

          /* cMap = */ new CMap(),

          /* lexer = */ new Lexer(encoding),

          fetchBuiltInCMap,

          useCMap

        );



        if (parsedCMap.isIdentityCMap) {

          return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);

        }

        return parsedCMap;
","async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
  try {
    const parsedCMap = await parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap);
    if (parsedCMap.isIdentityCMap) {
      return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
    }
    return parsedCMap;
  } catch (err) {
    // Handle potential errors
    console.error(err);
  }
}",0.4422043635019904,0.3345424765702511,0.3374088805716136,0.48148148148148145,0.6153846153846154,0.4104688769918045,0.2596093486503439,0.32243709948781424,0.4444444444444444,0.6153846153846154,0.4557994562610641,0.27970647559818806,0.38081192360874777,0.5263157894736842,0.6363636363636364
148,"  open() {

    this.overlayManager.open(this.overlayName).then(() => {

      if (

        !this._isViewerEmbedded ||

        this.reason === PasswordResponses.INCORRECT_PASSWORD

      ) {

        this.input.focus();

      }

      let promptString;

      if (this.reason === PasswordResponses.INCORRECT_PASSWORD) {

        promptString = this.l10n.get(

          ""password_invalid"",

          null,

          ""Invalid password. Please try again.""

        );

      } else {

        promptString = this.l10n.get(

          ""password_label"",

          null,

          ""Enter the password to open this PDF file.""

        );

      }

      promptString.then(msg => {

        this.label.textContent = msg;

      });

    });
","  async open() {

    await this.overlayManager.open(this.overlayName);

    const passwordIncorrect =

      this.reason === PasswordResponses.INCORRECT_PASSWORD;

    if (!this._isViewerEmbedded || passwordIncorrect) {

      this.input.focus();

    }

    this.label.textContent = await this.l10n.get(

      `password_${passwordIncorrect ? ""invalid"" : ""label""}`

    );
","open() {

async () => {

try {

await this.overlayManager.open(this.overlayName);

if (

!this._isViewerEmbedded ||

this.reason === PasswordResponses.INCORRECT_PASSWORD

) {

this.input.focus();

}

let promptString;

if (this.reason === PasswordResponses.INCORRECT_PASSWORD) {

promptString = this.l10n.get(

""password_invalid"",

null,

""Invalid password. Please try again.""

);

} else {

promptString = this.l10n.get(

""password_label"",

null,

""Enter the password to open this PDF file.""

);

}

await promptString.then(msg => {

this.label.textContent = msg;

});

} catch (error) {

console.error(error);

}

}

};",0.25610699199756615,0.019592018004500878,0.02722400968725612,0.47761194029850745,0.5,0.873876075457699,0.7324117659025282,0.897420894137223,0.8656716417910447,1.0,0.3968638901954754,0.03133987059332753,0.0858775949504788,0.5952380952380952,0.875
149,"    if (rawName) {

      pageName = this.l10n.get(

        ""document_properties_page_size_name_"" + rawName.toLowerCase(),

        null,

        rawName

      );

    }

    return Promise.all([

        ""document_properties_page_size_unit_"" +

          (this._isNonMetricLocale ? ""inches"" : ""millimeters""),

        null,

        this._isNonMetricLocale ? ""in"" : ""mm""

      pageName,

        ""document_properties_page_size_orientation_"" +

          (isPortrait ? ""portrait"" : ""landscape""),

        null,

        isPortrait ? ""portrait"" : ""landscape""

    ]).then(([{ width, height }, unit, name, orientation]) => {

      return this.l10n.get(

        ""document_properties_page_size_dimension_"" +

          (name ? ""name_"" : """") +

          ""string"",

        {

          width: width.toLocaleString(),

          height: height.toLocaleString(),

          unit,

          name,

          orientation,

        },

        ""{{width}} × {{height}} {{unit}} ("" +

          (name ? ""{{name}}, "" : """") +

          ""{{orientation}})""

      );

    });
","    const [{ width, height }, unit, name, orientation] = await Promise.all([

        `document_properties_page_size_unit_${

          this._isNonMetricLocale ? ""inches"" : ""millimeters""

        }`

      rawName &&

        this.l10n.get(

          `document_properties_page_size_name_${rawName.toLowerCase()}`

        ),

        `document_properties_page_size_orientation_${

          isPortrait ? ""portrait"" : ""landscape""

        }`

    ]);



    return this.l10n.get(

      `document_properties_page_size_dimension_${name ? ""name_"" : """"}string`,

      {

        width: width.toLocaleString(),

        height: height.toLocaleString(),

        unit,

        name,

        orientation,

      }

    );
","async function getPageSizeDimension(isPortrait) {
  const rawName = this._pageSize.name;
  let pageName;

  if (rawName) {
    pageName = this.l10n.get(
      ""document_properties_page_size_name_"" + rawName.toLowerCase(),
      null,
      rawName
    );
  }

  const unit = this._isNonMetricLocale ? ""inches"" : ""millimeters"";
  const name = this._isNonMetricLocale ? ""in"" : ""mm"";

  try {
    const [width, height] = await Promise.all([
      ""document_properties_page_size_unit_"" + (this._isNonMetricLocale ? ""inches"" : ""millimeters""),
      null,
      this._isNonMetricLocale ? ""in"" : ""mm"",
    ]);
    return this.l10n.get(
      ""document_properties_page_size_dimension_"" + (name ? ""name_"" : """") + ""string"",
      {
        width: width.toLocaleString(),
        height: height.toLocaleString(),
        unit,
        name,
        orientation: isPortrait ? ""portrait"" : ""landscape"",
      },
      ""{{width}} × {{height}} {{unit}} ("" + (name ? ""{{name}}, "" : """") + ""{{orientation}})"");
  } catch (error) {
    console.log(error);
  }
}",0.35017623872318726,0.16409083243249997,0.2003272026290253,0.569620253164557,0.4666666666666667,0.6234262428153728,0.5199891515839731,0.639538604487645,0.7341772151898734,0.6,0.3677253400344105,0.13310779639531306,0.3107482628633565,0.5098039215686274,0.5172413793103449
150,"          this._pdfViewer.pagesPromise.then(() => {

            this._eventBus.dispatch(""print"", { source: this });

          });
","          await this._pdfViewer.pagesPromise;

          this._eventBus.dispatch(""print"", { source: this });
","async function () {
  try {
    await this._pdfViewer.pagesPromise;
    this._eventBus.dispatch(""print"", { source: this });
  } catch (error) {
    console.log(error);
  }
}",0.6222803033601907,0.46199933699457096,0.47156632089063605,0.5555555555555556,0.0,0.5707139013940609,0.18759202316167214,0.48415247130346006,0.6111111111111112,0.0,0.8036534615178439,0.2915369229944523,1.0,0.9230769230769231,0.0
151,"  startCleanup() {

    return this.messageHandler.sendWithPromise(""Cleanup"", null).then(() => {

      for (let i = 0, ii = this.pageCache.length; i < ii; i++) {

        const page = this.pageCache[i];

        if (page) {

          const cleanupSuccessful = page.cleanup();

          if (!cleanupSuccessful) {

            throw new Error(

              `startCleanup: Page ${i + 1} is currently rendering.`

            );

          }

        }

      this.commonObjs.clear();

      this._hasJSActionsPromise = null;

    });
","  async startCleanup(keepLoadedFonts = false) {

    await this.messageHandler.sendWithPromise(""Cleanup"", null);

    if (this.destroyed) {

      return; // No need to manually clean-up when destruction has started.

    }

    for (let i = 0, ii = this.pageCache.length; i < ii; i++) {

      const page = this.pageCache[i];

      if (!page) {

        continue;

      const cleanupSuccessful = page.cleanup();



      if (!cleanupSuccessful) {

        throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);

      }

    }

    this.commonObjs.clear();

    if (!keepLoadedFonts) {

    }

    this._hasJSActionsPromise = null;
","async startCleanup() {

  const promise = this.messageHandler.sendWithPromise(""Cleanup"", null);

  try {

    await promise;

    for (let i = 0, ii = this.pageCache.length; i < ii; i++) {

      const page = this.pageCache[i];

      if (page) {

        const cleanupSuccessful = page.cleanup();

        if (!cleanupSuccessful) {

          throw new Error(

            `startCleanup: Page ${i + 1} is currently rendering.`

          );

        }

      }

    this.commonObjs.clear();

    this._hasJSActionsPromise = null;

  } catch (error) {

    console.log(""startCleanup: Error while cleaning up."", error);

  }

}",0.506027981961473,0.4570466762655689,0.6213638941142602,0.7692307692307693,0.17647058823529413,0.6759579509802643,0.6618924077355055,0.8632063645113438,0.8846153846153846,0.29411764705882354,0.510081310857823,0.4815462496963977,0.4872329411033156,0.703125,0.3684210526315789
152,"    it(""cleans up document resources"", function (done) {

      const promise = pdfDocument.cleanup();

      promise.then(function () {

        expect(true).toEqual(true);

        done();

      }, done.fail);
","    it(""cleans up document resources"", async function () {

      await pdfDocument.cleanup();



      expect(true).toEqual(true);
","async function testCleanupDocumentResources() {
  try {
    const result = await pdfDocument.cleanup();
    expect(true).toEqual(true);
    done();
  } catch (error) {
    done.fail();
  }
}",0.47509031253818607,0.16341149865741866,0.17694975149532557,0.56,0.0,0.27612405653234645,0.03424946089789314,0.041675336660064156,0.6,0.42857142857142855,0.49520245845398025,0.0627251733901403,0.13237037471149488,0.7857142857142857,0.0
153,"    it(""cleans up document resources after rendering of page"", function (done) {

      let canvasAndCtx;

      loadingTask.promise

        .then(pdfDoc => {

          return pdfDoc.getPage(1).then(pdfPage => {

            const viewport = pdfPage.getViewport({ scale: 1 });

            canvasAndCtx = CanvasFactory.create(

              viewport.width,

              viewport.height

            );

            const renderTask = pdfPage.render({

              canvasContext: canvasAndCtx.context,

              canvasFactory: CanvasFactory,

              viewport,

            });

            return renderTask.promise.then(() => {

              return pdfDoc.cleanup();

            });

          });

        })

        .then(() => {

          expect(true).toEqual(true);

          CanvasFactory.destroy(canvasAndCtx);

          loadingTask.destroy().then(done);

        }, done.fail);

    it(""cleans up document resources during rendering of page"", function (done) {

      let canvasAndCtx;

      loadingTask.promise

        .then(pdfDoc => {

          return pdfDoc.getPage(1).then(pdfPage => {

            const viewport = pdfPage.getViewport({ scale: 1 });

            canvasAndCtx = CanvasFactory.create(

              viewport.width,

              viewport.height

            );

            const renderTask = pdfPage.render({

              canvasContext: canvasAndCtx.context,

              canvasFactory: CanvasFactory,

              viewport,

            });

            renderTask.onContinue = function (cont) {

              waitSome(cont);

            };

            return pdfDoc

              .cleanup()

              .then(

                () => {

                  throw new Error(""shall fail cleanup"");

                },

                reason => {

                  expect(reason instanceof Error).toEqual(true);

                  expect(reason.message).toEqual(

                    ""startCleanup: Page 1 is currently rendering.""

                  );

                }

              )

              .then(() => {

                return renderTask.promise;

              })

              .then(() => {

                CanvasFactory.destroy(canvasAndCtx);

                loadingTask.destroy().then(done);

              });

          });

        })

        .catch(done.fail);
","    it(""cleans up document resources after rendering of page"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const viewport = pdfPage.getViewport({ scale: 1 });

      const canvasAndCtx = CanvasFactory.create(

        viewport.width,

        viewport.height

      );

      const renderTask = pdfPage.render({

        canvasContext: canvasAndCtx.context,

        canvasFactory: CanvasFactory,

        viewport,

      });

      await renderTask.promise;

      await pdfDoc.cleanup();



      expect(true).toEqual(true);



      CanvasFactory.destroy(canvasAndCtx);

      await loadingTask.destroy();

    it(""cleans up document resources during rendering of page"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const viewport = pdfPage.getViewport({ scale: 1 });

      const canvasAndCtx = CanvasFactory.create(

        viewport.width,

        viewport.height

      );

      const renderTask = pdfPage.render({

        canvasContext: canvasAndCtx.context,

        canvasFactory: CanvasFactory,

        viewport,

      });

      // Ensure that clean-up runs during rendering.

      renderTask.onContinue = function (cont) {

        waitSome(cont);

      };

      try {

        await pdfDoc.cleanup();

        throw new Error(""shall fail cleanup"");

      } catch (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(

          ""startCleanup: Page 1 is currently rendering.""

        );

      }

      await renderTask.promise;



      CanvasFactory.destroy(canvasAndCtx);

      await loadingTask.destroy();
","it(""cleans up document resources after rendering of page"", async function () {

  let canvasAndCtx;

  try {

    const pdfDoc = await loadingTask.promise;

    const pdfPage = await pdfDoc.getPage(1);

    const viewport = pdfPage.getViewport({ scale: 1 });

    canvasAndCtx = CanvasFactory.create(
      viewport.width,
      viewport.height
    );

    const renderTask = await pdfPage.render({
      canvasContext: canvasAndCtx.context,
      canvasFactory: CanvasFactory,
      viewport,
    });

    await renderTask.promise;

    return await pdfDoc.cleanup();

  } catch (error) {

    throw new Error(""shall fail cleanup"");

  } finally {

    expect(true).toEqual(true);

    CanvasFactory.destroy(canvasAndCtx);

    loadingTask.destroy().then(done);

  }

});",0.5350144914832808,0.4901030838100924,0.48641321545636446,0.6302083333333334,0.5333333333333333,0.3212339748107872,0.16291246228233724,0.2453567702941447,0.5833333333333334,0.29333333333333333,0.42364570465169127,0.25853963069585706,0.3516845086155198,0.7552447552447552,0.3291139240506329
154,"    return shadow(

      this,

      ""hasJSActions"",

      this.fieldObjects.then(fieldObjects => {

        return (

          (fieldObjects !== null &&

            Object.values(fieldObjects).some(fieldObject =>

              fieldObject.some(object => object.actions !== null)

            )) ||

          !!this.catalog.jsActions

        );

      })

    );
","    const promise = this.pdfManager.ensure(this, ""_parseHasJSActions"");

    return shadow(this, ""hasJSActions"", promise);

  }



  /**

   * @private

   */

  async _parseHasJSActions() {

    const [catalogJsActions, fieldObjects] = await Promise.all([

      this.pdfManager.ensureCatalog(""jsActions""),

      this.pdfManager.ensure(this, ""fieldObjects""),

    ]);



    if (catalogJsActions) {

      return true;

    }

    if (fieldObjects) {

      return Object.values(fieldObjects).some(fieldObject =>

        fieldObject.some(object => object.actions !== null)

      );

    }

    return false;
","return shadow(

  this,

  ""hasJSActions"",

  async () => {

    try {

      const fieldObjects = await this.fieldObjects;

      return (

        (fieldObjects !== null &&

          Object.values(fieldObjects).some(fieldObject =>

            fieldObject.some(object => object.actions !== null)

          )) ||

        !!this.catalog.jsActions

      );

    } catch (error) {

      console.log(""Error"", error);

    }

  });",0.34150535628880646,0.13772093428074758,0.2703172975971674,0.5294117647058824,0.42857142857142855,0.75235558100506,0.4808914141868042,0.7638250274804944,0.7647058823529411,1.0,0.24021142615603563,0.16479318557260242,0.16780576580478682,0.44642857142857145,0.18181818181818182
155,"    it(""should resolve with correct data"", function (done) {

      promiseCapability.promise.then(function (data) {

        expect(promiseCapability.settled).toEqual(true);



        expect(data).toEqual({ test: ""abc"" });

        done();

      }, done.fail);

    it(""should reject with correct reason"", function (done) {

      promiseCapability.promise.then(done.fail, function (reason) {

        expect(promiseCapability.settled).toEqual(true);

        done();

      });
","    it(""should resolve with correct data"", async function () {

      const data = await promiseCapability.promise;

      expect(promiseCapability.settled).toEqual(true);

      expect(data).toEqual({ test: ""abc"" });

    it(""should reject with correct reason"", async function () {

      try {

        await promiseCapability.promise;

        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(promiseCapability.settled).toEqual(true);

      }
","it(""should resolve with correct data"", async function () {

  let data = await promiseCapability.promise;

  expect(promiseCapability.settled).toEqual(true);

  expect(data).toEqual({ test: ""abc"" });

});

it(""should reject with correct reason"", async function () {

  let reason = await promiseCapability.promise.catch(function (reason) {

    expect(promiseCapability.settled).toEqual(true);

    return reason;

  });

});",0.46447609830665826,0.2841916948202655,0.3689615671846479,0.5576923076923077,0.6470588235294118,0.49692243155190197,0.29859241241662526,0.3689615671846479,0.6730769230769231,0.6470588235294118,0.7148691229431283,0.5931897173474694,0.5876542957925656,0.7555555555555555,0.9230769230769231
156,"        done.fail(""shall not dispatch DOM event."");

      Promise.resolve().then(() => {

        expect(count).toEqual(1);

        document.removeEventListener(""test"", domEventListener);

        done();

      });
","        // Shouldn't get here.

        expect(false).toEqual(true);

      await Promise.resolve();

      expect(count).toEqual(1);

      document.removeEventListener(""test"", domEventListener);
","function () {
  try {
    await Promise.resolve();
    expect(count).toEqual(1);
    document.removeEventListener(""test"", domEventListener);
    done();
  } catch (error) {
    console.log(""Error: "" + error);
  }
}",0.4302364605068961,0.07738233563462713,0.0768968397262906,0.5666666666666667,1.0,0.49784062909437193,0.12021577610863723,0.2044800736021839,0.6666666666666666,1.0,0.5709873508663644,0.17001078098404226,0.418286448568372,0.6956521739130435,1.0
157,"          throw new Error(""Should reject invalid parameters."");

      Promise.all([invalidTarget, invalidName, invalidDelay]).then(

        done,

        done.fail

      );

    it(""should resolve on event, using the DOM"", function (done) {

        pending(""Document in not supported in Node.js."");
","          // Shouldn't get here.

          expect(false).toEqual(true);

      await Promise.all([invalidTarget, invalidName, invalidDelay]);

    it(""should resolve on event, using the DOM"", async function () {

        pending(""Document is not supported in Node.js."");
","async function test() {
 try {
    const invalidTarget = Promise.reject(new Error(""Should reject invalid parameters.""))
    const invalidName = Promise.reject(new Error(""Should reject invalid parameters.""))
    const invalidDelay = Promise.reject(new Error(""Should reject invalid parameters.""))
    await Promise.all([invalidTarget, invalidName, invalidDelay])
 } catch (error) {
    done()
 } finally {
    done.fail()
  }
}",0.5646999323795485,0.3351774569797241,0.32362227253846987,0.6,0.0,0.23887617258487015,0.02768274100926734,0.04448861599688002,0.55,0.3333333333333333,0.4015375405266929,0.026636207669526582,0.05319816496356088,0.5263157894736842,0.0
158,"      buttonClicked.then(function (type) {

        expect(type).toEqual(WaitOnType.EVENT);

        done();

      }, done.fail);

    it(""should resolve on timeout, using the DOM"", function (done) {

        pending(""Document in not supported in Node.js."");
","      const type = await buttonClicked;

      expect(type).toEqual(WaitOnType.EVENT);

    it(""should resolve on timeout, using the DOM"", async function () {

        pending(""Document is not supported in Node.js."");
","async function buttonClicked() {
  try {
    const type = await expect(WaitOnType.EVENT);
    return type;
  } catch (err) {
    done.fail();
  } finally {
    done();
  }
}",0.4384139120116781,0.3964513253420688,0.39720432270464373,0.56,0.4,0.1759330438458388,0.011191021613657745,0.01254115376969737,0.28,0.4,0.1937112903487747,0.12173115521158184,0.14331008461488964,0.17647058823529413,0.3333333333333333
159,"      buttonClicked.then(function (type) {

        expect(type).toEqual(WaitOnType.TIMEOUT);

        done();

      }, done.fail);

    it(""should resolve on event, using the EventBus"", function (done) {
","      const type = await buttonClicked;

      expect(type).toEqual(WaitOnType.TIMEOUT);

    it(""should resolve on event, using the EventBus"", async function () {
","async function testAsync () {
  const type = await buttonClicked;
  expect(type).toEqual(WaitOnType.TIMEOUT);
}

it(""should resolve on event, using the EventBus"", async (done) => {
  try {
    await testAsync();
    done();
  } catch (e) {
    done.fail(e);
  }
});",0.41242965343390514,0.3807134866446316,0.392814650900513,0.47619047619047616,0.4,0.47858590923304956,0.1877061187176041,0.4123518039288796,0.7142857142857143,0.6,0.5917724779064294,0.3508439695638686,0.7598356856515925,0.9230769230769231,0.3333333333333333
160,"      pageRendered.then(function (type) {

        expect(type).toEqual(WaitOnType.EVENT);

        done();

      }, done.fail);

    it(""should resolve on timeout, using the EventBus"", function (done) {
","      const type = await pageRendered;

      expect(type).toEqual(WaitOnType.EVENT);

    it(""should resolve on timeout, using the EventBus"", async function () {
","pageRendered = async () => {
        try {
          const type = await WaitOnType.EVENT;
          expect(type).toEqual(WaitOnType.EVENT);
          done();
        } catch (error) {
          done.fail();
        }
      };

      it(""should resolve on timeout, using the EventBus"", async () => {

        const result = await pageRendered;
        expect(result).toEqual(WaitOnType.EVENT);
        done();
      });",0.41242965343390514,0.3807134866446316,0.392814650900513,0.47619047619047616,0.4,0.5405164861337655,0.15865624349792093,0.3843620819895216,0.6190476190476191,1.0,0.6145684871502134,0.2500653935141143,0.6184649653431497,0.9230769230769231,0.6666666666666666
161,"      pageRendered.then(function (type) {

        expect(type).toEqual(WaitOnType.TIMEOUT);

        done();

      }, done.fail);
","      const type = await pageRendered;

      expect(type).toEqual(WaitOnType.TIMEOUT);
","async function renderPage() {

  try {
    const type = await pageRendered;

    expect(type).toEqual(WaitOnType.TIMEOUT);
  } catch (e) {
    done();
  }
}",0.26031833135400084,0.03455747170954952,0.03303164318013808,0.47368421052631576,0.5,0.2971129650861748,0.01340082578177889,0.043472087194499145,0.631578947368421,0.5,0.7896270952152479,0.24941747177008258,1.0,0.9090909090909091,1.0
162,"    it(""should asynchronously fetch unknown keys"", function (done) {

      Promise.all(keyPromises)

        .then(function (values) {

          expect(values[0]).toBeUndefined();

          expect(values[1]).toBeUndefined();

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });

    it(""should asynchronously fetch correct values for multiple stored keys"", function (done) {

      Promise.all(keyPromises)

        .then(function (values) {

          expect(values[0]).toEqual(testFontFile3);

          expect(values[1]).toEqual(testFontFile2);

          expect(values[2]).toEqual(testFontFile);

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });
","    it(""should asynchronously fetch unknown keys"", async function () {

      const values = await Promise.all(keyPromises);

      expect(values[0]).toBeUndefined();

      expect(values[1]).toBeUndefined();

    it(""should asynchronously fetch correct values for multiple stored keys"", async function () {

      const values = await Promise.all(keyPromises);

      expect(values[0]).toEqual(testFontFile3);

      expect(values[1]).toEqual(testFontFile2);

      expect(values[2]).toEqual(testFontFile);
","it(""should asynchronously fetch unknown keys"", async () => {
  const values = await Promise.all(keyPromises);
  expect(values[0]).toBeUndefined();
  expect(values[1]).toBeUndefined();
});

it(""should asynchronously fetch correct values for multiple stored keys"", async () => {
  const values = await Promise.all(keyPromises);
  expect(values[0]).toEqual(testFontFile3);
  expect(values[1]).toEqual(testFontFile2);
  expect(values[2]).toEqual(testFontFile);
});",0.4471456346127993,0.2839133134644912,0.3045031120298954,0.5930232558139535,0.6071428571428571,0.45306123694557476,0.30682711662561984,0.3052517181998686,0.5930232558139535,0.6071428571428571,0.8605248056672062,0.720805728195706,0.7405242637038882,0.9807692307692307,1.0
163,"      fontDict

        .getAsync(""FontFile"", ""FontFile2"", ""FontFile3"")

        .then(function (value) {

          expect(value).toEqual(testFontFile);

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });
","      const value = await fontDict.getAsync(

        ""FontFile"",

        ""FontFile2"",

        ""FontFile3""

      );

      expect(value).toEqual(testFontFile);
","async function myFunction() {
    const value = await fontDict.getAsync(""FontFile"", ""FontFile2"", ""FontFile3"");
    expect(value).toEqual(testFontFile);
}",0.23879609622660838,0.015223083300988084,0.015718877363021206,0.42424242424242425,0.5,0.23979260581693482,0.017532201649672802,0.017395797375642234,0.42424242424242425,0.5,0.6154294125095574,0.21401603033752975,0.31020161970069987,0.9375,1.0
164,"    const readPromise = Promise.all([read1(), read2(), promise1, promise2]);

    readPromise

      .then(result => {

        expect(isStreamingSupported1).toEqual(false);

        expect(isRangeSupported1).toEqual(false);

        expect(isStreamingSupported2).toEqual(false);

        expect(isRangeSupported2).toEqual(false);

        expect(len1).toEqual(pdfLength);

        expect(len1).toEqual(len2);

        done();

      })

      .catch(reason => {

        done.fail(reason);

      });

  it(""read custom ranges for both http(s) and filesystem urls"", function (done) {
","    await Promise.all([read1(), read2(), promise1, promise2]);



    expect(isStreamingSupported1).toEqual(false);

    expect(isRangeSupported1).toEqual(false);

    expect(isStreamingSupported2).toEqual(false);

    expect(isRangeSupported2).toEqual(false);

    expect(len1).toEqual(pdfLength);

    expect(len1).toEqual(len2);

  it(""read custom ranges for both http(s) and filesystem urls"", async function () {
","async function testReadCustomRanges() {
  try {
    const readPromise = Promise.all([read1(), read2(), promise1, promise2]);
    const result = await readPromise;
    expect(isStreamingSupported1).toEqual(false);
    expect(isRangeSupported1).toEqual(false);
    expect(isStreamingSupported2).toEqual(false);
    expect(isRangeSupported2).toEqual(false);
    expect(len1).toEqual(pdfLength);
    expect(len1).toEqual(len2);
    done();
  } catch (reason) {
    done.fail(reason);
  }
}",0.41366232861037633,0.3901918133223586,0.42295074916463343,0.746268656716418,0.09523809523809523,0.5450513899370537,0.34328291836989283,0.3493604523235958,0.8208955223880597,0.6666666666666666,0.4363786540290552,0.24329753873713073,0.33384973044031435,0.9183673469387755,0.25
165,"    const readPromise = Promise.all([read(), promise]);



    readPromise

      .then(function (page) {

        expect(len).toEqual(pdf1Length);

        expect(count).toEqual(1);

        expect(isStreamingSupported).toEqual(false);

        expect(isRangeSupported).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""read custom ranges"", function (done) {
","    await Promise.all([read(), promise]);



    expect(len).toEqual(pdf1Length);

    expect(count).toEqual(1);

    expect(isStreamingSupported).toEqual(false);

    expect(isRangeSupported).toEqual(false);

  it(""read custom ranges"", async function () {
","const readPromise = Promise.all([read(), promise]);

async function testReadCustomRanges() {
  try {
    const page = await readPromise;
    expect(len).toEqual(pdf1Length);
    expect(count).toEqual(1);
    expect(isStreamingSupported).toEqual(false);
    expect(isRangeSupported).toEqual(false);
    done();
  } catch (reason) {
    done.fail(reason);
  }
}",0.2509898883425326,0.12786525665750156,0.15488217550050765,0.6545454545454545,0.06666666666666667,0.533432772944977,0.3090015909429233,0.3459416220491062,0.7454545454545455,0.7333333333333333,0.37948159373960866,0.11943763958804512,0.2627744496561037,0.8857142857142857,0.25
166,"    const readPromises = Promise.all([

    readPromises

      .then(function () {

        expect(result1.value).toEqual(rangeSize);

        expect(result2.value).toEqual(tailSize);

        expect(isStreamingSupported).toEqual(false);

        expect(isRangeSupported).toEqual(true);

        expect(fullReaderCancelled).toEqual(true);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });
","    await Promise.all([

    expect(result1.value).toEqual(rangeSize);

    expect(result2.value).toEqual(tailSize);

    expect(isStreamingSupported).toEqual(false);

    expect(isRangeSupported).toEqual(true);

    expect(fullReaderCancelled).toEqual(true);
","async function testRead() {

  try {

    const result1 = await readPromises;

    expect(result1.value).toEqual(rangeSize);

    const result2 = await readPromises;

    expect(result2.value).toEqual(tailSize);

    expect(isStreamingSupported).toEqual(false);

    expect(isRangeSupported).toEqual(true);

    expect(fullReaderCancelled).toEqual(true);

  } catch (reason) {

    done.fail(reason);

  } finally {

    await readPromises;

  }

}",0.22754587378393343,0.10045554323637397,0.17923344640485428,0.5535714285714286,0.07692307692307693,0.3532851268759627,0.11385032360134208,0.20038908500140973,0.7142857142857143,0.38461538461538464,0.4970080263214043,0.07781062585666583,0.46173663094410267,0.8484848484848485,0.6
167,"    const readPromise = Promise.all([read(), promise]);

    readPromise

      .then(function () {

        expect(len).toEqual(pdfLength);

        expect(isStreamingSupported).toEqual(true);

        expect(isRangeSupported).toEqual(false);

        done();

      })

      .catch(done.fail);

  it(""read ranges with streaming"", function (done) {
","    await Promise.all([read(), promise]);



    expect(len).toEqual(pdfLength);

    expect(isStreamingSupported).toEqual(true);

    expect(isRangeSupported).toEqual(false);

  it(""read ranges with streaming"", async function () {
","const readPromise = Promise.all([read(), promise]);

async function() {
  try {
    const resolvedValue = await readPromise;
    expect(resolvedValue).toEqual(pdfLength);
    expect(isStreamingSupported).toEqual(true);
    expect(isRangeSupported).toEqual(false);
  } catch (error) {
    done.fail();
  }
}",0.2900220305448756,0.18072595569968908,0.1983544145418288,0.6976744186046512,0.08333333333333333,0.4804165576820655,0.17268932789342512,0.19471333694336412,0.7209302325581395,0.8333333333333334,0.3171460592304056,0.026058929270445657,0.047123008800602266,0.8620689655172413,0.3333333333333333
168,"    const readPromise = Promise.all([

    readPromise

      .then(function () {

        expect(isStreamingSupported).toEqual(true);

        expect(isRangeSupported).toEqual(true);

        expect(fullReaderCancelled).toEqual(true);

        expect(result1.value).toEqual(rangeSize);

        expect(result2.value).toEqual(tailSize);

        done();

      })

      .catch(done.fail);
","    await Promise.all([



    expect(isStreamingSupported).toEqual(true);

    expect(isRangeSupported).toEqual(true);

    expect(fullReaderCancelled).toEqual(true);

    expect(result1.value).toEqual(rangeSize);

    expect(result2.value).toEqual(tailSize);
","const readPromise = Promise.all([
    
        // Replace .then() callbacks by assigning the resolved value to a variable using the await keyword
        (async () => {
            try {
                let result1 = await isStreamingSupported();
                let result2 = await isRangeSupported();
                let fullReaderCancelled = await result1.value;
                expect(result1.value).toEqual(rangeSize);
                expect(result2.value).toEqual(tailSize);
                done();
            } catch (error) {
                done.fail(error);
            }
        })(),
    ]);",0.248853061871926,0.17788616890710254,0.22661698767151048,0.5,0.09090909090909091,0.31663042417005544,0.06751473091731673,0.24446151121745047,0.5,0.45454545454545453,0.15066150723722815,0.008857886206902943,0.08823258718645415,0.3055555555555556,0.2
169,"  beforeAll(function (done) {

    loadingTask.promise

      .then(function (doc) {

        return doc.getPage(1);

      })

      .then(function (data) {

        page = data;

        done();

      })

      .catch(done.fail);

  afterAll(function (done) {

    loadingTask.destroy().then(done);

  it(""renders to canvas with a default white background"", function (done) {
","  beforeAll(async function () {

    const doc = await loadingTask.promise;

    const data = await doc.getPage(1);

    page = data;

  afterAll(async function () {

    await loadingTask.destroy();

  it(""renders to canvas with a default white background"", async function () {
","beforeAll(async () => {
  try {
    const doc = await loadingTask.promise;
    page = await doc.getPage(1);
    done();
  } catch (error) {
    done.fail(error);
  } finally {
    await loadingTask.destroy();
  }
});
afterAll(done => {
  loadingTask.destroy().then(done);
});
it(""renders to canvas with a default white background"", async () => {
  try {
    const doc = await loadingTask.promise;
    page = await doc.getPage(1);
    done();
  } catch (error) {
    done.fail(error);
  } finally {
    await loadingTask.destroy();
  }
});",0.3117376377439463,0.2516546237169354,0.2709369528998753,0.3076923076923077,0.4166666666666667,0.38496954267283,0.12371286992384864,0.2559088905110612,0.41025641025641024,0.75,0.5874941384829904,0.23089254679327476,0.4574678455225249,0.7727272727272727,0.8888888888888888
170,"    renderTask.promise

      .then(function () {

        expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

          r: 255,

          g: 255,

          b: 255,

          a: 255,

        });

        CanvasFactory.destroy(canvasAndCtx);

        done();

      })

      .catch(done.fail);

  it(""renders to canvas with a custom background"", function (done) {
","    await renderTask.promise;



    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

      r: 255,

      g: 255,

      b: 255,

      a: 255,

    });

    CanvasFactory.destroy(canvasAndCtx);

  it(""renders to canvas with a custom background"", async function () {
","renderTask.promise
  .then(async function () {
    const canvasAndCtx = getCanvas();
    const context = canvasAndCtx.context;
    await renderTask(context);
    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({
      r: 255,
      g: 255,
      b: 255,
      a: 255,
    });
    CanvasFactory.destroy(canvasAndCtx);
    done();
  })
  .catch(done.fail);",0.5575213109127252,0.5894767731519405,0.6017195816100714,0.6388888888888888,0.4,0.5793443038973538,0.49149639037458465,0.5036586029926082,0.7222222222222222,0.6,0.6805399579680056,0.39867347136028913,0.4901530271783997,0.8333333333333334,1.0
171,"    renderTask.promise

      .then(function () {

        expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

          r: 255,

          g: 0,

          b: 0,

          a: 255,

        });

        CanvasFactory.destroy(canvasAndCtx);

        done();

      })

      .catch(done.fail);
","    await renderTask.promise;



    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

      r: 255,

      g: 0,

      b: 0,

      a: 255,

    });

    CanvasFactory.destroy(canvasAndCtx);
","async function() {

  try{

    const canvasAndCtx = await renderTask.promise;

    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({
      r: 255,
      g: 0,
      b: 0,
      a: 255,
    });

    CanvasFactory.destroy(canvasAndCtx);

    done();

  }catch(error){

    done.fail();

  }

}",0.5629431595655728,0.5610681750588928,0.573057404379869,0.6176470588235294,0.5,0.5840143747877468,0.4537526714268291,0.647010710077099,0.7352941176470589,0.5,0.7241699715726967,0.48758897719987776,1.0,0.9090909090909091,0.5
172,"  beforeAll(function (done) {

    loadingTask.promise.then(function (doc) {

      doc.getPage(1).then(function (firstPage) {

        page = firstPage;

        done();

      });

    });

  afterAll(function (done) {

    loadingTask.destroy().then(done);
","

  beforeAll(async function () {

    const doc = await loadingTask.promise;

    page = await doc.getPage(1);



  afterAll(async function () {

    await loadingTask.destroy();
","const loadingTask = PDFDocument.load(""https://file-examples-com.github.io/uploads/2017/08/PDF_sample_500kB.pdf"");
let page;
beforeAll(async () => {
  const doc = await loadingTask.promise;
  page = await doc.getPage(1);
});
afterAll(() => loadingTask.destroy());",0.17340978300884768,0.02560744480557418,0.02560744480557418,0.24242424242424243,0.4,0.1722151313534474,0.020828838183973034,0.02560744480557418,0.24242424242424243,0.4,0.5334126459642378,0.41072675483179805,0.4895904956918199,0.8333333333333334,0.4
173,"    it(""should produce a reasonably small svg:image"", function (done) {

      withZlib(true, getSVGImage)

        .then(function (svgImg) {

          expect(svgImg.nodeName).toBe(""svg:image"");

          expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

          expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

          const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

          // forceDataSchema = true, so the generated URL should be a data:-URL.

          expect(imgUrl).toMatch(/^data:image\/png;base64,/);

          // Test whether the generated image has a reasonable file size.

          // I obtained a data URL of size 366 with Node 8.1.3 and zlib 1.2.11.

          // Without zlib (uncompressed), the size of the data URL was excessive

          // (80246).

          expect(imgUrl.length).toBeLessThan(367);

        })

        .then(done, done.fail);

    it(""should be able to produce a svg:image without zlib"", function (done) {

      withZlib(false, getSVGImage)

        .then(function (svgImg) {

          expect(svgImg.nodeName).toBe(""svg:image"");

          expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

          expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

          const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

          expect(imgUrl).toMatch(/^data:image\/png;base64,/);

          // The size of our naively generated PNG file is excessive :(

          expect(imgUrl.length).toBe(80246);

        })

        .then(done, done.fail);
","    it(""should produce a reasonably small svg:image"", async function () {

      const svgImg = await withZlib(true, getSVGImage);

      expect(svgImg.nodeName).toBe(""svg:image"");

      expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

      expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

      const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

      // forceDataSchema = true, so the generated URL should be a data:-URL.

      expect(imgUrl).toMatch(/^data:image\/png;base64,/);

      // Test whether the generated image has a reasonable file size.

      // I obtained a data URL of size 366 with Node 8.1.3 and zlib 1.2.11.

      // Without zlib (uncompressed), the size of the data URL was excessive

      // (80246).

      expect(imgUrl.length).toBeLessThan(367);

    it(""should be able to produce a svg:image without zlib"", async function () {

      const svgImg = await withZlib(false, getSVGImage);

      expect(svgImg.nodeName).toBe(""svg:image"");

      expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

      expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

      const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

      expect(imgUrl).toMatch(/^data:image\/png;base64,/);

      // The size of our naively generated PNG file is excessive :(

      expect(imgUrl.length).toBe(80246);
","it(""should produce a reasonably small svg:image"", async () => {
  const svgImg = await withZlib(true, getSVGImage);
  expect(svgImg.nodeName).toBe(""svg:image"");
  expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");
  expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");
  const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");
  expect(imgUrl).toMatch(/^data:image\/png;base64,/);
  expect(imgUrl.length).toBeLessThan(367);
});

it(""should be able to produce a svg:image without zlib"", async () => {
  const svgImg = await withZlib(false, getSVGImage);
  expect(svgImg.nodeName).toBe(""svg:image"");
  expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");
  expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");
  const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");
  expect(imgUrl).toMatch(/^data:image\/png;base64,/);
  expect(imgUrl.length).toBe(80246);
});",0.73002316990328,0.7958607448464178,0.7998044538506718,0.8244274809160306,0.5,0.440441498176488,0.18361133251357276,0.2537271792763486,0.8244274809160306,0.5,0.6677695808455656,0.2849724354411847,0.3948015401149906,0.991304347826087,1.0
174,"      sleep(10)

        .then(() => {

          expect(log).toEqual("""");

          return reader.read();

        })

        .then(result => {

          expect(log).toEqual(""p"");

          expect(result.value).toEqual(""hi"");

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });

    it(""should not read any data when cancelled"", function (done) {
","

      await sleep(10);

      expect(log).toEqual("""");



      let result = await reader.read();

      expect(log).toEqual(""p"");

      expect(result.value).toEqual(""hi"");

      expect(result.done).toEqual(false);



      await sleep(10);

      result = await reader.read();

      expect(result.value).toEqual(undefined);

      expect(result.done).toEqual(true);

    it(""should not read any data when cancelled"", async function () {
","async function () {
      try {
        await sleep(10);
        expect(log).toEqual("""");
        const result = await reader.read();
        expect(log).toEqual(""p"");
        expect(result.value).toEqual(""hi"");
        expect(result.done).toEqual(false);
        await sleep(10);
        const result2 = await reader.read();
        expect(result2.value).toEqual(undefined);
        expect(result2.done).toEqual(true);
        done();
      } catch (error) {
        console.log(error);
      }
    };",0.4419022458189811,0.19868106291058338,0.19833968507122338,0.6705882352941176,0.7,0.36454724540608807,0.03212080903798474,0.031950525527544134,0.6941176470588235,0.7,0.6532566490081153,0.3747207684621333,0.44165510986697865,0.9545454545454546,0.8421052631578947
175,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2"");

          return reader.cancel(new AbortException(""reader cancelled.""));

        })

        .then(() => {

          expect(log).toEqual(""01p2c4"");

          done();

        });

    it(""should not read when errored"", function (done) {
","      await sleep(10);

      expect(log).toEqual(""01"");



      const result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01p2"");



      await reader.cancel(new AbortException(""reader cancelled.""));

      expect(log).toEqual(""01p2c4"");

    it(""should not read when errored"", async function () {
","async function testReader() {
    try {
        await sleep(10);
        const result = await reader.read();
        expect(result.value).toEqual([1, 2, 3, 4]);
        expect(result.done).toEqual(false);
        await sleep(10);
        const cancelResult = await reader.cancel(new AbortException(""reader cancelled.""));
        expect(log).toEqual(""01p2"");
        done();
    } catch (error) {
        console.error(error);
        done(error);
    }
}",0.4729973918891884,0.20361930556064284,0.20630426486555106,0.6585365853658537,0.8235294117647058,0.3819014266906354,0.12961016543394133,0.12683341794266054,0.6829268292682927,0.5882352941176471,0.5828419466065258,0.4040342490627249,0.5226204226092801,0.9672131147540983,0.4375
176,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return reader.read();

        })

        .catch(reason => {

          expect(log).toEqual(""01pe"");

          expect(reason instanceof UnknownErrorException).toEqual(true);

          expect(reason.message).toEqual(""should not read when errored"");

          done();

        });

    it(""should read data with blocking promise"", function (done) {
","      await sleep(10);

      expect(log).toEqual(""01"");

      const result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      try {

        await reader.read();



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(log).toEqual(""01pe"");

        expect(reason instanceof UnknownErrorException).toEqual(true);

        expect(reason.message).toEqual(""should not read when errored"");

      }

    it(""should read data with blocking promise"", async function () {
","async function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

async function test() {
  await sleep(10);
  const result = await reader.read();
  expect(result.value).toEqual([1, 2, 3, 4]);
  expect(result.done).toEqual(false);
  try {
    const nextResult = await reader.read();
    expect(nextResult.value).toEqual([1, 2, 3, 4]);
    expect(nextResult.done).toEqual(false);
  } catch (reason) {
    expect(log).toEqual(""01pe"");
    expect(reason instanceof UnknownErrorException).toEqual(true);
    expect(reason.message).toEqual(""should not read when errored"");
    done();
  }
}",0.5891782464357703,0.3865933010291833,0.4225006370948503,0.7142857142857143,0.8333333333333334,0.48453360726079014,0.26492394603109337,0.3514211612227452,0.7662337662337663,0.5555555555555556,0.595096961768945,0.45651361488399894,0.5627631210806701,0.8611111111111112,0.5
177,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([5, 6, 7, 8]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2p"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });

      function (done) {
","      await sleep(10);

      expect(log).toEqual(""01"");



      let result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01p2"");



      result = await reader.read();

      expect(result.value).toEqual([5, 6, 7, 8]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01p2p"");



      result = await reader.read();

      expect(result.value).toEqual(undefined);

      expect(result.done).toEqual(true);

      async function () {
","async function () {
  try {
    const result = await sleep(10);
    expect(log).toEqual(""01"");
    return reader.read();
  } catch (error) {
    console.error(error);
  }
  try {
    const result = await sleep(10);
    expect(result.value).toEqual([1, 2, 3, 4]);
    expect(result.done).toEqual(false);
    return sleep(10);
  } catch (error) {
    console.error(error);
  }
  try {
    const result = await sleep(10);
    expect(log).toEqual(""01p2"");
    return reader.read();
  } catch (error) {
    console.error(error);
  }
  try {
    const result = await sleep(10);
    expect(result.value).toEqual([5, 6, 7, 8]);
    expect(result.done).toEqual(false);
    return sleep(10);
  } catch (error) {
    console.error(error);
  }
  try {
    const result = await sleep(10);
    expect(log).toEqual(""01p2p"");
    return reader.read();
  } catch (error) {
    console.error(error);
  }
  try {
    const result = await sleep(10);
    expect(result.value).toEqual(undefined);
    expect(result.done).toEqual(true);
    done();
  } catch (error) {
    console.error(error);
  }
}",0.4146902826533127,0.14937203820677677,0.15044258141000366,0.6692913385826772,0.6896551724137931,0.46404710907386054,0.15454208234180533,0.3299385070896673,0.7165354330708661,0.6551724137931034,0.5054329729409743,0.14689018484904254,0.42769884977199746,0.84,0.6071428571428571
178,"        sleep(10)

          .then(() => {

            expect(log).toEqual(""012"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual([1, 2, 3, 4]);

            expect(result.done).toEqual(false);

            return sleep(10);

          })

          .then(() => {

            expect(log).toEqual(""012p"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual([5, 6, 7, 8]);

            expect(result.done).toEqual(false);

            return sleep(10);

          })

          .then(() => {

            expect(log).toEqual(""012p"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual(undefined);

            expect(result.done).toEqual(true);

            done();

          });

    it(""should ignore any pull after close is called"", function (done) {
","        await sleep(10);

        expect(log).toEqual(""012"");

        let result = await reader.read();

        expect(result.value).toEqual([1, 2, 3, 4]);

        expect(result.done).toEqual(false);



        await sleep(10);

        expect(log).toEqual(""012p"");



        result = await reader.read();

        expect(result.value).toEqual([5, 6, 7, 8]);

        expect(result.done).toEqual(false);



        await sleep(10);

        expect(log).toEqual(""012p"");



        result = await reader.read();

        expect(result.value).toEqual(undefined);

        expect(result.done).toEqual(true);

    it(""should ignore any pull after close is called"", async function () {
","async function test() {
  try {
    const sleep = () => new Promise((resolve) => setTimeout(resolve, 10));
    await sleep();
    expect(log).toEqual(""012"");
    const result = await reader.read();
    expect(result.value).toEqual([1, 2, 3, 4]);
    expect(result.done).toEqual(false);
    await sleep();
    expect(log).toEqual(""012p"");
    result = await reader.read();
    expect(result.value).toEqual([5, 6, 7, 8]);
    expect(result.done).toEqual(false);
    await sleep();
    expect(log).toEqual(""012p"");
    result = await reader.read();
    expect(result.value).toEqual(undefined);
    expect(result.done).toEqual(true);
    done();
  } catch (err) {
    console.error(err);
  }
}",0.46159053818681167,0.2395435208554557,0.23716345947799777,0.68,0.6896551724137931,0.3241412553352077,0.15113316417860145,0.14460427095533276,0.656,0.3448275862068966,0.6009772907718587,0.4364592934306387,0.564388645167,0.8673469387755102,0.5357142857142857
179,"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          capability.resolve();

          return capability.promise.then(() => {

            return reader.read();

          });

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });
","      await sleep(10);

      expect(log).toEqual(""01"");

      capability.resolve();

      await capability.promise;



      let result = await reader.read();

      expect(result.value).toEqual([1, 2, 3, 4]);

      expect(result.done).toEqual(false);



      await sleep(10);

      expect(log).toEqual(""01"");



      result = await reader.read();

      expect(result.value).toEqual(undefined);

      expect(result.done).toEqual(true);
","async function() {
      try {
        await sleep(10);
        let result = await capability.promise;
        expect(result.value).toEqual([1, 2, 3, 4]);
        expect(result.done).toEqual(false);
        await sleep(10);
        result = await reader.read();
        expect(result.value).toEqual(undefined);
        expect(result.done).toEqual(true);
        done();
      } catch (error) {
        console.log(error);
      }
    }",0.3995257147874347,0.11318297668686855,0.11386725088392284,0.6210526315789474,0.75,0.31039315814744667,0.1323722033073577,0.12235832401927109,0.5368421052631579,0.45,0.5269191147485908,0.4115015220712077,0.5546591756890844,0.7605633802816901,0.38095238095238093
180,"  it(""parses beginbfchar"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));

        expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));

        expect(cmap.lookup(0x05)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses beginbfrange with range"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x05)).toBeUndefined();

        expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));

        expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));

        expect(cmap.lookup(0x0c)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses beginbfrange with array"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x0c)).toBeUndefined();

        expect(cmap.lookup(0x0d)).toEqual(0x00);

        expect(cmap.lookup(0x12)).toEqual(0x05);

        expect(cmap.lookup(0x13)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses begincidchar"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x14)).toEqual(0x00);

        expect(cmap.lookup(0x15)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses begincidrange"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x15)).toBeUndefined();

        expect(cmap.lookup(0x16)).toEqual(0x00);

        expect(cmap.lookup(0x1b)).toEqual(0x05);

        expect(cmap.lookup(0x1c)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""decodes codespace ranges"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        const c = {};

        cmap.readCharCode(String.fromCharCode(1), 0, c);

        expect(c.charcode).toEqual(1);

        expect(c.length).toEqual(1);

        cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);

        expect(c.charcode).toEqual(3);

        expect(c.length).toEqual(4);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""decodes 4 byte codespace ranges"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        const c = {};

        cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);

        expect(c.charcode).toEqual(0x8ea1a1a1);

        expect(c.length).toEqual(4);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""read usecmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof CMap).toEqual(true);

        expect(cmap.useCMap).not.toBeNull();

        expect(cmap.builtInCMap).toBeFalsy();

        expect(cmap.length).toEqual(0x20a7);

        expect(cmap.isIdentityCMap).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses cmapname"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.name).toEqual(""Identity-H"");

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses wmode"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.vertical).toEqual(true);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""loads built in cmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof CMap).toEqual(true);

        expect(cmap.useCMap).toBeNull();

        expect(cmap.builtInCMap).toBeTruthy();

        expect(cmap.length).toEqual(0x20a7);

        expect(cmap.isIdentityCMap).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""loads built in identity cmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof IdentityCMap).toEqual(true);

        expect(cmap.vertical).toEqual(false);

        expect(cmap.length).toEqual(0x10000);

        expect(function () {

          return cmap.isIdentityCMap;

        }).toThrow(new Error(""should not access .isIdentityCMap""));

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""attempts to load a non-existent built-in CMap"", function (done) {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""null""),

      fetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(""Unknown CMap name: null"");

        done();

      }

    );

  it(""attempts to load a built-in CMap without the necessary API parameters"", function (done) {

      return CMapReaderFactory.fetch({

        name,

    }

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(

          'The CMap ""baseUrl"" parameter must be specified, ensure that ' +

            'the ""cMapUrl"" and ""cMapPacked"" API parameters are provided.'

        );

        done();

      }

    );

  it(""attempts to load a built-in CMap with inconsistent API parameters"", function (done) {

      return CMapReaderFactory.fetch({

        name,

    }

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        const message = reason.message;

        expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

        expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(

          true

        );

        done();

      }

    );
","  it(""parses beginbfchar"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));

    expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));

    expect(cmap.lookup(0x05)).toBeUndefined();



  it(""parses beginbfrange with range"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x05)).toBeUndefined();

    expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));

    expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));

    expect(cmap.lookup(0x0c)).toBeUndefined();



  it(""parses beginbfrange with array"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x0c)).toBeUndefined();

    expect(cmap.lookup(0x0d)).toEqual(0x00);

    expect(cmap.lookup(0x12)).toEqual(0x05);

    expect(cmap.lookup(0x13)).toBeUndefined();



  it(""parses begincidchar"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x14)).toEqual(0x00);

    expect(cmap.lookup(0x15)).toBeUndefined();



  it(""parses begincidrange"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.lookup(0x15)).toBeUndefined();

    expect(cmap.lookup(0x16)).toEqual(0x00);

    expect(cmap.lookup(0x1b)).toEqual(0x05);

    expect(cmap.lookup(0x1c)).toBeUndefined();



  it(""decodes codespace ranges"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    const c = {};

    cmap.readCharCode(String.fromCharCode(1), 0, c);

    expect(c.charcode).toEqual(1);

    expect(c.length).toEqual(1);

    cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);

    expect(c.charcode).toEqual(3);

    expect(c.length).toEqual(4);



  it(""decodes 4 byte codespace ranges"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    const c = {};

    cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);

    expect(c.charcode).toEqual(0x8ea1a1a1);

    expect(c.length).toEqual(4);



  it(""read usecmap"", async function () {

    const cmap = await CMapFactory.create({

    expect(cmap instanceof CMap).toEqual(true);

    expect(cmap.useCMap).not.toBeNull();

    expect(cmap.builtInCMap).toBeFalsy();

    expect(cmap.length).toEqual(0x20a7);

    expect(cmap.isIdentityCMap).toEqual(false);



  it(""parses cmapname"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.name).toEqual(""Identity-H"");



  it(""parses wmode"", async function () {

    const cmap = await CMapFactory.create({ encoding: stream });

    expect(cmap.vertical).toEqual(true);



  it(""loads built in cmap"", async function () {

    const cmap = await CMapFactory.create({

    expect(cmap instanceof CMap).toEqual(true);

    expect(cmap.useCMap).toBeNull();

    expect(cmap.builtInCMap).toBeTruthy();

    expect(cmap.length).toEqual(0x20a7);

    expect(cmap.isIdentityCMap).toEqual(false);



  it(""loads built in identity cmap"", async function () {

    const cmap = await CMapFactory.create({

    expect(cmap instanceof IdentityCMap).toEqual(true);

    expect(cmap.vertical).toEqual(false);

    expect(cmap.length).toEqual(0x10000);

    expect(function () {

      return cmap.isIdentityCMap;

    }).toThrow(new Error(""should not access .isIdentityCMap""));

  it(""attempts to load a non-existent built-in CMap"", async function () {

    try {

      await CMapFactory.create({

        encoding: Name.get(""null""),

        fetchBuiltInCMap,

        useCMap: null,

      });



      // Shouldn't get here.

      expect(false).toEqual(true);

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      expect(reason.message).toEqual(""Unknown CMap name: null"");

    }

  it(""attempts to load a built-in CMap without the necessary API parameters"", async function () {

      return CMapReaderFactory.fetch({ name });

    }

    try {

      await CMapFactory.create({

        encoding: Name.get(""Adobe-Japan1-1""),

        fetchBuiltInCMap: tmpFetchBuiltInCMap,

        useCMap: null,

      // Shouldn't get here.

      expect(false).toEqual(true);

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      expect(reason.message).toEqual(

        'The CMap ""baseUrl"" parameter must be specified, ensure that ' +

          'the ""cMapUrl"" and ""cMapPacked"" API parameters are provided.'

      );

    }

  it(""attempts to load a built-in CMap with inconsistent API parameters"", async function () {

      return CMapReaderFactory.fetch({ name });

    }

    try {

      await CMapFactory.create({

        encoding: Name.get(""Adobe-Japan1-1""),

        fetchBuiltInCMap: tmpFetchBuiltInCMap,

        useCMap: null,

      // Shouldn't get here.

      expect(false).toEqual(true);

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      const message = reason.message;

      expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

      expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(true);

    }
","it(""parses beginbfchar"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));
  expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));
  expect(cmap.lookup(0x05)).toBeUndefined();
});

it(""parses beginbfrange with range"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap.lookup(0x05)).toBeUndefined();
  expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));
  expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));
  expect(cmap.lookup(0x0c)).toBeUndefined();
});

it(""parses beginbfrange with array"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap.lookup(0x0c)).toBeUndefined();
  expect(cmap.lookup(0x0d)).toEqual(0x00);
  expect(cmap.lookup(0x12)).toEqual(0x05);
  expect(cmap.lookup(0x13)).toBeUndefined();
});

it(""parses begincidchar"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap.lookup(0x14)).toEqual(0x00);
  expect(cmap.lookup(0x15)).toBeUndefined();
});

it(""parses begincidrange"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap.lookup(0x15)).toBeUndefined();
  expect(cmap.lookup(0x16)).toEqual(0x00);
  expect(cmap.lookup(0x1b)).toEqual(0x05);
  expect(cmap.lookup(0x1c)).toBeUndefined();
});

it(""decodes codespace ranges"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  const c = {};
  cmap.readCharCode(String.fromCharCode(1), 0, c);
  expect(c.charcode).toEqual(1);
  expect(c.length).toEqual(1);
  cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);
  expect(c.charcode).toEqual(3);
  expect(c.length).toEqual(4);
});

it(""decodes 4 byte codespace ranges"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  const c = {};
  cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);
  expect(c.charcode).toEqual(0x8ea1a1a1);
  expect(c.length).toEqual(4);
});

it(""read usecmap"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap instanceof CMap).toEqual(true);
  expect(cmap.useCMap).not.toBeNull();
  expect(cmap.builtInCMap).toBeFalsy();
  expect(cmap.length).toEqual(0x20a7);
  expect(cmap.isIdentityCMap).toEqual(false);
});

it(""parses cmapname"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap.name).toEqual(""Identity-H"");
});

it(""parses wmode"", async () => {
  const cmap = await CMapFactory.create({ encoding: stream });
  expect(cmap.vertical).toEqual(true);
});

it(""loads built in cmap"", async () => {
  const cmap = await CMapFactory.create({
    cmapPromise
  });
  expect(cmap instanceof CMap).toEqual(true);
  expect(cmap.useCMap).toBeNull();
  expect(cmap.builtInCMap).toBeTruthy();
  expect(cmap.length).toEqual(0x20a7);
  expect(cmap.isIdentityCMap).toEqual(false);
});

it(""loads built in identity cmap"", async () => {
  const cmap = await CMapFactory.create({
    cmapPromise
  });
  expect(cmap instanceof IdentityCMap).toEqual(true);
  expect(cmap.vertical).toEqual(false);
  expect(cmap.length).toEqual(0x10000);
  expect(function () {
    return cmap.isIdentityCMap;
  }).toThrow(new Error(""should not access .isIdentityCMap""));
});

it(""attempts to load a non-existent built-in CMap"", async () => {
  const cmapPromise = await CMapFactory.create({
    encoding: Name.get(""null""),
    fetchBuiltInCMap,
    useCMap: null,
  });
  expect(cmapPromise).toBeNull();
});

it(""attempts to load a built-in CMap without the necessary API parameters"", async () => {
  const cmapPromise = await CMapFactory.create({
    name,
  });
  expect(cmapPromise).toBeNull();
});

it(""attempts to load a built-in CMap with inconsistent API parameters"", async () => {
  const cmapPromise = await CMapFactory.create({
    encoding: Name.get(""Adobe-Japan1-1""),
    fetchBuiltInCMap: tmpFetchBuiltInCMap,
    useCMap: null,
  });
  expect(cmapPromise).toBeNull();
});",0.4100572814133712,0.370493259028305,0.39475732358581805,0.6486175115207373,0.22636103151862463,0.36643721698301496,0.27671465338395407,0.3071729387502371,0.6497695852534562,0.23209169054441262,0.720738673102802,0.5560967959871838,0.5529453913381391,0.9001751313485113,0.8737373737373737
181,"        ensure(obj, prop, args) {

          return new Promise(function (resolve) {

            const value = obj[prop];

            if (typeof value === ""function"") {

              resolve(value.apply(obj, args));

            } else {

              resolve(value);

            }

          });
","        ensureDoc(prop, args) {

          return pdfManager.ensure(pdfDocument, prop, args);

        },

        async ensure(obj, prop, args) {

          const value = obj[prop];

          if (typeof value === ""function"") {

            return value.apply(obj, args);

          }

          return value;
","async function ensure (obj, prop, args) {

    try{

        const value = obj[prop];

        if (typeof value === ""function"") {

            return await value.apply(obj, args);

        } else {

            return await value;

        }

} catch (err) {

    throw err;

}",0.4882572117157472,0.460815302847248,0.49451769148117874,0.3548387096774194,0.6428571428571429,0.46017630945194654,0.3387693170882605,0.4650695612725209,0.3225806451612903,0.7142857142857143,0.48996309963454543,0.3742031646082125,0.4745381228188583,0.4444444444444444,0.6666666666666666
182,"      const promises = [

      ];

      Promise.all(promises)

        .then(function (data) {

          expect(data[0].loaded / data[0].total >= 0).toEqual(true);

          expect(data[1] instanceof PDFDocumentProxy).toEqual(true);

          expect(loadingTask).toEqual(data[1].loadingTask);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""creates pdf doc from URL and aborts before worker initialized"", function (done) {

      loadingTask.promise

        .then(function (reason) {

          done.fail(""shall fail loading"");

        })

        .catch(function (reason) {

          expect(true).toEqual(true);

          destroyed.then(done);

        });

    it(""creates pdf doc from URL and aborts loading after worker initialized"", function (done) {

      destroyed

        .then(function (data) {

          expect(true).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""creates pdf doc from typed array"", function (done) {

      const typedArrayPdfPromise = DefaultFileReaderFactory.fetch({

      typedArrayPdfPromise

        .then(typedArrayPdf => {

          // Sanity check to make sure that we fetched the entire PDF file.

          expect(typedArrayPdf.length).toEqual(basicApiFileLength);

          const loadingTask = getDocument(typedArrayPdf);

          const progressReportedCapability = createPromiseCapability();

          loadingTask.onProgress = function (data) {

            progressReportedCapability.resolve(data);

          };

          return Promise.all([

            loadingTask.promise,

            progressReportedCapability.promise,

          ]).then(function (data) {

            expect(data[0] instanceof PDFDocumentProxy).toEqual(true);

            expect(data[1].loaded / data[1].total).toEqual(1);

            loadingTask.destroy().then(done);

          });

        })

        .catch(done.fail);

    it(""creates pdf doc from invalid PDF file"", function (done) {

      loadingTask.promise

        .then(function () {

          done.fail(""shall fail loading"");

        })

        .catch(function (reason) {

          expect(reason instanceof InvalidPDFException).toEqual(true);

          expect(reason.message).toEqual(""Invalid PDF structure."");

          loadingTask.destroy().then(done);

        });

    it(""creates pdf doc from non-existent URL"", function (done) {

        // re-enable https://github.com/mozilla/pdf.js/issues/13061

        pending(""Fails intermittently on linux in browsers."");

      loadingTask.promise

        .then(function (error) {

          done.fail(""shall fail loading"");

        })

        .catch(function (error) {

          expect(error instanceof MissingPDFException).toEqual(true);

          loadingTask.destroy().then(done);

        });

    it(""creates pdf doc from PDF file protected with user and owner password"", function (done) {
","      const data = await Promise.all([

      ]);



      expect(data[0].loaded / data[0].total >= 0).toEqual(true);

      expect(data[1] instanceof PDFDocumentProxy).toEqual(true);

      expect(loadingTask).toEqual(data[1].loadingTask);



      await loadingTask.destroy();



    it(""creates pdf doc from URL and aborts before worker initialized"", async function () {

      try {

        await loadingTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(true).toEqual(true);

        await destroyed;

      }



    it(""creates pdf doc from URL and aborts loading after worker initialized"", async function () {



      await destroyed;

      expect(true).toEqual(true);



    it(""creates pdf doc from typed array"", async function () {

      const typedArrayPdf = await DefaultFileReaderFactory.fetch({

      // Sanity check to make sure that we fetched the entire PDF file.

      expect(typedArrayPdf.length).toEqual(basicApiFileLength);

      const loadingTask = getDocument(typedArrayPdf);

      const progressReportedCapability = createPromiseCapability();

      loadingTask.onProgress = function (data) {

        progressReportedCapability.resolve(data);

      };

      const data = await Promise.all([

        loadingTask.promise,

        progressReportedCapability.promise,

      ]);

      expect(data[0] instanceof PDFDocumentProxy).toEqual(true);

      expect(data[1].loaded / data[1].total).toEqual(1);

      await loadingTask.destroy();



    it(""creates pdf doc from invalid PDF file"", async function () {

      try {

        await loadingTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof InvalidPDFException).toEqual(true);

        expect(reason.message).toEqual(""Invalid PDF structure."");

      }



      await loadingTask.destroy();



    it(""creates pdf doc from non-existent URL"", async function () {

        // Re-enable in https://github.com/mozilla/pdf.js/issues/13061.

        pending(""Fails intermittently on Linux in browsers."");



      try {

        await loadingTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof MissingPDFException).toEqual(true);

      }



      await loadingTask.destroy();



    it(""creates pdf doc from PDF file protected with user and owner password"", async function () {
","const promises = [];

async function createPdfDocFromUrl() {
  const loadingTask = getDocument(url);
  try {
    const data = await loadingTask.promise;
    expect(data instanceof PDFDocumentProxy).toEqual(true);
    done();
  } catch (error) {
    done.fail(""shall fail loading"");
  } finally {
    loadingTask.destroy().then(done);
  }
}

async function createPdfDocFromTypedArray() {
  const typedArrayPdfPromise = DefaultFileReaderFactory.fetch({
    typedArrayPdfPromise,
  });
  try {
    const data = await loadingTask.promise;
    expect(data[0] instanceof PDFDocumentProxy).toEqual(true);
    done();
  } catch (error) {
    done.fail(""shall fail loading"");
  } finally {
    loadingTask.destroy().then(done);
  }
}

async function createPdfDocFromInvalidPdfFile() {
  const loadingTask = getDocument(invalidUrl);
  try {
    await loadingTask.promise;
    done.fail(""shall fail loading"");
  } catch (error) {
    expect(error instanceof InvalidPDFException).toEqual(true);
    expect(error.message).toEqual(""Invalid PDF structure."");
  } finally {
    loadingTask.destroy().then(done);
  }
}

async function createPdfDocFromNonExistentUrl() {
  const loadingTask = getDocument(nonExistentUrl);
  try {
    await loadingTask.promise;
    done.fail(""shall fail loading"");
  } catch (error) {
    expect(error instanceof MissingPDFException).toEqual(true);
  } finally {
    loadingTask.destroy().then(done);
  }
}

async function createPdfDocFromProtectedPdfFile() {
  const loadingTask = getDocument(protectedUrl, {
    password: ""test"",
  });
  try {
    const data = await loadingTask.promise;
    expect(data instanceof PDFDocumentProxy).toEqual(true);
    done();
  } catch (error) {
    done.fail(""shall fail loading"");
  } finally {
    loadingTask.destroy().then(done);
  }
}",0.5369929606496713,0.4669102115314238,0.48589222482774436,0.6678966789667896,0.5272727272727272,0.2804279240599627,0.10075999387618656,0.11145824379271489,0.5276752767527675,0.38181818181818183,0.3127334461393193,0.08325539924903654,0.09430440156840321,0.5317073170731708,0.5416666666666666
183,"      const promises = [

      ];

      Promise.all(promises)

        .then(function (data) {

          expect(data[2] instanceof PDFDocumentProxy).toEqual(true);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""creates pdf doc from PDF file protected with only a user password"", function (done) {
","      const data = await Promise.all([

      ]);

      expect(data[2] instanceof PDFDocumentProxy).toEqual(true);



      await loadingTask.destroy();



    it(""creates pdf doc from PDF file protected with only a user password"", async function () {
","async function createPdfDocFromPDFFileProtectedWithOnlyAUserPassword(done) {
  try {
    const promises = [];
    await Promise.all(promises);
    expect(data[2] instanceof PDFDocumentProxy).toEqual(true);
    await loadingTask.destroy();
    done();
  } catch (err) {
    done.fail();
  }
}",0.4159326285030989,0.4392441679776515,0.46258158412998246,0.42857142857142855,0.3333333333333333,0.263259063579897,0.057134546679170804,0.06256837430708388,0.6,0.3333333333333333,0.3128085589253995,0.1676136890247661,0.18144663363335373,0.6521739130434783,0.25
184,"      Promise.all([result1, result2, result3])

        .then(function () {

          done();

        })

        .catch(done.fail);

      function (done) {
","

      await Promise.all([result1, result2, result3]);

      async function () {
","async function run() {
  const [result1, result2, result3] = await Promise.all([result1, result2, result3]);
  done();
}",0.3539208441371681,0.05327524291588724,0.05806030754582867,0.30434782608695654,0.0,0.20215221598923347,0.03514847831369806,0.048822704483815524,0.391304347826087,0.3333333333333333,0.5458774748250039,0.20333448190047881,0.4347208719449914,0.5454545454545454,0.0
185,"        Promise.all([result1, result2])

          .then(function () {

            done();

          })

          .catch(done.fail);

    it(""creates pdf doc from empty typed array"", function (done) {

      loadingTask.promise.then(

        function () {

          done.fail(""shall not open empty file"");

        },

        function (reason) {

          expect(reason instanceof InvalidPDFException);

          expect(reason.message).toEqual(

            ""The PDF file is empty, i.e. its size is zero bytes.""

          );

          loadingTask.destroy().then(done);

        }

      );

    it(""worker created or destroyed"", function (done) {

      worker.promise

        .then(function () {

          expect(worker.name).toEqual(""test1"");

          expect(!!worker.port).toEqual(true);

          expect(worker.destroyed).toEqual(false);

          expect(!!worker._webWorker).toEqual(true);

          expect(worker.port === worker._webWorker).toEqual(true);



          worker.destroy();

          expect(!!worker.port).toEqual(false);

          expect(worker.destroyed).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""worker created or destroyed by getDocument"", function (done) {
","        await Promise.all([result1, result2]);

    it(""creates pdf doc from empty typed array"", async function () {

      try {

        await loadingTask.promise;

        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof InvalidPDFException).toEqual(true);

        expect(reason.message).toEqual(

          ""The PDF file is empty, i.e. its size is zero bytes.""

        );

      }



      await loadingTask.destroy();

    it(""worker created or destroyed"", async function () {

      await worker.promise;

      expect(worker.name).toEqual(""test1"");

      expect(!!worker.port).toEqual(true);

      expect(worker.destroyed).toEqual(false);

      expect(!!worker._webWorker).toEqual(true);

      expect(worker.port === worker._webWorker).toEqual(true);



      worker.destroy();

      expect(!!worker.port).toEqual(false);

      expect(worker.destroyed).toEqual(true);



    it(""worker created or destroyed by getDocument"", async function () {
","async function() {

  try {

    const result1 = await Promise.all([result1, result2]);

    done();

  } catch (reason) {

    expect(reason instanceof InvalidPDFException);

    expect(reason.message).toEqual(

      ""The PDF file is empty, i.e. its size is zero bytes.""

    );

    loadingTask.destroy().then(done);

  }

}

it(""creates pdf doc from empty typed array"", async function () {

  try {

    await worker.promise;

    expect(worker.name).toEqual(""test1"");

    expect(!!worker.port).toEqual(true);

    expect(worker.destroyed).toEqual(false);

    expect(!!worker._webWorker).toEqual(true);

    expect(worker.port === worker._webWorker).toEqual(true);

  } catch (reason) {

    expect(reason instanceof InvalidPDFException);

    expect(reason.message).toEqual(

      ""The PDF file is empty, i.e. its size is zero bytes.""

    );

    loadingTask.destroy().then(done);

  }

}

it(""worker created or destroyed"", async function () {

  try {

    await worker.promise;

    expect(worker.name).toEqual(""test1"");

    expect(!!worker.port).toEqual(true);

    expect(worker.destroyed).toEqual(false);

    expect(!!worker._webWorker).toEqual(true);

    expect(worker.port === worker._webWorker).toEqual(true);

  } catch (reason) {

    expect(reason instanceof InvalidPDFException);

    expect(reason.message).toEqual(

      ""The PDF file is empty, i.e. its size is zero bytes.""

    );

    loadingTask.destroy().then(done);

  }

}

it(""worker created or destroyed by getDocument"", async function () {

  try {

    await worker.promise;

    expect(worker.name).toEqual(""test1"");

    expect(!!worker.port).toEqual(true);

    expect(worker.destroyed).toEqual(false);

    expect(!!worker._webWorker).toEqual(true);

    expect(worker.port === worker._webWorker).toEqual(true);

  } catch (reason) {

    expect(reason instanceof InvalidPDFException);

    expect(reason.message).toEqual(

      ""The PDF file is empty, i.e. its size is zero bytes.""

    );

    loadingTask.destroy().then(done);

  }

}",0.5398622497936763,0.46144823043284544,0.46219379388378984,0.708029197080292,0.5277777777777778,0.5014171221776123,0.24352343228166046,0.4898417312057555,0.7445255474452555,0.5277777777777778,0.546893607599043,0.32296153226423235,0.7233645068835486,0.8198198198198198,0.32142857142857145
186,"      destroyPromise

        .then(function () {

          const destroyedWorker = loadingTask._worker;

          expect(!!destroyedWorker).toEqual(false);

          expect(worker.destroyed).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""worker created and can be used in getDocument"", function (done) {
","      await destroyPromise;



      const destroyedWorker = loadingTask._worker;

      expect(!!destroyedWorker).toEqual(false);

      expect(worker.destroyed).toEqual(true);



    it(""worker created and can be used in getDocument"", async function () {
","async () => {
  try {
    const destroyedWorker = await loadingTask._worker;
    expect(!!destroyedWorker).toEqual(false);
    expect(worker.destroyed).toEqual(true);
    done();
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}",0.5912392266812863,0.5112524626996514,0.52989492021597,0.6571428571428571,0.6666666666666666,0.5153184752794929,0.19940445989088912,0.20472658408422542,0.6571428571428571,1.0,0.4754629152120261,0.07164684238257436,0.09107438368292145,0.7391304347826086,1.0
187,"      destroyPromise

        .then(function () {

          expect(worker.destroyed).toEqual(false);

          worker.destroy();

          done();

        })

        .catch(done.fail);

    it(""creates more than one worker"", function (done) {
","      await destroyPromise;



      expect(worker.destroyed).toEqual(false);

      worker.destroy();



    it(""creates more than one worker"", async function () {
","`
async () => {
  try {
    await destroyPromise;
    expect(worker.destroyed).toEqual(false);
    worker.destroy();
    done();
  } catch (error) {
    done.fail(error);
  }
}

async () => {
  try {
    const workers = await createWorkersPromise;
    expect(workers).toBeDefined();
    expect(workers.length > 1).toEqual(true);
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.39440964774403153,0.2797803653491597,0.2907153684841096,0.6071428571428571,0.4,0.38323191931212097,0.025852698129040588,0.0642178362623003,0.6428571428571429,0.8,0.5396943525908943,0.06288149902199816,0.22089591134157885,0.875,1.0
188,"      const ready = Promise.all([

        worker1.promise,

        worker2.promise,

        worker3.promise,

      ]);

      ready

        .then(function () {

          expect(

            worker1.port !== worker2.port &&

              worker1.port !== worker3.port &&

              worker2.port !== worker3.port

          ).toEqual(true);

          worker1.destroy();

          worker2.destroy();

          worker3.destroy();

          done();

        })

        .catch(done.fail);
","      await Promise.all([worker1.promise, worker2.promise, worker3.promise]);



      expect(

        worker1.port !== worker2.port &&

          worker1.port !== worker3.port &&

          worker2.port !== worker3.port

      ).toEqual(true);

      worker1.destroy();

      worker2.destroy();

      worker3.destroy();


","const ready = Promise.all([

        worker1.promise,

        worker2.promise,

        worker3.promise,

      ]);

       async function () {

         try{

           const resolvedValue = await ready;

            expect(

              worker1.port !== worker2.port &&

                worker1.port !== worker3.port &&

                worker2.port !== worker3.port

            ).toEqual(true);

            worker1.destroy();

            worker2.destroy();

            worker3.destroy();

          } catch (err) {

            done.fail(err);

          } finally{

            done();

          }

        }",0.49079112195671615,0.4585795367839404,0.4830216087248652,0.7358490566037735,0.2857142857142857,0.7468737386402217,0.5118114004476522,0.740732970106047,0.8301886792452831,0.9047619047619048,0.6458757702121449,0.3504452825909103,0.8099808751807465,0.9230769230769231,0.5
189,"    beforeAll(function (done) {

      pdfLoadingTask.promise.then(function (data) {

        pdfDocument = data;

        done();

      });

    afterAll(function (done) {

      pdfLoadingTask.destroy().then(done);

    it(""gets page"", function (done) {

      const promise = pdfDocument.getPage(1);

      promise

        .then(function (data) {

          expect(data instanceof PDFPageProxy).toEqual(true);

          expect(data.pageNumber).toEqual(1);

          done();

        })

        .catch(done.fail);

    it(""gets non-existent page"", function (done) {
","

    beforeAll(async function () {

      pdfDocument = await pdfLoadingTask.promise;

    afterAll(async function () {

      await pdfLoadingTask.destroy();





    it(""gets page"", async function () {

      const data = await pdfDocument.getPage(1);

      expect(data instanceof PDFPageProxy).toEqual(true);

      expect(data.pageNumber).toEqual(1);



    it(""gets non-existent page"", async function () {
","beforeAll(async function () {
    const data = await pdfLoadingTask.promise;
    pdfDocument = data;
  });

  afterAll(async function () {
    await pdfLoadingTask.destroy();
  });

  it(""gets page"", async function () {
    try {
      const data = await pdfDocument.getPage(1);
      expect(data instanceof PDFPageProxy).toEqual(true);
      expect(data.pageNumber).toEqual(1);
    } catch (error) {
      done.fail(error);
    }
  });

  it(""gets non-existent page"", async function () {
    try {
      const data = await pdfDocument.getPage(1);
      expect(data instanceof PDFPageProxy).toEqual(true);
      expect(data.pageNumber).toEqual(1);
    } catch (error) {
      done.fail(error);
    }
  });",0.2743389012755184,0.1307445502762405,0.13994438815916643,0.4666666666666667,0.36,0.34516934579573544,0.080331199191236,0.1436795173250391,0.5166666666666667,0.64,0.6631787920853754,0.4049620854394213,0.7926248777738754,0.9166666666666666,0.5384615384615384
190,"      Promise.all([outOfRangePromise, nonIntegerPromise, nonNumberPromise])

        .then(function () {

          done();

        })

        .catch(done.fail);

    it(""gets page, from /Pages tree with circular reference"", function (done) {
","      await Promise.all([

        outOfRangePromise,

        nonIntegerPromise,

        nonNumberPromise,

      ]);

    it(""gets page, from /Pages tree with circular reference"", async function () {
","async function getPage() {
  try {
    await Promise.all([outOfRangePromise, nonIntegerPromise, nonNumberPromise]);
  } catch (error) {
    done(error);
  } finally {
    done();
  }
}",0.5364811178918836,0.3982080290671198,0.4143831091670813,0.3333333333333333,0.0,0.3015956316528866,0.030232667130855925,0.03329271662354771,0.47619047619047616,0.6666666666666666,0.45854254553586954,0.024289783953423513,0.0321026204122769,0.7777777777777778,0.0
191,"      Promise.all([page1, page2]).then(function () {

        loadingTask.destroy().then(done);

      }, done.fail);

    it(""gets page index"", function (done) {

      // reference to second page

      const ref = { num: 17, gen: 0 };

      const promise = pdfDocument.getPageIndex(ref);

      promise

        .then(function (pageIndex) {

          expect(pageIndex).toEqual(1);

          done();

        })

        .catch(done.fail);

    it(""gets invalid page index"", function (done) {

      const promise = pdfDocument.getPageIndex(ref);

      promise

        .then(function () {

          done.fail(""shall fail for invalid page reference."");

        })

        .catch(function (reason) {

          expect(reason instanceof Error).toEqual(true);

          done();

        });

    it(""gets destinations, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestinations();

      promise

        .then(function (data) {

          expect(data).toEqual({

            chapter1: [{ gen: 0, num: 17 }, { name: ""XYZ"" }, 0, 841.89, null],

          });

          done();

        })

        .catch(done.fail);

    it(""gets a destination, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestination(""chapter1"");

      promise

        .then(function (data) {

          expect(data).toEqual([

            { gen: 0, num: 17 },

            { name: ""XYZ"" },

            0,

            841.89,

            null,

          ]);

          done();

        })

        .catch(done.fail);

    it(""gets a non-existent destination, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestination(

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets destinations, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestinations();

      promise

        .then(function (destinations) {

          expect(destinations).toEqual({

            ""Page.1"": [{ num: 1, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

            ""Page.2"": [{ num: 6, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

          });

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets a destination, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestination(""Page.1"");

      });

      promise

        .then(function (destination) {

          expect(destination).toEqual([

            { num: 1, gen: 0 },

            { name: ""XYZ"" },

            0,

            375,

            null,

          ]);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets a non-existent destination, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestination(""non-existent-named-destination"");

      });

      promise

        .then(function (destination) {

          expect(destination).toEqual(null);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets non-string destination"", function (done) {
","      await Promise.all([page1, page2]);

      await loadingTask.destroy();

    it(""gets page index"", async function () {

      const ref = { num: 17, gen: 0 }; // Reference to second page.

      const pageIndex = await pdfDocument.getPageIndex(ref);

      expect(pageIndex).toEqual(1);



    it(""gets invalid page index"", async function () {



      try {

        await pdfDocument.getPageIndex(ref);



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof Error).toEqual(true);

      }

    it(""gets destinations, from /Dests dictionary"", async function () {

      const destinations = await pdfDocument.getDestinations();

      expect(destinations).toEqual({

        chapter1: [{ gen: 0, num: 17 }, { name: ""XYZ"" }, 0, 841.89, null],

      });



    it(""gets a destination, from /Dests dictionary"", async function () {

      const destination = await pdfDocument.getDestination(""chapter1"");

      expect(destination).toEqual([

        { gen: 0, num: 17 },

        { name: ""XYZ"" },

        0,

        841.89,

        null,

      ]);



    it(""gets a non-existent destination, from /Dests dictionary"", async function () {

      const destination = await pdfDocument.getDestination(

      expect(destination).toEqual(null);

    it(""gets destinations, from /Names (NameTree) dictionary"", async function () {

      const pdfDoc = await loadingTask.promise;

      const destinations = await pdfDoc.getDestinations();

      expect(destinations).toEqual({

        ""Page.1"": [{ num: 1, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

        ""Page.2"": [{ num: 6, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

      await loadingTask.destroy();



    it(""gets a destination, from /Names (NameTree) dictionary"", async function () {

      const pdfDoc = await loadingTask.promise;

      const destination = await pdfDoc.getDestination(""Page.1"");

      expect(destination).toEqual([

        { num: 1, gen: 0 },

        { name: ""XYZ"" },

        0,

        375,

        null,

      ]);

      await loadingTask.destroy();



    it(""gets a non-existent destination, from /Names (NameTree) dictionary"", async function () {

      const pdfDoc = await loadingTask.promise;

      const destination = await pdfDoc.getDestination(

        ""non-existent-named-destination""

      );

      expect(destination).toEqual(null);

      await loadingTask.destroy();

    it(""gets non-string destination"", async function () {
","async function getPageIndex(ref) {
  try {
    const pageIndex = await pdfDocument.getPageIndex(ref);
    return pageIndex;
  } catch (error) {
    return null;
  }
}

async function getDestinations() {
  const destinations = await pdfDocument.getDestinations();
  return destinations;
}

async function getDestination(name) {
  try {
    const destination = await pdfDocument.getDestination(name);
    return destination;
  } catch (error) {
    return null;
  }
}",0.43616911290857097,0.42702799518157497,0.4372670197076359,0.5415384615384615,0.33884297520661155,0.09282841478841242,0.00024389831601261708,0.0042038994263210805,0.2676923076923077,0.09917355371900827,0.1301534336161754,0.0065619703549302955,0.0640847238988287,0.28780487804878047,0.16216216216216217
192,"      Promise.all([numberPromise, booleanPromise, arrayPromise]).then(

        done,

        done.fail

      );

    it(""gets non-existent page labels"", function (done) {

      const promise = pdfDocument.getPageLabels();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets page labels"", function (done) {
","      await Promise.all([numberPromise, booleanPromise, arrayPromise]);

    it(""gets non-existent page labels"", async function () {

      const pageLabels = await pdfDocument.getPageLabels();

      expect(pageLabels).toEqual(null);



    it(""gets page labels"", async function () {
","async function test() {
      const numberPromise = pdfDocument.getPageLabels();
      const booleanPromise = numberPromise.then((data) => expect(data).toEqual(null));
      try {
        await booleanPromise;
        done();
      } catch (error) {
        done.fail(error);
      }
    }",0.26757353495405245,0.14347581549307062,0.15392455142936648,0.48717948717948717,0.2857142857142857,0.21084131974287745,0.021320565395732852,0.023509915040978442,0.5128205128205128,0.2857142857142857,0.25833800524311623,0.02584145048742771,0.02924970091981984,0.4782608695652174,0.5
193,"      Promise.all([promise0, promise1, promise2, promise3])

        .then(function (pageLabels) {

          expect(pageLabels[0]).toEqual([""i"", ""ii"", ""iii"", ""1""]);

          expect(pageLabels[1]).toEqual([""Front Page1""]);

          expect(pageLabels[2]).toEqual([""1"", ""2""]);

          expect(pageLabels[3]).toEqual([""X3""]);



          Promise.all([

            loadingTask0.destroy(),

            loadingTask1.destroy(),

            loadingTask2.destroy(),

            loadingTask3.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    it(""gets default page layout"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getPageLayout();

        })

        .then(function (mode) {

          expect(mode).toEqual("""");

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default page layout"", function (done) {

      pdfDocument

        .getPageLayout()

        .then(function (mode) {

          expect(mode).toEqual(""SinglePage"");

          done();

        })

        .catch(done.fail);

    it(""gets default page mode"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getPageMode();

        })

        .then(function (mode) {

          expect(mode).toEqual(""UseNone"");

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default page mode"", function (done) {

      pdfDocument

        .getPageMode()

        .then(function (mode) {

          expect(mode).toEqual(""UseOutlines"");

          done();

        })

        .catch(done.fail);

    it(""gets default viewer preferences"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getViewerPreferences();

        })

        .then(function (prefs) {

          expect(prefs).toEqual(null);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default viewer preferences"", function (done) {

      pdfDocument

        .getViewerPreferences()

        .then(function (prefs) {

          expect(prefs).toEqual({

            Direction: ""L2R"",

          });

          done();

        })

        .catch(done.fail);

    it(""gets default open action"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getOpenAction();

        })

        .then(function (openAction) {

          expect(openAction).toEqual(null);



          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets non-default open action (with destination)"", function (done) {

      pdfDocument

        .getOpenAction()

        .then(function (openAction) {

          expect(openAction.dest).toEqual([

            { num: 15, gen: 0 },

            { name: ""FitH"" },

            null,

          ]);

          expect(openAction.action).toBeUndefined();

          done();

        })

        .catch(done.fail);

    it(""gets non-default open action (with Print action)"", function (done) {
","      const pageLabels = await Promise.all([

        promise0,

        promise1,

        promise2,

        promise3,

      ]);

      expect(pageLabels[0]).toEqual([""i"", ""ii"", ""iii"", ""1""]);

      expect(pageLabels[1]).toEqual([""Front Page1""]);

      expect(pageLabels[2]).toEqual([""1"", ""2""]);

      expect(pageLabels[3]).toEqual([""X3""]);



      await Promise.all([

        loadingTask0.destroy(),

        loadingTask1.destroy(),

        loadingTask2.destroy(),

        loadingTask3.destroy(),

      ]);

    it(""gets default page layout"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pageLayout = await pdfDoc.getPageLayout();

      expect(pageLayout).toEqual("""");

      await loadingTask.destroy();

    });

    it(""gets non-default page layout"", async function () {

      const pageLayout = await pdfDocument.getPageLayout();

      expect(pageLayout).toEqual(""SinglePage"");

    it(""gets default page mode"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pageMode = await pdfDoc.getPageMode();

      expect(pageMode).toEqual(""UseNone"");

      await loadingTask.destroy();

    });

    it(""gets non-default page mode"", async function () {

      const pageMode = await pdfDocument.getPageMode();

      expect(pageMode).toEqual(""UseOutlines"");

    it(""gets default viewer preferences"", async function () {

      const pdfDoc = await loadingTask.promise;

      const prefs = await pdfDoc.getViewerPreferences();

      expect(prefs).toEqual(null);

      await loadingTask.destroy();

    });

    it(""gets non-default viewer preferences"", async function () {

      const prefs = await pdfDocument.getViewerPreferences();

      expect(prefs).toEqual({ Direction: ""L2R"" });

    it(""gets default open action"", async function () {

      const pdfDoc = await loadingTask.promise;

      const openAction = await pdfDoc.getOpenAction();

      expect(openAction).toEqual(null);

      await loadingTask.destroy();

    it(""gets non-default open action (with destination)"", async function () {

      const openAction = await pdfDocument.getOpenAction();

      expect(openAction.dest).toEqual([

        { num: 15, gen: 0 },

        { name: ""FitH"" },

        null,

      ]);

      expect(openAction.action).toBeUndefined();



    it(""gets non-default open action (with Print action)"", async function () {
","// Migrate from Promises to async/await
    async function getPageLabels() {
      try {
        const pageLabels = await Promise.all([promise0, promise1, promise2, promise3]);
        expect(pageLabels[0]).toEqual([""i"", ""ii"", ""iii"", ""1""]);
        expect(pageLabels[1]).toEqual([""Front Page1""]);
        expect(pageLabels[2]).toEqual([""1"", ""2""]);
        expect(pageLabels[3]).toEqual([""X3""]);
      } catch (error) {
        done.fail(error);
      }
    }
  
    async function getPageLayout() {
      try {
        const pdfDoc = await loadingTask.promise;
        const mode = await pdfDoc.getPageLayout();
        expect(mode).toEqual("""");
        loadingTask.destroy().then(done);
      } catch (error) {
        done.fail(error);
      }
    }
  
    async function getPageMode() {
      try {
        const mode = await pdfDocument.getPageMode();
        expect(mode).toEqual(""SinglePage"");
        done();
      } catch (error) {
        done.fail(error);
      }
    }
  
    async function getViewerPreferences() {
      try {
        const prefs = await pdfDocument.getViewerPreferences();
        expect(prefs).toEqual({ Direction: ""L2R"" });
        done();
      } catch (error) {
        done.fail(error);
      }
    }
  
    async function getOpenAction() {
      try {
        const openAction = await pdfDocument.getOpenAction();
        expect(openAction.dest).toEqual([{ num: 15, gen: 0 }, { name: ""FitH"" }, null]);
        expect(openAction.action).toBeUndefined();
        done();
      } catch (error) {
        done.fail(error);
      }
    }",0.36173783048109437,0.2846044217449463,0.29377851841456853,0.5674931129476584,0.3010752688172043,0.2788193981941326,0.09750550757228237,0.10788138938979858,0.6088154269972452,0.3010752688172043,0.478979402251259,0.20274344759673404,0.2212459743517754,0.8774703557312253,0.6144578313253012
194,"      Promise.all([promise1, promise2]).then(done, done.fail);

    it(""gets non-existent attachments"", function (done) {

      const promise = pdfDocument.getAttachments();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets attachments"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getAttachments();

      });

      promise

        .then(function (data) {

          const attachment = data[""foo.txt""];

          expect(attachment.filename).toEqual(""foo.txt"");

          expect(attachment.content).toEqual(

            new Uint8Array([98, 97, 114, 32, 98, 97, 122, 32, 10])

          );

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets javascript"", function (done) {

      const promise = pdfDocument.getJavaScript();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets javascript with printing instructions (JS action)"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getJavaScript();

      });

      promise

        .then(function (data) {

          expect(data).toEqual([

            ""this.print({bUI:true,bSilent:false,bShrinkToFit:true});"",

          ]);

          expect(data[0]).toMatch(AutoPrintRegExp);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);
","      await Promise.all([promise1, promise2]);

    it(""gets non-existent attachments"", async function () {

      const attachments = await pdfDocument.getAttachments();

      expect(attachments).toEqual(null);



    it(""gets attachments"", async function () {

      const pdfDoc = await loadingTask.promise;

      const attachments = await pdfDoc.getAttachments();

      const attachment = attachments[""foo.txt""];

      expect(attachment.filename).toEqual(""foo.txt"");

      expect(attachment.content).toEqual(

        new Uint8Array([98, 97, 114, 32, 98, 97, 122, 32, 10])

      );



      await loadingTask.destroy();

    it(""gets javascript"", async function () {

      const javascript = await pdfDocument.getJavaScript();

      expect(javascript).toEqual(null);



    it(""gets javascript with printing instructions (JS action)"", async function () {

      const pdfDoc = await loadingTask.promise;

      const javascript = await pdfDoc.getJavaScript();



      expect(javascript).toEqual([

        ""this.print({bUI:true,bSilent:false,bShrinkToFit:true});"",

      ]);

      expect(javascript[0]).toMatch(AutoPrintRegExp);



      await loadingTask.destroy();
","async function getJavaScript() {
  try {
    const promise = await loadingTask.promise.then((pdfDoc) => pdfDoc.getJavaScript());
    const data = await promise;
    expect(data).toEqual([
      ""this.print({bUI:true,bSilent:false,bShrinkToFit:true});"",
    ]);
    expect(data[0]).toMatch(AutoPrintRegExp);
    loadingTask.destroy().then(() => done());
  } catch (error) {
    done.fail(error);
  }
}",0.3538150717313689,0.23599460997317206,0.25131206037593246,0.562874251497006,0.36507936507936506,0.19459032359375195,0.016236126517322425,0.05097603754687841,0.47305389221556887,0.23809523809523808,0.20818380133028064,0.004809078425475435,0.010799856939188508,0.5094339622641509,0.3076923076923077
195,"    it(""checks that fingerprints are unique"", function (done) {

      Promise.all([loadingTask1.promise, loadingTask2.promise])

        .then(function (data) {

          const fingerprint1 = data[0].fingerprint;

          const fingerprint2 = data[1].fingerprint;

          expect(fingerprint1).not.toEqual(fingerprint2);

          expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");

          expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");

          Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]).then(

            done

          );

        })

        .catch(done.fail);
","    it(""checks that fingerprints are unique"", async function () {

      const data = await Promise.all([

        loadingTask1.promise,

        loadingTask2.promise,

      ]);

      const fingerprint1 = data[0].fingerprint;

      const fingerprint2 = data[1].fingerprint;

      expect(fingerprint1).not.toEqual(fingerprint2);

      expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");

      expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");

      await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);
","`it(""checks that fingerprints are unique"", async function () {
      try {
        const data = await Promise.all([loadingTask1.promise, loadingTask2.promise]);
        const fingerprint1 = data[0].fingerprint;
        const fingerprint2 = data[1].fingerprint;
        expect(fingerprint1).not.toEqual(fingerprint2);
        expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");
        expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");
        await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);
      } catch (error) {
        done.fail(error);
      }
    });`",0.5398431672560648,0.46131415640884105,0.4961537507106563,0.7619047619047619,0.44,0.4555384086353593,0.3536790538050789,0.4684745807363583,0.0,0.0,0.5917139573087253,0.6040600731823963,0.7627957560525048,0.0,0.0
196,"      afterEach(function (done) {

          loadingTask.destroy().then(done);

        } else {

          done();

      it(""server disallows cors"", function (done) {

        testCannotLoad(""basicapi.pdf"").then(done);

      it(""server allows cors without credentials, default withCredentials"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withoutCredentials"").then(done);

      it(""server allows cors without credentials, and withCredentials=false"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withoutCredentials"", {

        }).then(done);

      it(""server allows cors without credentials, but withCredentials=true"", function (done) {

        testCannotLoad(""basicapi.pdf?cors=withoutCredentials"", {

        }).then(done);

      it(""server allows cors with credentials, and withCredentials=true"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        }).then(done);

      it(""server allows cors with credentials, and withCredentials=false"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        }).then(done);

    beforeAll(function (done) {

      pdfLoadingTask.promise

        .then(function (doc) {

          pdfDocument = doc;

          pdfDocument.getPage(1).then(function (data) {

            page = data;

            done();

          });

        })

        .catch(done.fail);

    afterAll(function (done) {

      pdfLoadingTask.destroy().then(done);
","

      afterEach(async function () {

          await loadingTask.destroy();



      it(""server disallows cors"", async function () {

        await testCannotLoad(""basicapi.pdf"");



      it(""server allows cors without credentials, default withCredentials"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withoutCredentials"");



      it(""server allows cors without credentials, and withCredentials=false"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withoutCredentials"", {

        });



      it(""server allows cors without credentials, but withCredentials=true"", async function () {

        await testCannotLoad(""basicapi.pdf?cors=withoutCredentials"", {

        });



      it(""server allows cors with credentials, and withCredentials=true"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        });



      it(""server allows cors with credentials, and withCredentials=false"", async function () {

        await testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        });



    beforeAll(async function () {

      pdfDocument = await pdfLoadingTask.promise;

      page = await pdfDocument.getPage(1);

    afterAll(async function () {

      await pdfLoadingTask.destroy();






","async function testCannotLoad(url) {
  const loadingTask = PDFJS.getDocument({ url });

  try {
    await loadingTask.promise;
    done();
  } catch (error) {
    done();
  }
}

async function testCanLoad(url) {
  const loadingTask = PDFJS.getDocument({ url });

  try {
    await loadingTask.promise;
    done();
  } catch (error) {
    done();
  }
}",0.35136366673077435,0.32859363258148433,0.35071424535078727,0.3761467889908257,0.35,0.13882765532325977,0.003853136099661789,0.006273998954845213,0.22018348623853212,0.325,0.18472403158661274,0.0051445337107355,0.008751592635715502,0.1,0.625
197,"      Promise.all([defaultPromise, displayPromise, printPromise])

        .then(function () {

          done();

        })

        .catch(done.fail);

    it(""gets annotations containing relative URLs (bug 766086)"", function (done) {
","

      await Promise.all([defaultPromise, displayPromise, printPromise]);

    it(""gets annotations containing relative URLs (bug 766086)"", async function () {
","async function test() {
  try {
    const result = await Promise.all([defaultPromise, displayPromise, printPromise]);
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.5246228401385384,0.3768577683867149,0.38830025883410574,0.3333333333333333,0.0,0.2045062835418437,0.02542254141389555,0.030697830848717307,0.42857142857142855,0.3333333333333333,0.5070659530461719,0.14051676978912422,0.2210803757288965,0.6666666666666666,0.0
198,"      Promise.all([defaultPromise, docBaseUrlPromise, invalidDocBaseUrlPromise])

        .then(function (data) {

          const defaultAnnotations = data[0];

          const docBaseUrlAnnotations = data[1];

          const invalidDocBaseUrlAnnotations = data[2];

          expect(defaultAnnotations[0].url).toBeUndefined();

          expect(defaultAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          expect(docBaseUrlAnnotations[0].url).toEqual(

            ""http://www.example.com/0021/002156/215675E.pdf#15""

          );

          expect(docBaseUrlAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          expect(invalidDocBaseUrlAnnotations[0].url).toBeUndefined();

          expect(invalidDocBaseUrlAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          Promise.all([

            defaultLoadingTask.destroy(),

            docBaseUrlLoadingTask.destroy(),

            invalidDocBaseUrlLoadingTask.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    it(""gets text content"", function (done) {

      const promises = [defaultPromise, parametersPromise];

      Promise.all(promises)

        .then(function (data) {

          expect(!!data[0].items).toEqual(true);

          expect(data[0].items.length).toEqual(7);

          expect(!!data[0].styles).toEqual(true);

          // A simple check that ensures the two `textContent` object match.

          expect(JSON.stringify(data[0])).toEqual(JSON.stringify(data[1]));

          done();

        })

        .catch(done.fail);

    it(""gets text content, with correct properties (issue 8276)"", function (done) {

      loadingTask.promise

        .then(pdfDoc => {

          pdfDoc.getPage(1).then(pdfPage => {

            pdfPage.getTextContent().then(({ items, styles }) => {

              expect(items.length).toEqual(1);

              expect(Object.keys(styles)).toEqual([""Times""]);



              expect(items[0]).toEqual({

                dir: ""ltr"",

                fontName: ""Times"",

                height: 18,

                str: ""Issue 8276"",

                transform: [18, 0, 0, 18, 441.81, 708.4499999999999],

                width: 77.49,

              });

              expect(styles.Times).toEqual({

                fontFamily: ""serif"",

                ascent: NaN,

                descent: NaN,

                vertical: false,

              });



              loadingTask.destroy().then(done);

            });

          });

        })

        .catch(done.fail);
","      const [

        defaultAnnotations,

        docBaseUrlAnnotations,

        invalidDocBaseUrlAnnotations,

      ] = await Promise.all([

        defaultPromise,

        docBaseUrlPromise,

        invalidDocBaseUrlPromise,

      ]);

      expect(defaultAnnotations[0].url).toBeUndefined();

      expect(defaultAnnotations[0].unsafeUrl).toEqual(

        ""../../0021/002156/215675E.pdf#15""

      );

      expect(docBaseUrlAnnotations[0].url).toEqual(

        ""http://www.example.com/0021/002156/215675E.pdf#15""

      );

      expect(docBaseUrlAnnotations[0].unsafeUrl).toEqual(

        ""../../0021/002156/215675E.pdf#15""

      );

      expect(invalidDocBaseUrlAnnotations[0].url).toBeUndefined();

      expect(invalidDocBaseUrlAnnotations[0].unsafeUrl).toEqual(

        ""../../0021/002156/215675E.pdf#15""

      );

      await Promise.all([

        defaultLoadingTask.destroy(),

        docBaseUrlLoadingTask.destroy(),

        invalidDocBaseUrlLoadingTask.destroy(),

      ]);

    it(""gets text content"", async function () {

      const data = await Promise.all([defaultPromise, parametersPromise]);

      expect(!!data[0].items).toEqual(true);

      expect(data[0].items.length).toEqual(7);

      expect(!!data[0].styles).toEqual(true);

      // A simple check that ensures the two `textContent` object match.

      expect(JSON.stringify(data[0])).toEqual(JSON.stringify(data[1]));

    it(""gets text content, with correct properties (issue 8276)"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const { items, styles } = await pdfPage.getTextContent();

      expect(items.length).toEqual(1);

      expect(Object.keys(styles)).toEqual([""Times""]);



      expect(items[0]).toEqual({

        dir: ""ltr"",

        fontName: ""Times"",

        height: 18,

        str: ""Issue 8276"",

        transform: [18, 0, 0, 18, 441.81, 708.4499999999999],

        width: 77.49,

      });

      expect(styles.Times).toEqual({

        fontFamily: ""serif"",

        ascent: NaN,

        descent: NaN,

        vertical: false,

      });

      await loadingTask.destroy();
","async function getTextContent() {
  const promises = [defaultPromise, parametersPromise];

  try {
    const data = await Promise.all(promises);

    expect(data[0].items).toEqual(true);

    expect(data[0].items.length).toEqual(7);

    expect(data[0].styles).toEqual(true);

    // A simple check that ensures the two `textContent` object match.

    expect(JSON.stringify(data[0])).toEqual(JSON.stringify(data[1]));

    return data;
  } catch (error) {
    done.fail(error);
  }
}

async function getTextContentWithCorrectProperties() {
  try {
    const pdfDoc = await loadingTask.promise;

    const pdfPage = await pdfDoc.getPage(1);

    const textContent = await pdfPage.getTextContent();

    expect(textContent.items.length).toEqual(1);

    expect(Object.keys(textContent.styles)).toEqual([""Times""]);

    expect(textContent.items[0]).toEqual({
      dir: ""ltr"",

      fontName: ""Times"",

      height: 18,

      str: ""Issue 8276"",

      transform: [18, 0, 0, 18, 441.81, 708.4499999999999],

      width: 77.49,
    });

    expect(textContent.styles.Times).toEqual({
      fontFamily: ""serif"",

      ascent: NaN,

      descent: NaN,

      vertical: false,
    });

    loadingTask.destroy().then(done);
  } catch (error) {
    done.fail(error);
  }
}",0.5477866690277416,0.5381575495281752,0.5486248002070797,0.7661290322580645,0.3382352941176471,0.4059779957200609,0.3203206064323182,0.3446255320456483,0.5766129032258065,0.38235294117647056,0.45640864754114163,0.4186851539161633,0.43875760850188966,0.6567164179104478,0.3114754098360656
199,"    it(""gets operator list"", function (done) {

      const promise = page.getOperatorList();

      promise

        .then(function (oplist) {

          expect(!!oplist.fnArray).toEqual(true);

          expect(!!oplist.argsArray).toEqual(true);

          expect(oplist.lastChunk).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""gets operatorList with JPEG image (issue 4888)"", function (done) {

      loadingTask.promise

        .then(pdfDoc => {

          pdfDoc.getPage(1).then(pdfPage => {

            pdfPage.getOperatorList().then(opList => {

              const imgIndex = opList.fnArray.indexOf(OPS.paintImageXObject);

              const imgArgs = opList.argsArray[imgIndex];

              const { data } = pdfPage.objs.get(imgArgs[0]);

              expect(data instanceof Uint8ClampedArray).toEqual(true);

              expect(data.length).toEqual(90000);

              loadingTask.destroy().then(done);

            });

          });

        })

        .catch(done.fail);

      function (done) {
","    it(""gets operator list"", async function () {

      const operatorList = await page.getOperatorList();

      expect(!!operatorList.fnArray).toEqual(true);

      expect(!!operatorList.argsArray).toEqual(true);

      expect(operatorList.lastChunk).toEqual(true);

    it(""gets operatorList with JPEG image (issue 4888)"", async function () {

      const pdfDoc = await loadingTask.promise;

      const pdfPage = await pdfDoc.getPage(1);

      const operatorList = await pdfPage.getOperatorList();

      const imgIndex = operatorList.fnArray.indexOf(OPS.paintImageXObject);

      const imgArgs = operatorList.argsArray[imgIndex];

      const { data } = pdfPage.objs.get(imgArgs[0]);

      expect(data instanceof Uint8ClampedArray).toEqual(true);

      expect(data.length).toEqual(90000);



      await loadingTask.destroy();

      async function () {
","it(""gets operator list"", async () => {
  const oplist = await page.getOperatorList();
  expect(!!oplist.fnArray).toEqual(true);
  expect(!!oplist.argsArray).toEqual(true);
  expect(oplist.lastChunk).toEqual(true);
});

it(""gets operatorList with JPEG image (issue 4888)"", async () => {
  const pdfDoc = await loadingTask.promise;
  const pdfPage = await pdfDoc.getPage(1);
  const opList = await pdfPage.getOperatorList();
  const imgIndex = opList.fnArray.indexOf(OPS.paintImageXObject);
  const imgArgs = opList.argsArray[imgIndex];
  const { data } = await pdfPage.objs.get(imgArgs[0]);
  expect(data instanceof Uint8ClampedArray).toEqual(true);
  expect(data.length).toEqual(90000);
});",0.4592137706098275,0.3009118502478689,0.32200765796174907,0.6722689075630253,0.5416666666666666,0.45608385343506963,0.3951216092181818,0.398751619648147,0.6554621848739496,0.375,0.673086206291924,0.5331497794763088,0.5364844229807643,0.9560439560439561,0.6666666666666666
200,"      renderTask.promise

        .then(function () {

          done.fail(""shall cancel rendering"");

        })

        .catch(function (error) {

          expect(error instanceof RenderingCancelledException).toEqual(true);

          expect(error.message).toEqual(""Rendering cancelled, page 1"");

          expect(error.type).toEqual(""canvas"");

          CanvasFactory.destroy(canvasAndCtx);

          done();

        });

    it(""re-render page, using the same canvas, after cancelling rendering"", function (done) {
","      try {

        await renderTask.promise;

        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof RenderingCancelledException).toEqual(true);

        expect(reason.message).toEqual(""Rendering cancelled, page 1"");

        expect(reason.type).toEqual(""canvas"");

      }



      CanvasFactory.destroy(canvasAndCtx);

    it(""re-render page, using the same canvas, after cancelling rendering"", async function () {
","async function renderPage() {
  try {
    await renderTask.promise;
  } catch (error) {
    expect(error instanceof RenderingCancelledException).toEqual(true);
    expect(error.message).toEqual(""Rendering cancelled, page 1"");
    expect(error.type).toEqual(""canvas"");
    CanvasFactory.destroy(canvasAndCtx);
    done();
  }
}",0.4910410764601118,0.30045004214040766,0.3290988790846551,0.6346153846153846,0.7,0.49852797787741576,0.3238398696137607,0.3587335803574405,0.7115384615384616,0.6,0.47637524862197345,0.12130327784848453,0.14175585617429295,0.7674418604651163,0.875
201,"      renderTask.promise

        .then(

          () => {

            throw new Error(""shall cancel rendering"");

          },

          reason => {

            expect(reason instanceof RenderingCancelledException).toEqual(true);

          }

        )

        .then(() => {

          const reRenderTask = page.render({

            canvasContext: canvasAndCtx.context,

            canvasFactory: CanvasFactory,

            viewport,

          });

          return reRenderTask.promise;

        })

        .then(() => {

          CanvasFactory.destroy(canvasAndCtx);

          done();

        }, done.fail);

    it(""multiple render() on the same canvas"", function (done) {
","      try {

        await renderTask.promise;



        // Shouldn't get here.

        expect(false).toEqual(true);

      } catch (reason) {

        expect(reason instanceof RenderingCancelledException).toEqual(true);

      }



      const reRenderTask = page.render({

        canvasContext: canvasAndCtx.context,

        canvasFactory: CanvasFactory,

        viewport,

      });

      await reRenderTask.promise;



      CanvasFactory.destroy(canvasAndCtx);

    it(""multiple render() on the same canvas"", async function () {
","it(""multiple render() on the same canvas"", async function () {
  const renderTask = page.render({
    canvasContext: canvasAndCtx.context,
    canvasFactory: CanvasFactory,
    viewport,
  });
  try {
    await renderTask.promise;
  } catch (error) {
    expect(error instanceof RenderingCancelledException).toEqual(true);
  }
  const reRenderTask = page.render({
    canvasContext: canvasAndCtx.context,
    canvasFactory: CanvasFactory,
    viewport,
  });
  try {
    await reRenderTask.promise;
  } finally {
    CanvasFactory.destroy(canvasAndCtx);
    done();
  }
});",0.47964175225739913,0.33944446489827723,0.34596746391741545,0.5272727272727272,0.7058823529411765,0.4760506080054343,0.3236793998757455,0.3334642086165798,0.6,0.6470588235294118,0.6760219382874121,0.46348952510254177,0.6332264331753116,0.7948717948717948,0.8125
202,"      Promise.all([

            done.fail(""shall fail rendering"");

            /* it fails because we already using this canvas */

      ]).then(done);
","      await Promise.all([

            // Shouldn't get here.

            expect(false).toEqual(true);

            // It fails because we are already using this canvas.

      ]);
","async function renderCanvas() {
    try {
        const done = await Promise.all([done.fail(""shall fail rendering"")]);
        return done;
    } catch (error) {
        console.log(error);
        // handle error here
    }
}",0.35710197176971775,0.09344667213582157,0.12067550065733516,0.21428571428571427,0.0,0.3620741809953208,0.0072658577559704465,0.012459437653884122,0.42857142857142855,1.0,0.2752463216699612,0.008640609739997756,0.015421600016770207,0.07692307692307693,0.0
203,"    afterEach(function (done) {

      Promise.all(destroyPromises).then(done);

    it(""should correctly render PDFs in parallel"", function (done) {
","    afterEach(async function () {

      await Promise.all(destroyPromises);

    it(""should correctly render PDFs in parallel"", async function () {
","async function afterEach() {
  try {
    await Promise.all(destroyPromises);
    done();
  } catch (err) {
    console.error(""Error in afterEach:"", err);
  }
}

async function it() {
  try {
    const results = await Promise.all(renderPromises);
    expect(results).toEqual(expectedResults);
  } catch (err) {
    console.error(""Error in it:"", err);
  }
  done();
}",0.5564926583644138,0.3334477432809602,0.43797743563124014,0.45454545454545453,0.0,0.28826865153085035,0.006211915815063893,0.025650569096216352,0.45454545454545453,0.6666666666666666,0.5037284519325614,0.030744212557072603,0.09528070628428419,0.8888888888888888,0.0
204,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.id).toEqual(""10R"");

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.id).toEqual(""10R"");

      async function () {
","async function test() {
    try {
      const annotation = await AnnotationFactory.create();
      expect(annotation.data.annotationType).toEqual(AnnotationType.LINK);
      expect(annotation.data.id).toEqual(""10R"");
      done();
    } catch (error) {
      done.fail(error);
    }
  }",0.3237685168156789,0.04131551591106297,0.043441091034192435,0.6388888888888888,0.5714285714285714,0.2558931335793579,0.01291802583371725,0.02255927038847628,0.4166666666666667,0.5714285714285714,0.3878730892530793,0.03248711505764769,0.054719527668955166,0.4642857142857143,1.0
205,"        Promise.all([annotation1, annotation2]).then(done, done.fail);

    it(""should handle missing /Subtype"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toBeUndefined();

        done();

      }, done.fail);
","        await Promise.all([annotation1, annotation2]);

    it(""should handle missing /Subtype"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toBeUndefined();
","const annotation1 = Promise.resolve();
    const annotation2 = Promise.resolve();
    (async () => {
      try {
        const [data] = await Promise.all([annotation1, annotation2]);
        expect(data.annotationType).toBeUndefined();
      } catch (error) {
        done.fail(error);
      } finally {
        done();
      }
    })();",0.26813455070144165,0.15435109972796832,0.15936357366603357,0.5588235294117647,0.2,0.2001672206004379,0.016237908184412748,0.02560744480557418,0.5588235294117647,0.2,0.45465878800333287,0.046398855339878003,0.07658412276041004,0.6956521739130435,1.0
206,"    it(""should not parse IRT/RT when not defined"", function (done) {



      AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock).then(

        ({ data }) => {

          expect(data.inReplyTo).toBeUndefined();

          expect(data.replyType).toBeUndefined();

          done();

        },

        done.fail

    it(""should parse IRT and set default RT when not defined."", function (done) {
","    it(""should not parse IRT/RT when not defined"", async function () {

      const { data } = await AnnotationFactory.create(

        xref,

        ref,

        pdfManagerMock,

        idFactoryMock

      expect(data.inReplyTo).toBeUndefined();

      expect(data.replyType).toBeUndefined();

    it(""should parse IRT and set default RT when not defined"", async function () {
","it(""should not parse IRT/RT when not defined"", async () => {

    try {

      const data = await AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock);

      expect(data.inReplyTo).toBeUndefined();

      expect(data.replyType).toBeUndefined();

      done();

    } catch (error) {

      done.fail(error);

    }

  });

  it(""should parse IRT and set default RT when not defined."", async () => {

    try {

      const data = await AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock);

      expect(data.inReplyTo).toBeUndefined();

      expect(data.replyType).toBeUndefined();

      done();

    } catch (error) {

      done.fail(error);

    }

  });",0.5244350629459877,0.40971293734668085,0.4317773144372699,0.65625,0.6,0.54173731393991,0.2746069979633641,0.47359225779627573,0.71875,0.7,0.5296080293803236,0.2704602915074783,0.4585487490907391,0.5769230769230769,0.8125
207,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        done();

      }, done.fail);

    it(""should parse IRT/RT for a group type"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.inReplyTo).toEqual(annotationRef.toString());

      expect(data.replyType).toEqual(""R"");

    it(""should parse IRT/RT for a group type"", async function () {
","`it(""should parse IRT/RT for a group type"", async function(done) {
      try {
        const { data } = await AnnotationFactory.create();

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        done();
      } catch (error) {
        done.fail(error);
      }
    });`",0.4901628514341747,0.34177883785923663,0.3529995520044464,0.6944444444444444,0.5714285714285714,0.38004845458928727,0.2168299905777652,0.30336382777938387,0.0,0.0,0.47986257400411203,0.3816692391925841,0.537781056823864,0.0,0.0
208,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""Group"");

        expect(data.title).toEqual(""ParentTitle"");

        expect(data.contents).toEqual(""ParentText"");

        expect(data.creationDate).toEqual(""D:20180423"");

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

        expect(data.hasPopup).toEqual(true);

        done();

      }, done.fail);

    it(""should parse IRT/RT for a reply type"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.inReplyTo).toEqual(annotationRef.toString());

      expect(data.replyType).toEqual(""Group"");

      expect(data.title).toEqual(""ParentTitle"");

      expect(data.contents).toEqual(""ParentText"");

      expect(data.creationDate).toEqual(""D:20180423"");

      expect(data.modificationDate).toEqual(""D:20190423"");

      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

      expect(data.hasPopup).toEqual(true);

    it(""should parse IRT/RT for a reply type"", async function () {
","AnnotationFactory.create()
    .then(({ data }) => {
        expect(data.inReplyTo).toEqual(annotationRef.toString());
        expect(data.replyType).toEqual(""Group"");
        expect(data.title).toEqual(""ParentTitle"");
        expect(data.contents).toEqual(""ParentText"");
        expect(data.creationDate).toEqual(""D:20180423"");
        expect(data.modificationDate).toEqual(""D:20190423"");
        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
        expect(data.hasPopup).toEqual(true);
        done();
    }, done.fail);",0.5492974869038905,0.5537057239527383,0.5623696725792325,0.8705882352941177,0.21052631578947367,0.7523578035115139,0.5407041094705578,0.5448880952875724,0.9764705882352941,0.9473684210526315,0.43160324222335644,0.32306913245255287,0.3103841645338325,0.935064935064935,0.15789473684210525
209,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        expect(data.title).toEqual(""ReplyTitle"");

        expect(data.contents).toEqual(""ReplyText"");

        expect(data.creationDate).toEqual(""D:20180523"");

        expect(data.modificationDate).toEqual(""D:20190523"");

        expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));

        expect(data.hasPopup).toEqual(false);

        done();

      }, done.fail);

    it(""should not parse state model and state when not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.inReplyTo).toEqual(annotationRef.toString());

      expect(data.replyType).toEqual(""R"");

      expect(data.title).toEqual(""ReplyTitle"");

      expect(data.contents).toEqual(""ReplyText"");

      expect(data.creationDate).toEqual(""D:20180523"");

      expect(data.modificationDate).toEqual(""D:20190523"");

      expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));

      expect(data.hasPopup).toEqual(false);

    it(""should not parse state model and state when not defined"", async function () {
","async function test() {
  const data = await AnnotationFactory.create();
  expect(data.inReplyTo).toEqual(annotationRef.toString());
  expect(data.replyType).toEqual(""R"");
  expect(data.title).toEqual(""ReplyTitle"");
  expect(data.contents).toEqual(""ReplyText"");
  expect(data.creationDate).toEqual(""D:20180523"");
  expect(data.modificationDate).toEqual(""D:20190523"");
  expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));
  expect(data.hasPopup).toEqual(false);
}",0.5705821269094482,0.5984530237636183,0.6027609327905831,0.8705882352941177,0.21052631578947367,0.4223453671665826,0.2906551406928208,0.3293764827722712,0.8588235294117647,0.21052631578947367,0.6631141828047169,0.3283444738582803,0.3760603093086394,0.948051948051948,1.0
210,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.stateModel).toBeNull();

        expect(data.state).toBeNull();

        done();

      }, done.fail);

    it(""should correctly parse state model and state when defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.stateModel).toBeNull();

      expect(data.state).toBeNull();

    it(""should correctly parse state model and state when defined"", async function () {
","async function testCreate() {
  const data = await AnnotationFactory.create();

  expect(data.stateModel).toBeNull();
  expect(data.state).toBeNull();
}

it(""should correctly parse state model and state when defined"", async () => {
    try {
      const data = await AnnotationFactory.create();

      expect(data.stateModel).toBeNull();
      expect(data.state).toBeNull();
    } catch (err) {
      done.fail(err);
    }
  });
}",0.51390786778038,0.41072675483179805,0.41722614486115056,0.65625,0.5714285714285714,0.4978223537517108,0.22364174996640396,0.42836195075472494,0.625,0.7142857142857143,0.6535693970360877,0.2692202390728556,0.5117240157381622,0.8333333333333334,1.0
211,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.stateModel).toEqual(""Review"");

        expect(data.state).toEqual(""Rejected"");

        done();

      }, done.fail);

    it(""should correctly parse a URI action"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.stateModel).toEqual(""Review"");

      expect(data.state).toEqual(""Rejected"");

    it(""should correctly parse a URI action"", async function () {
","AnnotationFactory.create(async () => {
    const data = await AnnotationFactory.create(

      ).then(({ data }) => {
        expect(data.stateModel).toEqual(""Review"");
        expect(data.state).toEqual(""Rejected"");
        done();
      }, done.fail);
    });
  it(""should correctly parse a URI action"", async () => {

      const data = await AnnotationFactory.create(

      ).then(({ data }) => {
        expect(data.stateModel).toEqual(""Review"");
        expect(data.state).toEqual(""Rejected"");
        done();
      }, done.fail);
    });
  }",0.46336692404264596,0.2995316414137092,0.30603689509300896,0.6764705882352942,0.5714285714285714,0.6648749126160588,0.3081731023835149,0.7252761279126532,0.9117647058823529,0.7142857142857143,0.4662869545613862,0.1736006488622933,0.41682189465797687,0.8461538461538461,0.42857142857142855
212,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");

        expect(data.unsafeUrl).toEqual(

          ""http://www.ctan.org/tex-archive/info/lshort""

        );

        expect(data.dest).toBeUndefined();

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");

      expect(data.unsafeUrl).toEqual(

        ""http://www.ctan.org/tex-archive/info/lshort""

      );

      expect(data.dest).toBeUndefined();

      async function () {
","async function create() {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");
    expect(data.unsafeUrl).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");
    expect(data.dest).toBeUndefined();
    done();
  }",0.4332671168564326,0.30789512797772584,0.3164389365959547,0.7450980392156863,0.36363636363636365,0.3191089673960658,0.03722520852859804,0.0395671672945243,0.7450980392156863,0.45454545454545453,0.46028790217806753,0.04612470646140136,0.04872669083437829,0.8372093023255814,0.9090909090909091
213,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(""http://www.hmrc.gov.uk/"");

          expect(data.unsafeUrl).toEqual(""http://www.hmrc.gov.uk"");

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

      function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.hmrc.gov.uk/"");

        expect(data.unsafeUrl).toEqual(""http://www.hmrc.gov.uk"");

        expect(data.dest).toBeUndefined();

      async function () {
","async function test() {
    try {
        const { data } = await AnnotationFactory.create();
        expect(data.annotationType).toEqual(AnnotationType.LINK);
        expect(data.url).toEqual(""http://www.hmrc.gov.uk/"");
        expect(data.unsafeUrl).toEqual(""http://www.hmrc.gov.uk"");
        expect(data.dest).toBeUndefined();
    } catch (error) {
        done.fail(error);
    } finally {
        done();
    }
}",0.37266473321794824,0.1875114458383465,0.19441308418139638,0.7450980392156863,0.36363636363636365,0.35628527805667587,0.1023857820560022,0.19441308418139638,0.7647058823529411,0.36363636363636365,0.6743663430179461,0.274941620352113,0.5155470075336247,0.9069767441860465,1.0
214,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            new URL(

              stringToUTF8String(

                ""http://www.example.com/\xC3\xBC\xC3\xB6\xC3\xA4""

              )

            ).href

          );

          expect(data.unsafeUrl).toEqual(

          );

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

    it(""should correctly parse a GoTo action"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          new URL(

          ).href

        );

        expect(data.unsafeUrl).toEqual(

          stringToUTF8String(""http://www.example.com/\xC3\xBC\xC3\xB6\xC3\xA4"")

        );

        expect(data.dest).toBeUndefined();

    it(""should correctly parse a GoTo action"", async function () {
","async function testCreateAnnotation() {
  const annotationData = await AnnotationFactory.create();
  expect(annotationData.annotationType).toEqual(AnnotationType.LINK);
  expect(annotationData.url).toEqual(new URL(""http://www.example.com/üöä""));
  expect(annotationData.unsafeUrl).toEqual(undefined);
  expect(annotationData.dest).toBeUndefined();
}",0.42306544459426576,0.3115411047289339,0.3189711024645954,0.6981132075471698,0.36363636363636365,0.24560119270360503,0.005782651820150676,0.009212170452245422,0.6037735849056604,0.36363636363636365,0.4280661369019324,0.01911205931814028,0.0264858216229228,0.6666666666666666,1.0
215,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""page.157"");

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.dest).toEqual(""page.157"");

      async function () {
","async function testCreate(done) {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.LINK);
  expect(data.url).toBeUndefined();
  expect(data.unsafeUrl).toBeUndefined();
  expect(data.dest).toEqual(""page.157"");
  done();
}",0.3713902234140266,0.1875114458383465,0.19441308418139638,0.74,0.36363636363636365,0.4129934660613196,0.2588429664894704,0.2694945341194442,0.76,0.36363636363636365,0.43273252813227214,0.23014755887081007,0.23671328958901433,0.8095238095238095,0.45454545454545453
216,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toBeUndefined();

          expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

          expect(data.dest).toBeUndefined();

          expect(data.newWindow).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toEqual(true);

      async function () {
","async function test() {
const data = await AnnotationFactory.create();

expect(data.annotationType).toEqual(AnnotationType.LINK);

expect(data.url).toBeUndefined();

expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

expect(data.dest).toBeUndefined();

expect(data.newWindow).toEqual(true);

done();
}",0.3992278937158737,0.2545984531673679,0.2626909894424158,0.7719298245614035,0.3076923076923077,0.42928007540273977,0.31324516580380846,0.32425300355343933,0.7719298245614035,0.3076923076923077,0.6173475324739489,0.30223684058200134,0.3100104321709371,0.8571428571428571,1.0
217,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            ""http://www.example.com/0013/001346/134685E.pdf#4.3""

          );

          expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

    it(""should correctly parse a GoToR action, with named destination"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          ""http://www.example.com/0013/001346/134685E.pdf#4.3""

        );

        expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

        expect(data.dest).toBeUndefined();

    it(""should correctly parse a GoToR action, with named destination"", async function () {
","async function testCase() {
  try {
    const annotationData = await AnnotationFactory.create();
    expect(annotationData.annotationType).toEqual(AnnotationType.LINK);
    expect(annotationData.url).toEqual(""http://www.example.com/0013/001346/134685E.pdf#4.3"");
    expect(annotationData.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");
    expect(annotationData.dest).toBeUndefined();
  } catch (error) {
    done.fail(error);
  }
}",0.5358007404050102,0.49719876934333024,0.5068576245587143,0.7755102040816326,0.36363636363636365,0.2846220634041349,0.009108998473492844,0.010640850690356465,0.7551020408163265,0.36363636363636365,0.48871094724207964,0.024616160295041146,0.027788604283033546,0.9024390243902439,1.0
218,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.example.com/test.pdf#15"");

        expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#15"");

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toBeFalsy();

        done();

      }, done.fail);

    it(""should correctly parse a GoToR action, with explicit destination array"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toEqual(""http://www.example.com/test.pdf#15"");

      expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#15"");

      expect(data.dest).toBeUndefined();

      expect(data.newWindow).toBeFalsy();

    it(""should correctly parse a GoToR action, with explicit destination array"", async function () {
","async () => {
    try {
        const data = await AnnotationFactory.create();
        expect(data.annotationType).toEqual(AnnotationType.LINK);
        expect(data.url).toEqual(""http://www.example.com/test.pdf#15"");
        expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#15"");
        expect(data.dest).toBeUndefined();
        expect(data.newWindow).toBeFalsy();
        done();
    } catch (error) {
        done.fail(error);
    }
}",0.5288300325414452,0.49719876934333024,0.5068576245587143,0.8035714285714286,0.3076923076923077,0.38077643952170326,0.20342346639736558,0.1905614125685684,0.8214285714285714,0.3076923076923077,0.5678883484481982,0.17777891406054308,0.17710781306558324,0.9166666666666666,1.0
219,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          new URL(

            ""http://www.example.com/test.pdf#"" +

              '[14,{""name"":""XYZ""},null,298.043,null]'

          ).href

        );

        expect(data.unsafeUrl).toEqual(

        );

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toBeFalsy();

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toEqual(

        new URL(

        ).href

      );

      expect(data.unsafeUrl).toEqual(

        ""http://www.example.com/test.pdf#"" +

          '[14,{""name"":""XYZ""},null,298.043,null]'

      );

      expect(data.dest).toBeUndefined();

      expect(data.newWindow).toBeFalsy();

      async function () {
","async function testCreateAnnotation() {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toEqual(new URL(""http://www.example.com/test.pdf#"" + '[14,{""name"":""XYZ""},null,298.043,null]').href);
    expect(data.unsafeUrl).toEqual();
    expect(data.dest).toBeUndefined();
    expect(data.newWindow).toBeFalsy();
  }",0.36927264703655455,0.22727193675476884,0.23244892434430275,0.7096774193548387,0.3076923076923077,0.2774561598426243,0.021178687608474595,0.022889127940682732,0.7580645161290323,0.3076923076923077,0.45182787690420184,0.03189335152377926,0.03467741535228734,0.7407407407407407,1.0
220,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            new URL(""http://www.example.com/test/pdfs/Part II/Part II.pdf"").href

          );

          expect(data.unsafeUrl).toEqual(""Part II/Part II.pdf"");

          expect(data.dest).toBeUndefined();

          expect(data.newWindow).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          new URL(""http://www.example.com/test/pdfs/Part II/Part II.pdf"").href

        );

        expect(data.unsafeUrl).toEqual(""Part II/Part II.pdf"");

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toEqual(true);

      async function () {
","async function create() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toEqual(new URL(""http://www.example.com/test/pdfs/Part II/Part II.pdf"").href);
    expect(data.unsafeUrl).toEqual(""Part II/Part II.pdf"");
    expect(data.dest).toBeUndefined();
    expect(data.newWindow).toEqual(true);
    done();
  } catch (error) {
    done.fail();
  }
}",0.5302093736430207,0.5068456991984435,0.519414241779692,0.7868852459016393,0.3076923076923077,0.4044361808015039,0.20130088157694537,0.24494321111204645,0.7868852459016393,0.38461538461538464,0.5526242714405667,0.18812705960697632,0.23136857477648068,0.8679245283018868,0.9230769230769231
221,"        Promise.all([annotation1, annotation2, annotation3]).then(

          done,

          done.fail

        );

    it(""should correctly parse a Named action"", function (done) {
","        await Promise.all([annotation1, annotation2, annotation3]);

    it(""should correctly parse a Named action"", async function () {
","async function test() {
  try {
    const annotations = await Promise.all([annotation1, annotation2, annotation3]);
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.5705449410988184,0.38739209989720524,0.3947876644980683,0.5,0.0,0.2025585672948313,0.02297185935845028,0.03726240982087481,0.4166666666666667,0.3333333333333333,0.5111567389156301,0.14051676978912422,0.23744351920672957,0.6666666666666666,0.0
222,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.action).toEqual(""GoToPage"");

        done();

      }, done.fail);

    it(""should correctly parse a simple Dest"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.action).toEqual(""GoToPage"");

    it(""should correctly parse a simple Dest"", async function () {
","`
  AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.annotationType).toEqual(AnnotationType.LINK);
      expect(data.url).toBeUndefined();
      expect(data.unsafeUrl).toBeUndefined();
      expect(data.action).toEqual(""GoToPage"");
      done();
    }, done.fail);
  });

  it(""should correctly parse a simple Dest"", async () => {
    try {
      const data = await AnnotationFactory.create();
      expect(data.annotationType).toEqual(AnnotationType.LINK);
      expect(data.url).toBeUndefined();
      expect(data.unsafeUrl).toBeUndefined();
      expect(data.action).toEqual(""GoToPage"");
    } catch (error) {
      done.fail(error);
    }
  });",0.46412357420152717,0.35788354361456914,0.3641410562218426,0.7708333333333334,0.36363636363636365,0.6928022278617784,0.33789716803063213,0.6567965919013297,0.9583333333333334,0.8181818181818182,0.5754886745979524,0.21767823771792327,0.43200373340115916,0.925,0.7272727272727273
223,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""LI0"");

        done();

      }, done.fail);

    it(""should correctly parse a simple Dest, with explicit destination array"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.dest).toEqual(""LI0"");

    it(""should correctly parse a simple Dest, with explicit destination array"", async function () {
","async function create() {
      const { data } = await AnnotationFactory.create();
  
      expect(data.annotationType).toEqual(AnnotationType.LINK);
  
      expect(data.url).toBeUndefined();
  
      expect(data.unsafeUrl).toBeUndefined();
  
      expect(data.dest).toEqual(""LI0"");
  
      done();
    }
    
    it(""should correctly parse a simple Dest, with explicit destination array"", async function (done) {
      await create();
      done();
    });",0.5235281295041917,0.4748354118389711,0.4848074092080984,0.7708333333333334,0.36363636363636365,0.5842771673452348,0.4007130927627102,0.5576076978303504,0.8333333333333334,0.5454545454545454,0.7801994049784035,0.5186011471360957,0.7181055636866089,0.975,0.9090909090909091
224,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual([

          { num: 17, gen: 0 },

          { name: ""XYZ"" },

          0,

          841.89,

          null,

        ]);

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.url).toBeUndefined();

      expect(data.unsafeUrl).toBeUndefined();

      expect(data.dest).toEqual([

        { num: 17, gen: 0 },

        { name: ""XYZ"" },

        0,

        841.89,

        null,

      ]);

      async function () {
","const annotation = await AnnotationFactory.create();

    expect(annotation.data.annotationType).toEqual(AnnotationType.LINK);

    expect(annotation.data.url).toBeUndefined();

    expect(annotation.data.unsafeUrl).toBeUndefined();

    expect(annotation.data.dest).toEqual([
      { num: 17, gen: 0 },
      { name: ""XYZ"" },
      0,
      841.89,
      null,
    ]);

    done();",0.5915265342982521,0.6145917663576275,0.6200208643418742,0.7678571428571429,0.36363636363636365,0.44247278072860297,0.4662481155034405,0.4578637866317506,0.48214285714285715,0.36363636363636365,0.6086676947270293,0.4613907019457707,0.4732800769623463,0.5,1.0
225,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toBeUndefined();

          expect(data.unsafeUrl).toBeUndefined();

          expect(data.dest).toEqual(""page.157"");

          done();

        }, done.fail);

    it(""should not set quadpoints if not defined"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""page.157"");

    it(""should not set quadpoints if not defined"", async function () {
","it('should create an annotation and set the quadpoints if defined', async () => {
  const data = await AnnotationFactory.create({quadpoints: 'some value'});

  expect(data.annotationType).toEqual(AnnotationType.LINK);

  expect(data.url).toBeUndefined();

  expect(data.unsafeUrl).toBeUndefined();

  expect(data.dest).toEqual('page.157');
});",0.4824894446947202,0.39242591746953154,0.4030621643396521,0.7708333333333334,0.36363636363636365,0.28086234027391926,0.056281092169571056,0.0652743295321667,0.7291666666666666,0.2727272727272727,0.3142518629127131,0.06170036416533053,0.07257981475824929,0.85,0.2727272727272727
226,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.quadPoints).toBeUndefined();

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.quadPoints).toBeUndefined();

    it(""should set quadpoints if defined"", async function () {
","async () => {

    const annotation = await AnnotationFactory.create();

    try {
        expect(annotation.data.annotationType).toEqual(AnnotationType.LINK);
        expect(annotation.data.quadPoints).toBeUndefined();
        done();
    } catch (error) {
        done.fail();
    }
};",0.43676799126370947,0.24941747177008258,0.2595592551895173,0.6666666666666666,0.5714285714285714,0.26052417033347963,0.02297185935845028,0.023453826304472677,0.42424242424242425,0.5714285714285714,0.3846008561524381,0.027318298593910915,0.031085126015841524,0.48,1.0
227,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINK);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);
","async function testAnnotationFactory() {
  const annotation = await AnnotationFactory.create();
  expect(annotation.annotationType).toEqual(AnnotationType.LINK);
  expect(annotation.quadPoints).toEqual([
    [{ x: 10, y: 20 }, { x: 20, y: 20 }, { x: 10, y: 10 }, { x: 20, y: 10 }],
  ]);
}",0.7055549264789116,0.7725218915170873,0.7719200366207816,0.7777777777777778,0.5,0.6007051992729882,0.5738561601549507,0.5734090813814466,0.7555555555555555,0.5,0.7850957571586146,0.6199094839451336,0.628581652797433,0.8918918918918919,1.0
228,"    it(""should handle unknown field names"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual("""");

        done();

      }, done.fail);

    it(""should construct the field name when there are no ancestors"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo"");

        done();

      }, done.fail);

    it(""should construct the field name when there are ancestors"", function (done) {
","    it(""should handle unknown field names"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldName).toEqual("""");

    it(""should construct the field name when there are no ancestors"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldName).toEqual(""foo"");

    it(""should construct the field name when there are ancestors"", async function () {
","it(""should handle unknown field names"", async () => {
  const { data } = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.fieldName).toEqual("""");
});

it(""should construct the field name when there are no ancestors"", async () => {
  const { data } = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.fieldName).toEqual(""foo"");
});

it(""should construct the field name when there are ancestors"", async () => {
  const { data } = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.fieldName).toEqual(""foo"");
});",0.5418162450643014,0.409715893664632,0.42421575325924016,0.6811594202898551,0.6521739130434783,0.5411887563010527,0.3466425895005521,0.39782258063119474,0.6811594202898551,0.7391304347826086,0.7866948622350225,0.5427304965702,0.6229168768981916,0.9811320754716981,1.0
229,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo.bar.baz"");

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldName).toEqual(""foo.bar.baz"");

      async function () {
","async function createAnnotation() {
    try {
        const data = await AnnotationFactory.create();
        expect(data.annotationType).toEqual(AnnotationType.WIDGET);
        expect(data.fieldName).toEqual(""foo.bar.baz"");
    } catch (err) {
        done.fail(err);
    } finally {
        done();
    }
}",0.3237685168156789,0.04131551591106297,0.043441091034192435,0.6388888888888888,0.5714285714285714,0.31916191982308384,0.022889127940682732,0.043441091034192435,0.6388888888888888,0.5714285714285714,0.46160945854099933,0.03372742782933834,0.062710406334659,0.75,1.0
230,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.WIDGET);

          expect(data.fieldName).toEqual(""foo.bar"");

          done();

        }, done.fail);
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo.bar"");
","async function test() {
  try {
    const { data } = await AnnotationFactory.create();

    expect(data.annotationType).toEqual(AnnotationType.WIDGET);

    expect(data.fieldName).toEqual(""foo.bar"");

    done();
  } catch (error) {
    done.fail();
  }
}",0.3221018186827691,0.050781487573685676,0.05012578715739066,0.6875,0.5,0.35064445796670823,0.04657469807170698,0.10600313379512592,0.75,0.5,0.6958627507337594,0.22816849039973935,0.5969491792019646,0.9583333333333334,1.0
231,"    it(""should handle unknown text alignment, maximum length and flags"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(null);

        expect(data.maxLen).toEqual(null);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(false);

        expect(data.comb).toEqual(false);

        expect(data.defaultFieldValue).toEqual(""foo"");

        done();

      }, done.fail);

    });



    it(""should not set invalid text alignment, maximum length and flags"", function (done) {
","    it(""should handle unknown text alignment, maximum length and flags"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.textAlignment).toEqual(null);

      expect(data.maxLen).toEqual(null);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.multiLine).toEqual(false);

      expect(data.comb).toEqual(false);

      expect(data.defaultFieldValue).toEqual(""foo"");

    });



    it(""should not set invalid text alignment, maximum length and flags"", async function () {
","it(""should handle unknown text alignment, maximum length and flags"", async () => {
    const data = await AnnotationFactory.create();

    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.textAlignment).toEqual(null);
    expect(data.maxLen).toEqual(null);
    expect(data.readOnly).toEqual(false);
    expect(data.hidden).toEqual(false);
    expect(data.multiLine).toEqual(false);
    expect(data.comb).toEqual(false);
    expect(data.defaultFieldValue).toEqual(""foo"");
});

it(""should not set invalid text alignment, maximum length and flags"", async () => {
    try {
        const data = await AnnotationFactory.create();
        // do something with the data
    } catch (error) {
        // handle any errors that may occur
    }
});",0.6180148835882158,0.5788386392547236,0.598040172206573,0.7951807228915663,0.5,0.5668797809610702,0.37366969297278,0.5652623552964731,0.7831325301204819,0.5454545454545454,0.7522513468444216,0.4528699993097834,0.676135388067903,0.88,1.0
232,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(null);

        expect(data.maxLen).toEqual(null);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(false);

        expect(data.comb).toEqual(false);

        done();

      }, done.fail);

    it(""should set valid text alignment, maximum length and flags"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.textAlignment).toEqual(null);

      expect(data.maxLen).toEqual(null);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.multiLine).toEqual(false);

      expect(data.comb).toEqual(false);

    it(""should set valid text alignment, maximum length and flags"", async function () {
","async function testCreate() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.textAlignment).toEqual(null);
    expect(data.maxLen).toEqual(null);
    expect(data.readOnly).toEqual(false);
    expect(data.hidden).toEqual(false);
    expect(data.multiLine).toEqual(false);
    expect(data.comb).toEqual(false);
    done();
  } catch (error) {
    done.fail();
  }
}",0.5285271296323442,0.5176346692628243,0.5229444375018462,0.8382352941176471,0.23529411764705882,0.40492633646412557,0.2680586084621689,0.2781173256296274,0.8382352941176471,0.23529411764705882,0.6171059420072642,0.2691160593992013,0.28264104196318884,0.9166666666666666,1.0
233,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(1);

        expect(data.maxLen).toEqual(20);

        expect(data.readOnly).toEqual(true);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(true);

        done();

      }, done.fail);

    it(""should reject comb fields without a maximum length"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.comb).toEqual(false);

        done();

      }, done.fail);

    it(""should accept comb fields with a maximum length"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.comb).toEqual(true);

        done();

      }, done.fail);

    it(""should only accept comb fields when the flags are valid"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.textAlignment).toEqual(1);

      expect(data.maxLen).toEqual(20);

      expect(data.readOnly).toEqual(true);

      expect(data.hidden).toEqual(false);

      expect(data.multiLine).toEqual(true);

    it(""should reject comb fields without a maximum length"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.comb).toEqual(false);

    it(""should accept comb fields with a maximum length"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.comb).toEqual(true);

    it(""should only accept comb fields when the flags are valid"", async function () {
","async () => {
try {
const annotation = await AnnotationFactory.create();
expect(annotation.data.annotationType).toEqual(AnnotationType.WIDGET);
expect(annotation.data.textAlignment).toEqual(1);
expect(annotation.data.maxLen).toEqual(20);
expect(annotation.data.readOnly).toEqual(true);
expect(annotation.data.hidden).toEqual(false);
expect(annotation.data.multiLine).toEqual(true);
done();
} catch (error) {
done.fail();
}
};

it(""should reject comb fields without a maximum length"", async () => {
try {
const annotation = await AnnotationFactory.create();
expect(annotation.data.comb).toEqual(false);
done();
} catch (error) {
done.fail();
}
});

it(""should accept comb fields with a maximum length"", async () => {
try {
const annotation = await AnnotationFactory.create();
expect(annotation.data.comb).toEqual(true);
done();
} catch (error) {
done.fail();
}
});

it(""should only accept comb fields when the flags are valid"", async () => {
try {
const annotation = await AnnotationFactory.create();
expect(annotation.data.comb).toEqual(true);
done();
} catch (error) {
done.fail();
}
});",0.541284561956463,0.4152873220154263,0.42285092581042605,0.752,0.575,0.4209790240789169,0.21987076429171215,0.3330453320239554,0.456,0.675,0.5314294803401873,0.26538776874391323,0.41252251471018864,0.504950495049505,0.9428571428571428
234,"      promise.then(done, done.fail);

    it(""should render regular text for printing"", function (done) {
","      await promise;

    it(""should render regular text for printing"", async function () {
","async function(){
    try{
        const response = await fetch('https://api.example.com');
        return response;
    } catch(error){
        throw error;
    }
}",0.5220073315191557,0.44833867003844585,0.5146906560381768,0.125,0.0,0.11458333333333333,0.0,0.0,0.125,0.3333333333333333,0.35926124928889497,0.014628063653657535,0.022416933501922302,0.4,0.0
235,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""test\\print"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (test\\\\print) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render regular text in Japanese for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""test\\print"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

          "" 2.00 2.00 Td (test\\\\print) Tj ET Q EMC""

      );

    });



    it(""should render regular text in Japanese for printing"", async function () {
","async function create() {
  try {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""test\\print"" });
    const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
    expect(appearance).toEqual(""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (test\\\\print) Tj ET Q EMC"");
    done();
  } catch (err) {
    done.fail(err);
  }
}",0.6250680095649334,0.678185626761939,0.6805479499593328,0.68,0.46153846153846156,0.4696606608510383,0.38921851878449615,0.3909625861581186,0.56,0.5384615384615384,0.6802057311848309,0.5061273290531114,0.516893397884014,0.7692307692307693,0.9285714285714286
236,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm"" +

              ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

          );

          done();

        }, done.fail);

    });



    it(""should render regular text for printing using normal appearance"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: ""こんにちは世界の"",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      const utf16String =

        ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm"" +

          ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

      );

    });



    it(""should render regular text for printing using normal appearance"", async function () {
","async function () {
  try {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""こんにちは世界の"" });
    const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
    expect(appearance).toEqual(""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (こんにちは世界の) Tj ET Q EMC"");
    done();
  } catch(error) {
    done.fail(error);
  }
});",0.5972643523211358,0.6448107285130382,0.6486584454773876,0.625,0.47058823529411764,0.3983610004657203,0.2858422764715407,0.301299204382937,0.5357142857142857,0.47058823529411764,0.6278162884209759,0.4047168973006724,0.42118573928336805,0.7441860465116279,0.9411764705882353
237,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should render auto-sized text for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );

    it(""should render auto-sized text for printing"", async function () {
","AnnotationFactory.create(

    )

      .then(annotation => {

        const annotationStorage = new Map();



        return annotation.getOperatorList(

          partialEvaluator,

          task,

          false,

          annotationStorage

        );

      })

      .then(opList => {

        expect(opList.argsArray.length).toEqual(3);

        expect(opList.fnArray).toEqual([

          OPS.beginAnnotation,

          OPS.setFillRGBColor,

          OPS.endAnnotation,

        ]);

        expect(opList.argsArray[1]).toEqual(

          new Uint8ClampedArray([26, 51, 76])

        );

        done();

      })

      .catch(done.fail);",0.4853030851665233,0.41633444977675776,0.4263115826456079,0.7096774193548387,0.3888888888888889,0.8640140597465049,0.7788007830714049,0.7811981082443638,0.9516129032258065,0.9444444444444444,0.45075982659159486,0.32371772107413543,0.31299505467999894,0.8163265306122449,0.35
238,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""test (print)"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (test \\(print\\)) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render auto-sized text in Japanese for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""test (print)"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

          "" 2.00 2.00 Td (test \\(print\\)) Tj ET Q EMC""

      );

    });



    it(""should render auto-sized text in Japanese for printing"", async function () {
","`async` function test(done) {

    try {

      const annotation = await AnnotationFactory.create();

      const partialEvaluator = new PDFJS.PartialEvaluator(
        new PDFJS.PDFDocument({
          pdfManager: new PDFJS.PDFManager(),
        }),
        null,
        null
      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""test (print)"" });

      const appearance = await annotation._getAppearance(
        partialEvaluator,
        task,
        annotationStorage
      );

      expect(appearance).toEqual(
        ""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm"" +
          "" 2.00 2.00 Td (test \\(print\\)) Tj ET Q EMC""
      );

      done();
    } catch (error) {
      done.fail(error);
    }
  }",0.6343462488467664,0.6970961640905597,0.6987503697580442,0.68,0.46153846153846156,0.5914909223930114,0.5277364747379569,0.5997656763725502,0.7,0.5384615384615384,0.6657233841258368,0.6387731689097799,0.7695416130148126,0.8974358974358975,0.35714285714285715
239,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

              ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

          );

          done();

        }, done.fail);

    });



    it(""should not render a password for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: ""こんにちは世界の"",

      });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      const utf16String =

        ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

          ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

      );

    });

    it(""should not render a password for printing"", async function () {
","async function createAnnotation() {

  try {

    const annotation = await AnnotationFactory.create();

    const annotationStorage = new Map();

    annotationStorage.set(annotation.data.id, { value: ""こんにちは世界の"" });

    const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);

    const utf16String = ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

    expect(appearance).toEqual(""/Tx BMC q BT /Goth 8 Tf 0 g 1 0 0 1 0 0 Tm"" + ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`);

    done();

  } catch (error) {

    done.fail(error);

  }

}",0.5972643523211358,0.6448107285130382,0.6486584454773876,0.625,0.47058823529411764,0.4951184826359575,0.4391849353012562,0.44570075994845604,0.625,0.47058823529411764,0.7678500490208716,0.5646862290673789,0.5764814088765726,0.9302325581395349,1.0
240,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""mypassword"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should render multiline text for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""mypassword"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(null);

    });



    it(""should render multiline text for printing"", async function () {
","AnnotationFactory.create()
    .then(async annotation => {
      const annotationStorage = new Map();
      annotationStorage.set(annotation.data.id, { value: ""mypassword"" });
      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
      expect(appearance).toEqual(null);
      done();
    }, done.fail);
  });
  
  it(""should render multiline text for printing"", async function() {
    try {
      const appearance = await new Map().set(annotation.data.id, { value: ""mypassword"" });
      expect(appearance).toEqual(null);
      done();
    } catch (e) {
      console.error(e);
    }
  });
}",0.5150832563102203,0.46528784604407686,0.47393224957323643,0.6595744680851063,0.46153846153846156,0.5768851512772117,0.3627733703311941,0.529055287150812,0.723404255319149,0.6923076923076923,0.6017438228834973,0.36227557436010244,0.5843822568564261,0.8888888888888888,0.5714285714285714
241,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value:

              ""a aa aaa aaaa aaaaa aaaaaa "" +

              ""pneumonoultramicroscopicsilicovolcanoconiosis"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm "" +

              ""2.00 -5.00 Td (a aa aaa ) Tj\n"" +

              ""0.00 -5.00 Td (aaaa aaaaa ) Tj\n"" +

              ""0.00 -5.00 Td (aaaaaa ) Tj\n"" +

              ""0.00 -5.00 Td (pneumonoultr) Tj\n"" +

              ""0.00 -5.00 Td (amicroscopi) Tj\n"" +

              ""0.00 -5.00 Td (csilicovolca) Tj\n"" +

              ""0.00 -5.00 Td (noconiosis) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render multiline text in Japanese for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value:

          ""a aa aaa aaaa aaaaa aaaaaa "" +

          ""pneumonoultramicroscopicsilicovolcanoconiosis"",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm "" +

          ""2.00 -5.00 Td (a aa aaa ) Tj\n"" +

          ""0.00 -5.00 Td (aaaa aaaaa ) Tj\n"" +

          ""0.00 -5.00 Td (aaaaaa ) Tj\n"" +

          ""0.00 -5.00 Td (pneumonoultr) Tj\n"" +

          ""0.00 -5.00 Td (amicroscopi) Tj\n"" +

          ""0.00 -5.00 Td (csilicovolca) Tj\n"" +

          ""0.00 -5.00 Td (noconiosis) Tj ET Q EMC""

      );

    });



    it(""should render multiline text in Japanese for printing"", async function () {
","AnnotationFactory.create()
    .then(annotation => {
      const annotationStorage = new Map();
      annotationStorage.set(annotation.data.id, {
        value: ""a aa aaa aaaa aaaaa aaaaaa pneumonoultramicroscopicsilicovolcanoconiosis"",
      });
      return annotation._getAppearance(partialEvaluator, task, annotationStorage);
    })
    .then(appearance => {
      expect(appearance).toEqual(
        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm 2.00 -5.00 Td (a aa aaa ) Tj\n"" +
          ""0.00 -5.00 Td (aaaa aaaaa ) Tj\n"" +
          ""0.00 -5.00 Td (aaaaaa ) Tj\n"" +
          ""0.00 -5.00 Td (pneumonoultr) Tj\n"" +
          ""0.00 -5.00 Td (amicroscopi) Tj\n"" +
          ""0.00 -5.00 Td (csilicovolca) Tj\n"" +
          ""0.00 -5.00 Td (noconiosis) Tj ET Q EMC""
      );
      done();
    })
    .catch(done.fail);
});",0.7119178542103807,0.8190018128855309,0.81713114241753,0.75,0.46153846153846156,0.704559802306644,0.7052246992182036,0.7043606638545258,0.5625,0.8461538461538461,0.569732607823735,0.6632461880488502,0.6399430033539069,0.5471698113207547,0.42857142857142855
242,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm "" +

              ""2.00 -5.00 Td (\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f) Tj\n"" +

              ""0.00 -5.00 Td (\x4e\x16\x75\x4c\x30\x6e) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render multiline text with various EOL for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: ""こんにちは世界の"",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm "" +

          ""2.00 -5.00 Td (\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f) Tj\n"" +

          ""0.00 -5.00 Td (\x4e\x16\x75\x4c\x30\x6e) Tj ET Q EMC""

      );

    });



    it(""should render multiline text with various EOL for printing"", async function () {
","async function test() {
  try {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""こんにちは世界の"" });
    const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
    expect(appearance).toEqual(""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm 2.00 -5.00 Td (\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f) Tj\n0.00 -5.00 Td (\x4e\x16\x75\x4c\x30\x6e) Tj ET Q EMC"");
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.643695452139319,0.7098716943722262,0.7110639603388959,0.6923076923076923,0.46153846153846156,0.4267098994898496,0.3416464995737682,0.34596232915486097,0.5576923076923077,0.46153846153846156,0.6579421041975845,0.4314283339353051,0.4442425218794229,0.7560975609756098,1.0
243,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value:

              ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.\r"" +

              ""Aliquam vitae felis ac lectus bibendum ultricies quis non diam.\n"" +

              ""Morbi id porttitor quam, a iaculis dui.\r\n"" +

              ""Pellentesque habitant morbi tristique senectus et "" +

              ""netus et malesuada fames ac turpis egestas.\n\r\n\r"" +

              ""Nulla consectetur, ligula in tincidunt placerat, "" +

              ""velit augue consectetur orci, sed mattis libero nunc ut massa.\r"" +

              ""Etiam facilisis tempus interdum."",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(expectedAppearance);

          done();

        }, done.fail);

    it(""should render comb for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value:

          ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.\r"" +

          ""Aliquam vitae felis ac lectus bibendum ultricies quis non diam.\n"" +

          ""Morbi id porttitor quam, a iaculis dui.\r\n"" +

          ""Pellentesque habitant morbi tristique senectus et "" +

          ""netus et malesuada fames ac turpis egestas.\n\r\n\r"" +

          ""Nulla consectetur, ligula in tincidunt placerat, "" +

          ""velit augue consectetur orci, sed mattis libero nunc ut massa.\r"" +

          ""Etiam facilisis tempus interdum."",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(expectedAppearance);

    it(""should render comb for printing"", async function () {
","async function createAnnotation(partialEvaluator, task, annotationStorage) {
  const annotation = await AnnotationFactory.create();
  const value = `Lorem ipsum dolor sit amet, consectetur adipiscing elit.\rAliquam vitae felis ac lectus bibendum ultricies quis non diam.\nMorbi id porttitor quam, a iaculis dui.\r\nPellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\n\r\n\rNulla consectetur, ligula in tincidunt placerat, velit augue consectetur orci, sed mattis libero nunc ut massa.\rEtiam facilisis tempus interdum.`;
  annotationStorage.set(annotation.data.id, { value });
  return await annotation._getAppearance(partialEvaluator, task, annotationStorage);
}

async function renderCombForPrinting() {
  const done = {};
  try {
    const expectedAppearance = `...`; // define the expected appearance here
    const partialEvaluator = await getPartialEvaluator();
    const task = await getTask();
    const annotationStorage = new Map();
    const appearance = await createAnnotation(partialEvaluator, task, annotationStorage);
    expect(appearance).toEqual(expectedAppearance);
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.6990278070838138,0.8035813177220114,0.8021778897527485,0.7288135593220338,0.46153846153846156,0.4593809061968469,0.29281937005627034,0.36869382448339866,0.4067796610169492,0.7692307692307693,0.4349397918710765,0.32134170937243123,0.41841745811187486,0.5,0.5
244,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""aa(aa)a\\"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 2 Tm"" +

              "" (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\() Tj"" +

              "" 8.00 0 Td (a) Tj 8.00 0 Td (a) Tj"" +

              "" 8.00 0 Td (\\)) Tj 8.00 0 Td (a) Tj"" +

              "" 8.00 0 Td (\\\\) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render comb with Japanese text for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""aa(aa)a\\"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 2 Tm"" +

          "" (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\() Tj"" +

          "" 8.00 0 Td (a) Tj 8.00 0 Td (a) Tj"" +

          "" 8.00 0 Td (\\)) Tj 8.00 0 Td (a) Tj"" +

          "" 8.00 0 Td (\\\\) Tj ET Q EMC""

      );

    });



    it(""should render comb with Japanese text for printing"", async function () {
","test(""should render comb with Japanese text for printing"", async () => {
  const annotationStorage = new Map();
  try {
    const annotation = await AnnotationFactory.create();
    annotationStorage.set(annotation.data.id, { value: ""aa(aa)a\\"" });
    const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
    expect(appearance).toEqual(
      ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 2 Tm"" +
        "" (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\() Tj"" +
        "" 8.00 0 Td (a) Tj 8.00 0 Td (a) Tj"" +
        "" 8.00 0 Td (\\)) Tj 8.00 0 Td (a) Tj"" +
        "" 8.00 0 Td (\\\\) Tj ET Q EMC""
    );
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
});",0.6924966815944877,0.7977990452916524,0.7963635052621225,0.7142857142857143,0.46153846153846156,0.6009639892687675,0.7123868013683647,0.7464142106517601,0.7142857142857143,0.23076923076923078,0.7726990827868752,0.7599465156127422,0.8260879107728543,0.9333333333333333,0.5714285714285714
245,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm"" +

              "" (\x30\x53) Tj 8.00 0 Td (\x30\x93) Tj 8.00 0 Td (\x30\x6b) Tj"" +

              "" 8.00 0 Td (\x30\x61) Tj 8.00 0 Td (\x30\x6f) Tj"" +

              "" 8.00 0 Td (\x4e\x16) Tj 8.00 0 Td (\x75\x4c) Tj"" +

              "" 8.00 0 Td (\x30\x6e) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should save text"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: ""こんにちは世界の"",

      });

      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm"" +

          "" (\x30\x53) Tj 8.00 0 Td (\x30\x93) Tj 8.00 0 Td (\x30\x6b) Tj"" +

          "" 8.00 0 Td (\x30\x61) Tj 8.00 0 Td (\x30\x6f) Tj"" +

          "" 8.00 0 Td (\x4e\x16) Tj 8.00 0 Td (\x75\x4c) Tj"" +

          "" 8.00 0 Td (\x30\x6e) Tj ET Q EMC""

      );

    });



    it(""should save text"", async function () {
","const createAnnotation = async () => {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""こんにちは世界の"" });
    return await annotation._getAppearance(partialEvaluator, task, annotationStorage);
};

const testSaveText = async () => {
    try {
        const appearance = await createAnnotation();
        expect(appearance).toEqual(""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm (\u3053) Tj 8.00 0 Td (\u3093) Tj 8.00 0 Td (\u306b) Tj 8.00 0 Td (\u3061) Tj 8.00 0 Td (\u306f) Tj 8.00 0 Td (\x4e\x16) Tj 8.00 0 Td (\u754c) Tj 8.00 0 Td (\u306e) Tj ET Q EMC"");
        done();
    } catch (error) {
        done.fail(error);
    }
};",0.6867902099463375,0.7874190075024624,0.7839176564587116,0.7142857142857143,0.46153846153846156,0.38954114331439355,0.3572031704360203,0.3754119522721031,0.5178571428571429,0.3076923076923077,0.4691256636807121,0.38384790482842734,0.419638876878548,0.6444444444444445,0.42857142857142855
246,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""hello world"" });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(2, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] "" +

              ""/V (hello world) /AP << /N 2 0 R>> /M (date)>>\nendobj\n""

          );

          expect(newData.data).toEqual(

            ""2 0 obj\n<< /Length 77 /Subtype /Form /Resources "" +

              ""<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

              ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (hello world) Tj "" +

              ""ET Q EMC\nendstream\nendobj\n""

          );

          done();

        }, done.fail);

    });



    it(""should get field object for usage in JS sandbox"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""hello world"" });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [oldData, newData] = data;

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(newData.ref).toEqual(Ref.get(2, 0));



      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR "" +

          ""<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] "" +

          ""/V (hello world) /AP << /N 2 0 R>> /M (date)>>\nendobj\n""

      );

      expect(newData.data).toEqual(

        ""2 0 obj\n<< /Length 77 /Subtype /Form /Resources "" +

          ""<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

          ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (hello world) Tj "" +

          ""ET Q EMC\nendstream\nendobj\n""

      );

    });



    it(""should get field object for usage in JS sandbox"", async function () {
","async function createAnnotation() {

  const annotation = await AnnotationFactory.create();

  const annotationStorage = new Map();

  annotationStorage.set(annotation.data.id, { value: ""hello world"" });

  return await annotation.save(partialEvaluator, task, annotationStorage);

}

async function verifyData() {

  const data = await createAnnotation();

  expect(data.length).toEqual(2);

  const [oldData, newData] = data;

  expect(oldData.ref).toEqual(Ref.get(123, 0));

  expect(newData.ref).toEqual(Ref.get(2, 0));

  oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

  expect(oldData.data).toEqual(

    ""123 0 obj\n"" +

      ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR "" +

      ""<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] "" +

      ""/V (hello world) /AP << /N 2 0 R>> /M (date)>>\nendobj\n""

  );

  expect(newData.data).toEqual(

    ""2 0 obj\n<< /Length 77 /Subtype /Form /Resources "" +

      ""<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

      ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (hello world) Tj "" +

      ""ET Q EMC\nendstream\nendobj\n""

  );

  done();

}

verifyData();",0.7069418965303225,0.8523028771476133,0.8508855843945522,0.8518518518518519,0.2727272727272727,0.7195588426724319,0.8188726804403655,0.8135714444581161,0.8518518518518519,0.3939393939393939,0.756863604032252,0.8358041691302394,0.8314319328689929,0.9484536082474226,0.4117647058823529
247,"      AnnotationFactory.create(

      )

        .then(annotation => {

          return annotation.getFieldObject();

        })

        .then(object => {

          const actions = object.actions;

          expect(actions[""Mouse Enter""]).toEqual([""hello()""]);

          expect(actions[""Mouse Exit""]).toEqual([

            ""world()"",

            ""olleh()"",

            ""foo()"",

            ""dlrow()"",

            ""oof()"",

          ]);

          expect(actions[""Mouse Down""]).toEqual([""bar()""]);

          done();

        }, done.fail);

    it(""should save Japanese text"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const fieldObject = await annotation.getFieldObject();

      const actions = fieldObject.actions;

      expect(actions[""Mouse Enter""]).toEqual([""hello()""]);

      expect(actions[""Mouse Exit""]).toEqual([

        ""world()"",

        ""olleh()"",

        ""foo()"",

        ""dlrow()"",

        ""oof()"",

      ]);

      expect(actions[""Mouse Down""]).toEqual([""bar()""]);

    it(""should save Japanese text"", async function () {
","async function createAnnotation() {
  const annotation = await AnnotationFactory.create();
  const object = await annotation.getFieldObject();
  const actions = object.actions;
  expect(actions[""Mouse Enter""]).toEqual([""hello()""]);
  expect(actions[""Mouse Exit""]).toEqual([
    ""world()"",
    ""olleh()"",
    ""foo()"",
    ""dlrow()"",
    ""oof()"",
  ]);
  expect(actions[""Mouse Down""]).toEqual([""bar()""]);
}",0.47777434883115244,0.41718457776773915,0.41864400035256966,0.7419354838709677,0.3333333333333333,0.4859770922258095,0.428715812387361,0.4399237393115759,0.7419354838709677,0.3333333333333333,0.7536494673521485,0.5407156349837596,0.5597796703222705,0.9807692307692307,0.9333333333333333
248,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(2, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] "" +

              `/V (\xfe\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\nendobj\n`

          );

          expect(newData.data).toEqual(

            ""2 0 obj\n<< /Length 82 /Subtype /Form /Resources "" +

              ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

              `/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (${utf16String}) Tj ` +

              ""ET Q EMC\nendstream\nendobj\n""

          );

          done();

        }, done.fail);
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, {

        value: ""こんにちは世界の"",

      });

      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      const utf16String =

        ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

      expect(data.length).toEqual(2);

      const [oldData, newData] = data;

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(newData.ref).toEqual(Ref.get(2, 0));



      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR "" +

          ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] "" +

          `/V (\xfe\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\nendobj\n`

      );

      expect(newData.data).toEqual(

        ""2 0 obj\n<< /Length 82 /Subtype /Form /Resources "" +

          ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

          `/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (${utf16String}) Tj ` +

          ""ET Q EMC\nendstream\nendobj\n""

      );
","async function createAnnotation(annotationFactory) {
  try {
    const annotation = await annotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""こんにちは世界の"" });
    const data = await annotation.save(partialEvaluator, task, annotationStorage);
    const utf16String = ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";
    expect(data.length).toEqual(2);
    const [oldData, newData] = data;
    expect(oldData.ref).toEqual(Ref.get(123, 0));
    expect(newData.ref).toEqual(Ref.get(2, 0));
    oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
    expect(oldData.data).toEqual(""123 0 obj\n<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR << /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] `/V (\xfe\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\nendobj\n"");
    expect(newData.data).toEqual(""2 0 obj\n<< /Length 82 /Subtype /Form /Resources << /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\n/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (${utf16String}) Tj ET Q EMC\nendstream\nendobj\n"");
    return data;
  } catch (error) {
    console.error(error);
  }
}",0.742752473932609,0.8469597913622694,0.844770825088887,0.8198198198198198,0.4594594594594595,0.5703845149703701,0.601225989231135,0.6082399985782734,0.6396396396396397,0.43243243243243246,0.7662614283371443,0.6617928418614614,0.6701701647201987,0.7857142857142857,0.9473684210526315
249,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        expect(data.exportValue).toEqual(""Checked"");

        done();

      }, done.fail);

    it(""should handle checkboxes without export value"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.defaultFieldValue).toEqual(""2"");

      expect(data.radioButton).toEqual(false);

      expect(data.exportValue).toEqual(""Checked"");

    it(""should handle checkboxes without export value"", async function () {
","async function testCreate() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.checkBox).toEqual(true);
    expect(data.fieldValue).toEqual(""1"");
    expect(data.defaultFieldValue).toEqual(""2"");
    expect(data.radioButton).toEqual(false);
    expect(data.exportValue).toEqual(""Checked"");
  } catch (error) {
    done();
  }
}",0.4877891560665364,0.42293855423204196,0.43342640336743693,0.828125,0.26666666666666666,0.3906963056114086,0.2255489037266197,0.2268196520523481,0.84375,0.26666666666666666,0.6159919532545525,0.26512298021756175,0.27027340422921947,0.9285714285714286,1.0
250,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        done();

      }, done.fail);

    it(""should handle checkboxes without /Off appearance"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.defaultFieldValue).toEqual(""2"");

      expect(data.radioButton).toEqual(false);

    it(""should handle checkboxes without /Off appearance"", async function () {
","async function testCreateAnnotation() {
    try {
        const data = await AnnotationFactory.create();
        expect(data.annotationType).toEqual(AnnotationType.WIDGET);
        expect(data.checkBox).toEqual(true);
        expect(data.fieldValue).toEqual(""1"");
        expect(data.defaultFieldValue).toEqual(""2"");
        expect(data.radioButton).toEqual(false);
    } catch (error) {
        done.fail();
    }
}",0.4755813416400173,0.39242591746953154,0.3986357128268013,0.8035714285714286,0.3076923076923077,0.36500271190599526,0.178551492991616,0.18805276122577164,0.7857142857142857,0.3076923076923077,0.5923221032020414,0.22067731046885494,0.23194443567264392,0.9166666666666666,1.0
251,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        expect(data.exportValue).toEqual(""Checked"");

        done();

      }, done.fail);

    it(""should render checkbox with fallback font for printing"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.defaultFieldValue).toEqual(""2"");

      expect(data.radioButton).toEqual(false);

      expect(data.exportValue).toEqual(""Checked"");

    it(""should render checkbox with fallback font for printing"", async function () {
","async function createAnnotation() {
    try {
        const { data } = await AnnotationFactory.create();
        expect(data.annotationType).toEqual(AnnotationType.WIDGET);
        expect(data.checkBox).toEqual(true);
        expect(data.fieldValue).toEqual(""1"");
        expect(data.defaultFieldValue).toEqual(""2"");
        expect(data.radioButton).toEqual(false);
        expect(data.exportValue).toEqual(""Checked"");
        done();
    } catch (error) {
        done.fail(error);
    }
}

it(""should render checkbox with fallback font for printing"", function () {
    createAnnotation();
});",0.5144272048307187,0.4748354118389711,0.4880817408172368,0.828125,0.26666666666666666,0.5086855343164864,0.34732675666474594,0.5613737139345331,0.859375,0.26666666666666666,0.6440726520546532,0.4359170096009643,0.6915640748081247,0.9821428571428571,0.4666666666666667
252,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(5);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.dependency,

            OPS.setFont,

            OPS.showText,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[3][0][0].fontChar).toEqual(""✔"");

          done();

        })

        .catch(done.fail);

    it(""should render checkboxes for printing"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(5);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.dependency,

        OPS.setFont,

        OPS.showText,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[3][0][0].fontChar).toEqual(""✔"");

    it(""should render checkboxes for printing"", async function () {
","async function createAnnotation() {
    const annotation = await AnnotationFactory.create();

    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: true });

    const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);

    expect(opList.argsArray.length).toEqual(5);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.dependency, OPS.setFont, OPS.showText, OPS.endAnnotation]);
    expect(opList.argsArray[3][0][0].fontChar).toEqual(""✔"");

    return opList;
  }

  it(""should render checkboxes for printing"", async () => {
    try {
      const opList = await createAnnotation();
      expect(opList.argsArray.length).toEqual(5);
      expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.dependency, OPS.setFont, OPS.showText, OPS.endAnnotation]);
      expect(opList.argsArray[3][0][0].fontChar).toEqual(""✔"");
    } catch (error) {
      done.fail(error);
    }
  });",0.5293620430015352,0.473635514593578,0.48129709078740734,0.7534246575342466,0.4090909090909091,0.4421051128543997,0.23323061408854304,0.35897564056691356,0.7671232876712328,0.4090909090909091,0.5517279860745182,0.2937106351341358,0.4715346424972705,0.9833333333333333,0.4583333333333333
253,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        }, done.fail)

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        }, done.fail)

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        }, done.fail);

    it(""should render checkboxes for printing two times"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      let operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );



      annotationStorage.set(annotation.data.id, { value: false });



      operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([76, 51, 26])

      );

    it(""should render checkboxes for printing twice"", async function () {
","AnnotationFactory.create()
     .then(annotation => {
       const annotationStorage = new Map();
       annotationStorage.set(annotation.data.id, { value: true });
       return Promise.all([annotation, annotation.getOperatorList(partialEvaluator, task, false, annotationStorage)]);
     })
     .then(([annotation, opList]) => {
       expect(opList.argsArray.length).toEqual(3);
       expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
       expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
       return annotation;
     })
     .then(annotation => {
       const annotationStorage = new Map();
       annotationStorage.set(annotation.data.id, { value: false });
       return annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
     })
     .then(opList => {
       expect(opList.argsArray.length).toEqual(3);
       expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
       expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));
       done();
     });
   it(""should render checkboxes for printing two times"", function (done) {",0.4707231151993285,0.3522003272422583,0.3706491690008132,0.7518796992481203,0.40816326530612246,0.6694522550410692,0.4380215476196064,0.45998081303876287,0.9022556390977443,0.8775510204081632,0.44806026183137104,0.24148801584689608,0.25966392256769716,0.8910891089108911,0.4
254,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        })

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        })

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should render checkboxes for printing using normal appearance"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      for (let i = 0; i < 2; i++) {

        annotationStorage.set(annotation.data.id, { value: true });



        const operatorList = await annotation.getOperatorList(

          partialEvaluator,

          task,

          false,

          annotationStorage

        );

        expect(operatorList.argsArray.length).toEqual(3);

        expect(operatorList.fnArray).toEqual([

          OPS.beginAnnotation,

          OPS.setFillRGBColor,

          OPS.endAnnotation,

        ]);

        expect(operatorList.argsArray[1]).toEqual(

          new Uint8ClampedArray([26, 51, 76])

        );

      }

    it(""should render checkboxes for printing using normal appearance"", async function () {
","async function createAnnotation() {
  try {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: true });
    const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
    expect(opList.argsArray.length).toEqual(3);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
    return annotation;
  } catch (error) {
    done.fail(error);
  }
}

async function renderCheckboxesForPrinting() {
  try {
    const annotation = await createAnnotation();
    const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
    expect(opList.argsArray.length).toEqual(3);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.36815770658184055,0.23250244691227379,0.26415583936932197,0.7368421052631579,0.2391304347826087,0.3405047287046412,0.13981678543498335,0.14423547361372221,0.7518796992481203,0.32608695652173914,0.43742122143790035,0.1568894601042134,0.21977955263151494,0.873015873015873,0.5
255,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should save checkboxes"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );

    it(""should save checkboxes"", async function () {
","async function testSaveCheckboxes() {
  try {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
    expect(opList.argsArray.length).toEqual(3);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.46023670659363297,0.3671365260976781,0.3752439920331262,0.7096774193548387,0.3888888888888889,0.3429431316293487,0.1258491000974452,0.13122808591815752,0.7258064516129032,0.3888888888888889,0.6072035233355867,0.22637483204056413,0.2432555878323948,0.9591836734693877,1.0
256,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        }, done.fail)

        .then(([annotation, [oldData]]) => {

          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/V /Checked /AS /Checked /M (date)>>\nendobj\n""

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should handle radio buttons with a field value"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      const [oldData] = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Btn "" +

          ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

          ""/V /Checked /AS /Checked /M (date)>>\nendobj\n""

      );



      annotationStorage.set(annotation.data.id, { value: false });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data).toEqual(null);

    });



    it(""should handle radio buttons with a field value"", async function () {
","async function test() {
  try {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: true });
    const [annotation, oldData] = await Promise.all([annotation, annotation.save(partialEvaluator, task, annotationStorage)]);
    expect(oldData.ref).toEqual(Ref.get(123, 0));
    expect(oldData.data).toEqual(""123 0 obj\n"" + ""<< /Type /Annot /Subtype /Widget /FT /Btn "" + ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" + ""/V /Checked /AS /Checked /M (date)>>\nendobj\n"");
    return annotation;
  } catch (error) {
    done.fail();
  }
}",0.5477525622228688,0.5483090896206295,0.551279302631598,0.7130434782608696,0.3783783783783784,0.40909026744219257,0.34841704954507324,0.38101100024719886,0.5826086956521739,0.32432432432432434,0.5451147616815368,0.46310803473550255,0.4788798861078031,0.6867469879518072,0.5517241379310345
257,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.buttonValue).toEqual(""2"");

        done();

      }, done.fail);

    it(""should handle radio buttons with a field value not an ascii string"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(false);

      expect(data.radioButton).toEqual(true);

      expect(data.fieldValue).toEqual(""1"");

      expect(data.buttonValue).toEqual(""2"");

    it(""should handle radio buttons with a field value that's not an ASCII string"", async function () {
","async function test() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.checkBox).toEqual(false);
    expect(data.radioButton).toEqual(true);
    expect(data.fieldValue).toEqual(""1"");
    expect(data.buttonValue).toEqual(""2"");
  } catch (error) {
    done.fail();
  }
}",0.48052723032688577,0.39416223381555254,0.4166829512282543,0.8035714285714286,0.3076923076923077,0.34371927890853676,0.13755274871304538,0.14391777351450838,0.7857142857142857,0.3076923076923077,0.5634952585498204,0.1627725251305604,0.17454184240205473,0.9166666666666666,1.0
258,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(""‚I=‚ðﬁàŠe3"");

        expect(data.buttonValue).toEqual(""‚I=‚ðﬁàŠe3"");

        done();

      }, done.fail);

    it(""should handle radio buttons without a field value"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(false);

      expect(data.radioButton).toEqual(true);

      expect(data.fieldValue).toEqual(""‚I=‚ðﬁàŠe3"");

      expect(data.buttonValue).toEqual(""‚I=‚ðﬁàŠe3"");

    it(""should handle radio buttons without a field value"", async function () {
","AnnotationFactory.create( )
    .then ( ({ data }) => {
      expect (data.annotationType).toEqual(AnnotationType.WIDGET);
      expect (data.checkBox).toEqual(false);
      expect (data.radioButton).toEqual(true);
      expect (data.fieldValue).toEqual(""‚I=‚ðﬁàŠe3"");
      expect (data.buttonValue).toEqual(""‚I=‚ðﬁàŠe3"");
      done();
    }, done.fail);
  } );
}",0.5044064789911962,0.45022125383821326,0.456140925862835,0.8035714285714286,0.3076923076923077,0.5410567971048438,0.14100024578768863,0.13586430526904905,0.9642857142857143,0.9230769230769231,0.2870504155188959,0.011328360454400999,0.010270737518618322,0.8958333333333334,0.23076923076923078
259,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(null);

        expect(data.buttonValue).toEqual(""2"");

        done();

      }, done.fail);

    it(""should render radio buttons for printing"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.checkBox).toEqual(false);

      expect(data.radioButton).toEqual(true);

      expect(data.fieldValue).toEqual(null);

      expect(data.buttonValue).toEqual(""2"");

    it(""should render radio buttons for printing"", async function () {
","async function test() {
    try {
        const data = await AnnotationFactory.create();

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(null);

        expect(data.buttonValue).toEqual(""2"");

        done();
    } catch (error) {
        done.fail(error);
    }
}

it(""should render radio buttons for printing"", function (done) {
    test().then(() => {
        done();
    }).catch((error) => {
        done.fail(error);
    });
});",0.47579509737537284,0.39242591746953154,0.4030621643396521,0.8,0.3076923076923077,0.5106411347103024,0.3029483108475601,0.5955602839377053,0.8363636363636363,0.3076923076923077,0.5112716079342114,0.2258043389079604,0.4428500142691474,0.9148936170212766,0.46153846153846156
260,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        }, done.fail)

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        }, done.fail)

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        }, done.fail);

    it(""should render radio buttons for printing using normal appearance"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      let operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([26, 51, 76])

      );



      annotationStorage.set(annotation.data.id, { value: false });



      operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([76, 51, 26])

      );

    it(""should render radio buttons for printing using normal appearance"", async function () {
","async function test() {
  const annotationFactory = new AnnotationFactory();
  const task = null;
  const partialEvaluator = null;
  try {
    const annotation = await annotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: true });
    const [annotation1, opList] = await Promise.all([
      annotation,
      annotation.getOperatorList(partialEvaluator, task, false, annotationStorage),
    ]);
    expect(opList.argsArray.length).toEqual(3);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: false });
    const opList1 = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
    expect(opList1.argsArray.length).toEqual(3);
    expect(opList1.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList1.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));
    done();
  } catch (error) {
    done.fail();
  }
}",0.48837041974473844,0.38859486083717487,0.4048438535875362,0.7518796992481203,0.40816326530612246,0.3819951899224088,0.22197055550652592,0.2308222342582974,0.7894736842105263,0.2857142857142857,0.4024830935464539,0.2150071831646397,0.25952915141721555,0.9603960396039604,0.175
261,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        })

        .catch(done.fail);

    it(""should save radio buttons"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();



      const operatorList = await annotation.getOperatorList(

        partialEvaluator,

        task,

        false,

        annotationStorage

      );

      expect(operatorList.argsArray.length).toEqual(3);

      expect(operatorList.fnArray).toEqual([

        OPS.beginAnnotation,

        OPS.setFillRGBColor,

        OPS.endAnnotation,

      ]);

      expect(operatorList.argsArray[1]).toEqual(

        new Uint8ClampedArray([76, 51, 26])

      );

    it(""should save radio buttons"", async function () {
","async function createAnnotation() {
    try {
      const annotation = await AnnotationFactory.create();
      const annotationStorage = new Map();
      const opList = await annotation.getOperatorList(
        partialEvaluator,
        task,
        false,
        annotationStorage,
      );
      expect(opList.argsArray.length).toEqual(3);
      expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
      expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));
      done();
    } catch (error) {
      done.fail(error);
    }
  }

  it(""should save radio buttons"", function () {
    createAnnotation();
  });",0.46890631164088636,0.3846040630837685,0.3924548752360495,0.7096774193548387,0.3888888888888889,0.3991566729110554,0.2113189384935821,0.2544833803907828,0.7419354838709677,0.3888888888888889,0.5371381801673422,0.3139142040010154,0.4050466799336595,0.9795918367346939,0.45
262,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        }, done.fail)

        .then(([annotation, data]) => {

          expect(data.length).toEqual(2);

          const [radioData, parentData] = data;

          radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(radioData.ref).toEqual(Ref.get(123, 0));

          expect(radioData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

          );

          expect(parentData.ref).toEqual(Ref.get(456, 0));

          expect(parentData.data).toEqual(

            ""456 0 obj\n<< /V /Checked /Kids [123 0 R]>>\nendobj\n""

          );



          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should save radio buttons without a field value"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      let data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [radioData, parentData] = data;

      radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(radioData.ref).toEqual(Ref.get(123, 0));

      expect(radioData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

          ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

          ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

      );

      expect(parentData.ref).toEqual(Ref.get(456, 0));

      expect(parentData.data).toEqual(

        ""456 0 obj\n<< /V /Checked /Kids [123 0 R]>>\nendobj\n""

      );



      annotationStorage.set(annotation.data.id, { value: false });



      data = await annotation.save(partialEvaluator, task, annotationStorage);

      expect(data).toEqual(null);

    });



    it(""should save radio buttons without a field value"", async function () {
","it('should save radio buttons without a field value', function(done) {
  AnnotationFactory.create()
    .then(annotation => {
      const annotationStorage = new Map();
      annotationStorage.set(annotation.data.id, { value: false });
      return annotation.save(partialEvaluator, task, annotationStorage);
    })
    .then(data => {
      expect(data).toEqual(null);
      done();
    }, done.fail);
});",0.6054473543803638,0.6346510104047762,0.6351320292266979,0.7746478873239436,0.37735849056603776,0.21580917102360417,0.05427490529536615,0.20731415722052277,0.4507042253521127,0.1509433962264151,0.16390940211438682,0.052015522609442,0.13544026766628714,0.4,0.06818181818181818
263,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        })

        .then(([annotation, data]) => {

          expect(data.length).toEqual(2);

          const [radioData, parentData] = data;

          radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(radioData.ref).toEqual(Ref.get(123, 0));

          expect(radioData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

          );

          expect(parentData.ref).toEqual(Ref.get(456, 0));

          expect(parentData.data).toEqual(

            ""456 0 obj\n<< /Kids [123 0 R] /V /Checked>>\nendobj\n""

          );

          done();

        })

        .catch(done.fail);

    });



    it(""should save nothing"", function (done) {

      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          return annotation.save(partialEvaluator, task, annotationStorage);

        })

        .then(data => {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""should handle push buttons"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: true });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [radioData, parentData] = data;

      radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(radioData.ref).toEqual(Ref.get(123, 0));

      expect(radioData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

          ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

          ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

      );

      expect(parentData.ref).toEqual(Ref.get(456, 0));

      expect(parentData.data).toEqual(

        ""456 0 obj\n<< /Kids [123 0 R] /V /Checked>>\nendobj\n""

      );

    });



    it(""should save nothing"", async function () {

      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data).toEqual(null);

    it(""should handle push buttons"", async function () {
","it(""should save nothing"", function(done) {
  AnnotationFactory.create()
    .then(annotation => {
      const annotationStorage = new Map();
      return annotation.save(partialEvaluator, task, annotationStorage);
    })
    .then(data => {
      expect(data).toEqual(null);
      done();
    })
    .catch(done.fail);
});",0.604661162092396,0.6343868494310805,0.636286746987095,0.7328767123287672,0.41509433962264153,0.21802403120471595,0.018251189879429596,0.1703349840477309,0.5136986301369864,0.16981132075471697,0.14070104938736494,0.005309380185745672,0.04317329928279756,0.41228070175438597,0.10204081632653061
264,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.pushButton).toEqual(true);

        expect(data.actions.Action).toEqual([""do_something();""]);

        done();

      }, done.fail);

    it(""should handle push buttons that act as a tooltip only"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.pushButton).toEqual(true);

      expect(data.actions.Action).toEqual([""do_something();""]);

    it(""should handle push buttons that act as a tooltip only"", async function () {
","async function createAnnotation() {

    let data = await AnnotationFactory.create();

    expect(data.annotationType).toEqual(AnnotationType.WIDGET);

    expect(data.pushButton).toEqual(true);

    expect(data.actions.Action).toEqual([""do_something();""]);

    done();

}",0.5237481676642801,0.45022125383821326,0.456140925862835,0.7441860465116279,0.4444444444444444,0.3555224606723191,0.0932007944151481,0.11700274336456751,0.7674418604651163,0.4444444444444444,0.5001896831909075,0.051775260110507045,0.06326918693883722,0.8857142857142857,1.0
265,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.pushButton).toEqual(true);

        expect(data.alternativeText).toEqual(""An alternative text"");

        done();

      }, done.fail);

    it(""should handle URL in A dict in push buttons"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.pushButton).toEqual(true);

      expect(data.alternativeText).toEqual(""An alternative text"");

    it(""should handle URL in A dict in push buttons"", async function () {
","async function createAnnotation() {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.pushButton).toEqual(true);
  expect(data.alternativeText).toEqual(""An alternative text"");
}

it(""should handle URL in A dict in push buttons"", async function (done) {
  try {
    await createAnnotation();
    done();
  } catch (error) {
    done.fail(error);
  }
});",0.5347672285434557,0.4748354118389711,0.4880817408172368,0.7317073170731707,0.4444444444444444,0.5185308668372,0.3255612416171093,0.5236299764091974,0.7804878048780488,0.4444444444444444,0.5712015048575302,0.37065734067703937,0.5909163555207582,0.8787878787878788,0.4444444444444444
266,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

        done();

      }, done.fail);

    it(""should handle URL in AA dict in push buttons"", function (done) {

      // D stands for MouseDown
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

    it(""should handle URL in AA dict in push buttons"", async function () {

      // D stands for MouseDown.
","async function testCreate() {
    
      let data = await AnnotationFactory.create();

      expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

      done();

    } catch (error) {
        console.log('Error: ' + error);
    }

  it(""should handle URL in AA dict in push buttons"", async function () {

    // D stands for MouseDown

    try {
        
      await testCreate();

    } catch (error) {
        console.log('Error: ' + error);
    }
});",0.45987908093441077,0.45617777001984994,0.47308214346138305,0.5769230769230769,0.3333333333333333,0.5149652499435086,0.25557207878265975,0.5222376389400927,0.6153846153846154,0.6666666666666666,0.5689572887222906,0.33528499045526794,0.6627663866561166,0.7777777777777778,0.5
267,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

        done();

      }, done.fail);
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");
","async function test() {
  const data = await AnnotationFactory.create();

  try {
    expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");
  } catch (error) {
    done.fail(error);
  }

  done();
}",0.28588192787933964,0.03034691922392704,0.02984745896009824,0.5833333333333334,0.5,0.30057378694090203,0.024218026052883736,0.05307712171072445,0.625,0.5,0.46236007523660605,0.027854685173648884,0.07158561577277536,0.75,1.0
268,"    it(""should handle missing option arrays"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual([]);

        done();

      }, done.fail);

    it(""should handle option arrays with array elements"", function (done) {
","    it(""should handle missing option arrays"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual([]);

    it(""should handle option arrays with array elements"", async function () {
","it(""should handle missing option arrays"", async () => {

  const data = await AnnotationFactory.create();

  expect(data.annotationType).toEqual(AnnotationType.WIDGET);

  expect(data.options).toEqual([]);

});

it(""should handle option arrays with array elements"", async () => {

  const data = await AnnotationFactory.create();

  expect(data.annotationType).toEqual(AnnotationType.WIDGET);

  expect(data.options).toEqual([[]]);

});",0.47761408061541055,0.36033217429111203,0.38345748150386344,0.6666666666666666,0.5,0.4714102716967733,0.2926394666583954,0.3541127312398089,0.6388888888888888,0.6,0.6701227190504336,0.3777959269369953,0.4455520921218821,0.8571428571428571,1.0
269,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should handle option arrays with string elements"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual(expected);

    it(""should handle option arrays with string elements"", async function () {
","async function testCase(done) {
      try{
        const data = await AnnotationFactory.create();

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

    } catch (e) {
         done.fail(e);
      }
}

it(""should handle option arrays with string elements"", testCase);",0.48321840698973023,0.34177883785923663,0.3529995520044464,0.6666666666666666,0.5714285714285714,0.5238794913955799,0.27195592687669795,0.3820035971471801,0.7272727272727273,0.7142857142857143,0.47696738385952214,0.28495577603220296,0.3943423308344571,0.8,0.42857142857142855
270,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should handle inherited option arrays (issue 8094)"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual(expected);

    it(""should handle inherited option arrays (issue 8094)"", async function () {
","it(""should handle inherited option arrays (issue 8094)"", async function () {
      try {
        const data = await AnnotationFactory.create();
        expect(data.annotationType).toEqual(AnnotationType.WIDGET);
        expect(data.options).toEqual(expected);
      } catch (error) {
        done.fail(error);
      }
    });",0.4820731241099097,0.34177883785923663,0.3484184204851643,0.6666666666666666,0.5714285714285714,0.4519135316020155,0.25638685577115294,0.34347506284470114,0.6363636363636364,0.5714285714285714,0.7178088492798594,0.44431885703527124,0.5869165400841667,0.84,1.0
271,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should decode form values"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.options).toEqual(expected);

    it(""should decode form values"", async function () {
","async function create() {
try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.options).toEqual(expected);
} catch (err) {
    done.fail(err);
} finally {
    done();
}}

it(""should decode form values"", async function () {
try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.options).toEqual(expected);
} catch (err) {
    done.fail(err);
} finally {
    done();
}});",0.403841188645543,0.1860533529275829,0.19121616355935117,0.6666666666666666,0.5714285714285714,0.4521240792930893,0.06316759950045185,0.19121616355935117,0.696969696969697,0.8571428571428571,0.5907172395096761,0.16720322190847908,0.49852287898736825,0.84,0.8571428571428571
272,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldValue).toEqual([decodedString]);

        expect(data.defaultFieldValue).toEqual(""foo"");

        expect(data.options).toEqual([

          { exportValue: decodedString, displayValue: decodedString },

        ]);

        done();

      }, done.fail);

    it(""should convert the field value to an array"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.fieldValue).toEqual([decodedString]);

      expect(data.defaultFieldValue).toEqual(""foo"");

      expect(data.options).toEqual([

        { exportValue: decodedString, displayValue: decodedString },

      ]);

    it(""should convert the field value to an array"", async function () {
","// Wrapped in async function to enable the use of await
async function createAnnotation() {
  try {
    const annotation = await AnnotationFactory.create();
    expect(annotation.data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(annotation.data.fieldValue).toEqual([decodedString]);
    expect(annotation.data.defaultFieldValue).toEqual(""foo"");
    expect(annotation.data.options).toEqual([{ exportValue: decodedString, displayValue: decodedString }]);
  } catch (error) {
    done.fail();
  }
}",0.6091472054958346,0.5697232579989888,0.5744127337956701,0.7924528301886793,0.5,0.28690332320780826,0.07628670307350822,0.09962847655017769,0.4716981132075472,0.5,0.4445472858580939,0.09592545068492521,0.12670813719189472,0.5555555555555556,1.0
273,"      promise.then(done, done.fail);

    it(""should handle unknown flags"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(false);

        expect(data.multiSelect).toEqual(false);

        done();

      }, done.fail);

    it(""should not set invalid flags"", function (done) {
","      await promise;

    it(""should handle unknown flags"", async function () {

      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.combo).toEqual(false);

      expect(data.multiSelect).toEqual(false);

    it(""should not set invalid flags"", async function () {
","async function createAnnotation() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.readOnly).toEqual(false);
    expect(data.hidden).toEqual(false);
    expect(data.combo).toEqual(false);
    expect(data.multiSelect).toEqual(false);
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}",0.4651605229436032,0.3216697796870732,0.3404295069871576,0.7540983606557377,0.4444444444444444,0.40619408780419025,0.1364391382831056,0.13952118378975725,0.7377049180327869,0.6111111111111112,0.42634397103611954,0.16341357933411946,0.16862897147702552,0.84,0.5333333333333333
274,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(false);

        expect(data.multiSelect).toEqual(false);

        done();

      }, done.fail);

    it(""should set valid flags"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.readOnly).toEqual(false);

      expect(data.hidden).toEqual(false);

      expect(data.combo).toEqual(false);

      expect(data.multiSelect).toEqual(false);

    it(""should set valid flags"", async function () {
","it(""should set valid flags"", async () => {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.readOnly).toEqual(false);
  expect(data.hidden).toEqual(false);
  expect(data.combo).toEqual(false);
  expect(data.multiSelect).toEqual(false);
});",0.43657238158571265,0.3180610472500743,0.3242398751041724,0.7962962962962963,0.3076923076923077,0.42647178177338624,0.3174875225134448,0.30292951911001464,0.7777777777777778,0.3076923076923077,0.6743749569444523,0.39516591027546977,0.3892904392414698,0.9130434782608695,1.0
275,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(true);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(true);

        expect(data.multiSelect).toEqual(true);

        done();

      }, done.fail);

    it(""should render choice for printing"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.WIDGET);

      expect(data.readOnly).toEqual(true);

      expect(data.hidden).toEqual(false);

      expect(data.combo).toEqual(true);

      expect(data.multiSelect).toEqual(true);

    it(""should render choice for printing"", async function () {
","async function testAnnotationFactoryCreate() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.readOnly).toEqual(true);
    expect(data.hidden).toEqual(false);
    expect(data.combo).toEqual(true);
    expect(data.multiSelect).toEqual(true);
  } catch (error) {
    done.fail();
  } finally {
    done();
  }
}",0.45760125447783984,0.35788354361456914,0.36853287030818627,0.7962962962962963,0.3076923076923077,0.3630110316920122,0.15450079547146167,0.19355472730798323,0.7962962962962963,0.3076923076923077,0.5782498842303672,0.18598826516078387,0.2357069239345978,0.8913043478260869,1.0
276,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""a value"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (a value) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should save choice"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""a value"" });



      const appearance = await annotation._getAppearance(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(appearance).toEqual(

        ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

          "" 2.00 2.00 Td (a value) Tj ET Q EMC""

      );

    });



    it(""should save choice"", async function () {
","async function test() {
  const annotationFactory = new AnnotationFactory();
  try {
    const annotation = await annotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""a value"" });
    const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
    expect(appearance).toEqual(""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (a value) Tj ET Q EMC"");
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.6162278064555288,0.6623594855533385,0.6610132787303149,0.68,0.46153846153846156,0.44855769493609793,0.43655021904628205,0.4499882530058018,0.6,0.3076923076923077,0.5377851229762736,0.5313953027865713,0.5849466543199882,0.8205128205128205,0.21428571428571427
277,"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""C"" });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(1, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R>>>> "" +

              ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +

              ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""

          );

          expect(newData.data).toEqual(

            ""1 0 obj\n"" +

              ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +

              ""/BBox [0 0 32 10]>> stream\n"" +

              ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +

              ""endstream\nendobj\n""

          );

          done();

        }, done.fail);

    it(""should set the line coordinates"", function (done) {
","      const annotation = await AnnotationFactory.create(

      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""C"" });



      const data = await annotation.save(

        partialEvaluator,

        task,

        annotationStorage

      );

      expect(data.length).toEqual(2);

      const [oldData, newData] = data;

      expect(oldData.ref).toEqual(Ref.get(123, 0));

      expect(newData.ref).toEqual(Ref.get(1, 0));



      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

      expect(oldData.data).toEqual(

        ""123 0 obj\n"" +

          ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +

          ""<< /Font << /Helv 314 0 R>>>> "" +

          ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +

          ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""

      );

      expect(newData.data).toEqual(

        ""1 0 obj\n"" +

          ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +

          ""/BBox [0 0 32 10]>> stream\n"" +

          ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +

          ""endstream\nendobj\n""

      );

    it(""should set the line coordinates"", async function () {
","async function test() {
  const annotation = await AnnotationFactory.create();
  const annotationStorage = new Map();
  annotationStorage.set(annotation.data.id, { value: ""C"" });
  const data = await annotation.save(partialEvaluator, task, annotationStorage);
  expect(data.length).toEqual(2);
  const [oldData, newData] = data;
  expect(oldData.ref).toEqual(Ref.get(123, 0));
  expect(newData.ref).toEqual(Ref.get(1, 0));
  oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
  expect(oldData.data).toEqual(
    ""123 0 obj\n"" +
      ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +
      ""<< /Font << /Helv 314 0 R>>>> "" +
      ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +
      ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""
  );
  expect(newData.data).toEqual(
    ""1 0 obj\n"" +
      ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +
      ""/BBox [0 0 32 10]>> stream\n"" +
      ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +
      ""endstream\nendobj\n""
  );
  done();
}",0.707301652064442,0.8523028771476133,0.8496310038374277,0.8545454545454545,0.2727272727272727,0.7077257307143681,0.8434992584441419,0.8419491189587849,0.8727272727272727,0.2727272727272727,0.9381638483989767,0.8795208715965366,0.8832355321003801,0.98989898989899,1.0
278,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINE);

        expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);

        done();

      }, done.fail);

    it(""should correctly parse a file attachment"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.LINE);

      expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);

    it(""should correctly parse a file attachment"", async function () {
","AnnotationFactory.create().then(({ data }) => {
  expect(data.annotationType).toEqual(AnnotationType.LINE);
  expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);
  done();
}, done.fail);",0.5097401974900496,0.39242591746953154,0.3986357128268013,0.6764705882352942,0.5714285714285714,0.664679052353069,0.4226706686588658,0.46713797772820004,0.9117647058823529,0.8571428571428571,0.373632099851688,0.1457556240341958,0.15097057757035834,0.7692307692307693,0.42857142857142855
279,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);

        expect(data.file.filename).toEqual(""Test.txt"");

        expect(data.file.content).toEqual(stringToBytes(""Test attachment""));

        done();

      }, done.fail);

    it(""should inherit properties from its parent"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);

      expect(data.file.filename).toEqual(""Test.txt"");

      expect(data.file.content).toEqual(stringToBytes(""Test attachment""));

    it(""should inherit properties from its parent"", async function () {
","async function testCreate() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);
    expect(data.file.filename).toEqual(""Test.txt"");
    expect(data.file.content).toEqual(stringToBytes(""Test attachment""));
  } catch (error) {
    done.fail();
  } finally {
    done();
  }
}",0.48183465237456186,0.35788354361456914,0.3641410562218426,0.7608695652173914,0.4444444444444444,0.36926468554721764,0.11076060807725355,0.13924499401499874,0.782608695652174,0.4444444444444444,0.5517324215338946,0.13796620851017116,0.17422663552014367,0.8947368421052632,1.0
280,"      AnnotationFactory.create(

      ).then(({ data, viewable }) => {

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

        done();

      }, done.fail);

    it(""should handle missing parent properties"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.POPUP);

      expect(data.modificationDate).toEqual(""D:20190423"");

      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

    it(""should handle missing parent properties"", async function () {
","async function testCreate() {
    try {
        const annotation = await AnnotationFactory.create();
        expect(annotation.data.annotationType).toEqual(AnnotationType.POPUP);
        expect(annotation.data.modificationDate).toEqual(""D:20190423"");
        expect(annotation.data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
        done();
    } catch (error) {
        done.fail(error);
    }
}

async function testHandleMissingParentProperties() {
    try {
        const annotation = await AnnotationFactory.create();
        expect(annotation.data.missingParentProperty).toBeUndefined();
    } catch (error) {
        done.fail(error);
    }
}",0.47950908448329654,0.3697159037309286,0.37660326248508585,0.7272727272727273,0.4444444444444444,0.30937908423749483,0.05992026878339571,0.12204051261102798,0.5,0.5555555555555556,0.41566928957699123,0.03408981146282771,0.07303179128958157,0.5555555555555556,1.0
281,"      AnnotationFactory.create(

      ).then(({ data, viewable }) => {

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        expect(data.modificationDate).toEqual(null);

        expect(data.color).toEqual(null);

        done();

      }, done.fail);

      function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.POPUP);

      expect(data.modificationDate).toEqual(null);

      expect(data.color).toEqual(null);

      async function () {
","async function create(data, viewable) {
  try {
    const annotationType = await data.annotationType;
    const modificationDate = await data.modificationDate;
    const color = await data.color;
  } catch (error) {
    done();
  }
}",0.3166054919554333,0.07563852830111553,0.07967232840950672,0.6666666666666666,0.4444444444444444,0.20559202169235388,0.009152541620698935,0.019564751497922906,0.23809523809523808,0.5555555555555556,0.14596387416002454,0.023017423600862546,0.05103415147060813,0.17647058823529413,0.3333333333333333
282,"        AnnotationFactory.create(

        ).then(({ data, viewable }) => {

          expect(data.annotationType).toEqual(AnnotationType.POPUP);

          // We should not modify the `annotationFlags` returned through

          // e.g., the API.

          expect(data.annotationFlags).toEqual(25);

          // The popup should inherit the `viewable` property of the parent.

          expect(viewable).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","        const { data, viewable } = await AnnotationFactory.create(

        );

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        // We should not modify the `annotationFlags` returned through

        // e.g., the API.

        expect(data.annotationFlags).toEqual(25);

        // The popup should inherit the `viewable` property of the parent.

        expect(viewable).toEqual(true);

      async function () {
","`async function test() {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.POPUP);
    // We should not modify the `annotationFlags` returned through
    // e.g., the API.
    expect(data.annotationFlags).toEqual(25);
    // The popup should inherit the `viewable` property of the parent.
    const viewable = data.viewable;
    return { data, viewable };
  }
  try {
    const result = await test();
    expect(result.data.annotationType).toEqual(AnnotationType.POPUP);
    // We should not modify the `annotationFlags` returned through
    // e.g., the API.
    expect(result.data.annotationFlags).toEqual(25);
    // The popup should inherit the `viewable` property of the parent.
    expect(result.viewable).toEqual(true);
  } catch (error) {
    done.fail(error);
  }`",0.6478899745921751,0.7026349669314458,0.7059981021689619,0.6829268292682927,0.5,0.4962050237871751,0.30932925154031055,0.67549084360839,0.0,0.0,0.5114733595090584,0.3281526690448942,0.7177407689913391,0.0,0.0
283,"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.title).toEqual(""Correct Title"");

          expect(data.contents).toEqual(""Correct Text"");

          expect(data.modificationDate).toEqual(""D:20190423"");

          expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

          done();

        }, done.fail);

    it(""should handle a single ink list"", function (done) {
","        const { data } = await AnnotationFactory.create(

        );

        expect(data.title).toEqual(""Correct Title"");

        expect(data.contents).toEqual(""Correct Text"");

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

    it(""should handle a single ink list"", async function () {
","async function testCreateAnnotationFactory() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.title).toEqual(""Correct Title"");
    expect(data.contents).toEqual(""Correct Text"");
    expect(data.modificationDate).toEqual(""D:20190423"");
    expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
    done();
  } catch (error) {
    done.fail();
  }
}

it(""should handle a single ink list"", async function () {
  await testCreateAnnotationFactory();
});",0.5380040841537114,0.49719876934333024,0.502719665173613,0.7884615384615384,0.36363636363636365,0.5128939504717202,0.3428955163829333,0.5373516141752759,0.8076923076923077,0.36363636363636365,0.6198145127416765,0.43590190636977316,0.6797197809605695,0.9090909090909091,0.45454545454545453
284,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.INK);

        expect(data.inkLists.length).toEqual(1);

        expect(data.inkLists[0]).toEqual([

          { x: 1, y: 1 },

          { x: 1, y: 2 },

          { x: 2, y: 2 },

          { x: 3, y: 3 },

        ]);

        done();

      }, done.fail);

    it(""should handle multiple ink lists"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.INK);

      expect(data.inkLists.length).toEqual(1);

      expect(data.inkLists[0]).toEqual([

        { x: 1, y: 1 },

        { x: 1, y: 2 },

        { x: 2, y: 2 },

        { x: 3, y: 3 },

      ]);

    it(""should handle multiple ink lists"", async function () {
","async function testCreate() {
  try {
    const annotation = await AnnotationFactory.create();
    expect(annotation.data.annotationType).toEqual(AnnotationType.INK);
    expect(annotation.data.inkLists.length).toEqual(1);
    expect(annotation.data.inkLists[0]).toEqual([
      { x: 1, y: 1 },
      { x: 1, y: 2 },
      { x: 2, y: 2 },
      { x: 3, y: 3 },
    ]);
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}",0.6681060467388886,0.7126577774165892,0.7153219650945211,0.8,0.4444444444444444,0.5237710312861675,0.5024162113000312,0.5664052875820127,0.5818181818181818,0.4444444444444444,0.6922428514509995,0.5293990483216697,0.6012744851419026,0.6382978723404256,1.0
285,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.INK);

        expect(data.inkLists.length).toEqual(2);

        expect(data.inkLists[0]).toEqual([

          { x: 1, y: 1 },

          { x: 1, y: 2 },

        ]);

        expect(data.inkLists[1]).toEqual([

          { x: 3, y: 3 },

          { x: 4, y: 5 },

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.INK);

      expect(data.inkLists.length).toEqual(2);

      expect(data.inkLists[0]).toEqual([

        { x: 1, y: 1 },

        { x: 1, y: 2 },

      ]);

      expect(data.inkLists[1]).toEqual([

        { x: 3, y: 3 },

        { x: 4, y: 5 },

      ]);

    it(""should set quadpoints to null if not defined"", async function () {
","async function testCreate() {
      const data = await AnnotationFactory.create();

      expect(data.annotationType).toEqual(AnnotationType.INK);

      expect(data.inkLists.length).toEqual(2);

      expect(data.inkLists[0]).toEqual([
        { x: 1, y: 1 },
        { x: 1, y: 2 }
      ]);

      expect(data.inkLists[1]).toEqual([
        { x: 3, y: 3 },
        { x: 4, y: 5 }
      ]);

      done();
    }",0.6708735051762468,0.7429740887849459,0.7487585682836773,0.828125,0.36363636363636365,0.5526342269412469,0.511990221287907,0.5067853228407165,0.828125,0.36363636363636365,0.7440782943654846,0.5322888891738196,0.5333100025738329,0.9107142857142857,1.0
286,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
","async () => {
     try {
         const annotation = await AnnotationFactory.create();
         expect(annotation.data.annotationType).toEqual(AnnotationType.HIGHLIGHT);
         expect(annotation.data.quadPoints).toEqual(null);
         done();
     } catch (error) {
         done.fail(error);
     }
 }, (done) => {
     it(""should set quadpoints if defined"", function () {
         try {
             const annotation = await AnnotationFactory.create();
             expect(annotation.data.quadPoints).toEqual(null);
             done();
         } catch (error) {
             done.fail(error);
         }
     });
 });",0.43676799126370947,0.24941747177008258,0.2595592551895173,0.6666666666666666,0.5714285714285714,0.40909240099590094,0.1141708367196601,0.3230645681297444,0.48484848484848486,0.7142857142857143,0.48652425798647897,0.11143093225027423,0.3146660996956416,0.52,1.0
287,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null when empty"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);

    it(""should set quadpoints to null when empty"", async function () {
","async function testCreateAnnotation() {
    try {
      const data = await AnnotationFactory.create();
      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);
      expect(data.quadPoints).toEqual([
        [
          { x: 10, y: 20 },
          { x: 20, y: 20 },
          { x: 10, y: 10 },
          { x: 20, y: 10 },
        ],
      ]);
    } catch (error) {
      done.fail(error);
    } finally {
      done();
    }
  }
  
  it(""should set quadpoints to null when empty"", async function () {
    await testCreateAnnotation();
  });",0.7012791020944698,0.7316546574572416,0.7360757326835556,0.7659574468085106,0.5714285714285714,0.6576112713017987,0.5357067385418764,0.7360757326835556,0.7872340425531915,0.5714285714285714,0.6906601769614299,0.6063097773661402,0.8303236044722537,0.8974358974358975,0.42857142857142855
288,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints to null if not defined"", async function () {
","async function test() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);
    expect(data.quadPoints).toEqual(null);
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.5024073368581534,0.3784157746763232,0.39311833466105284,0.6666666666666666,0.5714285714285714,0.33618343172379056,0.053276105491624544,0.05336238330829972,0.6666666666666666,0.5714285714285714,0.468750214028142,0.037121793133434305,0.0378790629791337,0.8,1.0
289,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
","const data = await AnnotationFactory.create();

expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

if (data.quadPoints !== null) {
  expect(data.quadPoints).toEqual(null);
}
done();",0.43676799126370947,0.24941747177008258,0.2595592551895173,0.6666666666666666,0.5714285714285714,0.3175802106074605,0.01564124470993995,0.01658435962466406,0.6666666666666666,0.5714285714285714,0.4560134242936516,0.030781808034896878,0.0332718891397095,0.76,1.0
290,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);

    it(""should set quadpoints to null if not defined"", async function () {
","const annotation = await AnnotationFactory.create();

expect(annotation.data.annotationType).toEqual(AnnotationType.UNDERLINE);

expect(annotation.data.quadPoints).toEqual([
  [
    { x: 10, y: 20 },
    { x: 20, y: 20 },
    { x: 10, y: 10 },
    { x: 20, y: 10 },
  ],
]);",0.7045579704333143,0.7374371126600839,0.7434087508360916,0.7659574468085106,0.5714285714285714,0.5342612252723782,0.504539824313981,0.507885015985258,0.5531914893617021,0.5714285714285714,0.6763573456033461,0.5229165995036185,0.5414871418841253,0.6410256410256411,1.0
291,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
","AnnotationFactory.create()

async () => {
  try {
    const { data } = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);
    expect(data.quadPoints).not.toBeNull();
  } catch (e) {
    done.fail();
  } finally {
    done();
  }
}",0.43676799126370947,0.24941747177008258,0.2595592551895173,0.6666666666666666,0.5714285714285714,0.3414324230947786,0.019427446513842185,0.02595592551895173,0.6060606060606061,0.7142857142857143,0.5690084925106043,0.19427446513842178,0.28175950490399515,0.8,1.0
292,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);

    it(""should set quadpoints to null if not defined"", async function () {
","async function testAnnotation() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);
    expect(data.quadPoints).toEqual([
      [
        { x: 10, y: 20 },
        { x: 20, y: 20 },
        { x: 10, y: 10 },
        { x: 20, y: 10 },
      ],
    ]);
    done();
  } catch (error) {
    done.fail(error);
  }
}",0.7045579704333143,0.7374371126600839,0.7434087508360916,0.7659574468085106,0.5714285714285714,0.6396857547419122,0.6190482720842398,0.6023087286463271,0.7659574468085106,0.5714285714285714,0.7802972243474159,0.6301375048792498,0.6192565207155418,0.8717948717948718,1.0
293,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

      expect(data.quadPoints).toEqual(null);

    it(""should set quadpoints if defined"", async function () {
","async function create() {
    try {
      const data = await AnnotationFactory.create();
      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);
      expect(data.quadPoints).toEqual(null);
    } catch (error) {
      done.fail(error);
    }
  }",0.43676799126370947,0.24941747177008258,0.2595592551895173,0.6666666666666666,0.5714285714285714,0.34415989928977475,0.026801651563557783,0.029491625249220933,0.6060606060606061,0.7142857142857143,0.43574566297081324,0.04104424101861004,0.04479555372178579,0.8,0.8571428571428571
294,"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);
","      const { data } = await AnnotationFactory.create(

      );

      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

      expect(data.quadPoints).toEqual([

        [

          { x: 10, y: 20 },

          { x: 20, y: 20 },

          { x: 10, y: 10 },

          { x: 20, y: 10 },

        ],

      ]);
","async function testCreateAnnotation() {
  try {
    const data = await AnnotationFactory.create();

    expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

    expect(data.quadPoints).toEqual([
      [
        { x: 10, y: 20 },
        { x: 20, y: 20 },
        { x: 10, y: 10 },
        { x: 20, y: 10 },
      ],
    ]);

    done();
  } catch (error) {
    done.fail(error);
  }
}",0.7055549264789116,0.7725218915170873,0.7719200366207816,0.7777777777777778,0.5,0.6789640787898112,0.6225727142169835,0.7932836009422612,0.8,0.5,0.8344433066862438,0.624990517823067,0.8208908170300164,0.8918918918918919,1.0
295,"  function runOperatorListCheck(evaluator, stream, resources, callback) {

    const result = new OperatorList();

    evaluator

      .getOperatorList({

        stream,

        task,

        resources,

        operatorList: result,

      })

      .then(

        function () {

          callback(result);

        },

        function (reason) {

          callback(reason);

        }

      );
","  async function runOperatorListCheck(evaluator, stream, resources) {

    const operatorList = new OperatorList();

    await evaluator.getOperatorList({

      stream,

      task,

      resources,

      operatorList,

    });

    return operatorList;
","async function runOperatorListCheck(evaluator, stream, resources) {
  try {
    const result = await evaluator.getOperatorList({ stream, task, resources, operatorList: new OperatorList() });
    return result;
  } catch (error) {
    throw error;
  }
}",0.19519812420977364,0.0684959311816431,0.07896323232411816,0.16666666666666666,0.4666666666666667,0.27602402397401093,0.19989805420874343,0.20419804168730046,0.1,0.6,0.4544200779663675,0.3110891870529496,0.4940911248125205,0.3125,0.7
296,"    it(""table was truncated in the middle of functions"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font2324), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(

            /(ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)

          ).toEqual(true);

          done();

        });
","    it(""table was truncated in the middle of functions"", async function () {

      const cMap = await CMapFactory.create({

      const font = new Font(""font"", new Stream(font2324), {

        loadedName: ""font"",

        type: ""CIDFontType2"",

        differences: [],

        defaultEncoding: [],

        cMap,

        toUnicode: new ToUnicodeMap([]),

      });

      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(

        /(ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)

      ).toEqual(true);
","`it(""table was truncated in the middle of functions"", async function () {

      const cMap = await CMapFactory.create({});

      const font = new Font(""font"", new Stream(font2324), {
        loadedName: ""font"",
        type: ""CIDFontType2"",
        differences: [],
        defaultEncoding: [],
        cMap,
        toUnicode: new ToUnicodeMap([]),
      });

      const output = await ttx(font.data);

      verifyTtxOutput(output);

      expect(
        /(ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)
      ).toEqual(true);
    });`",0.5524416284343939,0.6490603436973633,0.6687647780988204,0.6538461538461539,0.23809523809523808,0.5637956097243076,0.6097866810190316,0.6453957578781989,0.0,0.0,0.7081411021314452,0.9042878500265974,0.9282765584991837,0.0,0.0
297,"      ttx(font.data, function (output) {

        verifyTtxOutput(output);

        expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

        done();

      });

    it(""has invalid selection attributes presence"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font1282), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

          done();

        });
","      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

    it(""has invalid selection attributes presence"", async function () {

      const cMap = await CMapFactory.create({

      const font = new Font(""font"", new Stream(font1282), {

        loadedName: ""font"",

        type: ""CIDFontType2"",

        differences: [],

        defaultEncoding: [],

        cMap,

        toUnicode: new ToUnicodeMap([]),

      });

      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);
","async function testTTX() {
  const font = new Font(""font"", new Stream(font1282), {
    loadedName: ""font"",
    type: ""CIDFontType2"",
    differences: [],
    defaultEncoding: [],
    cMap: await CMapFactory.create(),
    toUnicode: new ToUnicodeMap([]),
  });

  try {
    const output = await ttx(font.data);
    verifyTtxOutput(output);
    expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);
  } catch (error) {
    console.log(""Error occurred: "", error);
  } finally {
    done();
  }
}

it(""has invalid selection attributes presence"", async () => {
  await testTTX();
});",0.5241874089084534,0.5338662241666582,0.535786637273607,0.64,0.3870967741935484,0.5230749613272215,0.38447290239949483,0.4794398461351979,0.68,0.5483870967741935,0.5735541876485225,0.47271493368080386,0.5920645874760568,0.8484848484848485,0.38095238095238093
298,"    it(""has invalid version number"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font2109), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(

            true

          );

          done();

        });

    it(""has invalid glyph name indexes"", function (done) {
","    it(""has invalid version number"", async function () {

      const cMap = await CMapFactory.create({

      const font = new Font(""font"", new Stream(font2109), {

        loadedName: ""font"",

        type: ""CIDFontType2"",

        differences: [],

        defaultEncoding: [],

        cMap,

        toUnicode: new ToUnicodeMap([]),

      });

      const output = await ttx(font.data);



      verifyTtxOutput(output);

      expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(true);

    it(""has invalid glyph name indexes"", async function () {
","it(""has invalid version number"", async function () {
  try {
    const cMap = await CMapFactory.create({});
    const font = new Font(""font"", new Stream(font2109), {
      loadedName: ""font"",
      type: ""CIDFontType2"",
      differences: [],
      defaultEncoding: [],
      cMap,
      toUnicode: new ToUnicodeMap([]),
    });
    const output = await ttx(font.data);
    verifyTtxOutput(output);
    expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(true);
  } catch (error) {
    // Handle error
  }
});

it(""has invalid glyph name indexes"", async function () {
  try {
    const cMap = await CMapFactory.create({});
    const font = new Font(""font"", new Stream(font2109), {
      loadedName: ""font"",
      type: ""CIDFontType2"",
      differences: [],
      defaultEncoding: [],
      cMap,
      toUnicode: new ToUnicodeMap([]),
    });
    const output = await ttx(font.data);
    verifyTtxOutput(output);
    expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(true);
  } catch (error) {
    // Handle error
  }
});",0.5110943118767409,0.5479780847766769,0.5565843479154721,0.6481481481481481,0.2916666666666667,0.5843944987013168,0.26847822474621263,0.5783590293183138,0.7407407407407407,0.75,0.7185277674280688,0.42234967165711473,0.9023108486046109,0.8571428571428571,0.6923076923076923
299,"function ttx(data) {

  return new Promise((resolve, reject) => {

    const xhr = new XMLHttpRequest();

    xhr.open(""POST"", ""/ttx"");



    const encodedData = encodeFontData(data);

    xhr.setRequestHeader(""Content-type"", ""text/plain"");

    xhr.setRequestHeader(""Content-length"", encodedData.length);



    xhr.onreadystatechange = function getPdfOnreadystatechange(e) {

      if (xhr.readyState === 4) {

        if (xhr.status === 200) {

          resolve(xhr.responseText);

        } else {

          reject(new Error(xhr.statusText));

        }

      }

    };

    xhr.send(encodedData);
","async function ttx(data) {

  const response = await fetch(""/ttx"", {

    method: ""POST"",

    body: encodeFontData(data),



  if (!response.ok) {

    throw new Error(response.statusText);

  }

  return response.text();
","async function ttx(data) {
    try {
        const xhr = new XMLHttpRequest();
        await xhr.open(""POST"", ""/ttx"");
        const encodedData = encodeFontData(data);
        await xhr.setRequestHeader(""Content-type"", ""text/plain"");
        await xhr.setRequestHeader(""Content-length"", encodedData.length);
        let responseText = null;
        await xhr.onreadystatechange = function getPdfOnreadystatechange(e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    responseText = xhr.responseText;
                } else {
                    throw new Error(xhr.statusText);
                }
            }
        };
        await xhr.send(encodedData);
        return responseText;
    } catch (err) {
        console.error(err);
    }
}",0.1548679870615263,0.020269215726030472,0.03167736171601544,0.3770491803278688,0.19047619047619047,0.5176877081453402,0.4239821062065247,0.5936851978814714,0.6721311475409836,0.38095238095238093,0.425242790571533,0.060837606285167045,0.20013355600096513,0.44,1.0
300,"  setPDFNetworkStreamFactory(params => {

    return streamsPromise.then(streams => {

      const [{ PDFNetworkStream }, { PDFFetchStream }] = streams;

      if (isFetchSupported() && isValidFetchUrl(params.url)) {

        return new PDFFetchStream(params);

      }

      return new PDFNetworkStream(params);

    });

} else if (PDFJSDev.test(""GENERIC"")) {

  const { isNodeJS } = require(""./shared/is_node.js"");

  if (isNodeJS) {

    const PDFNodeStream = require(""./display/node_stream.js"").PDFNodeStream;

    const PDFNetworkStream = require(""./display/network.js"").PDFNetworkStream;

    let PDFFetchStream;

    if (isFetchSupported()) {

      PDFFetchStream = require(""./display/fetch_stream.js"").PDFFetchStream;

    }

      if (PDFFetchStream && isValidFetchUrl(params.url)) {

} else if (PDFJSDev.test(""CHROME"")) {

  const PDFNetworkStream = require(""./display/network.js"").PDFNetworkStream;

  let PDFFetchStream;

  const isChromeWithFetchCredentials = function () {

    // fetch does not include credentials until Chrome 61.0.3138.0 and later.

    // https://chromium.googlesource.com/chromium/src/+/2e231cf052ca5e68e22baf0008ac9e5e29121707

    try {

      // Indexed properties on window are read-only in Chrome 61.0.3151.0+

      // https://chromium.googlesource.com/chromium/src.git/+/58ab4a971b06dec13e4edf9de8382ca6847f6190

      window[999] = 123; // should throw. Note: JS strict mode MUST be enabled.

      delete window[999];

      return false;

    } catch (e) {

      return true;

    }

  };

  if (isFetchSupported() && isChromeWithFetchCredentials()) {

    PDFFetchStream = require(""./display/fetch_stream.js"").PDFFetchStream;

  }

  setPDFNetworkStreamFactory(params => {

    if (PDFFetchStream && isValidFetchUrl(params.url)) {

      return new PDFFetchStream(params);

    }

    return new PDFNetworkStream(params);

  });
","

  setPDFNetworkStreamFactory(async params => {

    const [{ PDFNetworkStream }, { PDFFetchStream }] = await streamsPromise;

    if (isValidFetchUrl(params.url)) {

      return new PDFFetchStream(params);

    }

    return new PDFNetworkStream(params);

} else if (PDFJSDev.test(""GENERIC || CHROME"")) {

  if (PDFJSDev.test(""GENERIC"") && isNodeJS) {

    const { PDFNodeStream } = require(""./display/node_stream.js"");



    const { PDFNetworkStream } = require(""./display/network.js"");

    const { PDFFetchStream } = require(""./display/fetch_stream.js"");



      if (isValidFetchUrl(params.url)) {
","async function setPDFNetworkStreamFactory(params) {
  const streamsPromise = await this.getStreams();
  const [{ PDFNetworkStream }, { PDFFetchStream }] = streamsPromise;
  if (isNodeJS()) {
    const PDFNodeStream = require('./display/node_stream').PDFNodeStream;
    return new PDFNodeStream(params);
  } else {
    if (isValidFetchUrl(params.url)) {
      if (PDFFetchStream) {
        return new PDFFetchStream(params);
      } else {
        return new PDFNetworkStream(params);
      }
    } else {
      return new PDFNetworkStream(params);
    }
  }
}",0.2112678638149867,0.06284359201853332,0.1384561748364834,0.4306569343065693,0.21311475409836064,0.24008513291909905,0.05464569503784565,0.12874138444278654,0.5474452554744526,0.22950819672131148,0.4762277168577399,0.3034303601257338,0.3135395721124447,0.6792452830188679,0.6086956521739131
301,"      const registry = properties.cidSystemInfo.registry;

      const ordering = properties.cidSystemInfo.ordering;

      const ucs2CMapName = Name.get(registry + ""-"" + ordering + ""-UCS2"");

      return CMapFactory.create({

      }).then(function (ucs2CMap) {

        const cMap = properties.cMap;

        const toUnicode = [];

        cMap.forEach(function (charcode, cid) {

          if (cid > 0xffff) {

            throw new FormatError(""Max size of CID is 65,535"");

          }

          // e) Map the CID obtained in step (a) according to the CMap

          // obtained in step (d), producing a Unicode value.

          const ucs2 = ucs2CMap.lookup(cid);

          if (ucs2) {

            toUnicode[charcode] = String.fromCharCode(

              (ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1)

            );

          }

        });

        return new ToUnicodeMap(toUnicode);

    return Promise.resolve(

      new IdentityToUnicodeMap(properties.firstChar, properties.lastChar)

    );
","      const { registry, ordering } = properties.cidSystemInfo;

      const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);

      const ucs2CMap = await CMapFactory.create({

      const toUnicode = [];

      properties.cMap.forEach(function (charcode, cid) {

        if (cid > 0xffff) {

          throw new FormatError(""Max size of CID is 65,535"");

        }

        // e) Map the CID obtained in step (a) according to the CMap

        // obtained in step (d), producing a Unicode value.

        const ucs2 = ucs2CMap.lookup(cid);

        if (ucs2) {

          toUnicode[charcode] = String.fromCharCode(

            (ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1)

          );

        }

      });

      return new ToUnicodeMap(toUnicode);

    return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
","async function createToUnicodeMap(properties) {

    const registry = properties.cidSystemInfo.registry;

    const ordering = properties.cidSystemInfo.ordering;

    const ucs2CMapName = Name.get(registry + ""-"" + ordering + ""-UCS2"");

    try {

      const ucs2CMap = await CMapFactory.create({

        registry,

        ordering,

        ucs2CMapName,

      });

      const cMap = properties.cMap;

      const toUnicode = [];

      for (let charcode of Object.keys(cMap)) {

        if (charcode > 0xffff) {

          throw new FormatError(""Max size of CID is 65,535"");

        }

        // e) Map the CID obtained in step (a) according to the CMap

        // obtained in step (d), producing a Unicode value.

        const ucs2 = ucs2CMap.lookup(charcode);

        if (ucs2) {

          toUnicode[charcode] = String.fromCharCode(

            (ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1)

          );

        }

      }

      return new ToUnicodeMap(toUnicode);

    } catch (err) {

      console.log(""Error creating ToUnicodeMap"", err);

    }

  }",0.6146159051012097,0.6749172718374931,0.6889034914244885,0.6375,0.45714285714285713,0.703083828976168,0.6477380532572563,0.7520972626474153,0.8125,0.6,0.6516637533341525,0.5126348184075508,0.6910790184584709,0.6029411764705882,0.8
302,"    return undefined;

  return loadScript(PDFWorker.workerSrc);

function loadAndEnablePDFBug(enabledTabs) {

  const appConfig = PDFViewerApplication.appConfig;

  return loadScript(appConfig.debuggerScriptPath).then(function () {

    PDFBug.enable(enabledTabs);

    PDFBug.init({ OPS }, appConfig.mainContainer);

  });
","    return;

  await loadScript(PDFWorker.workerSrc);

async function initPDFBug(enabledTabs) {

  const { debuggerScriptPath, mainContainer } = PDFViewerApplication.appConfig;

  await loadScript(debuggerScriptPath);

  PDFBug.init({ OPS }, mainContainer, enabledTabs);
","async function loadAndEnablePDFBug(enabledTabs) {
  // Load the PDF worker script
  const workerSrc = await loadScript(PDFWorker.workerSrc);

  // Load the debugger script
  const debuggerScriptPath = appConfig.debuggerScriptPath;
  try {
    await loadScript(debuggerScriptPath);
  } catch (error) {
    console.log(""Error loading the debugger script"");
    return undefined;
  }

  // Enable the PDFBug on specified tabs
  PDFBug.enable(enabledTabs);

  // Initialize the PDFBug
  PDFBug.init({ OPS }, appConfig.mainContainer);
}",0.29353222779973676,0.07264339766175722,0.07118248323415952,0.3939393939393939,0.6363636363636364,0.4093890436485517,0.07180344843678853,0.20211636252105467,0.6363636363636364,0.7272727272727273,0.3292639506289463,0.02931363507372905,0.08774216744205622,0.5,0.7
303,"  destroy() {

    const transportDestroyed = !this._transport

      ? Promise.resolve()

      : this._transport.destroy();

    return transportDestroyed.then(() => {

      this._transport = null;

      if (this._worker) {

        this._worker.destroy();

        this._worker = null;

      }

    });
","  async destroy() {

    await this._transport?.destroy();

    this._transport = null;

    if (this._worker) {

      this._worker.destroy();

      this._worker = null;

    }
","async destroy() {

    const transportDestroyed = !this._transport

      ? Promise.resolve()

      : this._transport.destroy();

    try{

      await transportDestroyed;

      this._transport = null;

      if (this._worker) {

        this._worker.destroy();

        this._worker = null;

      }

    }catch(err){

      console.error('Error destroying worker', err);

    }

  }",0.42408248458789183,0.37296014486104284,0.40029287041360156,0.5897435897435898,0.3333333333333333,0.768663815411692,0.585963464146733,0.7194610282692662,0.7692307692307693,1.0,0.7226373390354827,0.3594039880288692,0.7619145988822923,0.7692307692307693,1.0
304,"  render(viewport, intent = ""display"") {

    return Promise.all([

      this.pdfPage.getAnnotations({ intent }),

      this._hasJSActionsPromise,

    ]).then(([annotations, hasJSActions = false]) => {

      if (this._cancelled || annotations.length === 0) {

        return;

      }

      const parameters = {

        viewport: viewport.clone({ dontFlip: true }),

        div: this.div,

        annotations,

        page: this.pdfPage,

        imageResourcesPath: this.imageResourcesPath,

        renderForms: this.renderForms,

        linkService: this.linkService,

        downloadManager: this.downloadManager,

        annotationStorage: this.annotationStorage,

        enableScripting: this.enableScripting,

        hasJSActions,

        mouseState: this._mouseState,

      };

      if (this.div) {

        // If an annotationLayer already exists, refresh its children's

        // transformation matrices.

        AnnotationLayer.update(parameters);

      } else {

        // Create an annotation layer div and render the annotations

        // if there is at least one annotation.

        this.div = document.createElement(""div"");

        this.div.className = ""annotationLayer"";

        this.pageDiv.appendChild(this.div);

        parameters.div = this.div;

        AnnotationLayer.render(parameters);

        this.l10n.translate(this.div);

      }

    });
","  async render(viewport, intent = ""display"") {

    const [annotations, hasJSActions = false, fieldObjects = null] =

      await Promise.all([

        this.pdfPage.getAnnotations({ intent }),

        this._hasJSActionsPromise,

        this._fieldObjectsPromise,

      ]);

    if (this._cancelled || annotations.length === 0) {

      return;

    }

    const parameters = {

      viewport: viewport.clone({ dontFlip: true }),

      div: this.div,

      annotations,

      page: this.pdfPage,

      imageResourcesPath: this.imageResourcesPath,

      renderForms: this.renderForms,

      linkService: this.linkService,

      downloadManager: this.downloadManager,

      annotationStorage: this.annotationStorage,

      enableScripting: this.enableScripting,

      hasJSActions,

      fieldObjects,

      mouseState: this._mouseState,

    };

    if (this.div) {

      // If an annotationLayer already exists, refresh its children's

      // transformation matrices.

      AnnotationLayer.update(parameters);

    } else {

      // Create an annotation layer div and render the annotations

      // if there is at least one annotation.

      this.div = document.createElement(""div"");

      this.div.className = ""annotationLayer"";

      this.pageDiv.appendChild(this.div);

      parameters.div = this.div;



      AnnotationLayer.render(parameters);

      this.l10n.translate(this.div);

    }
","render(viewport, intent = ""display"") {
  
  return await Promise.all([
    
    this.pdfPage.getAnnotations({ intent }),
    
    this._hasJSActionsPromise,
    
  ]).then(([annotations, hasJSActions = false]) => {
    
    if (this._cancelled || annotations.length === 0) {
      
      return;
      
    }
    
    const parameters = {
      
      viewport: viewport.clone({ dontFlip: true }),
      
      div: this.div,
      
      annotations,
      
      page: this.pdfPage,
      
      imageResourcesPath: this.imageResourcesPath,
      
      renderForms: this.renderForms,
      
      linkService: this.linkService,
      
      downloadManager: this.downloadManager,
      
      annotationStorage: this.annotationStorage,
      
      enableScripting: this.enableScripting,
      
      hasJSActions,
      
      mouseState: this._mouseState,
      
    };
    
    if (this.div) {
      
      // If an annotationLayer already exists, refresh its children's
      
      // transformation matrices.
      
      AnnotationLayer.update(parameters);
      
    } else {
      
      // Create an annotation layer div and render the annotations
      
      // if there is at least one annotation.
      
      this.div = document.createElement(""div"");
      
      this.div.className = ""annotationLayer"";
      
      this.pageDiv.appendChild(this.div);
      
      parameters.div = this.div;
      
      AnnotationLayer.render(parameters);
      
      this.l10n.translate(this.div);
      
    }
    
  });
  
}",0.7922178722287433,0.839528183794873,0.8824789650518765,0.8252427184466019,0.6216216216216216,0.9809384293000267,0.9672705043138806,0.9856094264784593,0.970873786407767,1.0,0.759473042399405,0.8483756893886883,0.8463792253069712,0.8431372549019608,0.5
305,"loadingTask.promise

  .then(function (pdfDocument) {

    console.log(""# PDF document loaded."");

    pdfDocument.getPage(1).then(function (page) {

      // Render the page on a Node canvas with 100% scale.

      const viewport = page.getViewport({ scale: 1.0 });

      const canvasFactory = new NodeCanvasFactory();

      const canvasAndContext = canvasFactory.create(

        viewport.width,

        viewport.height

      );

      const renderContext = {

        canvasContext: canvasAndContext.context,

        viewport,

        canvasFactory,

      };

      const renderTask = page.render(renderContext);

      renderTask.promise.then(function () {

        // Convert the canvas to an image buffer.

        const image = canvasAndContext.canvas.toBuffer();

        fs.writeFile(""output.png"", image, function (error) {

          if (error) {

            console.error(""Error: "" + error);

          } else {

            console.log(

              ""Finished converting first page of PDF file to a PNG image.""

            );

          }

        });

      });

  })

  .catch(function (reason) {

  });
","(async function () {

  try {

    const pdfDocument = await loadingTask.promise;

    console.log(""# PDF document loaded."");

    const page = await pdfDocument.getPage(1);

    // Render the page on a Node canvas with 100% scale.

    const viewport = page.getViewport({ scale: 1.0 });

    const canvasFactory = new NodeCanvasFactory();

    const canvasAndContext = canvasFactory.create(

      viewport.width,

      viewport.height

    );

    const renderContext = {

      canvasContext: canvasAndContext.context,

      viewport,

      canvasFactory,

    };

    const renderTask = page.render(renderContext);

    await renderTask.promise;

    // Convert the canvas to an image buffer.

    const image = canvasAndContext.canvas.toBuffer();

    fs.writeFile(""output.png"", image, function (error) {

      if (error) {

        console.error(""Error: "" + error);

      } else {

        console.log(

          ""Finished converting first page of PDF file to a PNG image.""

        );

      }

  } catch (reason) {

  }

})();
","async function convertPdfToImage() {

    try {

        const pdfDocument = await loadingTask.promise;

        console.log(""# PDF document loaded."");

        const page = await pdfDocument.getPage(1);

        // Render the page on a Node canvas with 100% scale.

        const viewport = page.getViewport({ scale: 1.0 });

        const canvasFactory = new NodeCanvasFactory();

        const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);

        const renderContext = {
            canvasContext: canvasAndContext.context,
            viewport,
            canvasFactory
        };

        const renderTask = await page.render(renderContext);

        // Convert the canvas to an image buffer.

        const image = await canvasAndContext.canvas.toBuffer();

        fs.writeFile(""output.png"", image, function (error) {
            if (error) {
                console.error(""Error: "" + error);
            } else {
                console.log(
                    ""Finished converting first page of PDF file to a PNG image.""
                );
            }
        });

    } catch (reason) {
        // handle error
    }
}",0.6985365261527926,0.7700532179726685,0.829862117407733,0.7692307692307693,0.425,0.6466497458962641,0.6690202960257114,0.7373589073395651,0.7802197802197802,0.4,0.8548694007196957,0.807906799738818,0.8297003747178124,0.8045977011494253,0.9772727272727273
306,"function pageLoaded() {

  loadingTask.promise.then(function (pdfDocument) {

    pdfDocument.getPage(PAGE_NUMBER).then(function (page) {

      const viewport = page.getViewport({ scale: PAGE_SCALE });

      page.getTextContent().then(function (textContent) {

        // building SVG and adding that to the DOM

        const svg = buildSVG(viewport, textContent);

        document.getElementById(""pageContainer"").appendChild(svg);

      });

    });

  });
","async function pageLoaded() {

  const pdfDocument = await loadingTask.promise;

  const page = await pdfDocument.getPage(PAGE_NUMBER);

  const viewport = page.getViewport({ scale: PAGE_SCALE });

  const textContent = await page.getTextContent();

  // building SVG and adding that to the DOM

  const svg = buildSVG(viewport, textContent);

  document.getElementById(""pageContainer"").appendChild(svg);
","async function pageLoaded() {

loadingTask.promise.then(async (pdfDocument) => {

const page = await pdfDocument.getPage(PAGE_NUMBER);

const viewport = page.getViewport({ scale: PAGE_SCALE });

const textContent = await page.getTextContent();

// building SVG and adding that to the DOM

const svg = buildSVG(viewport, textContent);

document.getElementById(""pageContainer"").appendChild(svg);

});",0.5240647088208825,0.5178599727630709,0.5925014266230232,0.5192307692307693,0.4666666666666667,0.5444559798107153,0.5537185010971457,0.6279515719918692,0.5961538461538461,0.4,0.7233488345141722,0.8399190502263365,0.8284762878303527,0.825,0.4
307,"// Will be using promises to load document, pages and misc data instead of

// callback.

loadingTask.promise

  .then(function (doc) {

    const numPages = doc.numPages;

    console.log(""# Document Loaded"");

    console.log(""Number of Pages: "" + numPages);

    console.log();

    let lastPromise = Promise.resolve(); // will be used to chain promises

    const loadPage = function (pageNum) {

      return doc.getPage(pageNum).then(function (page) {

        console.log(""# Page "" + pageNum);

        const viewport = page.getViewport({ scale: 1.0 });

        console.log(""Size: "" + viewport.width + ""x"" + viewport.height);

        console.log();

        return page.getOperatorList().then(function (opList) {

          const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);

          svgGfx.embedFonts = true;

          return svgGfx.getSVG(opList, viewport).then(function (svg) {

            return writeSvgToFile(svg, getFilePathForPage(pageNum)).then(

              function () {

                console.log(""Page: "" + pageNum);

              },

              function (err) {

                console.log(""Error: "" + err);

              }

            );

          });

        });

      });

    };



    for (let i = 1; i <= numPages; i++) {

      lastPromise = lastPromise.then(loadPage.bind(null, i));

    }

    return lastPromise;

  })

  .then(

    function () {

      console.log(""# End of Document"");

    },

    function (err) {

      console.error(""Error: "" + err);

  );
","// Will be using async/await to load document, pages and misc data.

(async function () {

  const doc = await loadingTask.promise;

  const numPages = doc.numPages;

  console.log(""# Document Loaded"");

  console.log(`Number of Pages: ${numPages}`);

  console.log();

  for (let pageNum = 1; pageNum <= numPages; pageNum++) {

    try {

      const page = await doc.getPage(pageNum);

      console.log(`# Page ${pageNum}`);

      const viewport = page.getViewport({ scale: 1.0 });

      console.log(`Size: ${viewport.width}x${viewport.height}`);

      console.log();

      const opList = await page.getOperatorList();

      const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);

      svgGfx.embedFonts = true;

      const svg = await svgGfx.getSVG(opList, viewport);

      await writeSvgToFile(svg, getFilePathForPage(pageNum));

    } catch (err) {

      console.log(`Error: ${err}`);

  }

  console.log(""# End of Document"");

})();
","async function loadDocument() {
  const doc = await loadingTask.promise;
  const numPages = doc.numPages;

  console.log(""# Document Loaded"");
  console.log(""Number of Pages: "" + numPages);
  console.log();

  let lastPromise = Promise.resolve(); // will be used to chain promises
  const loadPage = async (pageNum) => {
    try {
      const page = await doc.getPage(pageNum);
      console.log(""# Page "" + pageNum);
      const viewport = page.getViewport({ scale: 1.0 });
      console.log(""Size: "" + viewport.width + ""x"" + viewport.height);
      console.log();

      const opList = await page.getOperatorList();
      const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);
      svgGfx.embedFonts = true;
      const svg = await svgGfx.getSVG(opList, viewport);

      await writeSvgToFile(svg, getFilePathForPage(pageNum));
      console.log(""Page: "" + pageNum);
    } catch (err) {
      console.error(""Error: "" + err);
    }
  };

  for (let i = 1; i <= numPages; i++) {
    lastPromise = await loadPage(i);
  }

  try {
    console.log(""# End of Document"");
  } catch (err) {
    console.error(""Error: "" + err);
  }
}",0.2755355302879304,0.19749086469232396,0.22048602410139412,0.46987951807228917,0.21428571428571427,0.5312259450868451,0.5271128592315097,0.5180433594405981,0.6987951807228916,0.38095238095238093,0.5511124071918004,0.4016247198169521,0.5808914370167776,0.7027027027027027,0.5192307692307693
308,"loadingTask.promise.then(function (pdfDocument) {

});
","(async function () {

  const pdfDocument = await loadingTask.promise;

})();
","async function loadPDF() {
const pdfDocument = await loadingTask.promise;
}",0.3020500050770357,0.021105340631872645,0.07598356856515925,0.1111111111111111,0.0,0.3020500050770357,0.021105340631872645,0.07598356856515925,0.1111111111111111,0.0,0.650885271376865,0.537284965911771,0.5662561195956892,0.5,1.0
309,"   * @returns {Promise} Returns a promise containing a {PDFPageProxy} object.

   * @private

  _ensurePdfPageLoaded(pageView) {

      return Promise.resolve(pageView.pdfPage);

    if (this._pagesRequests.has(pageView)) {

      return this._pagesRequests.get(pageView);

    const promise = this.pdfDocument

      .getPage(pageView.id)

      .then(pdfPage => {

        if (!pageView.pdfPage) {

          pageView.setPdfPage(pdfPage);

        }

        this._pagesRequests.delete(pageView);

        return pdfPage;

      })

      .catch(reason => {

        console.error(""Unable to get page for page view"", reason);

        // Page error -- there is nothing that can be done.

        this._pagesRequests.delete(pageView);

      });

    this._pagesRequests.set(pageView, promise);

    return promise;
","   * @returns {Promise<PDFPageProxy | null>}

  async #ensurePdfPageLoaded(pageView) {

      return pageView.pdfPage;

    try {

      const pdfPage = await this.pdfDocument.getPage(pageView.id);

      if (!pageView.pdfPage) {

        pageView.setPdfPage(pdfPage);

      }

      return pdfPage;

    } catch (reason) {

      console.error(""Unable to get page for page view"", reason);

      return null; // Page error -- there is nothing that can be done.
","async _ensurePdfPageLoaded(pageView) {
  const pdfPage = await pageView.pdfPage;
  if (!pdfPage) {
    pdfPage = await this.pdfDocument.getPage(pageView.id);
    pageView.setPdfPage(pdfPage);
  }
  return pdfPage;
}",0.346681732046393,0.3380442566035578,0.36349748639682894,0.5185185185185185,0.16666666666666666,0.1276266007852382,0.004018155591382394,0.012661087055743186,0.38271604938271603,0.1111111111111111,0.25050209871019163,0.10531668938816494,0.1824059911668873,0.35714285714285715,0.35714285714285715
310,"   * @returns {PDFPage}

   * @private

  _ensurePdfPageLoaded(thumbView) {

      return Promise.resolve(thumbView.pdfPage);

    if (this._pagesRequests.has(thumbView)) {

      return this._pagesRequests.get(thumbView);

    const promise = this.pdfDocument

      .getPage(thumbView.id)

      .then(pdfPage => {

        if (!thumbView.pdfPage) {

          thumbView.setPdfPage(pdfPage);

        }

        this._pagesRequests.delete(thumbView);

        return pdfPage;

      })

      .catch(reason => {

        console.error(""Unable to get page for thumb view"", reason);

        // Page error -- there is nothing that can be done.

        this._pagesRequests.delete(thumbView);

      });

    this._pagesRequests.set(thumbView, promise);

    return promise;
","   * @returns {Promise<PDFPageProxy | null>}

  async #ensurePdfPageLoaded(thumbView) {

      return thumbView.pdfPage;

    try {

      const pdfPage = await this.pdfDocument.getPage(thumbView.id);

      if (!thumbView.pdfPage) {

        thumbView.setPdfPage(pdfPage);

      }

      return pdfPage;

    } catch (reason) {

      console.error(""Unable to get page for thumb view"", reason);

      return null; // Page error -- there is nothing that can be done.
","async function _ensurePdfPageLoaded(thumbView) {

    try {

        const pdfPage = await thumbView.pdfPage || this.pdfDocument.getPage(thumbView.id).then((pdfPage => {

            if (!thumbView.pdfPage) {

                thumbView.setPdfPage(pdfPage);

            }

            this._pagesRequests.delete(thumbView);

            return pdfPage;

        })).catch(reason => {

            console.error(""Unable to get page for thumb view"", reason);

            // Page error -- there is nothing that can be done.

            this._pagesRequests.delete(thumbView);

        });

    } catch (e) {

        console.error('Error occurred while ensuring PDF page loaded: ', e);

    }

    return pdfPage;

}",0.40729222311262914,0.38995602114320366,0.4039088172532588,0.5540540540540541,0.28125,0.6450837261852219,0.5031338939686391,0.5442618215830595,0.6891891891891891,0.84375,0.5505503508883203,0.44332100766338844,0.5922137292232259,0.5238095238095238,0.6428571428571429
311,"loadingTask.promise.then(function (pdfDocument) {

  return pdfDocument.getPage(PAGE_TO_VIEW).then(function (pdfPage) {

    // Creating the page view with default parameters.

    const pdfPageView = new pdfjsViewer.PDFPageView({

      container,

      id: PAGE_TO_VIEW,

      scale: SCALE,

      defaultViewport: pdfPage.getViewport({ scale: SCALE }),

      eventBus,

      // We can enable text/annotation/xfa/struct-layers, as needed.

      textLayerFactory: !pdfDocument.isPureXfa

        ? new pdfjsViewer.DefaultTextLayerFactory()

        : null,

      annotationLayerFactory: new pdfjsViewer.DefaultAnnotationLayerFactory(),

      xfaLayerFactory: pdfDocument.isPureXfa

        ? new pdfjsViewer.DefaultXfaLayerFactory()

        : null,

      structTreeLayerFactory: new pdfjsViewer.DefaultStructTreeLayerFactory(),

    });

    // Associate the actual page with the view, and draw it.

    pdfPageView.setPdfPage(pdfPage);

    return pdfPageView.draw();

});
","(async function () {

  const pdfDocument = await loadingTask.promise;

  const pdfPage = await pdfDocument.getPage(PAGE_TO_VIEW);

  // Creating the page view with default parameters.

  const pdfPageView = new pdfjsViewer.PDFPageView({

    container,

    id: PAGE_TO_VIEW,

    scale: SCALE,

    defaultViewport: pdfPage.getViewport({ scale: SCALE }),

    eventBus,

    // We can enable text/annotation/xfa/struct-layers, as needed.

    textLayerFactory: !pdfDocument.isPureXfa

      ? new pdfjsViewer.DefaultTextLayerFactory()

      : null,

    annotationLayerFactory: new pdfjsViewer.DefaultAnnotationLayerFactory(),

    xfaLayerFactory: pdfDocument.isPureXfa

      ? new pdfjsViewer.DefaultXfaLayerFactory()

      : null,

    structTreeLayerFactory: new pdfjsViewer.DefaultStructTreeLayerFactory(),

  // Associate the actual page with the view, and draw it.

  pdfPageView.setPdfPage(pdfPage);

  return pdfPageView.draw();

})();
","function loadPDF() {
  try {
    const pdfDocument = await loadingTask.promise;
    const pdfPage = await pdfDocument.getPage(PAGE_TO_VIEW);
    const pdfPageView = new pdfjsViewer.PDFPageView({
      container,
      id: PAGE_TO_VIEW,
      scale: SCALE,
      defaultViewport: pdfPage.getViewport({ scale: SCALE }),
      eventBus,
      textLayerFactory: !pdfDocument.isPureXfa
        ? new pdfjsViewer.DefaultTextLayerFactory()
        : null,
      annotationLayerFactory: new pdfjsViewer.DefaultAnnotationLayerFactory(),
      xfaLayerFactory: pdfDocument.isPureXfa
        ? new pdfjsViewer.DefaultXfaLayerFactory()
        : null,
      structTreeLayerFactory: new pdfjsViewer.DefaultStructTreeLayerFactory(),
    });
    pdfPageView.setPdfPage(pdfPage);
    return await pdfPageView.draw();
  } catch (error) {
    console.error(""Error while loading PDF document"", error);
  }
}",0.7346959274713509,0.7923936405091314,0.8595242561946699,0.7192982456140351,0.5675675675675675,0.5880187706821861,0.48559756796089354,0.49189240334063444,0.8070175438596491,0.5675675675675675,0.6963027918159944,0.5481975385805137,0.5685500168236255,0.8113207547169812,0.8571428571428571
312,"    return this.xref

      .fetchAsync(ref)

      .then(obj => {

        // Ensure that the object that was found is actually a Page dictionary.

        if (

          isDict(obj, ""Page"") ||

          (isDict(obj) && !obj.has(""Type"") && obj.has(""Contents""))

        ) {

          if (ref && !catalog.pageKidsCountCache.has(ref)) {

            catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.

          }

          return [obj, ref];

        throw new FormatError(

          ""The Linearization dictionary doesn't point "" +

            ""to a valid Page dictionary.""

        );

      })

      .catch(reason => {

        info(reason);

        return catalog.getPageDict(pageIndex);

      });
","    try {

      const obj = await this.xref.fetchAsync(ref);

      // Ensure that the object that was found is actually a Page dictionary.

      if (

        isDict(obj, ""Page"") ||

        (isDict(obj) && !obj.has(""Type"") && obj.has(""Contents""))

      ) {

        if (ref && !catalog.pageKidsCountCache.has(ref)) {

          catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.

        return [obj, ref];

      }

      throw new FormatError(

        ""The Linearization dictionary doesn't point to a valid Page dictionary.""

      );

    } catch (reason) {

      info(reason);

      return catalog.getPageDict(pageIndex);

    }
","async function() {
  try {
    let result = await this.xref.fetchAsync(ref);
    if (isDict(result, ""Page"") || (isDict(result) && !result.has(""Type"") && result.has(""Contents""))) {
      if (ref && !catalog.pageKidsCountCache.has(ref)) {
        catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.
      }
      return [result, ref];
    } else {
      throw new FormatError(
        ""The Linearization dictionary doesn't point to a valid Page dictionary.""
      );
    }
  } catch (reason) {
    info(reason);
    return catalog.getPageDict(pageIndex);
  }
}",0.6881790290735629,0.7140254760984144,0.715458316963514,0.7121212121212122,0.6111111111111112,0.5368956542436677,0.388798090980447,0.40524917245887027,0.7424242424242424,0.6111111111111112,0.7274314938433499,0.5115396470330802,0.5272185864048357,0.8709677419354839,1.0
313,"  function rasterizeTextLayer(

    return new Promise(function (resolve, reject) {
","  async function rasterizeTextLayer(

    try {
","async function rasterizeTextLayer() {
    try {
      const canvas = document.createElement(""canvas"");
      canvas.width = this.width;
      canvas.height = this.height;
      const ctx = canvas.getContext(""2d"");
      for (const element of this.texts) {
        ctx.font = `bold ${element.style.fontSize}px sans-serif`;
        ctx.fillText(element.value, element.x, element.y);
      }
      return canvas.toBuffer(""image/png"");
    } catch (error) {
      throw new Error(`Error rasterizing text layer: ${error}`);
    }
  }",0.2832259300517472,0.06900940978236146,0.06389431042462725,0.0,0.0,0.2623414633234586,0.005186671025518576,0.04417918226831578,0.0,0.0,0.2943766967834993,0.010968473790606286,0.16653831334339092,0.0,0.0
314,"    function next() {

      while (nodesToVisit.length) {

        const currentNode = nodesToVisit.pop();

        if (currentNode instanceof Ref) {

          const count = pageKidsCountCache.get(currentNode);

          // Skip nodes where the page can't be.

          if (count >= 0 && currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

          // Prevent circular references in the /Pages tree.

          if (visitedNodes.has(currentNode)) {

            capability.reject(

              new FormatError(""Pages tree contains circular reference."")

            );

            return;

          }

          visitedNodes.put(currentNode);



          xref.fetchAsync(currentNode).then(function (obj) {

            if (isDict(obj, ""Page"") || (isDict(obj) && !obj.has(""Kids""))) {

              // Cache the Page reference, since it can *greatly* improve

              // performance by reducing redundant lookups in long documents

              // where all nodes are found at *one* level of the tree.

              if (currentNode && !pageKidsCountCache.has(currentNode)) {

                pageKidsCountCache.put(currentNode, 1);

              }



              if (pageIndex === currentPageIndex) {

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            }

            nodesToVisit.push(obj);

            next();

          }, capability.reject);

          return;

        }



        // Must be a child page dictionary.

        if (!(currentNode instanceof Dict)) {

          capability.reject(

            new FormatError(

              ""Page dictionary kid reference points to wrong type of object.""

            )

          );

          return;

        }



        let count;

        try {

          count = currentNode.get(""Count"");

        } catch (ex) {

          if (ex instanceof MissingDataException) {

            throw ex;

          }

        if (Number.isInteger(count) && count >= 0) {

          // Cache the Kids count, since it can reduce redundant lookups in

          // documents where all nodes are found at *one* level of the tree.

          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {

            pageKidsCountCache.put(objId, count);

          }

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

        let kids;

        try {

          kids = currentNode.get(""Kids"");

        } catch (ex) {

          if (ex instanceof MissingDataException) {

            throw ex;

        }

        if (!Array.isArray(kids)) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          let type;

          try {

            type = currentNode.get(""Type"");

          } catch (ex) {

            if (ex instanceof MissingDataException) {

              throw ex;

          }

          if (

            isName(type, ""Page"") ||

            (!currentNode.has(""Type"") && currentNode.has(""Contents""))

          ) {

              capability.resolve([currentNode, null]);

              return;

          capability.reject(

            new FormatError(""Page dictionary kids object is not an array."")

          );

          return;

        // Always check all `Kids` nodes, to avoid getting stuck in an empty

        // node further down in the tree (see issue5644.pdf, issue8088.pdf),

        // and to ensure that we actually find the correct `Page` dict.

        for (let last = kids.length - 1; last >= 0; last--) {

          nodesToVisit.push(kids[last]);

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;
","    while (nodesToVisit.length) {

      const currentNode = nodesToVisit.pop();

      if (currentNode instanceof Ref) {

        const count = pageKidsCountCache.get(currentNode);

        // Skip nodes where the page can't be.

        if (count >= 0 && currentPageIndex + count <= pageIndex) {

          currentPageIndex += count;

          continue;

        // Prevent circular references in the /Pages tree.

        if (visitedNodes.has(currentNode)) {

          throw new FormatError(""Pages tree contains circular reference."");

        visitedNodes.put(currentNode);

        const obj = await xref.fetchAsync(currentNode);

        if (obj instanceof Dict) {

          let type = obj.getRaw(""Type"");

          if (type instanceof Ref) {

            type = await xref.fetchAsync(type);

          if (isName(type, ""Page"") || !obj.has(""Kids"")) {

            // Cache the Page reference, since it can *greatly* improve

            // performance by reducing redundant lookups in long documents

            // where all nodes are found at *one* level of the tree.

            if (currentNode && !pageKidsCountCache.has(currentNode)) {

              pageKidsCountCache.put(currentNode, 1);



              return [obj, currentNode];

        }

        nodesToVisit.push(obj);

        continue;

      }

      // Must be a child page dictionary.

      if (!(currentNode instanceof Dict)) {

        throw new FormatError(

          ""Page dictionary kid reference points to wrong type of object.""

        );

      }

      const { objId } = currentNode;



      let count = currentNode.getRaw(""Count"");

      if (count instanceof Ref) {

        count = await xref.fetchAsync(count);

      }

      if (Number.isInteger(count) && count >= 0) {

        // Cache the Kids count, since it can reduce redundant lookups in

        // documents where all nodes are found at *one* level of the tree.

        if (objId && !pageKidsCountCache.has(objId)) {

          pageKidsCountCache.put(objId, count);

        // Skip nodes where the page can't be.

        if (currentPageIndex + count <= pageIndex) {

          currentPageIndex += count;

          continue;

        }

      }



      let kids = currentNode.getRaw(""Kids"");

      if (kids instanceof Ref) {

        kids = await xref.fetchAsync(kids);

      }

      if (!Array.isArray(kids)) {

        // Prevent errors in corrupt PDF documents that violate the

        // specification by *inlining* Page dicts directly in the Kids

        // array, rather than using indirect objects (fixes issue9540.pdf).

        let type = currentNode.getRaw(""Type"");

        if (type instanceof Ref) {

          type = await xref.fetchAsync(type);

        }

        if (isName(type, ""Page"") || !currentNode.has(""Kids"")) {

          if (currentPageIndex === pageIndex) {

            return [currentNode, null];

          }

          currentPageIndex++;

          continue;



        throw new FormatError(""Page dictionary kids object is not an array."");

      }



      // Always check all `Kids` nodes, to avoid getting stuck in an empty

      // node further down in the tree (see issue5644.pdf, issue8088.pdf),

      // and to ensure that we actually find the correct `Page` dict.

      for (let last = kids.length - 1; last >= 0; last--) {

        nodesToVisit.push(kids[last]);



    throw new Error(`Page index ${pageIndex} not found.`);
","async function findPage(xref, pageIndex) {
  const capability = createPromiseCapability();
  let nodesToVisit = [];
  let visitedNodes = new Set();
  let currentPageIndex = 0;
  let pageKidsCountCache = new Map();

  function next() {
    while (nodesToVisit.length > 0) {
      const currentNode = nodesToVisit.pop();
      if (currentNode instanceof Ref) {
        const count = pageKidsCountCache.get(currentNode);
        if (count >= 0 && currentPageIndex + count <= pageIndex) {
          currentPageIndex += count;
          continue;
        }
        if (!visitedNodes.has(currentNode)) {
          visitedNodes.add(currentNode);
          const obj = await xref.fetchAsync(currentNode);
          if (isDict(obj, ""Page"") || isDict(obj) && !obj.has(""Kids"")) {
            if (pageIndex === currentPageIndex) {
              capability.resolve([obj, currentNode]);
            } else {
              currentPageIndex++;
              next();
            }
          }
        }
      } else if (currentNode instanceof Dict) {
        let count;
        try {
          count = currentNode.get(""Count"");
        } catch (ex) {
          if (ex instanceof MissingDataException) {
            throw ex;
          }
          if (!Number.isInteger(count) || count < 0) {
            capability.reject(new FormatError(""Invalid Count in Page dictionary""));
            return;
          }
          const objId = currentNode.objId;
          if (objId && !pageKidsCountCache.has(objId)) {
            pageKidsCountCache.set(objId, count);
          }
          if (currentPageIndex + count <= pageIndex) {
            currentPageIndex += count;
            continue;
          }
        }
        let kids;
        try {
          kids = currentNode.get(""Kids"");
        } catch (ex) {
          if (ex instanceof MissingDataException) {
            throw ex;
          }
          if (!Array.isArray(kids)) {
            capability.reject(new FormatError(""Page dictionary kids object is not an array""));
            return;
          }
        }
        for (let last = kids.length - 1; last >= 0; last--) {
          nodesToVisit.push(kids[last]);
        }
      } else if (!isDict(currentNode)) {
        capability.reject(new FormatError(""Page dictionary kid reference points to wrong type of object""));
        return;
      }
    }
  }
  next();
  return capability.promise;
}",0.6212366016730264,0.673378117452939,0.6765929197810387,0.6206896551724138,0.5142857142857142,0.4475009563657746,0.28439333631445446,0.3543242275175543,0.8084291187739464,0.34285714285714286,0.3693219648740663,0.20394435402560643,0.245023705850411,0.7130044843049327,0.3153153153153153
315,"  close() {

    this.overlayManager.close(this.overlayName).then(() => {

      this.input.value = """";

    });
","  async close() {

    await this.overlayManager.close(this.overlayName);

    this.input.value = """";
","async close() {

  try {

    await this.overlayManager.close(this.overlayName);

    this.input.value = """";

  } catch (error) {

    console.error(""Error closing overlay"", error);

  }
}",0.4563988948532074,0.1525487608028145,0.14923729480049117,0.5238095238095238,1.0,0.43568292351141924,0.0627251733901403,0.1561969968460128,0.5238095238095238,1.0,0.7518583345620418,0.2915369229944523,0.8408964152537145,0.875,1.0
316,"  fontFallback(id, handler) {

    const promises = [];

    this.fontCache.forEach(function (promise) {

      promises.push(promise);

    });

    return Promise.all(promises).then(translatedFonts => {

      for (const translatedFont of translatedFonts) {

        if (translatedFont.loadedName === id) {

          translatedFont.fallback(handler);

          return;

        }

    });

  cleanup(manuallyTriggered = false) {

    const promises = [];

    this.fontCache.forEach(function (promise) {

      promises.push(promise);

    });

    return Promise.all(promises).then(translatedFonts => {

      for (const { dict } of translatedFonts) {

        delete dict.cacheKey;

      }

      this.fontCache.clear();

      this.builtInCMapCache.clear();

      this.standardFontDataCache.clear();

    });
","  async fontFallback(id, handler) {

    const translatedFonts = await Promise.all(this.fontCache);

    for (const translatedFont of translatedFonts) {

      if (translatedFont.loadedName === id) {

        translatedFont.fallback(handler);

        return;

    }

  async cleanup(manuallyTriggered = false) {

    const translatedFonts = await Promise.all(this.fontCache);

    for (const { dict } of translatedFonts) {

      delete dict.cacheKey;

    }

    this.fontCache.clear();

    this.builtInCMapCache.clear();

    this.standardFontDataCache.clear();
","async fontFallback(id, handler) {
  const promises = [];

  this.fontCache.forEach((promise) => {
    promises.push(promise);
  });

  try {
    const translatedFonts = await Promise.all(promises);
    for (const translatedFont of translatedFonts) {
      if (translatedFont.loadedName === id) {
        translatedFont.fallback(handler);
        return;
      }
    }
  } catch (err) {
    console.error(err);
  }
}

async cleanup(manuallyTriggered = false) {
  const promises = [];

  this.fontCache.forEach((promise) => {
    promises.push(promise);
  });

  try {
    const translatedFonts = await Promise.all(promises);
    for (const { dict } of translatedFonts) {
      delete dict.cacheKey;
    }
    this.fontCache.clear();
    this.builtInCMapCache.clear();
    this.standardFontDataCache.clear();
  } catch (err) {
    console.error(err);
  }
}",0.532203128911242,0.48613175219290955,0.514220076851837,0.6046511627906976,0.5238095238095238,0.6278754505558691,0.49300223472883176,0.6552659019353977,0.7441860465116279,0.6190476190476191,0.6904455205276219,0.4719921572647218,0.8598166866655697,0.7457627118644068,0.6842105263157895
317,"    return resourcesPromise.then(resources => {

      const opList = new OperatorList();

      opList.addOp(OPS.beginAnnotation, [

        data.id,

        data.rect,

        transform,

        matrix,

        isUsingOwnCanvas,

      ]);

      return evaluator

        .getOperatorList({

          stream: appearance,

          task,

          resources,

          operatorList: opList,

          fallbackFontDict: this._fallbackFontDict,

        })

        .then(() => {

          opList.addOp(OPS.endAnnotation, []);

          this.reset();

          return opList;

        });
","    const opList = new OperatorList();

    let optionalContent;

    if (this.oc) {

      optionalContent = await evaluator.parseMarkedContentProps(

        this.oc,

        /* resources = */ null

      );

    }

    if (optionalContent !== undefined) {

      opList.addOp(OPS.beginMarkedContentProps, [""OC"", optionalContent]);

    }



    opList.addOp(OPS.beginAnnotation, [

      data.id,

      data.rect,

      transform,

      matrix,

      isUsingOwnCanvas,

    ]);



    await evaluator.getOperatorList({

      stream: appearance,

      task,

      resources,

      operatorList: opList,

      fallbackFontDict: this._fallbackFontDict,

    opList.addOp(OPS.endAnnotation, []);



    if (optionalContent !== undefined) {

      opList.addOp(OPS.endMarkedContent, []);

    }

    this.reset();

    return opList;
","async function() {
    try {
      const resources = await resourcesPromise;
      const opList = new OperatorList();
      opList.addOp(OPS.beginAnnotation, [data.id, data.rect, transform, matrix, isUsingOwnCanvas]);
      await evaluator.getOperatorList({
        stream: appearance,
        task,
        resources,
        operatorList: opList,
        fallbackFontDict: this._fallbackFontDict,
      });
      opList.addOp(OPS.endAnnotation, []);
      this.reset();
      return opList;
    } catch (e) {
      console.log(""Error"", e);
    }
  }",0.5555558069906974,0.303031965040158,0.4941912629226316,0.675,0.75,0.49110117941906867,0.3692833077839388,0.4367880765590026,0.825,0.3333333333333333,0.37873176957275345,0.2627361979698263,0.27393001075596995,0.5,0.4782608695652174
318,"    return this._getAppearance(evaluator, task, annotationStorage).then(

      content => {

        if (this.appearance && content === null) {

          return super.getOperatorList(

            evaluator,

            task,

            intent,

            renderForms,

            annotationStorage

          );

        }

        const operatorList = new OperatorList();

        // Even if there is an appearance stream, ignore it. This is the

        // behaviour used by Adobe Reader.

        if (!this._defaultAppearance || content === null) {

          return operatorList;

        }

        const matrix = [1, 0, 0, 1, 0, 0];

        const bbox = [

          0,

          0,

          this.data.rect[2] - this.data.rect[0],

          this.data.rect[3] - this.data.rect[1],

        ];



        const transform = getTransformMatrix(this.data.rect, bbox, matrix);

        operatorList.addOp(OPS.beginAnnotation, [

          this.data.id,

          this.data.rect,

          transform,

          this.getRotationMatrix(annotationStorage),

        ]);



        const stream = new StringStream(content);

        return evaluator

          .getOperatorList({

            stream,

            task,

            resources: this._fieldResources.mergedResources,

            operatorList,

          })

          .then(function () {

            operatorList.addOp(OPS.endAnnotation, []);

            return operatorList;

          });

      }

    );
","    const content = await this._getAppearance(

      evaluator,

      task,

      annotationStorage

    );

    if (this.appearance && content === null) {

      return super.getOperatorList(

        evaluator,

        task,

        intent,

        renderForms,

        annotationStorage

      );

    }

    const operatorList = new OperatorList();

    // Even if there is an appearance stream, ignore it. This is the

    // behaviour used by Adobe Reader.

    if (!this._defaultAppearance || content === null) {

      return operatorList;

    }

    const matrix = [1, 0, 0, 1, 0, 0];

    const bbox = [

      0,

      0,

      this.data.rect[2] - this.data.rect[0],

      this.data.rect[3] - this.data.rect[1],

    ];

    const transform = getTransformMatrix(this.data.rect, bbox, matrix);



    let optionalContent;

    if (this.oc) {

      optionalContent = await evaluator.parseMarkedContentProps(

        this.oc,

        /* resources = */ null

      );

    }

    if (optionalContent !== undefined) {

      operatorList.addOp(OPS.beginMarkedContentProps, [""OC"", optionalContent]);

    }



    operatorList.addOp(OPS.beginAnnotation, [

      this.data.id,

      this.data.rect,

      transform,

      this.getRotationMatrix(annotationStorage),

    ]);



    const stream = new StringStream(content);

    await evaluator.getOperatorList({

      stream,

      task,

      resources: this._fieldResources.mergedResources,

      operatorList,

    });

    operatorList.addOp(OPS.endAnnotation, []);



    if (optionalContent !== undefined) {

      operatorList.addOp(OPS.endMarkedContent, []);

    }

    return operatorList;
","async function getOperatorList(evaluator, task, intent, renderForms, annotationStorage) {
  try {
    const appearance = await this._getAppearance(evaluator, task, annotationStorage);
    if (this.appearance && content === null) {
      return super.getOperatorList(
        evaluator,
        task,
        intent,
        renderForms,
        annotationStorage,
      );
    }
    const operatorList = new OperatorList();
    // Even if there is an appearance stream, ignore it. This is the
    // behaviour used by Adobe Reader.
    if (!this._defaultAppearance || content === null) {
      return operatorList;
    }
    const matrix = [1, 0, 0, 1, 0, 0];
    const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]];
    const transform = getTransformMatrix(this.data.rect, bbox, matrix);
    operatorList.addOp(OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage)]);
    const stream = new StringStream(content);
    return await evaluator
      .getOperatorList({
        stream,
        task,
        resources: this._fieldResources.mergedResources,
        operatorList,
      })
      .then(() => {
        operatorList.addOp(OPS.endAnnotation, []);
        return operatorList;
      });
  } catch (error) {
    throw new Error(`Error during getOperatorList: ${error}`);
  }
}",0.667461677075408,0.6512411359239623,0.8125870538591512,0.8541666666666666,0.35185185185185186,0.7086668860811915,0.6551787771942633,0.757035063426799,0.8854166666666666,0.5370370370370371,0.5474924103823107,0.5460340233763437,0.5493580645589516,0.7868852459016393,0.3076923076923077
319,"  getAnnotationsData(intent) {

    return this._parsedAnnotations.then(function (annotations) {

      const annotationsData = [];



      if (annotations.length === 0) {

        return annotationsData;

      const intentAny = !!(intent & RenderingIntentFlag.ANY),

        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

        intentPrint = !!(intent & RenderingIntentFlag.PRINT);

      for (const annotation of annotations) {

        // Get the annotation even if it's hidden because

        // JS can change its display.

        if (

          intentAny ||

          (intentDisplay && annotation.viewable) ||

          (intentPrint && annotation.printable)

        ) {

          annotationsData.push(annotation.data);

      return annotationsData;

    });
","  async getAnnotationsData(handler, task, intent) {

    const annotations = await this._parsedAnnotations;

    if (annotations.length === 0) {

      return [];

    }



    const textContentPromises = [];

    const annotationsData = [];

    let partialEvaluator;



    const intentAny = !!(intent & RenderingIntentFlag.ANY),

      intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

      intentPrint = !!(intent & RenderingIntentFlag.PRINT);



    for (const annotation of annotations) {

      // Get the annotation even if it's hidden because

      // JS can change its display.

      const isVisible = intentAny || (intentDisplay && annotation.viewable);

      if (isVisible || (intentPrint && annotation.printable)) {

        annotationsData.push(annotation.data);

      if (annotation.hasTextContent && isVisible) {

        if (!partialEvaluator) {

          partialEvaluator = new PartialEvaluator({

            xref: this.xref,

            handler,

            pageIndex: this.pageIndex,

            idFactory: this._localIdFactory,

            fontCache: this.fontCache,

            builtInCMapCache: this.builtInCMapCache,

            standardFontDataCache: this.standardFontDataCache,

            globalImageCache: this.globalImageCache,

            options: this.evaluatorOptions,

          });

        textContentPromises.push(

          annotation

            .extractTextContent(partialEvaluator, task, this.view)

            .catch(function (reason) {

              warn(

                `getAnnotationsData - ignoring textContent during ""${task.name}"" task: ""${reason}"".`

              );

            })

        );

    }



    await Promise.all(textContentPromises);

    return annotationsData;
","async function getAnnotationsData(intent) {
  try {
    const annotations = await this._parsedAnnotations;
    const annotationsData = [];
    if (annotations.length === 0) return annotationsData;
    for (const annotation of annotations) {
      const intentAny = !!(intent & RenderingIntentFlag.ANY);
      const intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY);
      const intentPrint = !!(intent & RenderingIntentFlag.PRINT);
      if (
        intentAny ||
        (intentDisplay && annotation.viewable) ||
        (intentPrint && annotation.printable)
      ) {
        annotationsData.push(annotation.data);
    }
    return annotationsData;
  } catch (err) {
    console.error(err);
  }
}",0.6035641284324664,0.36059591299889426,0.6989597460301167,0.7777777777777778,0.5769230769230769,0.6029205907750177,0.4986067938385837,0.5028191590050765,0.8333333333333334,0.5769230769230769,0.28423067831858423,0.15559001249156917,0.2162270993135298,0.5206611570247934,0.24444444444444444
320,"    this.textLayerDiv.append(endOfContent);

    this.eventBus.dispatch(""textlayerrendered"", {

      source: this,

      pageNumber: this.pageNumber,

      numTextDivs: this.textDivs.length,

    });

  render() {

    if (!(this.textContent || this.textContentStream) || this.renderingDone) {

    this.cancel();

    this.textDivs.length = 0;

    const textLayerFrag = document.createDocumentFragment();

      container: textLayerFrag,

      viewport: this.viewport,

    this.textLayerRenderTask.promise.then(

      () => {

        this.textLayerDiv.append(textLayerFrag);

        this.#finishRendering();

        this.highlighter?.enable();

        this.accessibilityManager?.enable();

      },

      function (reason) {

        // Cancelled or failed to render text layer; skipping errors.

      }

    );
","    this.div.append(endOfContent);

    this.#bindMouse();

  }



  get numTextDivs() {

    return this.textDivs.length;

  async render(viewport) {

    if (!(this.textContent || this.textContentStream)) {

      throw new Error(

        `Neither ""textContent"" nor ""textContentStream"" specified.`

      );

    }



    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);

    if (this.renderingDone) {

      const { rotation } = viewport;

      const mustRotate = rotation !== this.#rotation;

      const mustRescale = scale !== this.#scale;

      if (mustRotate || mustRescale) {

        this.hide();

        updateTextLayer({

          container: this.div,

          viewport,

          textDivs: this.textDivs,

          textDivProperties: this.textDivProperties,

          isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,

          mustRescale,

          mustRotate,

        });

        this.show();

        this.#scale = scale;

        this.#rotation = rotation;

      }

    this.cancel();

      container: this.div,

      viewport,

      textDivProperties: this.textDivProperties,

      isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,



    await this.textLayerRenderTask.promise;

    this.#finishRendering();

    this.#scale = scale;

    this.accessibilityManager?.enable();

    this.show();

  }



  hide() {

    // We turn off the highlighter in order to avoid to scroll into view an

    // element of the text layer which could be hidden.

    this.highlighter?.disable();

    this.div.hidden = true;

  }



  show() {

    this.div.hidden = false;

    this.highlighter?.enable();
","this.textLayerDiv.append(endOfContent);

    this.eventBus.dispatch(""textlayerrendered"", {

      source: this,

      pageNumber: this.pageNumber,

      numTextDivs: this.textDivs.length,

    });

  render() {

    if (!(this.textContent || this.textContentStream) || this.renderingDone) {

    this.cancel();

    this.textDivs.length = 0;

    const textLayerFrag = document.createDocumentFragment();

      container: textLayerFrag,

      viewport: this.viewport,

    try{
        await this.textLayerRenderTask.promise;
        this.textLayerDiv.append(textLayerFrag);
        this.#finishRendering();
        this.highlighter?.enable();
        this.accessibilityManager?.enable();
    }catch{ 
      // Cancelled or failed to render text layer; skipping errors.
     }
}",0.28900067104771476,0.027181908433859172,0.07061971755594158,0.6296296296296297,0.42857142857142855,0.8353673175198973,0.7727967978922656,0.7662033363848547,0.8024691358024691,1.0,0.19240560731266554,0.013783844552672321,0.028006072382718947,0.6206896551724138,0.10714285714285714
321,"      const result = XfaLayer.render(parameters);

      return Promise.resolve(result);

    return this.pdfPage

      .getXfa()

      .then(xfaHtml => {

        if (this._cancelled || !xfaHtml) {

          return { textDivs: [] };

        }

        const parameters = {

          viewport: viewport.clone({ dontFlip: true }),

          div: this.div,

          xfaHtml,

          annotationStorage: this.annotationStorage,

          linkService: this.linkService,

          intent,

        };

        if (this.div) {

          return XfaLayer.update(parameters);

        }

        // Create an xfa layer div and render the form

        this.div = document.createElement(""div"");

        this.pageDiv.append(this.div);

        parameters.div = this.div;

        return XfaLayer.render(parameters);

      })

      .catch(error => {

        console.error(error);

      });
","      return XfaLayer.render(parameters);

    const xfaHtml = await this.pdfPage.getXfa();

    if (this._cancelled || !xfaHtml) {

      return { textDivs: [] };

    }



    const parameters = {

      viewport: viewport.clone({ dontFlip: true }),

      div: this.div,

      xfaHtml,

      annotationStorage: this.annotationStorage,

      linkService: this.linkService,

      intent,

    };

    if (this.div) {

      return XfaLayer.update(parameters);

    }

    // Create an xfa layer div and render the form

    this.div = document.createElement(""div"");

    this.pageDiv.append(this.div);

    parameters.div = this.div;

    return XfaLayer.render(parameters);
","async () => {
    try {
        const result = await XfaLayer.render(parameters);
        return Promise.resolve(result);
    } catch (error) {
        console.error(error);
    }
}",0.6995115433641831,0.7500041641904411,0.7644791865468418,0.8192771084337349,0.4642857142857143,0.14988420399295152,0.0079935416258999,0.02872055489668071,0.27710843373493976,0.2857142857142857,0.11470906291947772,0.003920306803996746,0.010251913253360811,0.22727272727272727,0.21739130434782608
322,"gulp.task(""jsdoc"", function (done) {

  rimraf(JSDOC_BUILD_DIR, function () {

    mkdirp(JSDOC_BUILD_DIR).then(function () {

      const command =

        '""node_modules/.bin/jsdoc"" -d ' +

        JSDOC_BUILD_DIR +

        "" "" +

        JSDOC_FILES.join("" "");

      exec(command, done);

    });

  });
","gulp.task(""jsdoc"", async function (done) {

  await rimraf(JSDOC_BUILD_DIR);

  await mkdirp(JSDOC_BUILD_DIR);



  const command = `""node_modules/.bin/jsdoc"" -d ${JSDOC_BUILD_DIR} ${JSDOC_FILES.join(

    "" ""

  )}`;

  exec(command, done);
","const jsdoc = gulp.task(""jsdoc"", async () => {
  await rimraf(JSDOC_BUILD_DIR);
  await mkdirp(JSDOC_BUILD_DIR);
  const command = `""node_modules/.bin/jsdoc"" -d ${JSDOC_BUILD_DIR} ${JSDOC_FILES.join("" "")}`;
  exec(command, done);
});",0.32911969471429436,0.06836380976403407,0.0738725448507191,0.42424242424242425,0.75,0.24815305531955,0.060343199330474474,0.061056900735604415,0.45454545454545453,0.4166666666666667,0.6161519600581337,0.49693695965817614,0.5510042139076919,0.9166666666666666,0.5
323,"   * @param {PDFManager} pdfManager

   * @param {boolean} collectFields

  static create(xref, ref, pdfManager, idFactory, collectFields, pageRef) {

    return Promise.all([

      pdfManager.ensureCatalog(""acroForm""),

      // Only necessary to prevent the `pdfManager.docBaseUrl`-getter, used

      // with certain Annotations, from throwing and thus breaking parsing:

      pdfManager.ensureCatalog(""baseUrl""),

      // Only necessary in the `Catalog.parseDestDictionary`-method,

      // when parsing ""GoToE"" actions:

      pdfManager.ensureCatalog(""attachments""),

      pdfManager.ensureDoc(""xfaDatasets""),

      collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1,

      pageRef ? pdfManager.ensureCatalog(""structTreeRoot"") : null,

    ]).then(

      ([

        acroForm,

        baseUrl,

        attachments,

        xfaDatasets,

        pageIndex,

        structTreeRoot,

      ]) =>

        pdfManager.ensure(this, ""_create"", [

          xref,

          ref,

          pdfManager,

          idFactory,

          acroForm,

          attachments,

          xfaDatasets,

          collectFields,

          pageIndex,

          structTreeRoot,

          pageRef,

        ])

    );
","   * @params {Object} annotationGlobals

   * @param {boolean} [collectFields]

  static async create(

    xref,

    ref,

    annotationGlobals,

    idFactory,

    collectFields,

    pageRef

  ) {

    const pageIndex = collectFields

      ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)

      : null;



    return annotationGlobals.pdfManager.ensure(this, ""_create"", [

      xref,

      ref,

      annotationGlobals,

      idFactory,

      pageIndex,

      pageRef,

    ]);
","async create(xref, ref, pdfManager, idFactory, collectFields, pageRef) {
    try{
      const acroForm = await pdfManager.ensureCatalog(""acroForm"");
      const baseUrl = await pdfManager.ensureCatalog(""baseUrl"");
      const attachments = await pdfManager.ensureCatalog(""attachments"");
      const xfaDatasets = await pdfManager.ensureDoc(""xfaDatasets"");
      const pageIndex = collectFields ? await this._getPageIndex(xref, ref, pdfManager) : -1;
      const structTreeRoot = pageRef ? await pdfManager.ensureCatalog(""structTreeRoot"") : null;
      return pdfManager.ensure(this, ""_create"", [
        xref,
        ref,
        pdfManager,
        idFactory,
        acroForm,
        attachments,
        xfaDatasets,
        collectFields,
        pageIndex,
        structTreeRoot,
        pageRef,
      ]);
    } catch(error) {
      console.log(error);
    }
  }",0.23636795225865714,0.03807320491208851,0.057275753999689906,0.36363636363636365,0.4864864864864865,0.4075062919135103,0.24800444695493068,0.2508167894951794,0.5636363636363636,0.5675675675675675,0.3652402107254217,0.16872788123995264,0.30163735037646755,0.1724137931034483,0.8181818181818182
324,"        return Promise.all(annotationPromises).then(function (annotations) {

          if (annotations.length === 0) {

            return annotations;

          }



          const sortedAnnotations = [];

          let popupAnnotations;

          // Ensure that PopupAnnotations are handled last, since they depend on

          // their parent Annotation in the display layer; fixes issue 11362.

          for (const annotation of annotations) {

            if (!annotation) {

              continue;

            }

            if (annotation instanceof PopupAnnotation) {

              (popupAnnotations ||= []).push(annotation);

              continue;

            }

            sortedAnnotations.push(annotation);

          if (popupAnnotations) {

            sortedAnnotations.push(...popupAnnotations);

          return sortedAnnotations;

        });

    return shadow(this, ""_parsedAnnotations"", parsedAnnotations);
","        const sortedAnnotations = [];

        let popupAnnotations;

        // Ensure that PopupAnnotations are handled last, since they depend on

        // their parent Annotation in the display layer; fixes issue 11362.

        for (const annotation of await Promise.all(annotationPromises)) {

          if (!annotation) {

            continue;

          if (annotation instanceof PopupAnnotation) {

            (popupAnnotations ||= []).push(annotation);

            continue;

          sortedAnnotations.push(annotation);

        }

        if (popupAnnotations) {

          sortedAnnotations.push(...popupAnnotations);

        }

        return sortedAnnotations;

    return shadow(this, ""_parsedAnnotations"", promise);
","async function getParsedAnnotations() {
  try {
    const annotationPromises = [];
    // Code to be migrated
    return await Promise.all(annotationPromises).then(annotations => {
      if (annotations.length === 0) {
        return annotations;
      }

      const sortedAnnotations = [];
      let popupAnnotations;

      for (const annotation of annotations) {
        if (!annotation) {
          continue;
        }

        if (annotation instanceof PopupAnnotation) {
          (popupAnnotations ||= []).push(annotation);
          continue;
        }

        sortedAnnotations.push(annotation);
      }

      if (popupAnnotations) {
        sortedAnnotations.push(...popupAnnotations);
      }

      return sortedAnnotations;
    });
  } catch (err) {
    console.error(""Error occurred while getting parsed annotations"", err);
    throw err;
  }
}",0.646395303503899,0.6442245336944696,0.6504475894120353,0.6909090909090909,0.6,0.6261485691669315,0.4861183039415615,0.5518093060594979,0.8,0.6666666666666666,0.542663670415258,0.3238095229140203,0.44961195716598407,0.7608695652173914,0.6363636363636364
325,"        return Promise.all(promises).then(refs => {

          let newRefs = [];

          let xfaData = null;

          if (isPureXfa) {

            xfaData = refs[0];

            if (!xfaData) {

              return stream.bytes;

            }

          } else {

            newRefs = refs.flat(2);



            if (newRefs.length === 0) {

              // No new refs so just return the initial bytes

              return stream.bytes;

            }

          const needAppearances =

            acroFormRef &&

            acroForm instanceof Dict &&

            newRefs.some(ref => ref.needAppearances);



          const xfa = (acroForm instanceof Dict && acroForm.get(""XFA"")) || null;

          let xfaDatasetsRef = null;

          let hasXfaDatasetsEntry = false;

          if (Array.isArray(xfa)) {

            for (let i = 0, ii = xfa.length; i < ii; i += 2) {

              if (xfa[i] === ""datasets"") {

                xfaDatasetsRef = xfa[i + 1];

                hasXfaDatasetsEntry = true;

              }

            }

            if (xfaDatasetsRef === null) {

              xfaDatasetsRef = xref.getNewTemporaryRef();

            }

          } else if (xfa) {

            // TODO: Support XFA streams.

            warn(""Unsupported XFA type."");

          let newXrefInfo = Object.create(null);

          if (xref.trailer) {

            // Get string info from Info in order to compute fileId.

            const infoObj = Object.create(null);

            const xrefInfo = xref.trailer.get(""Info"") || null;

            if (xrefInfo instanceof Dict) {

              xrefInfo.forEach((key, value) => {

                if (typeof value === ""string"") {

                  infoObj[key] = stringToPDFString(value);

                }

              });

            newXrefInfo = {

              rootRef: xref.trailer.getRaw(""Root"") || null,

              encryptRef: xref.trailer.getRaw(""Encrypt"") || null,

              newRef: xref.getNewTemporaryRef(),

              infoRef: xref.trailer.getRaw(""Info"") || null,

              info: infoObj,

              fileIds: xref.trailer.get(""ID"") || null,

              startXRef: linearization

                ? startXRef

                : xref.lastXRefStreamPos ?? startXRef,

              filename,

            };

          return incrementalUpdate({

            originalData: stream.bytes,

            xrefInfo: newXrefInfo,

            newRefs,

            xref,

            hasXfa: !!xfa,

            xfaDatasetsRef,

            hasXfaDatasetsEntry,

            needAppearances,

            acroFormRef,

            acroForm,

            xfaData,

          }).finally(() => {

            xref.resetNewTemporaryRef();

          });
","        const refs = await Promise.all(promises);

        let newRefs = [];

        let xfaData = null;

        if (isPureXfa) {

          xfaData = refs[0];

          if (!xfaData) {

            return stream.bytes;

        } else {

          newRefs = refs.flat(2);

          if (newRefs.length === 0) {

            // No new refs so just return the initial bytes

            return stream.bytes;

        }

        const needAppearances =

          acroFormRef &&

          acroForm instanceof Dict &&

          newRefs.some(ref => ref.needAppearances);



        const xfa = (acroForm instanceof Dict && acroForm.get(""XFA"")) || null;

        let xfaDatasetsRef = null;

        let hasXfaDatasetsEntry = false;

        if (Array.isArray(xfa)) {

          for (let i = 0, ii = xfa.length; i < ii; i += 2) {

            if (xfa[i] === ""datasets"") {

              xfaDatasetsRef = xfa[i + 1];

              hasXfaDatasetsEntry = true;

          }

          if (xfaDatasetsRef === null) {

            xfaDatasetsRef = xref.getNewTemporaryRef();

          }

        } else if (xfa) {

          // TODO: Support XFA streams.

          warn(""Unsupported XFA type."");

        }

        let newXrefInfo = Object.create(null);

        if (xref.trailer) {

          // Get string info from Info in order to compute fileId.

          const infoObj = Object.create(null);

          const xrefInfo = xref.trailer.get(""Info"") || null;

          if (xrefInfo instanceof Dict) {

            xrefInfo.forEach((key, value) => {

              if (typeof value === ""string"") {

                infoObj[key] = stringToPDFString(value);

              }

            });

          newXrefInfo = {

            rootRef: xref.trailer.getRaw(""Root"") || null,

            encryptRef: xref.trailer.getRaw(""Encrypt"") || null,

            newRef: xref.getNewTemporaryRef(),

            infoRef: xref.trailer.getRaw(""Info"") || null,

            info: infoObj,

            fileIds: xref.trailer.get(""ID"") || null,

            startXRef: linearization

              ? startXRef

              : xref.lastXRefStreamPos ?? startXRef,

            filename,

          };

        }



        return incrementalUpdate({

          originalData: stream.bytes,

          xrefInfo: newXrefInfo,

          newRefs,

          xref,

          hasXfa: !!xfa,

          xfaDatasetsRef,

          hasXfaDatasetsEntry,

          needAppearances,

          acroFormRef,

          acroForm,

          xfaData,

        }).finally(() => {

          xref.resetNewTemporaryRef();
","async function getUpdatedData(stream, xref, startXRef, linearization, filename) {

  let newRefs = [];

  let xfaData = null;

  if (isPureXfa) {

    xfaData = refs[0];

    if (!xfaData) {

      return stream.bytes;

    }

  } else {

    newRefs = refs.flat(2);



    if (newRefs.length === 0) {

      // No new refs so just return the initial bytes

      return stream.bytes;

    }

  const needAppearances =

    acroFormRef &&

    acroForm instanceof Dict &&

    newRefs.some(ref => ref.needAppearances);



  const xfa = (acroForm instanceof Dict && acroForm.get(""XFA"")) || null;

  let xfaDatasetsRef = null;

  let hasXfaDatasetsEntry = false;

  if (Array.isArray(xfa)) {

    for (let i = 0, ii = xfa.length; i < ii; i += 2) {

      if (xfa[i] === ""datasets"") {

        xfaDatasetsRef = xfa[i + 1];

        hasXfaDatasetsEntry = true;

      }

    }

    if (xfaDatasetsRef === null) {

      xfaDatasetsRef = xref.getNewTemporaryRef();

    }

  } else if (xfa) {

    // TODO: Support XFA streams.

    warn(""Unsupported XFA type."");

  let newXrefInfo = Object.create(null);

  if (xref.trailer) {

    // Get string info from Info in order to compute fileId.

    const infoObj = Object.create(null);

    const xrefInfo = xref.trailer.get(""Info"") || null;

    if (xrefInfo instanceof Dict) {

      xrefInfo.forEach((key, value) => {

        if (typeof value === ""string"") {

          infoObj[key] = stringToPDFString(value);

        }

      });

    newXrefInfo = {

      rootRef: xref.trailer.getRaw(""Root"") || null,

      encryptRef: xref.trailer.getRaw(""Encrypt"") || null,

      newRef: xref.getNewTemporaryRef(),

      infoRef: xref.trailer.getRaw(""Info"") || null,

      info: infoObj,

      fileIds: xref.trailer.get(""ID"") || null,

      startXRef: linearization

        ? startXRef

        : xref.lastXRefStreamPos ?? startXRef,

      filename,

    };

  return incrementalUpdate({

    originalData: stream.bytes,

    xrefInfo: newXrefInfo,

    newRefs,

    xref,

    hasXfa: !!xfa,

    xfaDatasetsRef,

    hasXfaDatasetsEntry,

    needAppearances,

    acroFormRef,

    acroForm,

    xfaData,

  }).finally(() => {

    xref.resetNewTemporaryRef();

  });

}",0.7924854929922778,0.9526008557531807,0.9517439682658411,0.9019607843137255,0.36363636363636365,0.8393751241889736,0.9664562731272117,0.9855183769263655,0.9509803921568627,0.45454545454545453,0.8272189911626304,0.93262974434291,0.9491399932013844,0.9435897435897436,0.4835164835164835
326,"  addAltTextButton() {

    AnnotationEditor._l10nPromise

      .get(""editor_alt_text_button_label"")

      .then(msg => {

        altText.textContent = msg;

        altText.setAttribute(""aria-label"", msg);

      });
","  async addAltTextButton() {

    const msg = await AnnotationEditor._l10nPromise.get(

      ""editor_alt_text_button_label""

    );

    altText.textContent = msg;

    altText.setAttribute(""aria-label"", msg);
","addAltTextButton() async {

await AnnotationEditor._l10nPromise

  .get(""editor_alt_text_button_label"")

  .then(msg => {

    altText.textContent = msg;

    altText.setAttribute(""aria-label"", msg);

  });
}",0.389306281138713,0.2829559628326351,0.33260249505555045,0.5416666666666666,0.4,0.8432742428536208,0.6803749333171202,0.8593887047640296,0.8333333333333334,1.0,0.3467960281588246,0.26518122980477765,0.28073304156067924,0.6190476190476191,0.2222222222222222
327,"    return this.loadFont(

    )

      .then(translated => {

        if (!translated.font.isType3Font) {

          return translated;

        }

        return translated

          .loadType3Data(this, resources, task)

          .then(function () {

            // Add the dependencies to the parent operatorList so they are

            // resolved before Type3 operatorLists are executed synchronously.

            operatorList.addDependencies(translated.type3Dependencies);



            return translated;

          })

          .catch(

            reason =>

              new TranslatedFont({

                loadedName: ""g_font_error"",

                font: new ErrorFont(`Type3 font load error: ${reason}`),

                dict: translated.font,

                evaluatorOptions: this.options,

              })

          );

      })

      .then(translated => {

        state.font = translated.font;

        translated.send(this.handler);

        return translated.loadedName;

      });
","    let translated = await this.loadFont(

    );



    if (translated.font.isType3Font) {

      try {

        await translated.loadType3Data(this, resources, task);

        // Add the dependencies to the parent operatorList so they are

        // resolved before Type3 operatorLists are executed synchronously.

        operatorList.addDependencies(translated.type3Dependencies);

      } catch (reason) {

        translated = new TranslatedFont({

          loadedName: ""g_font_error"",

          font: new ErrorFont(`Type3 font load error: ${reason}`),

          dict: translated.font,

          evaluatorOptions: this.options,

        });

      }

    }



    state.font = translated.font;

    translated.send(this.handler);

    return translated.loadedName;
","async function loadFont() {
  try {
    const translated = await this.loadFont();
    if (!translated.font.isType3Font) {
      return translated;
    }
    const type3Data = await translated.loadType3Data(this, resources, task);
    operatorList.addDependencies(type3Data.type3Dependencies);
    return translated;
  } catch (error) {
    return new TranslatedFont({
      loadedName: ""g_font_error"",
      font: new ErrorFont(`Type3 font load error: ${error}`),
      dict: translated.font,
      evaluatorOptions: this.options,
    });
  }
}",0.44138892202138935,0.5263849628204829,0.5181603923144434,0.5671641791044776,0.15384615384615385,0.3193994308426603,0.21671599887841622,0.24802294148418813,0.582089552238806,0.23076923076923078,0.4951272459624485,0.30307725583207135,0.33151977833218843,0.6792452830188679,0.6666666666666666
328,"    function handleSetFont(fontName, fontRef) {

      return self

        .loadFont(fontName, fontRef, resources)

        .then(function (translated) {

          if (!translated.font.isType3Font) {

            return translated;

          }

          return translated

            .loadType3Data(self, resources, task)

            .catch(function () {

              // Ignore Type3-parsing errors, since we only use `loadType3Data`

              // here to ensure that we'll always obtain a useful /FontBBox.

            })

            .then(function () {

              return translated;

            });

        })

        .then(function (translated) {

          textState.loadedName = translated.loadedName;

          textState.font = translated.font;

          textState.fontMatrix =

            translated.font.fontMatrix || FONT_IDENTITY_MATRIX;

        });
","    async function handleSetFont(fontName, fontRef) {

      const translated = await self.loadFont(fontName, fontRef, resources);



      if (translated.font.isType3Font) {

        try {

          await translated.loadType3Data(self, resources, task);

        } catch {

          // Ignore Type3-parsing errors, since we only use `loadType3Data`

          // here to ensure that we'll always obtain a useful /FontBBox.

        }

      }



      textState.loadedName = translated.loadedName;

      textState.font = translated.font;

      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
","`async function handleSetFont(fontName, fontRef) {
    
    try {
    
      const translated = await self.loadFont(fontName, fontRef, resources);
      
      if (!translated.font.isType3Font) {
        return translated;
      }
      
      await translated.loadType3Data(self, resources, task);
      textState.loadedName = translated.loadedName;
      textState.font = translated.font;
      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
      
    } catch (error) {
    
      // Ignore Type3-parsing errors, since we only use `loadType3Data` here to ensure that we'll always obtain a useful /FontBBox.
      textState.loadedName = translated.loadedName;
      textState.font = translated.font;
      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
      
    }
    
  }`",0.4761804172664475,0.4780591151983019,0.4698828928505389,0.4067796610169492,0.55,0.4948977797416439,0.48644519293845023,0.49314592602812535,0.0,0.0,0.5792110615085363,0.5831814683748914,0.7336627776592537,0.0,0.0
329,"        return this.extractDataStructures(dict, dict, properties).then(

          newProperties => {

            if (widths) {

              const glyphWidths = [];

              let j = firstChar;

              for (const width of widths) {

                glyphWidths[j++] = this.xref.fetchIfRef(width);

              }

              newProperties.widths = glyphWidths;

            } else {

              newProperties.widths = this.buildCharCodeToWidth(

                metrics.widths,

                newProperties

              );

            }

            return new Font(baseFontName, file, newProperties);

          }
","

        const newProperties = await this.extractDataStructures(

          dict,

          dict,

          properties

        if (widths) {

          const glyphWidths = [];

          let j = firstChar;

          for (const width of widths) {

            glyphWidths[j++] = this.xref.fetchIfRef(width);

          }

          newProperties.widths = glyphWidths;

        } else {

          newProperties.widths = this.buildCharCodeToWidth(

            metrics.widths,

            newProperties

          );

        }

        return new Font(baseFontName, file, newProperties);
","async function extractDataStructures(dict, dict, properties) {
    try {
        const newProperties = await this.extractDataStructures(dict, dict, properties);

        if (widths) {
            const glyphWidths = [];

            let j = firstChar;

            for (const width of widths) {
                glyphWidths[j++] = await this.xref.fetchIfRef(width);
            }

            newProperties.widths = glyphWidths;
        } else {
            newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
        }

        return await Font(baseFontName, file, newProperties);
    } catch (error) {
        console.log(`Error: ${error}`);
        throw error;
    }
}",0.6647098574271152,0.8344257534912468,0.8346832525971886,0.4634146341463415,0.5263157894736842,0.5742654413867745,0.48769024274639194,0.6527604830060975,0.6829268292682927,0.47368421052631576,0.46778302541930034,0.4990941391402729,0.6779203154781047,0.4,0.29411764705882354
330,"    return this.extractDataStructures(dict, baseDict, properties).then(

      newProperties => {

        this.extractWidths(dict, descriptor, newProperties);



        return new Font(fontName.name, fontFile, newProperties);

      }
","    const newProperties = await this.extractDataStructures(

      dict,

      baseDict,

      properties

    this.extractWidths(dict, descriptor, newProperties);



    return new Font(fontName.name, fontFile, newProperties);
","async function extractDataStructures(dict, baseDict, properties) {
  try {
    const newProperties = await this.extractDataStructures(dict, baseDict, properties);

    this.extractWidths(dict, descriptor, newProperties);



    return new Font(fontName.name, fontFile, newProperties);
  } catch (err) {
    console.error(err);
  }
}",0.4599557999982691,0.4682568791024402,0.471566320890636,0.5,0.4,0.6372932450022908,0.2940008093703827,0.5676721706387805,0.6875,1.0,0.48180765567322814,0.3120943348400659,0.6318029545195133,0.4,0.5833333333333334
331,"    return this.getOperatorList({

    }).then(function () {

      operatorList.addOp(OPS.paintFormXObjectEnd, []);

      if (group) {

        operatorList.addOp(OPS.endGroup, [groupOptions]);

      }

      if (optionalContent !== undefined) {

        operatorList.addOp(OPS.endMarkedContent, []);

      }

    });
","    await this.getOperatorList({

    });

    operatorList.addOp(OPS.paintFormXObjectEnd, []);

    if (group) {

      operatorList.addOp(OPS.endGroup, [groupOptions]);

    }

    if (optionalContent !== undefined) {

      operatorList.addOp(OPS.endMarkedContent, []);

    }
","async function() {
  await this.getOperatorList({

  });
   operatorList.addOp(OPS.paintFormXObjectEnd, []);

    if (group) {

      operatorList.addOp(OPS.endGroup, [groupOptions]);

    }

    if (optionalContent !== undefined) {

      operatorList.addOp(OPS.endMarkedContent, []);

    }
}",0.8067426477900133,0.7280097950310651,0.7151770123452039,0.7837837837837838,1.0,0.8089110376558348,0.7028766405577902,0.7219566992547383,0.8108108108108109,1.0,0.9455349868550634,0.8133899474202537,1.0,0.96875,1.0
332,"    return promise.then(function () {

      if (gStateObj.length > 0) {

        operatorList.addOp(OPS.setGState, [gStateObj]);

      }

      if (isSimpleGState) {

        localGStateCache.set(cacheKey, gStateRef, gStateObj);

      }

    });
","    await promise;

    if (gStateObj.length > 0) {

      operatorList.addOp(OPS.setGState, [gStateObj]);

    }



    if (isSimpleGState) {

      localGStateCache.set(cacheKey, gStateRef, gStateObj);

    }
","return async () => {

  if (gStateObj.length > 0) {

    operatorList.addOp(OPS.setGState, [gStateObj]);

  }

  if (isSimpleGState) {

    localGStateCache.set(cacheKey, gStateRef, gStateObj);

  }

};",0.7952661432002321,0.729455361818095,0.7208399802136026,0.7307692307692307,1.0,0.8467556632509745,0.764786017043723,0.8145443282678673,0.8076923076923077,1.0,0.8488877659520155,0.6910621773335011,0.847346029331704,0.8571428571428571,1.0
333,"    return toUnicodePromise

      .then(readToUnicode => {

        properties.toUnicode = readToUnicode;

        return this.buildToUnicode(properties);

      })

      .then(builtToUnicode => {

        properties.toUnicode = builtToUnicode;

        if (cidToGidBytes) {

          properties.cidToGidMap = this.readCidToGidMap(

            cidToGidBytes,

            builtToUnicode

          );

        }

        return properties;

      });
","

    properties.toUnicode = await toUnicodePromise;



    const builtToUnicode = await this.buildToUnicode(properties);

    properties.toUnicode = builtToUnicode;



    if (cidToGidBytes) {

      properties.cidToGidMap = this.readCidToGidMap(

        cidToGidBytes,

        builtToUnicode

      );

    }

    return properties;
","return toUnicodePromise
   .then(async readToUnicode => {

     properties.toUnicode = readToUnicode;

     return await this.buildToUnicode(properties);

   })
   .then(async builtToUnicode => {

     properties.toUnicode = builtToUnicode;

     if (cidToGidBytes) {

       properties.cidToGidMap = this.readCidToGidMap(

         cidToGidBytes,

         builtToUnicode

       );

     }

     return properties;

   });",0.5501027766035377,0.4964816560139548,0.4955961170668626,0.625,0.5833333333333334,0.8017025663455893,0.7045003719995943,0.7835598933827631,0.71875,1.0,0.6260215572773039,0.47482319663767886,0.6428993961079003,0.75,0.6363636363636364
334,"  readToUnicode(cmapObj) {

      return Promise.resolve(null);

      return CMapFactory.create({

      }).then(function (cmap) {

        return new ToUnicodeMap(cmap.getMap());

      });

    } else if (cmapObj instanceof BaseStream) {

      return CMapFactory.create({

        encoding: cmapObj,

        fetchBuiltInCMap: this._fetchBuiltInCMapBound,

        useCMap: null,

      }).then(

        function (cmap) {

          if (cmap instanceof IdentityCMap) {

            return new IdentityToUnicodeMap(0, 0xffff);

          const map = new Array(cmap.length);

          // Convert UTF-16BE

          // NOTE: cmap can be a sparse array, so use forEach instead of

          // `for(;;)` to iterate over all keys.

          cmap.forEach(function (charCode, token) {

            // Some cmaps contain *only* CID characters (fixes issue9367.pdf).

            if (typeof token === ""number"") {

              map[charCode] = String.fromCodePoint(token);

              return;

            }

            const str = [];

            for (let k = 0; k < token.length; k += 2) {

              const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

              if ((w1 & 0xf800) !== 0xd800) {

                // w1 < 0xD800 || w1 > 0xDFFF

                str.push(w1);

                continue;

              }

              k += 2;

              const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

              str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);

            map[charCode] = String.fromCodePoint(...str);

          });

          return new ToUnicodeMap(map);

        },

        reason => {

          if (reason instanceof AbortException) {

            return null;

          }

          if (this.options.ignoreErrors) {

            warn(`readToUnicode - ignoring ToUnicode data: ""${reason}"".`);

            return null;

          throw reason;

      );

    return Promise.resolve(null);
","  async readToUnicode(cmapObj) {

      return null;

      const cmap = await CMapFactory.create({

      });



      if (cmap instanceof IdentityCMap) {

        return new IdentityToUnicodeMap(0, 0xffff);

      }

      return new ToUnicodeMap(cmap.getMap());

    }

    if (cmapObj instanceof BaseStream) {

      try {

        const cmap = await CMapFactory.create({

          encoding: cmapObj,

          fetchBuiltInCMap: this._fetchBuiltInCMapBound,

          useCMap: null,

        });



        const map = new Array(cmap.length);

        // Convert UTF-16BE

        // NOTE: cmap can be a sparse array, so use forEach instead of

        // `for(;;)` to iterate over all keys.

        cmap.forEach(function (charCode, token) {

          // Some cmaps contain *only* CID characters (fixes issue9367.pdf).

          if (typeof token === ""number"") {

            map[charCode] = String.fromCodePoint(token);

            return;

          const str = [];

          for (let k = 0; k < token.length; k += 2) {

            const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

            if ((w1 & 0xf800) !== 0xd800) {

              // w1 < 0xD800 || w1 > 0xDFFF

              str.push(w1);

              continue;

            k += 2;

            const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

            str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);

          map[charCode] = String.fromCodePoint(...str);

        });

        return new ToUnicodeMap(map);

      } catch (reason) {

        if (reason instanceof AbortException) {

          return null;

        if (this.options.ignoreErrors) {

          warn(`readToUnicode - ignoring ToUnicode data: ""${reason}"".`);

          return null;

        }

        throw reason;

      }

    return null;
","async readToUnicode(cmapObj) {

  let cmap = null;

  try {

    cmap = await CMapFactory.create({ encoding: cmapObj, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });

  } catch (reason) {

    if (reason instanceof AbortException) {

      return null;

    }

    if (this.options.ignoreErrors) {

      warn(`readToUnicode - ignoring ToUnicode data: ""${reason}"".`);

      return null;

    }

    throw reason;

  }

  if (cmap instanceof IdentityCMap) {

    return new IdentityToUnicodeMap(0, 0xffff);

  const map = new Array(cmap.length);

  // Convert UTF-16BE

  // NOTE: cmap can be a sparse array, so use forEach instead of `for (;;)` to iterate over all keys.

  cmap.forEach((charCode, token) => {

    // Some cmaps contain *only* CID characters (fixes issue9367.pdf).

    if (typeof token === ""number"") {

      map[charCode] = String.fromCodePoint(token);

      return;

    }

    const str = [];

    for (let k = 0; k < token.length; k += 2) {

      const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

      if ((w1 & 0xf800) !== 0xd800) {

        // w1 < 0xD800 || w1 > 0xDFFF

        str.push(w1);

        continue;

      }

      k += 2;

      const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

      str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);

    map[charCode] = String.fromCodePoint(...str);

  });

  return new ToUnicodeMap(map);

} else {

  return null;

}

return cmap;

}",0.6962753326836495,0.8123751331867363,0.8117413490630129,0.8125,0.3484848484848485,0.6666494457097404,0.791120466347767,0.7822954983093764,0.775,0.3181818181818182,0.6570610729326819,0.8027830137537096,0.7911755636913038,0.82,0.21428571428571427
335,"function waitOnEventOrTimeout({ target, name, delay = 0 }) {

  return new Promise(function (resolve, reject) {

    if (

      typeof target !== ""object"" ||

      !(name && typeof name === ""string"") ||

      !(Number.isInteger(delay) && delay >= 0)

    ) {

      throw new Error(""waitOnEventOrTimeout - invalid parameters."");

    }



    function handler(type) {

      if (target instanceof EventBus) {

        target._off(name, eventHandler);

      } else {

        target.removeEventListener(name, eventHandler);

      }



      if (timeout) {

        clearTimeout(timeout);

      }

      resolve(type);

    }

    const eventHandler = handler.bind(null, WaitOnType.EVENT);

      target._on(name, eventHandler);

      target.addEventListener(name, eventHandler);

    const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);

    const timeout = setTimeout(timeoutHandler, delay);

  });
","async function waitOnEventOrTimeout({ target, name, delay = 0 }) {

  if (

    typeof target !== ""object"" ||

    !(name && typeof name === ""string"") ||

    !(Number.isInteger(delay) && delay >= 0)

  ) {

    throw new Error(""waitOnEventOrTimeout - invalid parameters."");

  }

  const { promise, resolve } = Promise.withResolvers();

  function handler(type) {

      target._off(name, eventHandler);

      target.removeEventListener(name, eventHandler);

    if (timeout) {

      clearTimeout(timeout);

    }

    resolve(type);

  }



  const eventHandler = handler.bind(null, WaitOnType.EVENT);

  if (target instanceof EventBus) {

    target._on(name, eventHandler);

  } else {

    target.addEventListener(name, eventHandler);

  }



  const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);

  const timeout = setTimeout(timeoutHandler, delay);



  return promise;
","async function waitOnEventOrTimeout(
  { target, name, delay = 0 }
) {

  if (
    typeof target !== ""object"" ||
    !(name && typeof name === ""string"") ||
    !(Number.isInteger(delay) && delay >= 0)
  ) {
    throw new Error(""waitOnEventOrTimeout - invalid parameters."");
  }

  try {
    let type;
    const eventHandler = (type = WaitOnType.EVENT) => {
      target._off(name, eventHandler);
      target.removeEventListener(name, eventHandler);
      if (timeout) {
        clearTimeout(timeout);
      }
      resolve(type);
    };
    target._on(name, eventHandler);
    target.addEventListener(name, eventHandler);
    const timeout = setTimeout(() => {
      type = WaitOnType.TIMEOUT;
      handler(type);
    }, delay);
  } catch (error) {
    throw new Error(""waitOnEventOrTimeout - error: "" + error.message);
  }
}",0.7383807180700114,0.7371719356934995,0.7629709832065923,0.8636363636363636,0.5897435897435898,0.5788819660248603,0.49237212947427944,0.5230391845086115,0.6590909090909091,0.6410256410256411,0.5782711822017101,0.5128030984899432,0.5214731641554129,0.6741573033707865,0.6046511627906976
336,"        this.pdfDocument

          .getPageIndex(destRef)

          .then(pageIndex => {

            this.cachePageRef(pageIndex + 1, destRef);

            this.#goToDestinationHelper(rawDest, namedDest, explicitDest);

          })

          .catch(() => {

            console.error(

              `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

                `a valid page reference, for dest=""${rawDest}"".`

            );

          });

        return;

        `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

          `a valid destination reference, for dest=""${rawDest}"".`

        `PDFLinkService.#goToDestinationHelper: ""${pageNumber}"" is not ` +

          `a valid page number, for dest=""${rawDest}"".`
","        try {

          pageNumber = (await this.pdfDocument.getPageIndex(destRef)) + 1;

          this.cachePageRef(pageNumber, destRef);

        } catch {

          console.error(

            `goToDestination: ""${destRef}"" is not a valid page reference, for dest=""${dest}"".`

          );

          return;

        }

        `goToDestination: ""${destRef}"" is not a valid destination reference, for dest=""${dest}"".`

        `goToDestination: ""${pageNumber}"" is not a valid page number, for dest=""${dest}"".`
","async function goToDestinationHelper(destRef) {
  try {
    const pageIndex = await this.pdfDocument.getPageIndex(destRef);
    this.cachePageRef(pageIndex + 1, destRef);
    this.#goToDestinationHelper(rawDest, namedDest, explicitDest);
  } catch (error) {
    console.error(
      `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not a valid page reference, for dest=""${rawDest}"".`
    );
  }
}",0.3654147820903634,0.1903783030725184,0.20044749195560177,0.2708333333333333,0.8,0.37890666368724313,0.23763355766558075,0.26132643041672504,0.4166666666666667,0.6,0.360511814640225,0.1856422278794215,0.19758150126971386,0.5588235294117647,0.5
337,"    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);

    return dataPromises.then(([contentStream]) => {

      const partialEvaluator = new PartialEvaluator({

        xref: this.xref,

        handler,

        pageIndex: this.pageIndex,

        idFactory: this._localIdFactory,

        fontCache: this.fontCache,

        builtInCMapCache: this.builtInCMapCache,

        standardFontDataCache: this.standardFontDataCache,

        globalImageCache: this.globalImageCache,

        systemFontCache: this.systemFontCache,

        options: this.evaluatorOptions,

      });

      return partialEvaluator.getTextContent({

        stream: contentStream,

        task,

        resources: this.resources,

        includeMarkedContent,

        disableNormalization,

        sink,

        viewBox: this.view,

      });
","    const langPromise = this.pdfManager.ensureCatalog(""lang"");

    const [contentStream, , lang] = await Promise.all([

      contentStreamPromise,

      resourcesPromise,

      langPromise,

    ]);

    const partialEvaluator = new PartialEvaluator({

      xref: this.xref,

      handler,

      pageIndex: this.pageIndex,

      idFactory: this._localIdFactory,

      fontCache: this.fontCache,

      builtInCMapCache: this.builtInCMapCache,

      standardFontDataCache: this.standardFontDataCache,

      globalImageCache: this.globalImageCache,

      systemFontCache: this.systemFontCache,

      options: this.evaluatorOptions,

    });

    return partialEvaluator.getTextContent({

      stream: contentStream,

      task,

      resources: this.resources,

      includeMarkedContent,

      disableNormalization,

      sink,

      viewBox: this.view,

      lang,
","const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);

async function getTextContent() {
  try {
    const [contentStream] = await dataPromises;
    const partialEvaluator = new PartialEvaluator({
      xref: this.xref,
      handler,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions,
    });
    return await partialEvaluator.getTextContent({
      stream: contentStream,
      task,
      resources: this.resources,
      includeMarkedContent,
      disableNormalization,
      sink,
      viewBox: this.view,
    });
  } catch (error) {
    console.log(error);
  }
}",0.7018692987323835,0.6982704585067312,0.7882765038646633,0.7209302325581395,0.6,0.7956066792552663,0.6416498498063392,0.8438776424085244,0.9302325581395349,0.7666666666666667,0.6174293033476376,0.5830095376477806,0.6985089179787946,0.6739130434782609,0.5142857142857142
338,"    return new Promise((resolve, reject) => {

      fs.readFile(params.path, (error, data) => {

        if (error || !data) {

          reject(error || new Error(`Empty file for: ${params.path}`));

          return;

        }

        resolve(new Uint8Array(data));

      });

    });
","    const data = await fs.promises.readFile(params.path);

    return new Uint8Array(data);
","const readFile = async (params) => {
  try {
    const data = await fs.readFile(params.path);
    if (!data) throw new Error(`Empty file for: ${params.path}`);
    return new Uint8Array(data);
  } catch (error) {
    reject(error || new Error(`Empty file for: ${params.path}`));
  }
};",0.1455289161125654,0.004255074452515724,0.018336780473936387,0.14285714285714285,0.4166666666666667,0.37847205736055667,0.21866274177785452,0.3118921543310387,0.4,0.5833333333333334,0.4176681268567122,0.08774216744205626,0.511501768556221,0.5,0.5714285714285714
339,"  _fetchData(url, compressionType) {

    return fetchData(

    ).then(data => ({

      cMapData:

        data instanceof ArrayBuffer

          ? new Uint8Array(data)

          : stringToBytes(data),

      compressionType,

    }));
","  async _fetch(url) {

    const data = await fetchData(

    );

    return data instanceof ArrayBuffer

      ? new Uint8Array(data)

      : stringToBytes(data);
","async function fetchData(url, compressionType) {
    try {
      const data = await fetchData(url);
      return {
        cMapData:
          data instanceof ArrayBuffer
            ? new Uint8Array(data)
            : stringToBytes(data),
        compressionType,
      };
    } catch (error) {
      console.log(error);
    }
  }",0.4372473766878384,0.33820862068668056,0.3631618384456254,0.38095238095238093,0.6666666666666666,0.47544441121404846,0.30305755396364525,0.5511010432735008,0.38095238095238093,0.6666666666666666,0.4138852932158795,0.29705344069848183,0.5695988432761473,0.3888888888888889,0.4
340,"  _fetchData(url) {

    return fetchData(url, /* type = */ ""arraybuffer"").then(

      data => new Uint8Array(data)

    );
","  async _fetch(url) {

    const data = await fetchData(url, /* type = */ ""arraybuffer"");

    return new Uint8Array(data);
","async _fetchData(url) {
    
    try {
      const data = await fetchData(url, ""arraybuffer"");
      return new Uint8Array(data);
    } catch (error) {
      console.log(""Error occurred:"", error);
    }
  }",0.43440180637828196,0.26518122980477765,0.32242599570835007,0.4,0.75,0.3046507768127169,0.023956565612760213,0.0446465416381073,0.4,0.75,0.6689900324741398,0.31573558123189943,0.4935578819979932,0.8666666666666667,1.0
341,"const fetchData = function (url) {

  return fs.promises.readFile(url).then(data => new Uint8Array(data));

};
","async function fetchData(url) {

  const data = await fs.promises.readFile(url);

  return new Uint8Array(data);

}
","const fetchData = async function (url) {
  try {
    const data = await fs.promises.readFile(url);
    return new Uint8Array(data);
  } catch (err) {
    console.log(err);
  }
};",0.24148227017071272,0.024316915840399723,0.02984745896009824,0.4117647058823529,0.5,0.3621376475240376,0.07289334177359764,0.16389254244019974,0.4117647058823529,0.8,0.6580855420420766,0.4028998029112093,0.8008709366856682,0.8571428571428571,0.5714285714285714
342,"  _fetchData(url, compressionType) {

    return fetchData(url).then(data => ({ cMapData: data, compressionType }));
","  async _fetch(url) {

    return fetchData(url);
","async function fetchData(url) {
  try {
    const data = await fetch(url);
    return { cMapData: data, compressionType };
  } catch (error) {
    throw error;
  }
}",0.13735952837541376,0.034222269664256,0.048549177170732344,0.13333333333333333,0.3333333333333333,0.2723891843361253,0.042601467364417965,0.11362193664674995,0.26666666666666666,0.6666666666666666,0.36510513514796056,0.009970222994544455,0.07545031759729783,0.375,1.0
343,"    messageHandler.on(""ReaderHeadersReady"", data => {

      const headersCapability = Promise.withResolvers();

      const fullReader = this._fullReader;

      fullReader.headersReady.then(() => {

        // If stream or range are disabled, it's our only way to report

        // loading progress.

        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {

          if (this._lastProgress) {

            loadingTask.onProgress?.(this._lastProgress);

          }

          fullReader.onProgress = evt => {

            loadingTask.onProgress?.({

              loaded: evt.loaded,

              total: evt.total,

            });

          };

        }

        headersCapability.resolve({

          isStreamingSupported: fullReader.isStreamingSupported,

          isRangeSupported: fullReader.isRangeSupported,

          contentLength: fullReader.contentLength,

        });

      }, headersCapability.reject);

      return headersCapability.promise;
","    messageHandler.on(""ReaderHeadersReady"", async data => {

      await this._fullReader.headersReady;

      const { isStreamingSupported, isRangeSupported, contentLength } =

        this._fullReader;



      // If stream or range are disabled, it's our only way to report

      // loading progress.

      if (!isStreamingSupported || !isRangeSupported) {

        if (this._lastProgress) {

          loadingTask.onProgress?.(this._lastProgress);

        }

        this._fullReader.onProgress = evt => {

          loadingTask.onProgress?.({

            loaded: evt.loaded,

            total: evt.total,

          });

        };

      }

      return { isStreamingSupported, isRangeSupported, contentLength };
","function () {
    try {
        const fullReader = this._fullReader;
        await fullReader.headersReady.then(() => {
            if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                if (this._lastProgress) {
                    loadingTask.onProgress?.(this._lastProgress);
                }
                fullReader.onProgress = evt => {
                    loadingTask.onProgress?.({
                        loaded: evt.loaded,
                        total: evt.total,
                    });
                };
            }
            headersCapability.resolve({
                isStreamingSupported: fullReader.isStreamingSupported,
                isRangeSupported: fullReader.isRangeSupported,
                contentLength: fullReader.contentLength,
            });
        }, headersCapability.reject);
    } catch (error) {
        console.log(error);
    }
}",0.47863101671592445,0.5150362701145739,0.5213627967491239,0.578125,0.3,0.5682515818287257,0.544029069182595,0.5539772581323078,0.875,0.3,0.46772193770147763,0.2928737508046936,0.30558875083178166,0.5581395348837209,0.7142857142857143
344,"        function (pdfDoc) {

          return pdfDoc.getPage(1).then(function (pdfPage) {

            return pdfPage.getAnnotations();

          });
","        async pdfDoc => {

          const pdfPage = await pdfDoc.getPage(1);

          return pdfPage.getAnnotations();
","async function getPDFAnnotations(pdfDoc) {
    try {
        const pdfPage = await pdfDoc.getPage(1);
        return await pdfPage.getAnnotations();
    } catch (error) {
        console.error('Error occurred while retrieving PDF annotations', error);
    }
}",0.30316578334554917,0.04411629359322707,0.05012578715739066,0.3684210526315789,0.75,0.3035991281446786,0.010438074937942448,0.03290580606182473,0.42105263157894735,0.75,0.6231148481538202,0.2250265947708922,0.6245756549872458,0.6428571428571429,1.0
345,"      pageColors: this.pageColors,

    const resultPromise = renderTask.promise.then(

      () => this.#finishRenderTask(renderTask, canvas),

      error => this.#finishRenderTask(renderTask, canvas, error)

    );

    resultPromise.finally(() => {

      zeroCanvas(canvas);



      this.eventBus.dispatch(""thumbnailrendered"", {

        source: this,

        pageNumber: this.id,

        pdfPage: this.pdfPage,

      });

    return resultPromise;
","      pageColors,

    let error = null;

    try {

      await renderTask.promise;

    } catch (e) {

      if (e instanceof RenderingCancelledException) {

        zeroCanvas(canvas);

        return;

      }

      error = e;

    } finally {

      // The renderTask may have been replaced by a new one, so only remove

      // the reference to the renderTask if it matches the one that is

      // triggering this callback.

      if (renderTask === this.renderTask) {

        this.renderTask = null;

      }

    }

    this.renderingState = RenderingStates.FINISHED;



    this.#convertCanvasToImage(canvas);

    zeroCanvas(canvas);



    this.eventBus.dispatch(""thumbnailrendered"", {

      source: this,

      pageNumber: this.id,

      pdfPage,

    if (error) {

      throw error;

    }
","async function renderPage() {
  const pageColors = this.pageColors;
  try {
    const resultPromise = await renderTask.promise();
    this.#finishRenderTask(renderTask, canvas);
    zeroCanvas(canvas);
    this.eventBus.dispatch(""thumbnailrendered"", {
      source: this,
      pageNumber: this.id,
      pdfPage: this.pdfPage,
    });
  } catch (error) {
    this.#finishRenderTask(renderTask, canvas, error);
  } finally {
    zeroCanvas(canvas);
    this.eventBus.dispatch(""thumbnailrendered"", {
      source: this,
      pageNumber: this.id,
      pdfPage: this.pdfPage,
    });
  }
}",0.42892305659841384,0.07239579141225144,0.19592801392877235,0.4473684210526316,1.0,0.4654689719960662,0.24282718954765525,0.3893836266662746,0.6842105263157895,0.5454545454545454,0.279389765605898,0.09206224422107705,0.11114496635066302,0.35185185185185186,0.5625
346,"  getContentStream() {

    return this.pdfManager.ensure(this, ""content"").then(content => {

      if (content instanceof BaseStream) {

        return content;

      }

      if (Array.isArray(content)) {

        return new StreamsSequenceStream(

          content,

          this._onSubStreamError.bind(this)

        );

      }

      // Replace non-existent page content with empty content.

      return new NullStream();

    });
","  async getContentStream() {

    const content = await this.pdfManager.ensure(this, ""content"");



    if (content instanceof BaseStream) {

      return content;

    }

    if (Array.isArray(content)) {

      return new StreamsSequenceStream(

        content,

        this._onSubStreamError.bind(this)

      );

    }

    // Replace non-existent page content with empty content.

    return new NullStream();
","async function getContentStream() {
  const content = await this.pdfManager.ensure(this, ""content"");
  if (content instanceof BaseStream) return content;
  if (Array.isArray(content)) return new StreamsSequenceStream(content, this._onSubStreamError.bind(this));
  return new NullStream();
}",0.6283304715815562,0.7787217513595732,0.8048704052369218,0.7297297297297297,0.2,0.2723791396779717,0.12566258392462143,0.14223235316564395,0.6216216216216216,0.2,0.6306168704917363,0.3558066311050136,0.4019549685089903,0.7647058823529411,1.0
347,"    return this._parsedAnnotations.then(function (annotations) {

      const promises = [];

      for (const annotation of annotations) {

        promises.push(

          annotation

            .save(partialEvaluator, task, annotationStorage, changes)

            .catch(function (reason) {

              warn(

                ""save - ignoring annotation data during "" +

                  `""${task.name}"" task: ""${reason}"".`

              );

              return null;

            })

        );

      }

      return Promise.all(promises);

    });

  loadResources(keys) {

    this.resourcesPromise ||= this.pdfManager.ensure(this, ""resources"");

    return this.resourcesPromise.then(() => {

      const objectLoader = new ObjectLoader(this.resources, keys, this.xref);

      return objectLoader.load();

    });

  getOperatorList({
","    const annotations = await this._parsedAnnotations;

    const promises = [];

    for (const annotation of annotations) {

      promises.push(

        annotation

          .save(partialEvaluator, task, annotationStorage, changes)

          .catch(function (reason) {

            warn(

              ""save - ignoring annotation data during "" +

                `""${task.name}"" task: ""${reason}"".`

            );

            return null;

          })

      );

    }

    return Promise.all(promises);

  async loadResources(keys) {

    await (this.resourcesPromise ??= this.pdfManager.ensure(this, ""resources""));

    const objectLoader = new ObjectLoader(this.resources, keys, this.xref);

    await objectLoader.load();

  async getOperatorList({
","async function loadResources(keys) {

    this.resourcesPromise ||= await this.pdfManager.ensure(this, ""resources"");

    return await this.resourcesPromise.then(() => {

        const objectLoader = new ObjectLoader(this.resources, keys, this.xref);

        return await objectLoader.load();

    });

}",0.6844977201233894,0.6981239470032315,0.6883944622995453,0.7605633802816901,0.5909090909090909,0.27351842653138214,0.12583050128990378,0.22432515105841597,0.38028169014084506,0.36363636363636365,0.20978524765838624,0.07310899810072542,0.13392971980554677,0.359375,0.2727272727272727
348,"      return partialEvaluator

        .getOperatorList({

          stream: contentStream,

          task,

          resources: this.resources,

          operatorList: opList,

        })

        .then(() => opList);

    return Promise.all([

    ]).then(function ([pageOpList, annotations, newAnnotations]) {

      if (newAnnotations) {

        // Some annotations can already exist (if it has the refToReplace

        // property). In this case, we replace the old annotation by the new

        // one.

        annotations = annotations.filter(

          a => !(a.ref && deletedAnnotations.has(a.ref))

        );

        for (let i = 0, ii = newAnnotations.length; i < ii; i++) {

          const newAnnotation = newAnnotations[i];

          if (newAnnotation.refToReplace) {

            const j = annotations.findIndex(

              a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)

            );

            if (j >= 0) {

              annotations.splice(j, 1, newAnnotation);

              newAnnotations.splice(i--, 1);

              ii--;

            }

        annotations = annotations.concat(newAnnotations);

        annotations.length === 0 ||

        intent & RenderingIntentFlag.ANNOTATIONS_DISABLE

        pageOpList.flush(/* lastChunk = */ true);

        return { length: pageOpList.totalLength };

      }

      const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),

        isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),

        intentAny = !!(intent & RenderingIntentFlag.ANY),

        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

        intentPrint = !!(intent & RenderingIntentFlag.PRINT);



      // Collect the operator list promises for the annotations. Each promise

      // is resolved with the complete operator list for a single annotation.

      const opListPromises = [];

      for (const annotation of annotations) {

        if (

          intentAny ||

          (intentDisplay &&

            annotation.mustBeViewed(annotationStorage, renderForms) &&

            annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||

          (intentPrint && annotation.mustBePrinted(annotationStorage))

        ) {

          opListPromises.push(

            annotation

              .getOperatorList(

                partialEvaluator,

                task,

                intent,

                annotationStorage

              )

              .catch(function (reason) {

                warn(

                  ""getOperatorList - ignoring annotation data during "" +

                    `""${task.name}"" task: ""${reason}"".`

                );

                return {

                  opList: null,

                  separateForm: false,

                  separateCanvas: false,

                };

              })

          );

        }

      return Promise.all(opListPromises).then(function (opLists) {

        let form = false,

          canvas = false;

        for (const { opList, separateForm, separateCanvas } of opLists) {

          pageOpList.addOpList(opList);

          form ||= separateForm;

          canvas ||= separateCanvas;

        }

        pageOpList.flush(

          /* lastChunk = */ true,

          /* separateAnnots = */ { form, canvas }

        );

        return { length: pageOpList.totalLength };

      });

    });
","      await partialEvaluator.getOperatorList({

        stream: contentStream,

        task,

        resources: this.resources,

        operatorList: opList,

      });

      return opList;

    // eslint-disable-next-line prefer-const

    let [pageOpList, annotations, newAnnotations] = await Promise.all([

    ]);



    if (newAnnotations) {

      // Some annotations can already exist (if it has the refToReplace

      // property). In this case, we replace the old annotation by the new one.

      annotations = annotations.filter(

        a => !(a.ref && deletedAnnotations.has(a.ref))

      );

      for (let i = 0, ii = newAnnotations.length; i < ii; i++) {

        const newAnnotation = newAnnotations[i];

        if (newAnnotation.refToReplace) {

          const j = annotations.findIndex(

            a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)

          );

          if (j >= 0) {

            annotations.splice(j, 1, newAnnotation);

            newAnnotations.splice(i--, 1);

            ii--;

      annotations = annotations.concat(newAnnotations);

    }

    if (

      annotations.length === 0 ||

      intent & RenderingIntentFlag.ANNOTATIONS_DISABLE

    ) {

      pageOpList.flush(/* lastChunk = */ true);

      return { length: pageOpList.totalLength };

    }

    const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),

      isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),

      intentAny = !!(intent & RenderingIntentFlag.ANY),

      intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

      intentPrint = !!(intent & RenderingIntentFlag.PRINT);



    // Collect the operator list promises for the annotations. Each promise

    // is resolved with the complete operator list for a single annotation.

    const opListPromises = [];

    for (const annotation of annotations) {

        intentAny ||

        (intentDisplay &&

          annotation.mustBeViewed(annotationStorage, renderForms) &&

          annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||

        (intentPrint && annotation.mustBePrinted(annotationStorage))

        opListPromises.push(

          annotation

            .getOperatorList(partialEvaluator, task, intent, annotationStorage)

            .catch(function (reason) {

              warn(

                ""getOperatorList - ignoring annotation data during "" +

                  `""${task.name}"" task: ""${reason}"".`

              );

              return {

                opList: null,

                separateForm: false,

                separateCanvas: false,

              };

            })

        );

    }

    const opLists = await Promise.all(opListPromises);

    let form = false,

      canvas = false;

    for (const { opList, separateForm, separateCanvas } of opLists) {

      pageOpList.addOpList(opList);

      form ||= separateForm;

      canvas ||= separateCanvas;

    }

    pageOpList.flush(

      /* lastChunk = */ true,

      /* separateAnnots = */ { form, canvas }

    );

    return { length: pageOpList.totalLength };
","return async function () {
    const opList = await partialEvaluator.getOperatorList({
      stream: contentStream,
      task,
      resources: this.resources,
      operatorList: opList,
    });
    const newOpList = await Promise.all([opList]);
    if (newOpList) {
      return { length: pageOpList.totalLength };
    } else {
      return null;
    }
  }();",0.7580061820025974,0.8524536576778399,0.8514918282998195,0.8651162790697674,0.46296296296296297,0.09392733047868246,0.00047063427240125335,0.04547985904629068,0.22790697674418606,0.10185185185185185,0.08999563942099739,0.0006540677756710697,0.061242365506404606,0.23444976076555024,0.06363636363636363
349,"  loadResources(keys, appearance) {

    return appearance.dict.getAsync(""Resources"").then(resources => {

      if (!resources) {

        return undefined;

      }



      const objectLoader = new ObjectLoader(resources, keys, resources.xref);

      return objectLoader.load().then(() => resources);

    });
","  async loadResources(keys, appearance) {

    const resources = await appearance.dict.getAsync(""Resources"");

    if (resources) {

      await ObjectLoader.load(resources, keys, resources.xref);

    }

    return resources;
","async function loadResources(keys, appearance) {
  const resources = await appearance.dict.getAsync(""Resources"");

  if (!resources) return undefined;

  const objectLoader = new ObjectLoader(resources, keys, resources.xref);
  await objectLoader.load();

  return resources;
}",0.24678979407267046,0.05627741057907439,0.058354293184134924,0.2571428571428571,0.6153846153846154,0.4353236683225692,0.32163973638587373,0.3471274643769305,0.45714285714285713,0.6153846153846154,0.6001022445375317,0.3699382260470039,0.5304707521031228,0.5,1.0
350,"function createIgnorer(ignorePath, withNodeModules) {

  return (!ignorePath

    ? Promise.resolve(null)

    : getFileContentOrNull(path.resolve(ignorePath))

  ).then(ignoreContent => _createIgnorer(ignoreContent, withNodeModules));
","async function createIgnorer(ignorePath, withNodeModules) {

  const ignoreContent = ignorePath

    ? await getFileContentOrNull(path.resolve(ignorePath))

    : null;



  return _createIgnorer(ignoreContent, withNodeModules);
","async function createIgnorer(ignorePath, withNodeModules) {

    const ignoreContent = await (await getFileContentOrNull(path.resolve(ignorePath))) || null;

    return _createIgnorer(ignoreContent, withNodeModules);
}",0.4129462611328435,0.17534823156623092,0.22798960799619905,0.391304347826087,0.8571428571428571,0.37030564439141145,0.1584450133726893,0.2171875020811554,0.391304347826087,0.7142857142857143,0.6645975767733515,0.5749089871602278,0.5952460258155314,0.5882352941176471,0.9
351,"function getFileInfo(filePath, opts) {

    return Promise.reject(

      new TypeError(

        `expect \`filePath\` to be a string, got \`${typeof filePath}\``

      )

  return createIgnorer(opts.ignorePath, opts.withNodeModules).then(ignorer =>

    _getFileInfo({

      ignorer,

      filePath: normalizeFilePath(filePath, opts.ignorePath),

      plugins: opts.plugins,

      resolveConfig: opts.resolveConfig,

      sync: false

    })

  );
","async function getFileInfo(filePath, opts) {

    throw new TypeError(

      `expect \`filePath\` to be a string, got \`${typeof filePath}\``

  const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);

  return _getFileInfo({

    ignorer,

    filePath: normalizeFilePath(filePath, opts.ignorePath),

    plugins: opts.plugins,

    resolveConfig: opts.resolveConfig,

    sync: false

  });
","async function getFileInfo(filePath, opts) {

    try {

      if (typeof filePath !== 'string') {

        throw new TypeError(`expect \`filePath\` to be a string, got \`${typeof filePath}\``);

      }

      const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);

      return _getFileInfo({

        ignorer,

        filePath: normalizeFilePath(filePath, opts.ignorePath),

        plugins: opts.plugins,

        resolveConfig: opts.resolveConfig,

        sync: false

      });

    } catch (error) {

      console.log('Error occurred while getting file info', error);

    }

}",0.7112120020333551,0.6273361951884318,0.6460832415164173,0.5714285714285714,1.0,0.6015919543799877,0.3195099616882574,0.5352095041833416,0.6285714285714286,0.9230769230769231,0.732617334573304,0.49437098395888174,0.8033440119025727,0.7096774193548387,0.9230769230769231
352,"function resolveConfigFile(filePath) {

  return load(filePath).then(result => {

    return result ? result.filepath : null;

  });
","async function resolveConfigFile(filePath) {

  const result = await load(filePath);

  return result ? result.filepath : null;
","async function resolveConfigFile(filePath) {
  try {
    const result = await load(filePath);
    return result ? result.filepath : null;
  } catch (err) {
    console.error(err);
  }
}",0.45858863051489906,0.4121183751323027,0.4472361469272936,0.375,0.6,0.42049567352057415,0.2533098404966104,0.4536728535856863,0.375,0.6,0.7973720729080287,0.560666841119542,0.9365137582048805,0.6923076923076923,1.0
353,"const editorconfigAsyncNoCache = (filePath, config) => {

  return Promise.resolve(maybeParse(filePath, config, editorconfig.parse)).then(

    editorConfigToPrettier

  );

const editorconfigAsyncWithCache = mem(editorconfigAsyncNoCache);

const editorconfigSyncWithCache = mem(editorconfigSyncNoCache);
","const editorconfigAsyncNoCache = async (filePath, config) => {

  const editorConfig = await maybeParse(filePath, config, editorconfig.parse);

  return editorConfigToPrettier(editorConfig);

const editorconfigAsyncWithCache = jsonStringifyMem(editorconfigAsyncNoCache);

const editorconfigSyncWithCache = jsonStringifyMem(editorconfigSyncNoCache);
","async function editorconfigAsyncNoCache(filePath, config) {
  try {
    let parsed = await maybeParse(filePath, config, editorconfig.parse);
    return editorConfigToPrettier(parsed);
  } catch (error) {
    console.error(""Error parsing editorconfig file:"", error);
    return null;
  }
}",0.4129756407028914,0.2171453338426706,0.2724765272145089,0.5833333333333334,0.5789473684210527,0.18896654154415626,0.00967763449717078,0.013732391328577063,0.4166666666666667,0.3157894736842105,0.34412447992448897,0.17543860064617767,0.20347477798897629,0.6086956521739131,0.3888888888888889
354,"  const { output } = bundleConfig;

  return bundler(bundleConfig, cache)

    .catch((error) => {

      console.log(FAIL + ""\n"");

      handleError(error);

    })

    .then((result) => {

      if (result.cached) {

        console.log(CACHED);

      } else {

        console.log(OK);

    });
","  const { output, target } = bundleConfig;

  try {

    const { cached } = await bundler(bundleConfig, cache);



    if (cached) {

      console.log(CACHED);

      return;

    }



    // Files including U+FFEE can't load in Chrome Extension

    // `prettier-chrome-extension` https://github.com/prettier/prettier-chrome-extension

    // details https://github.com/prettier/prettier/pull/8534

    if (target === ""universal"") {

      const file = path.join(""dist"", output);

      const content = fs.readFileSync(file, ""utf8"");

      if (content.includes(""\ufffe"")) {

        throw new Error(""Bundled umd file should not have U+FFFE character."");

    }



    console.log(OK);

  } catch (error) {

    console.log(FAIL + ""\n"");

    handleError(error);

  }
","const {output} = bundleConfig;

async function migrate() {
  try {
    const result = await bundler(bundleConfig, cache);
    if (result.cached) console.log(CACHED);
    else console.log(OK);
  } catch (error) {
    console.log(FAIL + ""\n"");
    handleError(error);
  }
}",0.35231122599606224,0.07717271771337461,0.2082626624613504,0.5238095238095238,0.6,0.3883302256696086,0.17115279944073908,0.18693000799960022,0.5952380952380952,0.6,0.2545336563801343,0.10977211384935694,0.19759328090194941,0.4307692307692308,0.28
355,"function logPromise(name, promise) {

  return promise

    .then((result) => {

      process.stdout.write(`${OK}\n`);

      return result;

    })

    .catch((err) => {

      process.stdout.write(`${FAIL}\n`);

      throw err;

    });

function runYarn(script) {

  return execa(""yarn"", [

    ""--silent"",

    ...(Array.isArray(script) ? script : [script]),

  ]).catch((error) => {

    throw new Error(`\`yarn ${script}\` failed\n${error.stdout}`);

  });
","async function logPromise(name, promiseOrAsyncFunction) {

  const promise =

    typeof promiseOrAsyncFunction === ""function""

      ? promiseOrAsyncFunction()

      : promiseOrAsyncFunction;



  try {

    const result = await promise;

    process.stdout.write(`${OK}\n`);

    return result;

  } catch (error) {

    process.stdout.write(`${FAIL}\n`);

    throw error;

  }

async function runYarn(args, options) {

  args = Array.isArray(args) ? args : [args];



  try {

    return await execa(""yarn"", [""--silent"", ...args], options);

  } catch (error) {

    throw new Error(`\`yarn ${args.join("" "")}\` failed\n${error.stdout}`);

  }

}



function runGit(args, options) {

  args = Array.isArray(args) ? args : [args];

  return execa(""git"", args, options);
","async function logPromise(name, promise) {
  try {
    const result = await promise;
    process.stdout.write(`${OK}\n`);
    return result;
  } catch (err) {
    process.stdout.write(`${FAIL}\n`);
    throw err;
  }
}",0.3167151395432497,0.06748129514088233,0.14625426303211647,0.453125,0.6,0.2693831391382025,0.12198243176339124,0.1451334581227521,0.34375,0.4666666666666667,0.17710678368890193,0.057127615939314536,0.183045550562325,0.35714285714285715,0.1111111111111111
356,"function formatStdin(context) {

  const ignorer = createIgnorerFromContextOrDie(context);

  getStdin()

    .then((input) => {

      if (

        relativeFilepath &&

        ignorer.ignores(fixWindowsSlashes(relativeFilepath))

      ) {

        writeOutput(context, { formatted: input });

        return;

      }

      const options = getOptionsForFile(context, filepath);

      if (listDifferent(context, input, options, ""(stdin)"")) {

        return;

      }

      writeOutput(context, format(context, input, options), options);

    })

    .catch((error) => {

      handleError(context, relativeFilepath || ""stdin"", error);

    });

function formatFiles(context) {

  const ignorer = createIgnorerFromContextOrDie(context);
","async function formatStdin(context) {

  const ignorer = await createIgnorerFromContextOrDie(context);

  try {

    const input = await getStdin();



    if (

      relativeFilepath &&

      ignorer.ignores(fixWindowsSlashes(relativeFilepath))

    ) {

      writeOutput(context, { formatted: input });

      return;

    }

    const options = await getOptionsForFile(context, filepath);

    if (listDifferent(context, input, options, ""(stdin)"")) {

      return;

    }

    writeOutput(context, await format(context, input, options), options);

  } catch (error) {

    handleError(context, relativeFilepath || ""stdin"", error);

  }

async function formatFiles(context) {

  const ignorer = await createIgnorerFromContextOrDie(context);
","async function formatStdin(context) {
  try {
    const input = await getStdin();
    if (relativeFilepath && ignorer.ignores(fixWindowsSlashes(relativeFilepath))) {
      writeOutput(context, { formatted: input });
      return;
    }
    const options = getOptionsForFile(context, filepath);
    if (listDifferent(context, input, options, ""(stdin)"")) {
      return;
    }
    writeOutput(context, format(context, input, options), options);
  } catch (error) {
    handleError(context, relativeFilepath || ""stdin"", error);
  }
}",0.663319651827651,0.6080248717928901,0.7088566766941842,0.6176470588235294,0.71875,0.5754716401646003,0.5363976698375569,0.5430624202326086,0.6911764705882353,0.53125,0.561513155627252,0.5758703635575394,0.5792731680423778,0.6666666666666666,0.42424242424242425
357,"function getFileContentOrNull(filename) {

  return new Promise((resolve, reject) => {

    fs.readFile(filename, ""utf8"", (error, data) => {

      if (error && error.code !== ""ENOENT"") {

        reject(createError(filename, error));

      } else {

        resolve(error ? null : data);

      }

    });

  });
","const fsAsync = fs.promises;

async function getFileContentOrNull(filename) {

  try {

    return await fsAsync.readFile(filename, ""utf8"");

  } catch (error) {

    return handleError(filename, error);

  }
","async function getFileContentOrNull(filename) {
  try {
    const data = await fs.readFile(filename, ""utf8"");
    return data;
  } catch (error) {
    if (error.code !== ""ENOENT"") {
      throw createError(filename, error);
    } else {
      return null;
    }
  }
}",0.208272939409206,0.033675795216380394,0.03879820180268301,0.1891891891891892,0.5714285714285714,0.21660674621380832,0.07322782345187179,0.07698294518714523,0.21621621621621623,0.5,0.3826161664522722,0.24960012840788245,0.4078486643853333,0.42857142857142855,0.4444444444444444
358,"    worker

      .format(code, options, { ast, doc, comments, reformat })

      .then((result) => this.setState(result));
","    const result = await worker.format(code, options, {

      ast,

      doc,

      comments,

      reformat,

    });

    this.setState(result);
","async function formatWorker() {
  const result = await this.format(code, options, { ast, doc, comments, reformat });
  await this.setState(result);
}",0.40155045179390003,0.2891784933232572,0.31702331385234306,0.5,0.5,0.38094661844352257,0.24941747177008258,0.4172261448611506,0.35714285714285715,0.5,0.49210604231577165,0.33380800216772966,0.5179495004286904,0.4166666666666667,0.7
359,"  componentDidMount() {

    this.worker.getMetadata().then(({ supportInfo, version }) => {

      this.setState({

        loaded: true,

        availableOptions: supportInfo.options.map(augmentOption),

        version: fixPrettierVersion(version),

      });
","  async componentDidMount() {

    const { supportInfo, version } = await this.worker.getMetadata();



    this.setState({

      loaded: true,

      availableOptions: supportInfo.options.map(augmentOption),

      version: fixPrettierVersion(version),
","async componentDidMount() {
  try {
    const { supportInfo, version } = await this.worker.getMetadata();
    this.setState({
      loaded: true,
      availableOptions: supportInfo.options.map(augmentOption),
      version: fixPrettierVersion(version),
    });
  } catch (error) {
    console.error('Error fetching metadata from worker', error);
  }
}",0.6249976515736497,0.40210746908120054,0.4578831372133982,0.64,0.0,0.6442321158253295,0.24450630489980987,0.5324221584015079,0.8,0.0,0.8387464953051684,0.4964806110717938,0.9494144610579709,0.9090909090909091,1.0
360,"    if (sync) {

      resolvedConfig = config.resolveConfig.sync(filePath);

    } else {

      return config.resolveConfig(filePath).then((resolvedConfig) => {

        fileInfo.inferredParser = getFileParser(

          resolvedConfig,

          filePath,

          plugins

        );

        return fileInfo;

      });

    }
","    const resolvedConfig = await config.resolveConfig(filePath);

    fileInfo.inferredParser = getFileParser(resolvedConfig, filePath, plugins);

    return fileInfo;
","async function resolveConfig(filePath) {
  try {
    const resolvedConfig = await config.resolveConfig.sync(filePath);
    fileInfo.inferredParser = getFileParser(resolvedConfig, filePath, plugins);
    return fileInfo;
  } catch (error) {
    // handle potential errors here
  }
}",0.257432026891125,0.02385372628957093,0.02968390508445278,0.39285714285714285,0.5833333333333334,0.29820234382683314,0.028760263877598696,0.03309673047735293,0.4642857142857143,0.6666666666666666,0.5656774295210093,0.2792238586462366,0.7431012440531852,0.6153846153846154,0.625
361," * @template {Options} Opts

 * @param {Opts} opts

 * @return {Opts[""sync""] extends true ? SyncExplorer : Explorer}

function getExplorer(opts) {

  // Normalize opts before passing to a memoized function

  opts = { sync: false, cache: false, ...opts };

  return getExplorerMemoized(opts);

function _resolveConfig(filePath, opts, sync) {

    sync: Boolean(sync),

  /** @type {[any, any]} */

  const arr = [

  ];



  const unwrapAndMerge = ([result, editorConfigured]) => {

    const merged = {

      ...editorConfigured,

      ...mergeOverrides(result, filePath),

    };



    for (const optionName of [""plugins"", ""pluginSearchDirs""]) {

      if (Array.isArray(merged[optionName])) {

        merged[optionName] = merged[optionName].map((value) =>

          typeof value === ""string"" && value.startsWith(""."") // relative path

            ? path.resolve(path.dirname(result.filepath), value)

            : value

        );

      }

    }



    if (!result && !editorConfigured) {

      return null;

    }

    // We are not using this option

    delete merged.insertFinalNewline;

    return merged;

  if (loadOpts.sync) {

    return unwrapAndMerge(arr);

  return Promise.all(arr).then(unwrapAndMerge);

}



const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);

resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);
"," * @param {Options} [options]

 * @return {Explorer}

function getExplorer(options) {

  return getExplorerMemoized(

    // Normalize opts before passing to a memoized function

    { cache: false, ...options }

  );

async function resolveConfig(filePath, opts) {



  const [result, editorConfigured] = await Promise.all([

  ]);

  const merged = {

    ...editorConfigured,

    ...mergeOverrides(result, filePath),

  for (const optionName of [""plugins"", ""pluginSearchDirs""]) {

    if (Array.isArray(merged[optionName])) {

      merged[optionName] = merged[optionName].map((value) =>

        typeof value === ""string"" && value.startsWith(""."") // relative path

          ? path.resolve(path.dirname(result.filepath), value)

          : value

      );

    }

  if (!result && !editorConfigured) {

    return null;

  }

  // We are not using this option

  delete merged.insertFinalNewline;

  return merged;

}
","@template {Options} Opts

  @param {Opts} opts

  @return {Opts[""sync""] extends true ? SyncExplorer : Explorer}

  async function getExplorer(opts) {

    // Normalize opts before passing to a memoized function

    opts = { sync: false, cache: false, ...opts };

    return await getExplorerMemoized(opts);

  }

  function _resolveConfig(filePath, opts, sync) {

    try {

      const result = await resolveEditorConfig(filePath, opts);

      const editorConfigured = result ? await resolveEditorConfig(result.filepath, opts) : null;

      if (!result && !editorConfigured) {

        return null;

      }

      // We are not using this option

      delete result.insertFinalNewline;

      const merged = {

        ...editorConfigured,

        ...mergeOverrides(result, filePath),

      };

      for (const optionName of [""plugins"", ""pluginSearchDirs""]) {

        if (Array.isArray(merged[optionName])) {

          merged[optionName] = merged[optionName].map((value) =>

            typeof value === ""string"" && value.startsWith(""."") // relative path

              ? path.resolve(path.dirname(result.filepath), value)

              : value

          );

        }

      }

      return merged;

    } catch (error) {

      throw new Error(`Error resolving config for file ${filePath}: ${error}`);

    }

  }

  const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);

  resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);",0.4038738633363557,0.4019049068184677,0.45310675550881296,0.5267175572519084,0.23376623376623376,0.6418216775022801,0.6867498239129612,0.7160677674285673,0.7099236641221374,0.45454545454545453,0.5954818700686031,0.4068467244122203,0.6627282774986986,0.7317073170731707,0.5806451612903226
362,"test(""API resolveConfig with no args"", () =>

  prettier.resolveConfig().then((result) => {

    expect(result).toEqual({});

  }));



test(""API resolveConfig.sync with no args"", () => {

  expect(prettier.resolveConfig.sync()).toEqual({});

});



test(""API resolveConfig with file arg"", () => {

  const file = path.resolve(path.join(__dirname, ""../cli/config/js/file.js""));

  return prettier.resolveConfig(file).then((result) => {

    expect(result).toMatchObject({

      tabWidth: 8,

    });

  });

test(""API resolveConfig.sync with file arg"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

test(""API resolveConfig with file arg and extension override"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/no-config/file.ts"")

  );

  return prettier.resolveConfig(file).then((result) => {

    expect(result).toMatchObject({

      semi: true,

    });

  });

});



test(""API resolveConfig.sync with file arg and extension override"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

test(""API resolveConfig with file arg and .editorconfig"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/editorconfig/file.js"")

  );

  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {

    expect(result).toMatchObject({

      useTabs: true,

      tabWidth: 8,

      printWidth: 100,

    });

  });

});



test(""API resolveConfig.sync with file arg and .editorconfig"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).toMatchObject({

test(""API resolveConfig.sync with file arg and .editorconfig (key = unset)"", () => {

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).not.toMatchObject({ tabWidth: ""unset"" });

});



test(""API resolveConfig with nested file arg and .editorconfig"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/editorconfig/lib/file.js"")

  );

  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {

    expect(result).toMatchObject({

      useTabs: false,

      tabWidth: 2,

      printWidth: 100,

    });

  });

test(""API resolveConfig.sync with nested file arg and .editorconfig"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).toMatchObject({

test(""API resolveConfig with nested file arg and .editorconfig and indent_size = tab"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/editorconfig/lib/indent_size=tab.js"")

  );

  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {

    expect(result).toMatchObject({

      useTabs: false,

      tabWidth: 8,

      printWidth: 100,

    });

  });

});



test(""API resolveConfig.sync with nested file arg and .editorconfig and indent_size = tab"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).toMatchObject({
","test(""API resolveConfig with no args"", async () => {

  await expect(prettier.resolveConfig()).resolves.toEqual({});

test(""API resolveConfig with file arg"", async () => {

  await expect(prettier.resolveConfig(file)).resolves.toMatchObject({

test(""API resolveConfig with file arg and extension override"", async () => {

  await expect(prettier.resolveConfig(file)).resolves.toMatchObject({

test(""API resolveConfig with file arg and .editorconfig"", async () => {

  await expect(prettier.resolveConfig(file)).resolves.toMatchObject({

  await expect(

    prettier.resolveConfig(file, { editorconfig: true })

  ).resolves.toMatchObject({

test(""API resolveConfig with file arg and .editorconfig (key = unset)"", async () => {

  await expect(

    prettier.resolveConfig(file, { editorconfig: true })

  ).resolves.not.toMatchObject({ tabWidth: ""unset"" });

test(""API resolveConfig with nested file arg and .editorconfig"", async () => {

  await expect(prettier.resolveConfig(file)).resolves.toMatchObject({

  await expect(

    prettier.resolveConfig(file, { editorconfig: true })

  ).resolves.toMatchObject({

test(""API resolveConfig with nested file arg and .editorconfig and indent_size = tab"", async () => {

  await expect(prettier.resolveConfig(file)).resolves.toMatchObject({

  await expect(

    prettier.resolveConfig(file, { editorconfig: true })

  ).resolves.toMatchObject({
","test(""API resolveConfig with no args"", async () => {
  const result = await prettier.resolveConfig();
  expect(result).toEqual({});
});

test(""API resolveConfig.sync with no args"", async () => {
  expect(prettier.resolveConfig.sync()).toEqual({});
});

test(""API resolveConfig with file arg"", async () => {
  const file = path.resolve(path.join(__dirname, ""../cli/config/js/file.js""));
  try {
    const result = await prettier.resolveConfig(file);
    expect(result).toMatchObject({ tabWidth: 8 });
  } catch (error) {
    console.log(error);
  }
});

test(""API resolveConfig.sync with file arg"", async () => {
  const file = path.resolve(path.join(__dirname, ""../cli/config/js/file.js""));
  expect(prettier.resolveConfig.sync(file)).toMatchObject({ tabWidth: 8 });
});

test(""API resolveConfig with file arg and extension override"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/no-config/file.ts"")
  );
  try {
    const result = await prettier.resolveConfig(file, { extension: "".ts"" });
    expect(result).toMatchObject({ semi: true });
  } catch (error) {
    console.log(error);
  }
});

test(""API resolveConfig.sync with file arg and extension override"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/no-config/file.ts"")
  );
  expect(prettier.resolveConfig.sync(file, { extension: "".ts"" })).toMatchObject({
    semi: true,
  });
});

test(""API resolveConfig with file arg and .editorconfig"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/file.js"")
  );
  try {
    const result = await prettier.resolveConfig(file, { editorconfig: true });
    expect(result).toMatchObject({ useTabs: true, tabWidth: 8, printWidth: 100 });
  } catch (error) {
    console.log(error);
  }
});

test(""API resolveConfig.sync with file arg and .editorconfig"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/file.js"")
  );
  expect(prettier.resolveConfig.sync(file, { editorconfig: true })).toMatchObject({
    useTabs: true,
    tabWidth: 8,
    printWidth: 100,
  });
});

test(""API resolveConfig with nested file arg and .editorconfig"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/file.js"")
  );
  try {
    const result = await prettier.resolveConfig(file, { editorconfig: true });
    expect(result).toMatchObject({ useTabs: false, tabWidth: 2, printWidth: 100 });
  } catch (error) {
    console.log(error);
  }
});

test(""API resolveConfig.sync with nested file arg and .editorconfig"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/file.js"")
  );
  expect(prettier.resolveConfig.sync(file, { editorconfig: true })).toMatchObject({
    useTabs: false,
    tabWidth: 2,
    printWidth: 100,
  });
});

test(""API resolveConfig with nested file arg and .editorconfig and indent_size = tab"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/indent_size=tab.js"")
  );
  try {
    const result = await prettier.resolveConfig(file, { editorconfig: true });
    expect(result).toMatchObject({ useTabs: false, tabWidth: 8, printWidth: 100 });
  } catch (error) {
    console.log(error);
  }
});

test(""API resolveConfig.sync with nested file arg and .editorconfig and indent_size = tab"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/indent_size=tab.js"")
  );
  expect(prettier.resolveConfig.sync(file, { editorconfig: true })).toMatchObject({
    useTabs: false,
    tabWidth: 8,
    printWidth: 100,
  });
});",0.29384696885569334,0.15273944264028602,0.2280903797150545,0.4131147540983607,0.38144329896907214,0.5550744656642176,0.4480337943787002,0.5963979198921636,0.7016393442622951,0.4742268041237113,0.5020375805104669,0.20115451367447268,0.5965062978778847,0.5181818181818182,0.6923076923076923
363,"  expect(prettier.resolveConfig.sync(doubleQuote)).toMatchObject({

test(""API resolveConfig removes $schema option"", () => {

  return prettier.resolveConfig(file).then((result) => {

    expect(result).toEqual({

      tabWidth: 42,

    });

  });

});



test(""API resolveConfig.sync removes $schema option"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/$schema/index.js"")

  );

  expect(prettier.resolveConfig.sync(file)).toEqual({

test(""API resolveConfig resolves relative path values based on config filepath"", () => {

  expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(

  ).toMatchObject({

test(""API resolveConfig de-references to an external module"", () => {

  expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toEqual({
","  await expect(prettier.resolveConfig(doubleQuote)).resolves.toMatchObject({

test(""API resolveConfig removes $schema option"", async () => {

  await expect(prettier.resolveConfig(file)).resolves.toEqual({

test(""API resolveConfig resolves relative path values based on config filepath"", async () => {

  await expect(

    prettier.resolveConfig(`${currentDir}/index.js`)

  ).resolves.toMatchObject({

  await expect(

    prettier.resolveConfig(

  ).resolves.toMatchObject({

test(""API resolveConfig de-references to an external module"", async () => {

  await expect(

    prettier.resolveConfig(`${currentDir}/index.js`)

  ).resolves.toEqual({
","expect(prettier.resolveConfig.sync(doubleQuote)).toMatchObject({

    test(""API resolveConfig removes $schema option"", async () => {
      try {
        const result = await prettier.resolveConfig.sync(file);
        expect(result).toEqual({
          tabWidth: 42,
        });
      } catch (error) {
        // handle error
      }
    });

    test(""API resolveConfig.sync removes $schema option"", () => {
      const file = path.resolve(path.join(__dirname, ""../cli/config/$schema/index.js""));
      expect(prettier.resolveConfig.sync(file)).toEqual({
        // ...
      });
    });

    test(""API resolveConfig resolves relative path values based on config filepath"", () => {
      expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toMatchObject({
        // ...
      });
    });

    test(""API resolveConfig de-references to an external module"", () => {
      expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toEqual({
        // ...
      });
    });
  }",0.36562667344619987,0.33527708723416355,0.3327851621061916,0.35,0.4444444444444444,0.6235888121403823,0.5188694299494148,0.6713191519454479,0.6375,0.6666666666666666,0.5199382247180068,0.29849244210595594,0.4687604567660713,0.3958333333333333,0.9166666666666666
364,"var require_async5 = __commonJS({

    var stream_1 = require_stream3();

        this._reader = new stream_1.default(this._settings);

      read(task) {

        const entries = [];

        return new Promise((resolve, reject) => {

          const stream2 = this.api(root, task, options);

          stream2.once(""error"", reject);

          stream2.on(""data"", (entry) => entries.push(options.transform(entry)));

          stream2.once(""end"", () => resolve(entries));

        });
","var require_async6 = __commonJS({

    var async_1 = require_async5();

        this._reader = new async_1.default(this._settings);

      async read(task) {

        const entries = await this.api(root, task, options);

        return entries.map((entry) => options.transform(entry));
","async function require_async5() {
    const stream = await require_stream3();
    const _reader = new stream.default(this._settings);

    async function read(task) {
        let entries = [];
        try {
            const stream2 = this.api(root, task, options);
            stream2.on(""error"", reject);
            stream2.once(""data"", (entry) => entries.push(options.transform(entry)));
            stream2.once(""end"", () => resolve(entries));
        } catch (err) {
            console.error(`Error reading data from API: ${err.message}`);
        }
    }
}",0.3036910047935912,0.1564392842963974,0.1827266487535655,0.42105263157894735,0.45454545454545453,0.5232054756125256,0.27009282798480166,0.3410703822802928,0.7543859649122807,0.7272727272727273,0.2940139511883444,0.03496169472407473,0.0723441100293029,0.46875,0.6
365,"    launchApp = function(appName, args, callback) {

        return new Promise((resolve) => {

            // if appName is an object and args is not set, then appName is actually args

            if (typeof appName === 'object' && !args) {

                args = appName;

                appName = undefined;

            }



            this.#postMessageWithCallback('launchApp', resolve, { app_name: appName, args });

        })
","    launchApp = async function launchApp(app_name, args, callback) {

        const app_info = await this.#ipc_stub({

            method: 'launchApp',

            callback,

            parameters: {

                app_name,

                args,

            },

        });

        

        return AppConnection.from(app_info, {

            appInstanceID: this.appInstanceID,

            messageTarget: this.messageTarget,

        });
","async launchApp(appName, args) {
  try {
    if (typeof appName === 'object' && !args) {
      args = appName;
      appName = undefined;
    }
    await this.#postMessageWithCallback('launchApp', resolve, { app_name: appName, args });
  } catch(err) {
    // handle error here
  }
}",0.18143966397022082,0.02372686706558563,0.02754498529623605,0.12903225806451613,0.5454545454545454,0.5466826327203408,0.39414258035172345,0.3937609710574987,0.5806451612903226,0.8181818181818182,0.0953197799544228,0.008197539732074256,0.010444217448254326,0.07692307692307693,0.2857142857142857
366,"import { svelte } from '../helpers.js';

describe('preprocess', () => {

	it('preprocesses entire component', () => {

		const source = `

			<h1>Hello __NAME__!</h1>

		`;

		const expected = `

			<h1>Hello world!</h1>

		`;

		return svelte.preprocess(source, {

			markup: ({ content }) => {

				return {

					code: content.replace('__NAME__', 'world')

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses style', () => {

		const source = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: $brand;

				}

			</style>

		`;



		const expected = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: purple;

				}

			</style>

		`;



		return svelte.preprocess(source, {

			style: ({ content }) => {

				return {

					code: content.replace('$brand', 'purple')

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses style asynchronously', () => {

		const source = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: $brand;

				}

			</style>

		`;



		const expected = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: purple;

				}

			</style>

		`;



		return svelte.preprocess(source, {

			style: ({ content }) => {

				return Promise.resolve({

					code: content.replace('$brand', 'purple')

				});

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses script', () => {

		const source = `

			<script>

				console.log(__THE_ANSWER__);

			</script>

		`;



		const expected = `

			<script>

				console.log(42);

			</script>

		`;



		return svelte.preprocess(source, {

			script: ({ content }) => {

				return {

					code: content.replace('__THE_ANSWER__', '42')

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses multiple matching tags', () => {

		const source = `

			<script>

				REPLACEME

			</script>

			<style>

				SHOULD NOT BE REPLACED

			</style>

			<script>

				REPLACEMETOO

			</script>

		`;



		const expected = `

			<script>

				replaceme

			</script>

			<style>

				SHOULD NOT BE REPLACED

			</style>

			<script>

				replacemetoo

			</script>

		`;



		return svelte.preprocess(source, {

			script: ({ content }) => {

				return {

					code: content.toLowerCase()

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('parses attributes', () => {

		const source = `

			<style type='text/scss' data-foo=""bar"" bool></style>

		`;



		const expected = `

			<style type='text/scss' data-foo=""bar"" bool>PROCESSED</style>

		`;



		return svelte.preprocess(source, {

			style: ({ attributes }) => {

				assert.deepEqual(attributes, {

					type: 'text/scss',

					'data-foo': 'bar',

					bool: true

				});

				return { code: 'PROCESSED' };

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('provides filename to processing hooks', () => {

		const source = `

			<h1>Hello __MARKUP_FILENAME__!</h1>

			<style>.red { color: __STYLE_FILENAME__; }</style>

			<script>console.log('__SCRIPT_FILENAME__');</script>

		`;



		const expected = `

			<h1>Hello file.html!</h1>

			<style>.red { color: file.html; }</style>

			<script>console.log('file.html');</script>

		`;



		return svelte.preprocess(source, {

			filename: 'file.html',

			markup: ({ content, filename }) => {

				return {

					code: content.replace('__MARKUP_FILENAME__', filename)

				};

			},

			style: ({ content, filename }) => {

				return {

					code: content.replace('__STYLE_FILENAME__', filename)

				};

			},

			script: ({ content, filename }) => {

				return {

					code: content.replace('__SCRIPT_FILENAME__', filename)

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});

	it('ignores null/undefined returned from preprocessor', () => {

		const source = `

			<script>

				console.log('ignore me');

			</script>

		`;

		const expected = `

			<script>

				console.log('ignore me');

			</script>

		`;

		return svelte.preprocess(source, {

			script: () => null

		}).then(processed => {

			assert.equal(processed.toString(), expected);
","import * as fs from 'fs';

import { loadConfig, svelte } from '../helpers.js';

describe.only('preprocess', () => {

	fs.readdirSync('test/preprocess/samples').forEach(dir => {

		if (dir[0] === '.') return;

		const config = loadConfig(`./preprocess/samples/${dir}/_config.js`);

		if (config.solo && process.env.CI) {

			throw new Error('Forgot to remove `solo: true` from test');

		}

		(config.skip ? it.skip : config.solo ? it.only : it)(dir, async () => {

			const input = fs.readFileSync(`test/preprocess/samples/${dir}/input.html`, 'utf-8');

			const expected = fs.readFileSync(`test/preprocess/samples/${dir}/output.html`, 'utf-8');

			const actual = await svelte.preprocess(input, config.preprocess);

			fs.writeFileSync(`test/preprocess/samples/${dir}/_actual.html`, actual);

			assert.equal(actual, expected);
","import { svelte } from '../helpers.js';

describe('preprocess', () => {
	it('preprocesses entire component', () => {
		const source = `
		<h1>Hello __NAME__!</h1>
	`;

		const expected = `
		<h1>Hello world!</h1>
	`;

		return svelte.preprocess(source, {
			markup: ({ content }) => {
				return { code: content.replace('__NAME__', 'world') };
			}
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});

	it('preprocesses style', () => {
		const source = `
		<div class='brand-color'>$brand</div>

		<style>
			.brand-color {
				color: $brand;
			}
		</style>
	`;

		const expected = `
		<div class='brand-color'>$brand</div>

		<style>
			.brand-color {
				color: purple;
			}
		</style>
	`;

		return svelte.preprocess(source, {
			style: ({ content }) => {
				return { code: content.replace('$brand', 'purple') };
			}
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});

	it('preprocesses style asynchronously', () => {
		const source = `
		<div class='brand-color'>$brand</div>

		<style>
			.brand-color {
				color: $brand;
			}
		</style>
	`;

		const expected = `
		<div class='brand-color'>$brand</div>

		<style>
			.brand-color {
				color: purple;
			}
		</style>
	`;

		return svelte.preprocess(source, {
			style: ({ content }) => {
				return Promise.resolve({ code: content.replace('$brand', 'purple') });
			}
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});

	it('preprocesses script', () => {
		const source = `
		<script>
			console.log(__THE_ANSWER__);
		</script>
	`;

		const expected = `
		<script>
			console.log(42);
		</script>
	`;

		return svelte.preprocess(source, {
			script: ({ content }) => {
				return { code: content.replace('__THE_ANSWER__', '42') };
			}
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});

	it('preprocesses multiple matching tags', () => {
		const source = `
		<script>REPLACEME</script>
		<style>SHOULD NOT BE REPLACED</style>
		<script>REPLACEMETOO</script>
	`;

		const expected = `
		<script>replaceme</script>
		<style>SHOULD NOT BE REPLACED</style>
		<script>replacemetoo</script>
	`;

		return svelte.preprocess(source, {
			script: ({ content }) => {
				return { code: content.toLowerCase() };
			}
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});

	it('parses attributes', () => {
		const source = `
		<style type='text/scss' data-foo=""bar"" bool></style>
	`;

		const expected = `
		<style type='text/scss' data-foo=""bar"" bool>PROCESSED</style>
	`;

		return svelte.preprocess(source, {
			style: ({ attributes }) => {
				assert.deepEqual(attributes, {
					type: 'text/scss',
					'data-foo': 'bar',
					bool: true
				});
				return { code: 'PROCESSED' };
			}
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});

	it('provides filename to processing hooks', () => {
		const source = `
		<h1>Hello __MARKUP_FILENAME__!</h1>
		<style>.red { color: __STYLE_FILENAME__; }</style>
		<script>console.log('__SCRIPT_FILENAME__');</script>
	`;

		const expected = `
		<h1>Hello file.html!</h1>
		<style>.red { color: file.html; }</style>
		<script>console.log('file.html');</script>
	`;

		return svelte.preprocess(source, {
			filename: 'file.html',
			markup: ({ content, filename }) => {
				return { code: content.replace('__MARKUP_FILENAME__', filename) };
			},
			style: ({ content, filename }) => {
				return { code: content.replace('__STYLE_FILENAME__', filename) };
			},
			script: ({ content, filename }) => {
				return { code: content.replace('__SCRIPT_FILENAME__', filename) };
			}
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});

	it('ignores null/undefined returned from preprocessor', () => {
		const source = `
		<script>
			console.log('ignore me');
		</script>
	`;

		const expected = `
		<script>
			console.log('ignore me');
		</script>
	`;

		return svelte.preprocess(source, {
			script: () => null
		}).then((processed) => {
			assert.equal(processed.toString(), expected);
		});
	});",0.12173184481727317,0.0007994109428919009,0.01888014765372258,0.19452054794520549,0.2727272727272727,0.9063450556976822,0.8985451187744721,0.9021775697696811,0.8246575342465754,1.0,0.28421327666980356,0.01804890318934622,0.107876772837024,0.3132530120481928,0.6976744186046512
367,"			})

				.then(bundle => bundle.generate({ format: 'iife', name: 'test' }))

				.then(result => {

					bundle = result.output[0].code;



					const nightmare = new Nightmare({ show: false });



					nightmare.on('console', (type, ...args) => {

						console[type](...args);

					});



					return nightmare

						.goto('http://localhost:6789')

						.evaluate(() => {

							return test(document.querySelector('main'));

						})

						.then(result => {

							if (result) console.log(result);

							return nightmare.end();

						})

						.catch(message => {

							console.log(addLineNumbers(bundle));

							return nightmare.end().then(() => {

								throw new Error(message);

							});

						});

				});
","			});



			const result = await bundle.generate({ format: 'iife', name: 'test' });

			code = result.output[0].code;



			const page = await browser.newPage();



			page.on('console', (type, ...args) => {

				console[type](...args);

			});

			try {

				await page.goto('http://localhost:6789');

				const result = await page.evaluate(() => test(document.querySelector('main')));

				if (result) console.log(result);

			} catch (err) {

				console.log(addLineNumbers(code));

				throw err;

			}
","async function migrate(bundle) {
  try {
    const result = await bundle.generate({ format: 'iife', name: 'test' });
    const nightmare = new Nightmare({ show: false });
    nightmare.on('console', (type, ...args) => console[type](...args));
    const output = await nightmare
      .goto('http://localhost:6789')
      .evaluate(() => test(document.querySelector('main')))
      .then(result => {
        if (result) console.log(result);
        return nightmare.end();
      })
      .catch(message => {
        console.log(addLineNumbers(bundle));
        return nightmare.end().then(() => {
          throw new Error(message);
        });
      });
    return output;
  } catch (err) {
    console.error(err);
  }
}",0.31993845347534533,0.17492230553887123,0.1758455063140293,0.5841584158415841,0.3448275862068966,0.5694810211338058,0.5658186614479567,0.6397257713289877,0.693069306930693,0.3793103448275862,0.4762704523650555,0.23507671150347387,0.3487976676161908,0.6447368421052632,0.6764705882352942
368,"fetch(`https://api.github.com/repos/sveltejs/svelte/stats/contributors`)

	.then(r => r.json())

	.then(contributors => {

		const munged = contributors

			.sort((a, b) => b.total - a.total)

			.map(({ author }) => ({ name: author.login, src: author.avatar_url }));

		const str = `[\n\t${munged.map(c => `{ name: '${c.name}', src: '${c.src}' }`).join(',\n\t')}\n]`;

		fs.writeFileSync(`../src/routes/_contributors.js`, `export default ${str};`);

	});
","const Jimp = require('jimp');

const SIZE = 64;

async function main() {

	const res = await fetch(`https://api.github.com/repos/sveltejs/svelte/stats/contributors`);

	const contributors = await res.json();

	const authors = contributors

		.sort((a, b) => b.total - a.total)

		.map(({ author }) => author);



	const sprite = new Jimp(SIZE * authors.length, SIZE);



	for (let i = 0; i < authors.length; i += 1) {

		const author = authors[i];

		console.log(`${i + 1} / ${authors.length}: ${author.login}`);



		const image_data = await fetch(author.avatar_url);

		const buffer = await image_data.arrayBuffer();



		const image = await Jimp.read(buffer);

		image.resize(SIZE, SIZE);



		sprite.composite(image, i * SIZE, 0);

	}



	await sprite.quality(80).write(`../static/contributors.jpg`);



	const str = `[\n\t${authors.map(a => `'${a.login}'`).join(',\n\t')}\n]`;



	fs.writeFileSync(`../src/routes/_contributors.js`, `export default ${str};`);

}



main();
","fetch(`https://api.github.com/repos/sveltejs/svelte/stats/contributors`)

	.then(async r => {
		const contributors = await r.json();
		const munged = contributors

			.sort((a, b) => b.total - a.total)

			.map(({ author }) => ({ name: author.login, src: author.avatar_url }));

		const str = `[\n\t${munged.map(c => `{ name: '${c.name}', src: '${c.src}' }`).join(',\n\t')}\n]`;

		fs.writeFileSync(`../src/routes/_contributors.js`, `export default ${str};`);
	});",0.3194333708809658,0.14487909059114823,0.37527863535695744,0.42424242424242425,0.3333333333333333,0.9196480645495575,0.8076797778670548,0.8709124803311751,1.0,1.0,0.13031560799599617,0.10903357650952711,0.16608820367342847,0.22727272727272727,0.018867924528301886
369,"let fulfil;

let thePromise = new Promise((f) => {

	fulfil = f;

});

	props: {

		thePromise

	test({ assert, component, target }) {

		fulfil(42);



		return thePromise

			.then(() => {

				assert.htmlEqual(

					target.innerHTML,

					`

					<p>the value is 42</p>

				`

				);



				let reject;



				thePromise = new Promise((f, r) => {

					reject = r;

				});



				component.thePromise = thePromise;



				assert.htmlEqual(

					target.innerHTML,

					`

					<p>loading...</p>

				`

				);



				reject(new Error('something broke'));



				return thePromise.catch(() => {});

			})

			.then(() => {

				assert.htmlEqual(

					target.innerHTML,

					`

					<p>oh no! something broke</p>

				`

				);

			});
","import { create_deferred } from '../../../helpers.js';

let deferred;

	before_test() {

		deferred = create_deferred();

	},



	get props() {

		return { thePromise: deferred.promise };

	async test({ assert, component, target }) {

		deferred.resolve(42);



		await deferred.promise;

		assert.htmlEqual(target.innerHTML, `<p>the value is 42</p>`);



		deferred = create_deferred();

		component.thePromise = deferred.promise;

		assert.htmlEqual(target.innerHTML, `<p>loading...</p>`);



		deferred.reject(new Error('something broke'));



		try {

			await deferred.promise;

		} catch {}



		assert.htmlEqual(target.innerHTML, `<p>oh no! something broke</p>`);
","async function test({ assert, component, target }) {

  try {

    fulfil(42);

    const promise = await thePromise;

    assert.htmlEqual(
      target.innerHTML,
      `
      <p>the value is 42</p>
    `
    );

    let reject;

    const promiseTwo = new Promise((f, r) => {
      reject = r;
    });

    component.thePromise = promiseTwo;

    assert.htmlEqual(
      target.innerHTML,
      `
      <p>loading...</p>
    `
    );

    reject(new Error('something broke'));

    const errorPromise = await thePromise.catch(() => {});

    assert.htmlEqual(
      target.innerHTML,
      `
      <p>oh no! something broke</p>
    `
    );

  } catch (error) {

    console.log('An error occurred:', error);

  }
}",0.24210366417577273,0.08648614565614014,0.0899057190241587,0.4074074074074074,0.38461538461538464,0.5740856692132772,0.543639759938915,0.5214588523367959,0.654320987654321,0.5769230769230769,0.29544752702415944,0.10234935231102395,0.13788231422717237,0.44155844155844154,0.5
370,"export const requestResolvedSubtree = path => system => {

  const {

    errActions,

    fn: {

      resolveSubtree,

      AST: { getLineNumberForPath }

    },

    specSelectors,

    specActions,

  } = system

  const specStr = specSelectors.specStr()

  const currentValue = specSelectors.specResolvedSubtree(path)

  if(currentValue) {

    return

  }

  return resolveSubtree(specSelectors.specJson().toJS(), path)

    .then(({ spec, errors }) => {

      errActions.clear({

        type: ""thrown""

      })

            console.error(err)
","let requestBatch = []

const debResolveSubtrees = debounce(async () => {

  const system = requestBatch.system // Just a reference to the ""latest"" system



  if(!system) {

    console.error(""debResolveSubtrees: don't have a system to operate on, aborting."")

    return

  }

    const {

      errActions,

      errSelectors,

      fn: {

        resolveSubtree,

        AST: { getLineNumberForPath }

      },

      specSelectors,

      specActions,

    } = system

  const specStr = specSelectors.specStr()

  try {

    var batchResult = await requestBatch.reduce(async (prev, path) => {

      const { resultMap, specWithCurrentSubtrees } = await prev



      const { errors, spec } = await resolveSubtree(specWithCurrentSubtrees, path)



      if(errSelectors.allErrors().size) {

        errActions.clear({

          type: ""thrown""

        })

      }
","export const requestResolvedSubtree = path => async system => {
  const {
    errActions,
    fn: { resolveSubtree, AST: { getLineNumberForPath } },
    specSelectors,
    specActions,
  } = system;
  const specStr = specSelectors.specStr();
  const currentValue = specSelectors.specResolvedSubtree(path);
  if (currentValue) return;
  try {
    const { spec, errors } = await resolveSubtree(
      specSelectors.specJson().toJS(),
      path
    );
    errActions.clear({ type: ""thrown"" });
    console.error(err);
    return spec;
  } catch (err) {
    errActions.throw({ type: ""requestResolvedSubtree"", message: err.message });
  }
};",0.4901413586377511,0.26751330574087556,0.48850667426467453,0.5681818181818182,0.6363636363636364,0.4861205545977044,0.387589096443345,0.5341658492201999,0.8863636363636364,0.13636363636363635,0.28144109435323666,0.21017874340849124,0.22654622513746034,0.48214285714285715,0.20689655172413793
371,"			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

			//

			session.addEventListener( 'inputsourceschange', updateInputSources );

	function updateInputSources( event ) {
","			referenceSpace = await session.requestReferenceSpace( referenceSpaceType );



			animation.setContext( session );

			animation.start();

			scope.isPresenting = true;

			scope.dispatchEvent( { type: 'sessionstart' } );

	function onInputSourcesChange( event ) {
","async function updateInputSources( event ) {
	const referenceSpaceType = await session.requestReferenceSpace(referenceSpaceType);
}",0.43786490516371096,0.059517164330538656,0.10370716220665804,0.5882352941176471,1.0,0.3467814980142417,0.25841212796263957,0.27577268762373897,0.35294117647058826,0.5,0.24611615986559726,0.043858544841520734,0.0612957497932821,0.3793103448275862,0.5
372,"			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

			//

			session.addEventListener( 'inputsourceschange', updateInputSources );

	function updateInputSources( event ) {
","			referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

			animation.setContext( session );

			animation.start();



			scope.isPresenting = true;

			scope.dispatchEvent( { type: 'sessionstart' } );

	function onInputSourcesChange( event ) {
","async function main() {
  try {
    const session = new XRSession();
    const referenceSpaceType = ""local"";
    await session.requestReferenceSpace(referenceSpaceType);
    updateInputSources(event);
  } catch (error) {
    console.log(error);
  }
}",0.43786490516371096,0.059517164330538656,0.10370716220665804,0.5882352941176471,1.0,0.22079440718121887,0.009970222994544455,0.020266229259742762,0.35294117647058826,0.5,0.2440876373603906,0.01312155138646134,0.014953135986135565,0.4482758620689655,0.5
373,"    return createLiveImage(base, info, name);

  const whiteLineMaterial = new THREE.LineBasicMaterial({

    color: 0xffffff,

    transparent: true,

    opacity: 0.5,

  });

  const blackLineMaterial = new THREE.LineBasicMaterial({

    color: 0x000000,

    transparent: true,

    opacity: 0.5,

  });



  function addGeometry(root, info, args = []) {

    return promise.then((geometryInfo) => {

      if (geometryInfo instanceof THREE.BufferGeometry ||

          geometryInfo instanceof THREE.Geometry) {

        const geometry = geometryInfo;

        geometryInfo = {

          geometry,

        };

      }

      const boxGeometry = geometryInfo.geometry || geometryInfo.lineGeometry;

      boxGeometry.computeBoundingBox();

      const centerOffset = new THREE.Vector3();

      boxGeometry.boundingBox.getCenter(centerOffset).multiplyScalar(-1);

      if (geometryInfo.geometry) {

        if (!info.material) {

          const material = new THREE.MeshPhongMaterial({

            flatShading: info.flatShading === false ? false : true,

            side: THREE.DoubleSide,

          });

          material.color.setHSL(Math.random(), .5, .5);

          info.material = material;

        }

        const mesh = new THREE.Mesh(geometryInfo.geometry, info.material);

        mesh.position.copy(centerOffset);

        root.add(mesh);

      }

      if (info.showLines !== false) {

        const lineMesh = new THREE.LineSegments(

          geometryInfo.lineGeometry || geometryInfo.geometry,

          geometryInfo.geometry ? whiteLineMaterial : blackLineMaterial);

        lineMesh.position.copy(centerOffset);

        root.add(lineMesh);

    });

  function updateGeometry(root, info, params) {

    addGeometry(root, info, Object.values(params)).then(() => {

      oldChildren.forEach((child) => {

        root.remove(child);

        child.geometry.dispose();

      });

  function createLiveImage(elem, info, name) {
","    createLiveImage(base, info, name);

  async function addGeometry(root, info, args = []) {

    let geometryInfo = await promise;

    if (geometryInfo instanceof THREE.BufferGeometry ||

        geometryInfo instanceof THREE.Geometry) {

      const geometry = geometryInfo;

      geometryInfo = {

        geometry,

      };

    }

    const boxGeometry = geometryInfo.geometry || geometryInfo.lineGeometry;

    boxGeometry.computeBoundingBox();

    const centerOffset = new THREE.Vector3();

    boxGeometry.boundingBox.getCenter(centerOffset).multiplyScalar(-1);

    if (geometryInfo.geometry) {

      if (!info.material) {

        const material = new THREE.MeshPhongMaterial({

          flatShading: info.flatShading === false ? false : true,

          side: THREE.DoubleSide,

        });

        material.color.setHSL(Math.random(), .5, .5);

        info.material = material;

      const mesh = new THREE.Mesh(geometryInfo.geometry, info.material);

      mesh.position.copy(centerOffset);

      root.add(mesh);

    }

    if (info.showLines !== false) {

      const lineMesh = new THREE.LineSegments(

        geometryInfo.lineGeometry || geometryInfo.geometry,

        new THREE.LineBasicMaterial({

          color: geometryInfo.geometry ? 0xffffff : colors.lines,

          transparent: true,

          opacity: 0.5,

        }));

      lineMesh.position.copy(centerOffset);

      root.add(lineMesh);

    }

  async function updateGeometry(root, info, params) {

    await addGeometry(root, info, Object.values(params));

    oldChildren.forEach((child) => {

      root.remove(child);

      child.geometry.dispose();

  const primitives = {};



  async function createLiveImage(elem, info, name) {
","return async (base, info, name) => {
    const geometryInfo = await createLiveImage(base, info, name);
    if (!info.material && !geometryInfo instanceof THREE.BufferGeometry || !geometryInfo instanceof THREE.Geometry) {
      const material = new THREE.MeshPhongMaterial({
        flatShading: info.flatShading === false ? false : true,
        side: THREE.DoubleSide,
      });
      material.color.setHSL(Math.random(), .5, .5);
      info.material = material;
    }
    const geometry = geometryInfo instanceof THREE.BufferGeometry || !geometryInfo instanceof THREE.Geometry ? geometryInfo : geometryInfo.geometry;
    if (geometry) {
      const mesh = new THREE.Mesh(geometry, info.material);
      mesh.position.copy(new THREE.Vector3());
      root.add(mesh);
    }
    const lineGeometry = geometryInfo.lineGeometry || geometryInfo.geometry;
    if (info.showLines !== false && lineGeometry) {
      const lineMesh = new THREE.LineSegments(lineGeometry, !geometry ? whiteLineMaterial : blackLineMaterial);
      lineMesh.position.copy(new THREE.Vector3());
      root.add(lineMesh);
    }
  };",0.6428249587289225,0.687463546529107,0.691367152584114,0.8024691358024691,0.39,0.36536665465452967,0.2718917174658487,0.302537864115233,0.5370370370370371,0.35,0.3741833883405419,0.28596067048352886,0.3064546338398926,0.5782312925170068,0.32608695652173914
374,"    addGeometry(root, info).then(() => {

      threejsLessonUtils.addDiagram(elem, {create: () => root});

    });
","    await addGeometry(root, info);

    threejsLessonUtils.addDiagram(elem, {create: () => root});
","async function addGeometry(root, info) {
  try {
    await addGeometry(root, info);
    threejsLessonUtils.addDiagram(elem, { create: () => root });
  } catch (err) {
    console.error(err);
  }
}",0.6109100057142229,0.4213952948452608,0.41113361690051975,0.6111111111111112,1.0,0.4229686042511725,0.022023814946586635,0.05873949094699214,0.6111111111111112,1.0,0.6155782250949708,0.1171291646655074,0.42210681263745264,0.9230769230769231,1.0
375,"		const writer = this;



		Promise.all( this.pending ).then( function () {

			const buffers = writer.buffers;

			const json = writer.json;

			const options = writer.options;

			const extensionsUsed = writer.extensionsUsed;

			// Merge buffers.

			const blob = new Blob( buffers, { type: 'application/octet-stream' } );

			// Declare extensions.

			const extensionsUsedList = Object.keys( extensionsUsed );

			if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;

			// Update bytelength of the single buffer.

			if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

			if ( options.binary === true ) {

				// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

				const reader = new window.FileReader();

				reader.readAsArrayBuffer( blob );

				reader.onloadend = function () {

					// Binary chunk.

					const binaryChunk = getPaddedArrayBuffer( reader.result );

					const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

					binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

					binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );



					// JSON chunk.

					const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

					const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

					jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

					jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );



					// GLB header.

					const header = new ArrayBuffer( GLB_HEADER_BYTES );

					const headerView = new DataView( header );

					headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

					headerView.setUint32( 4, GLB_VERSION, true );

					const totalByteLength = GLB_HEADER_BYTES

						+ jsonChunkPrefix.byteLength + jsonChunk.byteLength

						+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;

					headerView.setUint32( 8, totalByteLength, true );



					const glbBlob = new Blob( [

						header,

						jsonChunkPrefix,

						jsonChunk,

						binaryChunkPrefix,

						binaryChunk

					], { type: 'application/octet-stream' } );



					const glbReader = new window.FileReader();

					glbReader.readAsArrayBuffer( glbBlob );

					glbReader.onloadend = function () {



						onDone( glbReader.result );



					};

			} else {

				if ( json.buffers && json.buffers.length > 0 ) {

					const reader = new window.FileReader();

					reader.readAsDataURL( blob );

					reader.onloadend = function () {

						const base64data = reader.result;

						json.buffers[ 0 ].uri = base64data;

						onDone( json );

					};

				} else {

					onDone( json );

				}

		} );
","		await Promise.all( this.pending );

		const writer = this;

		const buffers = writer.buffers;

		const json = writer.json;

		options = writer.options;

		const extensionsUsed = writer.extensionsUsed;

		// Merge buffers.

		const blob = new Blob( buffers, { type: 'application/octet-stream' } );

		// Declare extensions.

		const extensionsUsedList = Object.keys( extensionsUsed );

		if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;

		// Update bytelength of the single buffer.

		if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

		if ( options.binary === true ) {

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

			const reader = new window.FileReader();

			reader.readAsArrayBuffer( blob );

			reader.onloadend = function () {

				// Binary chunk.

				const binaryChunk = getPaddedArrayBuffer( reader.result );

				const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

				binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

				binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );



				// JSON chunk.

				const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

				const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

				jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

				jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );



				// GLB header.

				const header = new ArrayBuffer( GLB_HEADER_BYTES );

				const headerView = new DataView( header );

				headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

				headerView.setUint32( 4, GLB_VERSION, true );

				const totalByteLength = GLB_HEADER_BYTES

					+ jsonChunkPrefix.byteLength + jsonChunk.byteLength

					+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;

				headerView.setUint32( 8, totalByteLength, true );



				const glbBlob = new Blob( [

					header,

					jsonChunkPrefix,

					jsonChunk,

					binaryChunkPrefix,

					binaryChunk

				], { type: 'application/octet-stream' } );



				const glbReader = new window.FileReader();

				glbReader.readAsArrayBuffer( glbBlob );

				glbReader.onloadend = function () {



					onDone( glbReader.result );

			};

		} else {

			if ( json.buffers && json.buffers.length > 0 ) {

				const reader = new window.FileReader();

				reader.readAsDataURL( blob );

				reader.onloadend = function () {

					const base64data = reader.result;

					json.buffers[ 0 ].uri = base64data;

					onDone( json );

				};

			} else {

				onDone( json );

		}


","const writer = this;

async function createGLB(json) {
	try {
		// Merge buffers.
		const blob = new Blob(writer.buffers, { type: 'application/octet-stream' });

		// Declare extensions.
		const extensionsUsedList = Object.keys(writer.extensionsUsed);
		if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;

		// Update bytelength of the single buffer.
		if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;

		if (writer.options.binary === true) {
			const reader = new window.FileReader();
			reader.readAsArrayBuffer(blob);
			reader.onloadend = async function () {
				// Binary chunk.
				const binaryChunk = getPaddedArrayBuffer(reader.result);

				// JSON chunk.
				const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);

				// GLB header.
				const header = new ArrayBuffer(GLB_HEADER_BYTES);
				const headerView = new DataView(header);
				headerView.setUint32(0, GLB_HEADER_MAGIC, true);
				headerView.setUint32(4, GLB_VERSION, true);
				const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
				headerView.setUint32(8, totalByteLength, true);

				const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], { type: 'application/octet-stream' });

				const glbReader = new window.FileReader();
				glbReader.readAsArrayBuffer(glbBlob);
				glbReader.onloadend = async function () {
					onDone(glbReader.result);
				};
			}
		} else {
			if (json.buffers && json.buffers.length > 0) {
				const reader = new window.FileReader();
				reader.readAsDataURL(blob);
				reader.onloadend = async function () {
					const base64data = reader.result;
					json.buffers[0].uri = base64data;
					onDone(json);
				};
			} else {
				onDone(json);
			}
		}
	} catch (error) {
		console.log('Error creating GLB:', error);
	}
}",0.9699922199086828,0.9614258635032622,0.9589175706845057,0.9678899082568807,0.9917355371900827,0.44220629250596555,0.283318974526886,0.32279484512924544,0.8073394495412844,0.35537190082644626,0.44511614462745364,0.2878673097024677,0.3250187952109477,0.812206572769953,0.35537190082644626
376,"			Promise.all( this.pending ).then( function () {



				const buffers = writer.buffers;

				const json = writer.json;

				const options = writer.options;

				const extensionsUsed = writer.extensionsUsed; // Merge buffers.



				const blob = new Blob( buffers, {

					type: 'application/octet-stream'

				} ); // Declare extensions.



				const extensionsUsedList = Object.keys( extensionsUsed );

				if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.



				if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;



				if ( options.binary === true ) {



					// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

					const reader = new window.FileReader();

					reader.readAsArrayBuffer( blob );

					reader.onloadend = function () {

						// Binary chunk.

						const binaryChunk = getPaddedArrayBuffer( reader.result );

						const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

						binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

						binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true ); // JSON chunk.

						const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

						const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

						jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

						jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true ); // GLB header.

						const header = new ArrayBuffer( GLB_HEADER_BYTES );

						const headerView = new DataView( header );

						headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

						headerView.setUint32( 4, GLB_VERSION, true );

						const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;

						headerView.setUint32( 8, totalByteLength, true );

						const glbBlob = new Blob( [ header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk ], {

							type: 'application/octet-stream'

						} );

						const glbReader = new window.FileReader();

						glbReader.readAsArrayBuffer( glbBlob );

						glbReader.onloadend = function () {

							onDone( glbReader.result );

						};

				} else {

					if ( json.buffers && json.buffers.length > 0 ) {

						const reader = new window.FileReader();

						reader.readAsDataURL( blob );

						reader.onloadend = function () {

							const base64data = reader.result;

							json.buffers[ 0 ].uri = base64data;

							onDone( json );

						};

					} else {

						onDone( json );

					}

			} );
","			await Promise.all( this.pending );

			const buffers = writer.buffers;

			const json = writer.json;

			options = writer.options;

			const extensionsUsed = writer.extensionsUsed; // Merge buffers.

			const blob = new Blob( buffers, {

				type: 'application/octet-stream'

			} ); // Declare extensions.

			const extensionsUsedList = Object.keys( extensionsUsed );

			if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.

			if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

			if ( options.binary === true ) {

				// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

				const reader = new window.FileReader();

				reader.readAsArrayBuffer( blob );

				reader.onloadend = function () {

					// Binary chunk.

					const binaryChunk = getPaddedArrayBuffer( reader.result );

					const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

					binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

					binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true ); // JSON chunk.



					const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

					const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

					jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

					jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true ); // GLB header.



					const header = new ArrayBuffer( GLB_HEADER_BYTES );

					const headerView = new DataView( header );

					headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

					headerView.setUint32( 4, GLB_VERSION, true );

					const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;

					headerView.setUint32( 8, totalByteLength, true );

					const glbBlob = new Blob( [ header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk ], {

						type: 'application/octet-stream'

					} );

					const glbReader = new window.FileReader();

					glbReader.readAsArrayBuffer( glbBlob );



					glbReader.onloadend = function () {



						onDone( glbReader.result );

				};

			} else {

				if ( json.buffers && json.buffers.length > 0 ) {

					const reader = new window.FileReader();

					reader.readAsDataURL( blob );

					reader.onloadend = function () {

						const base64data = reader.result;

						json.buffers[ 0 ].uri = base64data;

						onDone( json );

					};

				} else {

					onDone( json );

			}
","`await Promise.all( this.pending ).then( function () {

	const buffers = writer.buffers;

	const json = writer.json;

	const options = writer.options;

	const extensionsUsed = writer.extensionsUsed; // Merge buffers.

	const blob = new Blob( buffers, {

		type: 'application/octet-stream'

	} ); // Declare extensions.

	const extensionsUsedList = Object.keys( extensionsUsed );

	if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.

	if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

	if ( options.binary === true ) {

		// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

		const reader = new window.FileReader();

		reader.readAsArrayBuffer( blob );

		reader.onloadend = function () {

			// Binary chunk.

			const binaryChunk = getPaddedArrayBuffer( reader.result );

			const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

			binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

			binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true ); // JSON chunk.

			const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

			const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

			jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

			jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true ); // GLB header.

			const header = new ArrayBuffer( GLB_HEADER_BYTES );

			const headerView = new DataView( header );

			headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

			headerView.setUint32( 4, GLB_VERSION, true );

			const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;

			headerView.setUint32( 8, totalByteLength, true );

			const glbBlob = new Blob( [ header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk ], {

				type: 'application/octet-stream'

			} );

			const glbReader = new window.FileReader();

			glbReader.readAsArrayBuffer( glbBlob );

			glbReader.onloadend = function () {

				onDone( glbReader.result );

			};

	} else {

		if ( json.buffers && json.buffers.length > 0 ) {

			const reader = new window.FileReader();

			reader.readAsDataURL( blob );

			reader.onloadend = function () {

				const base64data = reader.result;

				json.buffers[ 0 ].uri = base64data;

				onDone( json );

			};

		} else {

			onDone( json );

		}

	} );`",0.9723068508018435,0.9662437874315714,0.9636554859931271,0.9675925925925926,0.9917355371900827,0.7474293212743606,0.9929452161673307,0.9967720689301116,0.0,0.0,0.7357960218274467,0.9620292787499515,0.9811548085598355,0.0,0.0
377,"			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {



				const times = new BigUint64Array( resultBuffer.getMappedRange() );

				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;



				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();

			} );
","			await resultBuffer.mapAsync( GPUMapMode.READ );

			const times = new BigUint64Array( resultBuffer.getMappedRange() );

			const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;

			this.renderer.info.updateTimestamp( type, duration );

			resultBuffer.unmap();
","async () => {


		const resultBuffer = await resultBuffer.mapAsync( GPUMapMode.READ );


		try{


		const times = new BigUint64Array( resultBuffer.getMappedRange() );


		const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;



		this.renderer.info.updateTimestamp( type, duration );


		resultBuffer.unmap();


		}catch(error){


		console.log(""Error in mapAsync"", error);

		}


		}",0.8387479863024316,0.7805692039988822,0.7906389574270607,0.7837837837837838,1.0,0.6908019089090418,0.6392612766932371,0.8575370925336641,0.8378378378378378,0.42857142857142855,0.7324157516686617,0.6187571563396405,0.944834421763578,0.9375,0.42857142857142855
378,"			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

				const times = new BigUint64Array( resultBuffer.getMappedRange() );

				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;

				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();





			} );
","			await resultBuffer.mapAsync( GPUMapMode.READ );

			const times = new BigUint64Array( resultBuffer.getMappedRange() );

			const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;

			this.renderer.info.updateTimestamp( type, duration );

			resultBuffer.unmap();
","(async() => {
  try {
    const times = await resultBuffer.mapAsync(GPUMapMode.READ);
    const duration = Number(times[1] - times[0]) / 1000000;
    this.renderer.info.updateTimestamp(type, duration);
    await resultBuffer.unmap();
  } catch (error) {
    console.log('Error:', error);
  }
})();",0.8387479863024316,0.7805692039988822,0.7906389574270607,0.7837837837837838,1.0,0.34216576861331083,0.12915834027289827,0.13525762993324086,0.6756756756756757,0.42857142857142855,0.33571913255397773,0.06394961132586074,0.06910549031862163,0.78125,0.42857142857142855
379,"			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

				const times = new BigUint64Array( resultBuffer.getMappedRange() );

				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;

				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();





			} );
","			await resultBuffer.mapAsync( GPUMapMode.READ );

			const times = new BigUint64Array( resultBuffer.getMappedRange() );

			const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;

			this.renderer.info.updateTimestamp( type, duration );

			resultBuffer.unmap();
","async function() {
    try {
        resultBuffer.mapAsync(GPUMapMode.READ)
        const times = new BigUint64Array(resultBuffer.getMappedRange())
        const duration = Number(times[1] - times[0]) / 1000000;
        this.renderer.info.updateTimestamp(type, duration);
        resultBuffer.unmap();
    } catch (error) {
        console.log(""Error: "", error)
    }
}",0.8387479863024316,0.7805692039988822,0.7906389574270607,0.7837837837837838,1.0,0.5181566261319042,0.12517062451384273,0.13664506920296307,0.8108108108108109,1.0,0.5439602139287749,0.12724963729321143,0.14234121842188827,0.90625,1.0
380,"function loadNoteToEditor(noteId) {

    $.get(baseApiUrl + 'notes/' + noteId).then(note => {

        globalCurrentNote = note;

        globalCurrentNoteLoadTime = Math.floor(new Date().getTime() / 1000);

        if (newNoteCreated) {

            newNoteCreated = false;

            $(""#note-title"").focus().select();

        }

        handleEncryption(note.detail.encryption > 0, false, () => {

            $(""#note-detail-wrapper"").show();

            // this may fal if the dialog has not been previously opened

            try {

                $(""#encryption-password-dialog"").dialog('close');

            }

            catch(e) {}

            $(""#encryption-password"").val('');

            decryptNoteIfNecessary(note);

            $(""#note-title"").val(note.detail.note_title);

            noteChangeDisabled = true;

            // Clear contents and remove all stored history. This is to prevent undo from going across notes

            $('#note-detail').summernote('reset');

            $('#note-detail').summernote('code', note.detail.note_text);

            document.location.hash = noteId;

            addRecentNote(noteId, note.detail.note_id);

            noteChangeDisabled = false;

            setNoteBackgroundIfEncrypted(note);

        });

    });

function loadNote(noteId, callback) {

    $.get(baseApiUrl + 'notes/' + noteId).then(note => {

        if (note.detail.encryption > 0 && !isEncryptionAvailable()) {

            return;

        }

        decryptNoteIfNecessary(note);

        callback(note);

    });
","async function loadNoteToEditor(noteId) {

    const note = await $.get(baseApiUrl + 'notes/' + noteId);

    globalCurrentNote = note;

    globalCurrentNoteLoadTime = Math.floor(new Date().getTime() / 1000);

    if (newNoteCreated) {

        newNoteCreated = false;

        $(""#note-title"").focus().select();

    }

    await handleEncryption(note.detail.encryption > 0, false);

    $(""#note-detail-wrapper"").show();

    // this may fal if the dialog has not been previously opened

    try {

        $(""#encryption-password-dialog"").dialog('close');

    }

    catch(e) {}

    $(""#encryption-password"").val('');

    decryptNoteIfNecessary(note);

    $(""#note-title"").val(note.detail.note_title);

    noteChangeDisabled = true;

    // Clear contents and remove all stored history. This is to prevent undo from going across notes

    $('#note-detail').summernote('reset');

    $('#note-detail').summernote('code', note.detail.note_text);

    document.location.hash = noteId;

    addRecentNote(noteId, note.detail.note_id);

    noteChangeDisabled = false;



    setNoteBackgroundIfEncrypted(note);

async function loadNote(noteId) {

    const note = await $.get(baseApiUrl + 'notes/' + noteId);



    if (note.detail.encryption > 0 && !isEncryptionAvailable()) {

        return;

    }

    decryptNoteIfNecessary(note);

    return note;
","async function loadNoteToEditor(noteId) {
    try {
      const note = await $.get(baseApiUrl + 'notes/' + noteId);
      globalCurrentNote = note;
      globalCurrentNoteLoadTime = Math.floor(new Date().getTime() / 1000);
      if (newNoteCreated) {
        newNoteCreated = false;
        $(""#note-title"").focus().select();
      }
      handleEncryption(note.detail.encryption > 0, false, async () => {
        $(""#note-detail-wrapper"").show();
        // this may fal if the dialog has not been previously opened
        try {
          $(""#encryption-password-dialog"").dialog('close');
        } catch (e) {}
        $(""#encryption-password"").val("""");
        decryptNoteIfNecessary(note);
        $(""#note-title"").val(note.detail.note_title);
        noteChangeDisabled = true;
        // Clear contents and remove all stored history. This is to prevent undo from going across notes
        $('#note-detail').summernote('reset');
        $('#note-detail').summernote('code', note.detail.note_text);
        document.location.hash = noteId;
        addRecentNote(noteId, note.detail.note_id);
        noteChangeDisabled = false;
        setNoteBackgroundIfEncrypted(note);
      });
    } catch (error) {
      console.log(""Error:"", error);
    }
  }",0.7033680776106401,0.7518162564509375,0.7646965945321633,0.8375,0.4594594594594595,0.6430347140851407,0.6816794522478505,0.6808310257143336,0.83125,0.3783783783783784,0.7468504597114901,0.6929512971601435,0.6775274647627401,0.8733333333333333,0.7435897435897436
381,"    encryptionPasswordFormEl.submit(() => {

        getDataKey(password).then(key => {

            dialogEl.dialog(""close"");



            dataKey = key;

            decryptTreeItems();

            if (encryptionDeferred !== null) {

                encryptionDeferred.resolve();

                encryptionDeferred = null;

            }

        })

            .catch(reason => {

                console.log(reason);

                error(reason);

            });

        return false;

    });
","    async function setupEncryptionSession() {

        const key = await getDataKey(password);

        if (key === false) {

            showError(""Wrong password!"");

            return;

        }

        dialogEl.dialog(""close"");

        dataKey = key;

        decryptTreeItems();

        if (encryptionDeferred !== null) {

            encryptionDeferred.resolve();

            encryptionDeferred = null;

        }

    }
","encryptionPasswordFormEl.submit(async () => {
        try {
            const key = await getDataKey(password);
            dialogEl.dialog(""close"");
            dataKey = key;
            decryptTreeItems();
            if (encryptionDeferred !== null) {
                encryptionDeferred.resolve();
                encryptionDeferred = null;
            }
        } catch (error) {
            console.log(reason);
            error(reason);
        }
        return false;
    });",0.49188360107227075,0.42736529994169026,0.4687405329188213,0.5714285714285714,0.5,0.5304814093240046,0.4908722558583935,0.5825839936825227,0.673469387755102,0.375,0.6890681010182194,0.5592005382665879,0.5852297605431315,0.7368421052631579,0.875
382,"    server.get('recent-notes').then(result => {

    });
","    async function reload() {

        const result = await server.get('recent-notes');



    }
","// Migrate Promise Chains to async/await Syntax
async function getRecentNotes() {
  try {
    const result = await server.get('recent-notes');
    // Logic to handle the resolved value goes here
  } catch (error) {
    // Logic to handle errors goes here
  } finally {
    // Logic to execute regardless of whether the promise was fulfilled or rejected goes here
  }
}",0.36518131820834887,0.021105340631872645,0.07598356856515925,0.36363636363636365,0.0,0.3834192591933151,0.003148013662646501,0.07598356856515925,0.45454545454545453,0.0,0.6287944060474615,0.08931622519425847,0.6076795808137692,0.8181818181818182,1.0
383,"            server.get('notes?search=' + searchText).then(resp => {

                // Pass a string to perform case insensitive matching

                getTree().filterBranches(node => {

                    return resp.includes(node.data.note_id);

                });

            });
","            const noteIds = await server.get('notes?search=' + encodeURIComponent(searchText));



            for (const noteId of noteIds) {

                await noteTree.expandToNote(noteId, {noAnimation: true, noEvents: true});

            }



            // Pass a string to perform case insensitive matching

            getTree().filterBranches(node => noteIds.includes(node.data.note_id));
","async function loadNotes(searchText) {
    try {
        const resp = await server.get('notes?search=' + searchText);

        getTree().filterBranches(node => {
            return resp.includes(node.data.note_id);
        });
    } catch (err) {
        console.error(err);
    }
}",0.43476377574223307,0.3366708947010077,0.51776882365254,0.38461538461538464,0.5,0.4872527400449056,0.2061487201475908,0.26209300926280094,0.7307692307692307,0.75,0.28517427705032306,0.09449268987384246,0.09923472135775273,0.36363636363636365,0.5833333333333334
384,"    function loadTree() {

        return server.get('tree').then(resp => {

            startNotePath = resp.start_note_path;

            if (document.location.hash) {

                startNotePath = getNotePathFromAddress();

            }

            return prepareNoteTree(resp.notes);

        });
","    async function loadTree() {

        const resp = await server.get('tree');

        startNotePath = resp.start_note_path;

        if (document.location.hash) {

            startNotePath = getNotePathFromAddress();

        }

        return prepareNoteTree(resp.notes);
","async function loadTree() {

    let resp;

    try {
        resp = await server.get('tree');
    } catch (error) {
        console.log(error);
        return;
    }

    startNotePath = resp.start_note_path;

    if (document.location.hash) {
        startNotePath = getNotePathFromAddress();
    }

    try {
        prepareNoteTree(resp.notes);
    } catch (error) {
        console.log(error);
        return;
    }
}",0.580305428649789,0.605478327168454,0.6383240325919926,0.6774193548387096,0.4,0.6082140854998178,0.2623787409066636,0.5253163107700272,0.6451612903225806,1.0,0.5611752522851836,0.34418320479193587,0.6505178043487984,0.75,0.5
385,"$form.submit(() => {

    server.put('tree/' + branchId + '/set-prefix', {

        prefix: prefix

    }).then(() => treeService.setPrefix(branchId, prefix));
","async function savePrefix() {

    await server.put('tree/' + branchId + '/set-prefix', { prefix: prefix });



    await treeService.setPrefix(branchId, prefix);

}



$form.submit(() => {

    savePrefix();
","$form.submit(async () => {
  try {
    await server.put('tree/' + branchId + '/set-prefix', { prefix: prefix });
    treeService.setPrefix(branchId, prefix);
  } catch (error) {
    console.log(error);
  }
});",0.6700422228689443,0.38305978177479755,0.5828233954152653,0.7142857142857143,1.0,0.6381140258122221,0.30536941697562214,0.5328009719875518,0.7142857142857143,1.0,0.6725114424767329,0.4838523878651957,0.5261933820417358,0.68,1.0
386,"$(document).ready(() => {

    server.get('migration').then(result => {

        const appDbVersion = result.app_dbVersion;

        const dbVersion = result.dbVersion;

        if (appDbVersion === dbVersion) {

            $(""#up-to-date"").show();

        }

        else {

            $(""#need-to-migrate"").show();

            $(""#app-db-version"").html(appDbVersion);

            $(""#db-version"").html(dbVersion);

        }

    });
","$(document).ready(async () => {

    const {appDbVersion, dbVersion} = await server.get('migration');

    console.log(""HI"", {appDbVersion, dbVersion});

    if (appDbVersion === dbVersion) {

        $(""#up-to-date"").show();

    }

    else {

        $(""#need-to-migrate"").show();



        $(""#app-db-version"").html(appDbVersion);

        $(""#db-version"").html(dbVersion);

    }
","$(document).ready(async () => {
    const result = await server.get('migration');
    const appDbVersion = result.app_dbVersion;
    const dbVersion = result.dbVersion;
    if (appDbVersion === dbVersion) {
      $(""#up-to-date"").show();
    } else {
      $(""#need-to-migrate"").show();
      $(""#app-db-version"").html(appDbVersion);
      $(""#db-version"").html(dbVersion);
    }
  });",0.5888788616855632,0.49183470956650166,0.5011807371757514,0.8,0.5625,0.7501134353057922,0.7348830810784188,0.8303433874174776,0.8727272727272727,0.5625,0.6897028170874688,0.5478748084045127,0.6743798561717779,0.8490566037735849,0.6875
387,"            $.post('/api/setup/sync-from-server', {

            }).then(() => {

                window.location.replace(""/"");

            }).catch((err) => {

                alert(""Error, see dev console for details."");

                console.error(err);
","            const resp = await $.post('/api/setup/sync-from-server', {



            if (resp.result === 'success') {

                this.step('sync-in-progress');



                checkOutstandingSyncs();



                setInterval(checkOutstandingSyncs, 1000);

            }

            else {

                showAlert('Sync setup failed: ', resp.error);

            }

async function checkOutstandingSyncs() {

    const stats = await $.get('/api/sync/stats');

    const totalOutstandingSyncs = stats.outstandingPushes + stats.outstandingPulls;



    $(""#outstanding-syncs"").html(totalOutstandingSyncs);

}


","async function setupSyncFromServer() {
    try {
        await $.post('/api/setup/sync-from-server', {});
        window.location.replace(""/"");
    } catch (err) {
        alert(""Error, see dev console for details."");
        console.error(err);
    }
}",0.22443134669885062,0.011326402345230238,0.02925612730731506,0.35714285714285715,0.5,0.6355852473269621,0.3299895472527792,0.49806572776935465,0.7142857142857143,1.0,0.09085336173741565,0.01424048921073572,0.01698313498306641,0.3018867924528302,0.030303030303030304
388,"    exportService.importIntoNote(currentNode.data.noteId).then(() => {

        $dialog.modal('hide');

    });
","    importIntoNote(currentNode.data.noteId);

function importIntoNote(importNoteId) {

    const formData = new FormData();

    formData.append('upload', $fileUploadInput[0].files[0]);



    // this is done to reset the field otherwise triggering import same file again would not work

    // https://github.com/zadam/trilium/issues/388

    $fileUploadInput.val('');



    $.ajax({

        url: baseApiUrl + 'notes/' + importNoteId + '/import',

        headers: server.getHeaders(),

        data: formData,

        dataType: 'json',

        type: 'POST',

        contentType: false, // NEEDED, DON'T REMOVE THIS

        processData: false, // NEEDED, DON'T REMOVE THIS

    })

        .fail((xhr, status, error) => alert('Import error: ' + xhr.responseText))

        .done(async note => {

            $dialog.modal('hide');



            infoService.showMessage(""Import finished successfully."")



            await treeService.reload();



            if (note) {

                const node = await treeService.activateNote(note.noteId);



                node.setExpanded(true);

            }

        });

}


","async function importNote() {
try {
const result = await exportService.importIntoNote(currentNode.data.noteId);
$dialog.modal('hide');
} catch (error) {
console.log(error);
}}",0.4489922558842638,0.010224980567175204,0.28574404296988,0.5,0.0,0.42196290281562654,0.01284618972676772,0.06389431042462725,0.6111111111111112,0.0,0.14966709784467658,0.0005802927527939849,0.008025986824670064,0.30434782608695654,0.2857142857142857
389,"function showDialog() {

    server.get('sql/schema').then(tables => {

        $tables.empty();



        for (const table of tables) {

            const $tableLink = $('<a href=""javascript:"">').text(table.name);



            const $columns = $(""<table>"");



            for (const column of table.columns) {

                $columns.append(

                    $(""<tr>"")

                        .append($(""<td>"").text(column.name))

                        .append($(""<td>"").text(column.type))

                );

            }



            $tableLink

                .attr(""title"", $columns.html())

                .tooltip({ html: true })

                .click(() => codeEditor.setValue(""SELECT * FROM "" + table.name + "" LIMIT 100""));



            $tables.append($tableLink).append("" "");

        }

    });


","async function showDialog() {

    await showTables();


","async function showDialog() {
  try {
    const tables = await server.get('sql/schema');
    $tables.empty();
    for (const table of tables) {
      const $tableLink = $('<a href=""javascript:"">').text(table.name);
      const $columns = $(""<table>"");
      for (const column of table.columns) {
        $columns.append($(""<tr>"").append($(""<td>"").text(column.name)).append($(""<td>"").text(column.type)));
      }
      $tableLink.attr(""title"", $columns.html()).tooltip({ html: true }).click(() => codeEditor.setValue(`SELECT * FROM ${table.name} LIMIT 100`));
      $tables.append($tableLink).append(' ');
    }
  } catch (error) {
    console.log(error);
  }
}",0.26465711815635695,4.111109942972711e-05,0.018183321121957637,0.04040404040404041,0.0,0.5368215124333141,0.4349037198810837,0.45286407033391324,0.797979797979798,0.46153846153846156,0.4541044880243996,0.04217698009415556,0.5520187497812208,0.2222222222222222,0.0
390,"        libraryLoader.requireLibrary(libraryLoader.SORTABLE).then(() => {

            new Sortable(this.$widgetsEnabled[0], {

                group: 'widgets',

                handle: '.handle',

                animation: 150

            });

            new Sortable(this.$widgetsDisabled[0], {

                group: 'widgets',

                handle: '.handle',

                animation: 150
","        await libraryLoader.requireLibrary(libraryLoader.SORTABLE);



        new Sortable(this.$widgetsEnabled[0], {

            group: 'widgets',

            handle: '.handle',

            animation: 150,

            onSort: evt => this.save()

        });

        new Sortable(this.$widgetsDisabled[0], {

            group: 'widgets',

            handle: '.handle',

            animation: 150,

            onSort: evt => this.save()

        });

    }



    async save() {

        const opts = {};



        this.$widgetsConfiguration.find('.list-group-item').each((i, el) => {

            const widgetName = $(el).find('div[data-widget-name]').attr('data-widget-name');



            opts[widgetName + 'Widget'] = JSON.stringify({

                enabled: $.contains(this.$widgetsEnabled[0], el),

                expanded: $(el).find(""input[type=checkbox]"").is("":checked""),

                position: (i + 1) * 10



        await server.put('options', opts);
","async function loadLibrary() {
    await libraryLoader.requireLibrary(libraryLoader.SORTABLE);
    new Sortable(this.$widgetsEnabled[0], {
        group: 'widgets',
        handle: '.handle',
        animation: 150
    });
    new Sortable(this.$widgetsDisabled[0], {
        group: 'widgets',
        handle: '.handle',
        animation: 150
    });
}",0.6677316165526006,0.2274290895971132,0.7127281458440583,0.7307692307692307,1.0,0.8622230153856522,0.6943776929402705,0.8698989839869534,0.8846153846153846,1.0,0.24685387135014422,0.1619598540251202,0.2725952194761432,0.37894736842105264,0.17391304347826086
391,"    // code below shouldn't be necessary normally, however there's some problem with interaction with context menu plugin

    // after opening context menu, standard shortcuts don't work, but they are detected here

    // so we essentially takeover the standard handling with our implementation.

    ""left"": node => {

        node.navigate($.ui.keyCode.LEFT, true).then(treeService.clearSelectedNodes);



        return false;

    },

    ""right"": node => {

        node.navigate($.ui.keyCode.RIGHT, true).then(treeService.clearSelectedNodes);

    },

    ""up"": node => {

        node.navigate($.ui.keyCode.UP, true).then(treeService.clearSelectedNodes);

        return false;

    },

    ""down"": node => {

        node.navigate($.ui.keyCode.DOWN, true).then(treeService.clearSelectedNodes);

        return false;

    },

    ""ctrl+shift+s"": node => {

        searchNoteService.searchInSubtree(node.data.noteId);

        return false;

};

export default keyBindings;
","    ""SearchInSubtree"": node => {

        searchNoteService.searchInSubtree(node.data.noteId);

    }

};

async function getKeyboardBindings() {

    const bindings = Object.assign({}, fixedKeyBindings);

    for (const actionName in templates) {

        const action = await keyboardActionService.getAction(actionName);

        for (const shortcut of action.effectiveShortcuts || []) {

            bindings[shortcut] = templates[actionName];

        }

    return bindings;

}



export default {

    getKeyboardBindings

};
","async function onKeyDown(node) {
    switch (event.keyCode) {
        case $.ui.keyCode.LEFT:
            node.navigate($.ui.keyCode.LEFT, true).then(treeService.clearSelectedNodes);
            return false;
        case $.ui.keyCode.RIGHT:
            node.navigate($.ui.keyCode.RIGHT, true).then(treeService.clearSelectedNodes);
            return false;
        case $.ui.keyCode.UP:
            node.navigate($.ui.keyCode.UP, true).then(treeService.clearSelectedNodes);
            return false;
        case $.ui.keyCode.DOWN:
            node.navigate($.ui.keyCode.DOWN, true).then(treeService.clearSelectedNodes);
            return false;
        default:
            return false;
    }
}",0.18933645670545074,0.029381587909812094,0.03993005087780278,0.41025641025641024,0.2777777777777778,0.3818941174601377,0.054342930850307884,0.09716516292186672,0.6538461538461539,0.7222222222222222,0.09929455023805533,0.010989617271900691,0.011729709221446227,0.13636363636363635,0.23809523809523808
392,"        server.put('options', opts).then(() => {

            toastService.showPersistent({

                id: ""options-change-saved"",

                title: ""Options status"",

                message: ""Options change have been saved."",

                icon: ""slider"",

                closeAfter: 2000

            })
","

        await this.updateMultipleOptions(opts);

    }



    async updateMultipleOptions(opts) {

        await server.put('options', opts);



        this.showUpdateNotification();

    }



    showUpdateNotification() {

        toastService.showPersistent({

            id: ""options-change-saved"",

            title: ""Options status"",

            message: ""Options change have been saved."",

            icon: ""slider"",

            closeAfter: 2000



    async updateCheckboxOption(name, $checkbox) {

        const isChecked = $checkbox.prop(""checked"");



        return await this.updateOption(name, isChecked ? 'true' : 'false');

    }



    setCheckboxState($checkbox, optionValue) {

        $checkbox.prop('checked', optionValue === 'true');

    }
","async function putOptions(opts) {
  try {
    await server.put('options', opts);
    toastService.showPersistent({
      id: ""options-change-saved"",
      title: ""Options status"",
      message: ""Options change have been saved."",
      icon: ""slider"",
      closeAfter: 2000,
    });
  } catch (err) {
    console.error(err);
  }
}",0.6808388964661379,0.29877355754377805,0.8055344092731546,0.6190476190476191,0.0,0.7527800246103986,0.4409493148854155,0.7130279264133219,0.8571428571428571,0.0,0.3225213292261473,0.28523312030155407,0.3100631147171792,0.3870967741935484,0.3076923076923077
393,"import froca from ""../../services/froca.js"";



// FIXME: this widget might not be useful anymore

    targetNote(noteId) {

        froca.getNote(noteId).then(note => {

            if (!note) {

                console.log(`Note ${noteId} has not been found. This might happen on the first run before the target note is created.`);



                if (!this.retried) {

                    this.retried = true;



                    setTimeout(() => this.targetNote(noteId), 15000); // should be higher than timeout for checkHiddenSubtree

                }

                return;

            }

            this.icon(note.getIcon());

            this.title(() => {

                const n = froca.getNoteFromCache(noteId);



                // always fresh, always decoded (when protected session is available)

                return n.title;

            });



            this.refreshIcon();

        });

        this.onClick(() => appContext.tabManager.openTabWithNoteWithHoisting(noteId, true));

        return this;
","import linkContextMenuService from ""../../menus/link_context_menu.js"";

import utils from ""../../services/utils.js"";

    constructor(noteToOpen) {

        super();

        this.noteToOpen = noteToOpen;

        this.title(() => this.noteToOpen.title)

            .icon(() => this.noteToOpen.getIcon())

            .onClick((widget, evt) => this.launch(evt))

            .onAuxClick((widget, evt) => this.launch(evt))

            .onContextMenu(evt => linkContextMenuService.openContextMenu(this.noteToOpen.noteId, null, evt));

    }

    async launch(evt) {

        const ctrlKey = utils.isCtrlKey(evt);

        if ((evt.which === 1 && ctrlKey) || evt.which === 2) {

            await appContext.tabManager.openInNewTab(this.noteToOpen.noteId);

        } else {

            await appContext.tabManager.openInSameTab(this.noteToOpen.noteId);

        }
","import froca from ""../../services/froca.js"";

// FIXME: this widget might not be useful anymore

async function targetNote(noteId) {
  try {
    const note = await froca.getNote(noteId);
    if (!note) {
      console.log(`Note ${noteId} has not been found. This might happen on the first run before the target note is created.`);
      if (!this.retried) {
        this.retried = true;
        setTimeout(() => this.targetNote(noteId), 15000); // should be higher than timeout for checkHiddenSubtree
      }
      return;
    }
    this.icon(note.getIcon());
    this.title(() => {
      const n = froca.getNoteFromCache(noteId);
      // always fresh, always decoded (when protected session is available)
      return n.title;
    });
    this.refreshIcon();
  } catch (error) {
    console.error(error);
  }
}
this.onClick(() => appContext.tabManager.openTabWithNoteWithHoisting(noteId, true));
return this;",0.29854761291089793,0.007918555418309605,0.009066013872341083,0.4125,0.7647058823529411,0.8375012580985449,0.79980305327716,0.9104960967640786,0.875,0.7647058823529411,0.23017704178425386,0.007812800129140889,0.014210688728457568,0.38144329896907214,0.5172413793103449
394,"var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {

    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }

    return new (P || (P = Promise))(function (resolve, reject) {

        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }

        function rejected(value) { try { step(generator[""throw""](value)); } catch (e) { reject(e); } }

        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }

        step((generator = generator.apply(thisArg, _arguments || [])).next());

    });

};

    return function (html) {

        return __awaiter(this, void 0, void 0, function* () {

            const manifestJson = dist_1.parseManifestJsonOnce(process.env.UNI_INPUT_DIR);

            const title = ((_a = manifestJson.h5) === null || _a === void 0 ? void 0 : _a.title) || manifestJson.name || '';

            return html.replace(/<title>(.*?)<\/title>/, `<title>${title}</title>`);

        });
","    return async function (html) {

        const manifestJson = dist_1.parseManifestJsonOnce(process.env.UNI_INPUT_DIR);

        const title = ((_a = manifestJson.h5) === null || _a === void 0 ? void 0 : _a.title) || manifestJson.name || '';

        return html.replace(/<title>(.*?)<\/title>/, `<title>${title}</title>`);
","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator[""throw""](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
return function (html) {
  return __awaiter(this, void 0, void 0, function* () {
    const manifestJson = dist_1.parseManifestJsonOnce(process.env.UNI_INPUT_DIR);
    const title = ((_a = manifestJson.h5) === null || _a === void 0 ? void 0 : _a.title) || manifestJson.name || """";
    return html.replace(/<title>(.*?)<\/title>/, `<title>${title}</title>`);
  });
};",0.19919379833323025,0.059753049578435434,0.24318156404434066,0.3188405797101449,0.175,0.8468752104885623,0.827788501222667,0.8329007465286836,0.8768115942028986,0.85,0.6628560831349664,0.24927045746242307,0.8465983195218867,0.8888888888888888,0.6666666666666666
395,"var __async = (__this, __arguments, generator) => {

  return new Promise((resolve, reject) => {

    var fulfilled = (value) => {

      try {

        step(generator.next(value));

      } catch (e2) {

        reject(e2);

      }

    };

    var rejected = (value) => {

      try {

        step(generator.throw(value));

      } catch (e2) {

        reject(e2);

      }

    };

    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);

    step((generator = generator.apply(__this, __arguments)).next());

  });

};

  (_0, _1) => __async(void 0, [_0, _1], function* (_, { resolve, reject }) {

      const data = yield navigator.clipboard.readText();

  })

  (_0, _1) => __async(void 0, [_0, _1], function* ({ data }, { resolve, reject }) {

      yield navigator.clipboard.writeText(data);

  }),
","  async (_, { resolve, reject }) => {

      const data = await navigator.clipboard.readText();

  }

  async ({ data }, { resolve, reject }) => {

      await navigator.clipboard.writeText(data);

  },
","async function _0(_0, _1) {
  const data = await navigator.clipboard.readText();
}

async function _1(_0, _1) {
  await navigator.clipboard.writeText(data);
}",0.11456158432001666,0.03008897153774735,0.11539084122206344,0.22321428571428573,0.08955223880597014,0.09385002131732013,0.002068026376208119,0.027649756121217433,0.19642857142857142,0.14925373134328357,0.44999790269008993,0.29468861860321305,0.3338744207285755,0.6,0.5714285714285714
396,"exports.mssqlQuery = function (connectionString, query) {

    return new Promise((resolve, reject) => {

        mssql.connect(connectionString).then(pool => {

            return pool.request()

                .query(query);

        }).then(result => {

            resolve(result);

        }).catch(err => {

            reject(err);

        }).finally(() => {

            mssql.close();

        });

    });
","exports.mssqlQuery = async function (connectionString, query) {

    let pool;

    try {

        pool = new mssql.ConnectionPool(connectionString);

        await pool.connect();

        await pool.request().query(query);

        pool.close();

    } catch (e) {

        if (pool) {

            pool.close();

        }

        throw e;

    }
","exports.mssqlQuery = async (connectionString, query) => {
    try {
      const pool = await mssql.connect(connectionString);
      const result = await pool.request().query(query);
      return result;
    } catch (err) {
      throw err;
    } finally {
      mssql.close();
    }
  };",0.2643759182908306,0.09812163258584557,0.10269754859886746,0.32727272727272727,0.5294117647058824,0.29053105252937905,0.025871788510887346,0.026091993799142305,0.34545454545454546,0.7647058823529411,0.31338081756330344,0.06144623708746547,0.06250892685345599,0.5581395348837209,0.5714285714285714
397,"const { warn, error } = require('./util/log')

program

  .usage('<app-name>')

  .parse(process.argv)



const projectName = program.args[0]

if (!projectName) {

  warn(`\n  Please provide an app name.`)

  program.outputHelp()

  process.exit(1)

}

const createGenerator = (id, requirePath = id) => ({

  id,

  apply: require(requirePath)

})

const builtInGenerators = fs

  .readdirSync(path.resolve(__dirname, './generators'))

  .filter(dir => dir.charAt(0) !== '.')

  .map(id => createGenerator(id, `./generators/${id}`))

debug(builtInGenerators)

const installedGenerators = resolveInstalledGenerators().map(id => {

  return createGenerator(id)

})

const targetDir = path.resolve(process.cwd(), projectName)

const creator = new Creator(projectName, builtInGenerators.concat(installedGenerators))

creator

  .create(targetDir)

  .then(() => {

    // TODO: log instructions

  })

  .catch(error)
","const chalk = require('chalk')

const rimraf = require('rimraf')

const inquirer = require('inquirer')

const { warn, error } = require('@vue/cli-shared-utils')

async function run () {

  program

    .usage('<app-name>')

    .parse(process.argv)



  const projectName = program.args[0]

  if (!projectName) {

    warn(`\n  Please provide an app name.`)

    program.outputHelp()

    process.exit(1)

  }



  const targetDir = path.resolve(process.cwd(), projectName)

  if (fs.existsSync(targetDir)) {

    const { overwrite } = await inquirer.prompt([

      {

        name: 'overwrite',

        type: 'confirm',

        message: `Target directory ${chalk.cyan(targetDir)} already exists.\n  Overwrite?`

      }

    ])

    if (overwrite) {

      rimraf.sync(targetDir)

    } else {

      return

    }

  }



  const createGenerator = (id, requirePath = id) => ({

    id,

    apply: require(requirePath)

  })

  const builtInGenerators = fs

    .readdirSync(path.resolve(__dirname, './generators'))

    .filter(dir => dir.charAt(0) !== '.')

    .map(id => createGenerator(id, `./generators/${id}`))

  debug(builtInGenerators)

  const installedGenerators = resolveInstalledGenerators().map(id => {

    return createGenerator(id)

  })

  const creator = new Creator(projectName, builtInGenerators.concat(installedGenerators))

  await creator.create(targetDir)

}

run().catch(error)
","const { warn, error } = require('./util/log')

async function main() {

  const projectName = program.args[0]

  if (!projectName) {

    warn(`\n  Please provide an app name.`)

    program.outputHelp()

    process.exit(1)

  }

  const builtInGenerators = fs

    .readdirSync(path.resolve(__dirname, './generators'))

    .filter(dir => dir.charAt(0) !== '.')

    .map(id => createGenerator(id, `./generators/${id}`))

  debug(builtInGenerators)

  const installedGenerators = resolveInstalledGenerators().map(id => {

    return createGenerator(id)

  })

  const targetDir = path.resolve(process.cwd(), projectName)

  const creator = new Creator(projectName, builtInGenerators.concat(installedGenerators))

  try {

    await creator.create(targetDir)

    // TODO: log instructions

  } catch (error) {

    error(`Error occurred while creating the project`, error)

  }
}",0.6841815931706909,0.5337155272116247,0.8209542547188962,0.9217391304347826,0.4603174603174603,0.6741598631005358,0.6845043958899171,0.6955028964018051,0.808695652173913,0.5079365079365079,0.4457751192858487,0.38427653640292836,0.4266373219247781,0.7168674698795181,0.2553191489361702
398,"  const chalk = require('chalk')



  function run (command, args, rawArgs) {

    removeArg(rawArgs, 'url')

    removeArg(rawArgs, 'mode')



    const serverPromise = args.url

      ? Promise.resolve({ url: args.url })

      : api.service.run('serve')



    return serverPromise.then(({ url, server }) => {

      const { info } = require('@vue/cli-shared-utils')

      info(`Starting e2e tests...`)



      const cyArgs = [

        command, // open or run

        '--config', `baseUrl=${url}`,

        ...rawArgs

      ]



      const execa = require('execa')

      const cypressBinPath = require.resolve('cypress/bin/cypress')

      const runner = execa(cypressBinPath, cyArgs, { stdio: 'inherit' })

      if (server) {

        runner.on('exit', () => server.close())

        runner.on('error', () => server.close())

      }



      if (process.env.VUE_CLI_TEST) {

        runner.on('exit', code => {

          process.exit(code)

        })

      }



      return runner

    })

  }



  const commandOptions = {

    '--mode': 'specify the mode the dev server should run in. (default: production)',

    '--url': 'run e2e tests against given url instead of auto-starting dev server'

  }



  api.registerCommand('e2e', {

    description: 'run e2e tests headlessly with `cypress run`',

    usage: 'vue-cli-service e2e [options]',

    options: Object.assign({

      '-s, --spec': 'runs a specific spec file. defaults to ""all""'

    }, commandOptions),

  }, (args, rawArgs) => run('run', args, rawArgs))

  api.registerCommand('e2e:open', {

    description: 'run e2e tests in interactive mode with `cypress open`',

    usage: 'vue-cli-service e2e:open [options]',

    options: commandOptions,

    details:

      `All Cypress CLI options are supported:\n` +

      chalk.yellow(`https://docs.cypress.io/guides/guides/command-line.html#cypress-open`)

  }, (args, rawArgs) => run('open', args, rawArgs))

  e2e: 'production',

  'e2e:open': 'production'
","  api.registerCommand('test:e2e', {

    description: 'run e2e tests with Cypress',

    usage: 'vue-cli-service test:e2e [options]',

    options: {

      '--headless': 'run in headless mode without GUI',

      '--mode': 'specify the mode the dev server should run in. (default: production)',

      '--url': 'run e2e tests against given url instead of auto-starting dev server',

      '-s, --spec': '(headless only) runs a specific spec file. defaults to ""all""'

    },

  }, async (args, rawArgs) => {

    removeArg(rawArgs, 'headless')

    removeArg(rawArgs, 'mode')

    removeArg(rawArgs, 'url')

    const { info } = require('@vue/cli-shared-utils')

    info(`Starting e2e tests...`)



    const { url, server } = args.url

      ? { url: args.url }

      : await api.service.run('serve')



    const cyArgs = [

      args.headless ? 'run' : 'open', // open or run

      '--config', `baseUrl=${url}`,

      ...rawArgs

    ]



    const execa = require('execa')

    const cypressBinPath = require.resolve('cypress/bin/cypress')

    const runner = execa(cypressBinPath, cyArgs, { stdio: 'inherit' })

    if (server) {

      runner.on('exit', () => server.close())

      runner.on('error', () => server.close())

    }



    if (process.env.VUE_CLI_TEST) {

      runner.on('exit', code => {

        process.exit(code)

      })

    }



    return runner

  })

  'test:e2e': 'production'
","const chalk = require('chalk');

async function run(command, args, rawArgs) {
  removeArg(rawArgs, 'url');
  removeArg(rawArgs, 'mode');
  let serverPromise;
  if (args.url) {
    serverPromise = Promise.resolve({ url: args.url });
  } else {
    serverPromise = api.service.run('serve');
  }
  const { info } = require('@vue/cli-shared-utils');
  try {
    const { url, server } = await serverPromise;
    info(`Starting e2e tests...`);
    const cyArgs = [
      command, // open or run
      '--config', `baseUrl=${url}`,
      ...rawArgs
    ];
    const execa = require('execa');
    const cypressBinPath = require.resolve('cypress/bin/cypress');
    const runner = execa(cypressBinPath, cyArgs, { stdio: 'inherit' });
    if (server) {
      runner.on('exit', () => server.close());
      runner.on('error', () => server.close());
    }
    if (process.env.VUE_CLI_TEST) {
      runner.on('exit', code => {
        process.exit(code);
      });
    }
    return runner;
  } catch (err) {
    console.error(`Error: ${err}`);
  }
}

const commandOptions = {
  '--mode': 'specify the mode the dev server should run in. (default: production)',
  '--url': 'run e2e tests against given url instead of auto-starting dev server'
};

api.registerCommand('e2e', {
  description: 'run e2e tests headlessly with `cypress run`',
  usage: 'vue-cli-service e2e [options]',
  options: Object.assign({
    '-s, --spec': 'runs a specific spec file. defaults to ""all""'
  }, commandOptions),
}, async (args, rawArgs) => {
  return await run('run', args, rawArgs);
});

api.registerCommand('e2e:open', {
  description: 'run e2e tests in interactive mode with `cypress open`',
  usage: 'vue-cli-service e2e:open [options]',
  options: commandOptions,
  details:
    `All Cypress CLI options are supported:\n` +
    chalk.yellow(`https://docs.cypress.io/guides/guides/command-line.html#cypress-open`)
}, async (args, rawArgs) => {
  return await run('open', args, rawArgs);
});",0.5223090789399578,0.4974572677049496,0.5141966304724642,0.7314285714285714,0.34615384615384615,0.688290582364499,0.5943021468179414,0.6677979115777837,0.8628571428571429,0.6282051282051282,0.5513276729994465,0.354263093622089,0.5160495192362424,0.8613138686131386,0.47368421052631576
399,"function list (base, context) {

  return new Promise((resolve, reject) => {

    fs.readdir(base, 'utf8', (err, files) => {

      if (err) {

        reject(err)

      } else {

        resolve(files.map(

          file => ({

            path: path.join(base, file),

            name: file

          })

        ).filter(

          file => fs.statSync(file.path).isDirectory()

        ))

      }

  })
","async function list (base, context) {

  const files = await fs.readdir(base, 'utf8')

  return files.map(

    file => ({

      path: path.join(base, file),

      name: file

  ).filter(

    file => fs.statSync(file.path).isDirectory()

  )
","async function list(base, context) {
    try {
        const files = await fs.readdir(base, 'utf8');
        return files.map((file) => ({ path: path.join(base, file), name: file }))
            .filter((file) => fs.statSync(file.path).isDirectory());
    } catch (err) {
        throw err;
    }
}",0.4005072887844834,0.2890874612665027,0.30969494062467756,0.4318181818181818,0.5714285714285714,0.372238202816402,0.18357283706672226,0.18416785298676466,0.45454545454545453,0.6666666666666666,0.6262276171786891,0.3392446203391626,0.4513801340898795,0.7142857142857143,1.0
400,"function deleteFolder (file) {

  return new Promise((resolve, reject) => {

    rimraf(file, err => {

      if (err) {

        reject(err)

      } else {

        resolve()

      }

    })

  })
","async function deleteFolder (file) {

  await fs.remove(file)
","async function deleteFolder (file) {

  try {

    await rimraf(file);

  } catch (err) {

    throw err;

  }

}",0.1061317341529644,0.03142141579679162,0.09680922451876967,0.07407407407407407,0.2222222222222222,0.19767621671415997,0.11769613478633797,0.11745317651474643,0.1111111111111111,0.4444444444444444,0.5329863968398892,0.23693055763743093,0.6950150297221261,0.2,1.0
