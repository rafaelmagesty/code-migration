removed_chunk,migrated_code,commit_date,commit_hash
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.INK);

        expect(data.inkLists.length).toEqual(1);

        expect(data.inkLists[0]).toEqual([

          { x: 1, y: 1 },

          { x: 1, y: 2 },

          { x: 2, y: 2 },

          { x: 3, y: 3 },

        ]);

        done();

      }, done.fail);

    it(""should handle multiple ink lists"", function (done) {
","it(""should handle multiple ink lists"", function (done) {
  const createAnnotatedObject = async (data) => {
    try {
      expect(data.annotationType).toEqual(AnnotationType.INK);
      expect(data.inkLists.length).toEqual(1);
      expect(data.inkLists[0]).toEqual([
        { x: 1, y: 1 },
        { x: 1, y: 2 },
        { x: 2, y: 2 },
        { x: 3, y: 3 }
      ]);
    } catch (error) {
      // Handle error
    };
  };

  await createAnnotatedObject(data);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data, viewable }) => {

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

        done();

      }, done.fail);

    it(""should handle missing parent properties"", function (done) {
","AnnotationFactory.create().await
          .then(({ data, viewable }) => {
            expect(data.annotationType).toEqual(AnnotationType.POPUP);
            expect(data.modificationDate).toEqual(""D:20190423"");
            expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
          })
      ).catch(() => done.fail);
    it(""should handle missing parent properties"", function (done) {",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"	provideCompletionItems(model: monaco.editor.IReadOnlyModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Thenable<monaco.languages.CompletionList> {

		const offset = this._positionToOffset(resource, position);

		return this._worker(resource).then(worker => {

			return worker.getCompletionsAtPosition(resource.toString(), offset);

		}).then(info => {

			if (!info) {

				return;

			}

			let suggestions: MyCompletionItem[] = info.entries.map(entry => {

				let range = wordRange;

				if (entry.replacementSpan) {

					const p1 = model.getPositionAt(entry.replacementSpan.start);

					const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);

					range = new Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);

				}

				return {

					uri: resource,

					position: position,

					range: range,

					label: entry.name,

					insertText: entry.name,

					sortText: entry.sortText,

					kind: SuggestAdapter.convertKind(entry.kind)

				};

			});

				suggestions

	resolveCompletionItem(_model: monaco.editor.IReadOnlyModel, _position: Position, item: monaco.languages.CompletionItem, token: CancellationToken): Thenable<monaco.languages.CompletionItem> {

		let myItem = <MyCompletionItem>item;

		return this._worker(resource).then(worker => {

			return worker.getCompletionEntryDetails(resource.toString(),

				this._positionToOffset(resource, position),

				myItem.label);



		}).then(details => {

			if (!details) {

				return myItem;

			return <MyCompletionItem>{

				uri: resource,

				position: position,

				label: details.name,

				kind: SuggestAdapter.convertKind(details.kind),

				detail: displayPartsToString(details.displayParts),

				documentation: {

					value: displayPartsToString(details.documentation)

				}

			};

		});
","provideCompletionItems(model: monaco.editor.IReadOnlyModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Thenable<monaco.languages.CompletionList> {
		const offset = this._positionToOffset(resource, position);

		return (
			await this._worker(resource)
			 .getCompletionsAtPosition(resource.toString(), offset)
		).then(info => {
			if (!info) {
				return;
			}
			let suggestions: MyCompletionItem[] = info.entries.map(entry => ({
				uri: resource,
				position: position,
				range: entry.replacementSpan ? new Range(
					model.getPositionAt(entry.replacementSpan.start),
					model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length)
				) : null,
				label: entry.name,
				insertText: entry.name,
				sortText: entry.sortText,
				kind: SuggestAdapter.convertKind(entry.kind)
			}));
			return suggestions;
		});
	}

	resolveCompletionItem(_model: monaco.editor.IReadOnlyModel, _position: Position, item: monaco.languages.CompletionItem, token: CancellationToken): Thenable<monaco.languages.CompletionItem> {
		let myItem = <MyCompletionItem>item;

		return (
			await this._worker(resource)
			 .getCompletionEntryDetails(
					resource.toString(),
					this._positionToOffset(resource, position),
					myItem.label
			 )
		).then(details => {
			if (!details) {
				return myItem;
			}
			return <MyCompletionItem>(
				uri: resource,
				position: position,
				label: details.name,
				kind: SuggestAdapter.convertKind(details.kind),
				detail: displayPartsToString(details.displayParts),
				documentation: {
					value: displayPartsToString(details.documentation)
				}
			);
		});
	}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.stateModel).toBeNull();

        expect(data.state).toBeNull();

        done();

      }, done.fail);

    it(""should correctly parse state model and state when defined"", function (done) {
","async function() {
      await AnnotationFactory.create()
        .then(({ data }) => {
          expect(data.stateModel).toBeNull();
          expect(data.state).toBeNull();
        });
    }

    it(""should correctly parse state model and state when defined"", done);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"render(process.argv[2] || '/')

  .then(html => console.log(html))

  .catch((err) => {

    console.error(err)

    process.exit(1)

  })
","async function renderHTML(argv2) {
  const defaultargv2 = '/';
  if (argv2 === undefined) {
    argv2 = defaultargv2;
  }
  
  await render(argv2);
}
  
await renderHTML(process.argv[2]);",2020-11-03 21:26:27+01:00,d441d79c6ca3eb3c0f64bba1217375e6505401c0
"      ModelA.create({ name: 'model-A' }, function(error, toyA) {

        assert.ifError(error);

        ModelB.create({ name: 'model-B' }, function(error, toyB) {

          assert.ifError(error);

          Parent.create({

            children: [

              {

                name: 'Child 1',

                toy: { kind: 'Test1', value: toyA._id }

              },

              {

                name: 'Child 2'

              },

              {

                name: 'Child 3',

                toy: { kind: 'Test2', value: toyB._id }

              }

            ]

          }, function(error, doc) {

            assert.ifError(error);

            test(doc._id);

          });

        });

      function test(id) {

        Parent.findById(id, function(error, doc) {

          assert.ifError(error);

          doc.populate('children.toy.value').then(function(doc) {

            assert.equal(doc.children[0].toy.value.name, 'model-A');

            assert.equal(doc.children[1].toy.value, null);

            assert.equal(doc.children[2].toy.value.name, 'model-B');

            done();

          }).catch(done);

        });

      }
","async ModelAcreate = async () => {
        const { name: nameA } = await ModelA.create({ name: 'model-A' });

        assert.ifError(nameA);

        const { name: nameB } = await ModelB.create({ name: 'model-B' });

        assert.ifError(nameB);

        Parent.create({
          children: [
            {
              name: 'Child 1',
              toy: { kind: 'Test1', value: nameA._id }
            },
            {
              name: 'Child 2'
            },
            {
              name: 'Child 3',
              toy: { kind: 'Test2', value: nameB._id }
            }
          ]
        }, function(error, doc) {
          assert.ifError(error);
          test(doc._id);
        });
      };

      async test = (id) => {
        Parent.findById(id, function(error, doc) {
          assert.ifError(error);
          const { children } = doc;
          
          await children.toy.value.forEach(async fn => {
            try {
              fn();
            } catch (err) {
                if ('done' in err) {
                  throw err.done;
                }
              }
            });
          });

          assert.equal(children[0].toy.value.name, 'model-A');
          assert.equal(children[1].toy.value, null);
          assert.equal(children[2].toy.value.name, 'model-B');
        });
      };",2023-02-08 14:49:02-05:00,55c53d0c813f88d9e7a1d45e95a2b62b3dd7fdf9
"        libraryLoader.requireLibrary(libraryLoader.SORTABLE).then(() => {

            new Sortable(this.$widgetsEnabled[0], {

                group: 'widgets',

                handle: '.handle',

                animation: 150

            });

            new Sortable(this.$widgetsDisabled[0], {

                group: 'widgets',

                handle: '.handle',

                animation: 150
","const loadSortedLibraries = async () => {
            const libraryResult = await libraryLoader.requireLibrary(libraryLoader.SORTABLE);
            
            if (libraryResult) {
                await createSortedLibraries(libraryResult, libraryLoader.SORTABLE);
            }
        };

        async function createSortedLibraries(result, sortBy) {
            const [sortedEnabled, sortedDisabled] = await Promise.all([
                new Promise((_, reject) => {
                    loadPromise(
                        libraryLoader.SORTABLE,
                        (err, value) => {
                            if (err) {
                                sortedEnabled = err;
                            } else {
                                sortedEnabled = value
                                    .then(v => v[0])
                                    .then(widgets => 
                                        new Sortable(widgets, {
                                            group: 'widgets',
                                            handle: '.handle',
                                            animation: 150
                                        })
                                    );
                            }
                        }
                    });
                }),
                new Promise((_, reject) => {
                    loadPromise(
                        libraryLoader.SORTABLE,
                        (err, value) => {
                            if (err) {
                                sortedDisabled = err;
                            } else {
                                sortedDisabled = value
                                    .then(v => v[1])
                                    .then(widgets => 
                                        new Sortable(widgets, {
                                            group: 'widgets',
                                            handle: '.handle',
                                            animation: 150
                                        })
                                    );
                            }
                        }
                    });
                })
            ];

            if (sortedEnabled) sortedEnabled.destroy();
            if (sortedDisabled) sortedDisabled.destroy();
        };",2019-08-22 22:14:01+02:00,b84542064cd4d0615f298f9f9ef68690c8fe92a6
"module.exports = (req, res) => {

  const start = process.hrtime()

  render(req.url).then((html) => {

    const end = process.hrtime(start)

    const time = ((end[0] * 1e9) + end[1]) / 1e6

    // @ts-ignore

    res.setHeader('X-Nuxt-Coldstart', global._coldstart + 'ms')

    res.setHeader('X-Nuxt-Responsetime', time + 'ms')



  }).catch((err) => {

    console.error(err)

    res.end('Error: ' + err)

  })
","module.exports = (req, res) => {
  const start = process.hrtime();

  const async renderResult = render(req.url);

  try {
    const end = process.hrtime(start);
    const time = ((end[0] * 1e9) + end[1]) / 1e6;

    res.setHeader('X-Nuxt-Coldstart', global._coldstart + 'ms');
    res.setHeader('X-Nuxt-Responsetime', time + 'ms');
  } catch (err) {
    console.error(err);
    res.end(`Error: ${err}`);
  }
};",2020-11-03 21:26:27+01:00,d441d79c6ca3eb3c0f64bba1217375e6505401c0
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual([

          { num: 17, gen: 0 },

          { name: ""XYZ"" },

          0,

          841.89,

          null,

        ]);

        done();

      }, done.fail);

      function (done) {
","const handleAnnotationFactoryOutput = async () => {
        await AnnotationFactory.create();

        let data;
        try {
          // ... existing processing of data ...
        } catch (error) {
          expect(error).fail();
        }
      };
      return handleAnnotationFactoryOutput;
      //...",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"  getPageDict(pageIndex) {

    const capability = createPromiseCapability();

    function next() {

      while (nodesToVisit.length) {

        const currentNode = nodesToVisit.pop();

        if (isRef(currentNode)) {

          count = pageKidsCountCache.get(currentNode);

          // Skip nodes where the page can't be.

          if (count > 0 && currentPageIndex + count < pageIndex) {

            currentPageIndex += count;

            continue;

          }

          xref.fetchAsync(currentNode).then(function(obj) {

            if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {

              if (pageIndex === currentPageIndex) {

                // Cache the Page reference, since it can *greatly* improve

                // performance by reducing redundant lookups in long documents

                // where all nodes are found at *one* level of the tree.

                if (currentNode && !pageKidsCountCache.has(currentNode)) {

                  pageKidsCountCache.put(currentNode, 1);

                }

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            nodesToVisit.push(obj);

            next();

          }, capability.reject);

          return;

        // Must be a child page dictionary.

        if (!isDict(currentNode)) {

          capability.reject(new FormatError(

            'Page dictionary kid reference points to wrong type of object.'));

          return;

        }

        count = currentNode.get('Count');

        if (Number.isInteger(count) && count >= 0) {

          // Cache the Kids count, since it can reduce redundant lookups in

          // documents where all nodes are found at *one* level of the tree.

          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {

            pageKidsCountCache.put(objId, count);

          }

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

        const kids = currentNode.get('Kids');

        if (!Array.isArray(kids)) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          if (isName(currentNode.get('Type'), 'Page') ||

              (!currentNode.has('Type') && currentNode.has('Contents'))) {

            if (currentPageIndex === pageIndex) {

              capability.resolve([currentNode, null]);

              return;

            }

            currentPageIndex++;

            continue;



          capability.reject(new FormatError(

            'Page dictionary kids object is not an array.'));

          return;

        // Always check all `Kids` nodes, to avoid getting stuck in an empty

        // node further down in the tree (see issue5644.pdf, issue8088.pdf),

        // and to ensure that we actually find the correct `Page` dict.

        for (let last = kids.length - 1; last >= 0; last--) {

          nodesToVisit.push(kids[last]);

        }

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;
","{
  ""next"": function() {
    while (nodesToVisit.length) {
      const currentNode = nodesToVisit.pop();

      if (isRef(currentNode)) {
        count = pageKidsCountCache.get(currentNode);
        
        if (count && currentPageIndex + count < pageIndex) {
          currentPageIndex += count;
          continue;
        }

        xref.fetchAsync(currentNode).then(function(obj) {
          if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {
            if (pageIndex === currentPageIndex) {
              const cached = pageKidsCountCache.get(currentNode);
              if (cached !== null) {
                capability.resolve([obj, currentNode]);
              } else {
                pageKidsCountCache.set(currentNode, 1);
                capability.resolve([obj, currentNode]);
              }
            } else {
              currentPageIndex++;
              next();
            }

            return;
          }
          
          nodesToVisit.push(obj);
          next();
        }, capability.reject);
        
        return;
      }

      if (!isDict(currentNode)) {
        capability.reject(new FormatError('Page dictionary kid reference points to wrong type of object.'));
        return;
      }

      count = currentNode.get('Count');
      
      if (Number.isInteger(count) && count >= 0) {
        const objId = currentNode.objId;
        pageKidsCountCache.set(objId, count);
        
        if (currentPageIndex + count <= pageIndex) {
          currentPageIndex += count;
          continue;
        }
      }

      kids = currentNode.get('Kids');

      if (!Array.isArray(kids)) {
        if (isName(currentNode.get('Type'), 'Page') || (!currentNode.has('Type') && currentNode.has('Contents'))) {
          if (currentPageIndex === pageIndex) {
            capability.resolve([currentNode, null]);
            return;
          }
          currentPageIndex++;
          continue;
        }

        capability.reject(new FormatError('Page dictionary kids object is not an array.'));
        return;
      }

      for (let last = kids.length - 1; last >= 0; last--) {
        nodesToVisit.push(kids[last]);
      }
      
      capability.reject(new Error(`Page index ${pageIndex} not found.));
    }
    
    return capability.promise;
  },

  async function getPageDict(pageIndex) {
    const capability = createPromiseCapability();

    await xref.fetchAsync(initialNode);
    
    if (isDict(initialNode) && !initialNode.has('Kids')) {
      pageKidsCountCache.set(initialNode, 1);
      
      if (currentPageIndex >= pageIndex) {
        return pageKidsCountCache.get(initialNode);
      }

      const kids = initialNode.get('Kids');
      
      if (!Array.isArray(kids)) {
        capability.reject(new FormatError(`Initial node is not an array: ${initialNode}`));
        return null;
      }
      
      for (let i = 0; i < kids.length; ++i) {
        await processKids(currentNode, kids[i]);
      }

      return pageKidsCountCache.get(initialNode);
    }

    const result = await capability.promise;

    if (result === null || result === '') {
      throw new Error(`Could not get page index ${pageIndex} from PDF document.`);
    }
    
    return result;
  },
}",2019-11-04 16:02:08+01:00,0d89006bf16b7262fe6aceb35557a9b54e3ec396
"  return hashPassword(newPlaintextPassword).then(hash => {

    const update = {

      $unset: {

        'services.password.reset': 1

      },

      $set: {'services.password.bcrypt': hash}

    };

    if (options.logout) {

      update.$unset['services.resume.loginTokens'] = 1;

    }

    Meteor.users.update({_id: user._id}, update);

  });
","const hashedPassword = await hashPassword(newPlaintextPassword);

const update = {
  $unset: {
    'services.password.reset': 1
  },
  $set: {'services.password.bcrypt': hashedPassword}
};

if (options.logout) {
  update.$unset['services.resume.loginTokens'] = 1;
}

await Meteor.users.update({_id: user._id}, update);",2022-08-26 15:53:40-03:00,d08790778a984e28ac73d81a5f42cd366b82ceb0
" * @template {Options} Opts

 * @param {Opts} opts

 * @return {Opts[""sync""] extends true ? SyncExplorer : Explorer}

function getExplorer(opts) {

  // Normalize opts before passing to a memoized function

  opts = { sync: false, cache: false, ...opts };

  return getExplorerMemoized(opts);

function _resolveConfig(filePath, opts, sync) {

    sync: Boolean(sync),

  /** @type {[any, any]} */

  const arr = [

  ];



  const unwrapAndMerge = ([result, editorConfigured]) => {

    const merged = {

      ...editorConfigured,

      ...mergeOverrides(result, filePath),

    };



    for (const optionName of [""plugins"", ""pluginSearchDirs""]) {

      if (Array.isArray(merged[optionName])) {

        merged[optionName] = merged[optionName].map((value) =>

          typeof value === ""string"" && value.startsWith(""."") // relative path

            ? path.resolve(path.dirname(result.filepath), value)

            : value

        );

      }

    }



    if (!result && !editorConfigured) {

      return null;

    }

    // We are not using this option

    delete merged.insertFinalNewline;

    return merged;

  if (loadOpts.sync) {

    return unwrapAndMerge(arr);

  return Promise.all(arr).then(unwrapAndMerge);

}



const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);

resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);
","const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);

const resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);",2022-05-05 19:15:08+08:00,34fadbe67d13df908023fb9a047eee1e90734aec
"  it('eachAsync() with parallel > numDocs (gh-8422)', function() {

    return co(function*() {

      yield Movie.deleteMany({});

      yield Movie.create([

        { name: 'Kickboxer' },

        { name: 'Ip Man' },

        { name: 'Enter the Dragon' }

      ]);

      let numDone = 0;

      const test = co.wrap(function*() {

        yield new Promise((resolve) => setTimeout(resolve, 100));

        ++numDone;

      });

      yield Movie.find().cursor().eachAsync(test, { parallel: 4 });

      assert.equal(numDone, 3);

    });

  it('eachAsync() with sort, parallel, and sync function (gh-8557)', function() {

    return co(function*() {

      yield User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);

      const cursor = User.aggregate([{ $sort: { order: 1 } }]).

        cursor();

      const docs = [];

      yield cursor.eachAsync((doc) => docs.push(doc), { parallel: 3 });

      assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);

    });
","it('eachAsync() with parallel > numDocs (gh-8422)', function*() {
  const test = async () => {
    await new Promise((resolve) => setTimeout(resolve, 100));
    return +true;
  };

  yield Movie.deleteMany({});

  yield Movie.create([{
    name: 'Kickboxer'
  }, {
    name: 'Ip Man'
  }, {
    name: 'Enter the Dragon'
  }]);

  let numDone = 0;

  const test2 = async () => {
    await new Promise((resolve) => setTimeout(resolve, 100));
    return +true;
  };

  yield Movie.find().cursor().eachAsync(test2, { parallel: 4 });

  yield Movie.find().cursor().eachAsync(test, { parallel: 4 });

  assert.equal(numDone, 3);
});

it('eachAsync() with sort, parallel, and sync function (gh-8557)', function*() {
  yield User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);

  const cursor = User.aggregate([{ $sort: { order: 1 } }])
    .cursor();

  const docs = [];

  yield cursor
    .eachAsync(async (doc) => {
      docs.push(doc);
    }, { parallel: 3 });

  assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);
});",2021-08-29 23:23:24+02:00,308934210593f11b950528350c8fe82560224d48
"  it('throws a MongooseServerSelectionError on server selection timeout (gh-8451)', function() {

    return mongoose.createConnection(uri, opts).asPromise().then(() => assert.ok(false), err => {

      assert.equal(err.name, 'MongooseServerSelectionError');

    });
","it('throws a MongooseServerSelectionError on server selection timeout (gh-8451)', function() {
  const result = await new Promise((resolve, reject) => {
    try {
      const connection = await mongoose.createConnection(uri, opts);
      // The assert statement is adjusted to correctly check the error name
      if (result.name === 'MongooseServerSelectionError' && result.message.includes('timeout')) {
        resolve(result); 
      } else {
        throw new Error('Expected MongooseServerSelectionError but did not get one');
      }
    } catch (err) {
      if (err instanceof MongooseServerSelectionError && err.message.includes('timeout')) {
        resolve(err);
      } else {
        reject(err);
      }
    } finally {
      resolve();
    }
  });

  // The result handling is adjusted to check the error name directly
  const caughtError = await result;
});

// Ensure that an MongooseServerSelectionError with 'timeout' message is thrown.",2023-02-01 15:02:31-05:00,f0c55f3278fd4aa3633baecfdf2b3776ca6cec4a
"    }).then(done);

  it(""performs a normal search and finds the previous result"", function (done) {

    testSearch({
","it(""performs a normal search and finds the previous result"", function (done) {

    testSearch({",2021-01-12 15:21:19+01:00,6dae2677d5fabe3116065c6ada5e50aec451dcba
"	public provideCodeActions(model: monaco.editor.ITextModel, range: Range, context: monaco.languages.CodeActionContext, token: CancellationToken): Promise<monaco.languages.CodeActionList> {

		return this._worker(resource).then(worker => {

			const start = this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn });

			const end = this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn });



			const formatOptions = FormatHelper._convertOptions(model.getOptions());

			const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);



			return worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions);



		}).then(codeFixes => {

			return codeFixes.filter(fix => {

				// Removes any 'make a new file'-type code fix

				return fix.changes.filter(change => change.isNewFile).length === 0;

			}).map(fix => {

				return this._tsCodeFixActionToMonacoCodeAction(model, context, fix);

			})

		}).then(result => {

			return {

				actions: result,

				dispose: () => { }

			};
","public provideCodeActions(model: monaco.editor.ITextModel, range: Range, context: monaco.languages.CodeActionContext, token: CancellationToken): Promise<monaco.languages.CodeActionList> {

    return async (worker) => {
        const start = this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn });
        const end = this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: endColumn });
        const formatOptions = FormatHelper._convertOptions(model.getOptions());
        const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);

        return worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions)
            .then(codeFixes => {
                return codeFixes.filter(fix => {
                    // Removes any 'make a new file'-type code fix
                    return fix.changes.filter(change => change.isNewFile).length === 0;
                })
                .map(fix => this._tsCodeFixActionToMonacoCodeAction(model, context, fix));
            })
            .then(result => {
                return {
                    actions: result,
                    dispose: () => { }
                };
            });
    };
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        })

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        })

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should render checkboxes for printing using normal appearance"", function (done) {
","AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });

          return async function() {
            const annotationStorage = new Map();
            annotationStorage.set(annotation.data.id, { value: true });
            return Promise.all([
              annotation,
              annotation.getOperatorList(
                partialEvaluator,
                task,
                false,
                annotationStorage
              )
            ]);
          };

        })

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);
          expect(opList.fnArray).toEqual([
            OPS.beginAnnotation,
            OPS.setFillRGBColor,
            OPS.endAnnotation
          ]);
          expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));

          return annotation;
        })

        .then(annotation => {

          const annotationStorage = new Map();
          annotationStorage.set(annotation.data.id, { value: true });
          return annotation.getOperatorList(
            partialEvaluator,
            task,
            false,
            annotationStorage
          );
        })

        .then(opList => {
          expect(opList.argsArray.length).toEqual(3);
          expect(opList.fnArray).toEqual([
            OPS.beginAnnotation,
            OPS.setFillRGBColor,
            OPS.endAnnotation
          ]);
          expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
          await done();
        })

        .catch(done => {
          done.catch((fail) => {
            if (fail) {
              throw new Error(`Error during annotation processing: ${fail.message}`);
            }
          });
        })
    it(""should render checkboxes for printing using normal appearance"", function (done) {
      // ...
    });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""a value"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (a value) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should save choice"", function (done) {
","const factory = new AnnotationFactory()

      async function createAnnotation(
        partialEvaluator,
        task,
        annotationStorage
      ) {
        const annotationStorage = new Map();

        await factory._create(annotation, partialEvaluator, task, annotationStorage);

        return factory._getAppearance(
          partialEvaluator,
          task,
          annotationStorage
        );
      }

      const appearance = await createAnnotation(partialEvaluator, task, annotationStorage);

      if (appearance !== ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +
          "" 2.00 2.00 Td (a value) Tj ET Q EMC"") {
        throw new Error('Appearance does not match expected value');
      }

      done();
    };});
  });
};});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"    it(""should handle unknown text alignment, maximum length and flags"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(null);

        expect(data.maxLen).toEqual(null);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(false);

        expect(data.comb).toEqual(false);

        expect(data.defaultFieldValue).toEqual(""foo"");

        done();

      }, done.fail);

    });



    it(""should not set invalid text alignment, maximum length and flags"", function (done) {
","(it(""should handle unknown text alignment, maximum length and flags"", async (done) {
  AnnotationFactory.create(async ({ data }) {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    
    expect(data.textAlignment).toEqual(null);
    expect(data.maxLen).toEqual(null);
    expect(data.readOnly).toEqual(false);
    expect(data.hidden).toEqual(false);
    expect(data.multiLine).toEqual(false);
    expect(data.comb).toEqual(false);
    expect(data.defaultFieldValue).toEqual(""foo"");
    
    done();
  });
});
(it(""should not set invalid text alignment, maximum length and flags"", async (done) {
})",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        done();

      }, done.fail);

    it(""should parse IRT/RT for a group type"", function (done) {
","const createAnnotatedMessage = async (data, annotations) => {
        await Promise.then((resolve, reject) => {
          if (resolve) {
            return data;
          } else {
            throw new Error(`Annotations failed to create message: ${reject()}`);
          }
        });
      };

    it(""should parse IRT/RT for a group type"", async (done) => {
      describe('createAnnotatedMessage', () => {
        let data = { /* ... */ };
        let annotations = {/* ... */};
        
        const result = await createAnnotatedMessage(data, annotations);
        expect(result.inReplyTo).toEqual(annotationRef.toString());
        expect(result.replyType).toEqual(""R"");
      });
    });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"    it('updateOne()', function(done) {

      BlogPost.create({ title: 'interoperable update as promise' }, function(err) {

        assert.ifError(err);

        const query = BlogPost.updateOne({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });

        query.exec(function(err, res) {

          assert.ifError(err);

          assert.equal(res.matchedCount, 1);

          assert.equal(res.modifiedCount, 1);

          BlogPost.count({ title: 'interoperable update as promise delta' }, function(err, count) {

            assert.ifError(err);

            assert.equal(count, 1);

            done();

          });

        });

      });

    it('findOne()', function(done) {

      BlogPost.create({ title: 'interoperable findOne as promise' }, function(err, created) {

        assert.ifError(err);

        const query = BlogPost.findOne({ title: 'interoperable findOne as promise' });

        query.exec(function(err, found) {

          assert.ifError(err);

          assert.equal(found.id, created.id);

          done();

        });

      });

    it('find()', function(done) {

      BlogPost.create(

        { title: 'interoperable find as promise' },

        function(err, createdOne, createdTwo) {

          assert.ifError(err);

          const query = BlogPost.find({ title: 'interoperable find as promise' }).sort('_id');

          query.exec(function(err, found) {

            assert.ifError(err);

            assert.equal(found.length, 2);

            const ids = {};

            ids[String(found[0]._id)] = 1;

            ids[String(found[1]._id)] = 1;

            assert.ok(String(createdOne._id) in ids);

            assert.ok(String(createdTwo._id) in ids);

            done();

          });

        });

    it('op can be changed', function(done) {

      BlogPost.create({ title: title }, function(err, created) {

        assert.ifError(err);

        const query = BlogPost.count({ title: title });

        query.exec('findOne', function(err, found) {

          assert.ifError(err);

          assert.equal(found.id, created.id);

          done();

        });

      });

      it.skip('count()', function(done) {

        BlogPost.create({ title: 'interoperable count as promise 2' }, function(err) {

          assert.ifError(err);

          const query = BlogPost.count({ title: 'interoperable count as promise 2' });

          const promise = query.exec();

          promise.then(function(count) {

            assert.equal(count, 1);

            done();

          }).catch(done);

        });

      });



      it.skip('update()', function(done) {

        BlogPost.create({ title: 'interoperable update as promise 2' }, function(err) {

          assert.ifError(err);

          const query = BlogPost.update({ title: 'interoperable update as promise 2' }, { title: 'interoperable update as promise delta 2' });

          const promise = query.exec();

          promise.then(function() {

            BlogPost.count({ title: 'interoperable update as promise delta 2' }, function(err, count) {

              assert.ifError(err);

              assert.equal(count, 1);

              done();

            });

          });

        });

      });


","it('updateOne()', function() {
  const updateOneAsync = async () => {
    await BlogPost.create({ title: 'interoperable update as promise' }, function(err) {
      await BlogPost.create({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });
      
      const query = BlogPost.updateOne({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });
      const result = await query.exec(function(err, res) {
        if (err) throw err;
        
        assert.equal(res.matchedCount, 1);
        assert.equal(res.modifiedCount, 1);
        
        const found = await BlogPost.count({ title: 'interoperable update as promise delta' });
        assert.equal(found, 1);
      });
    });
  };
  
  updateOneAsync();
});

it('findOne()', function() {
  const findOneAsync = async () => {
    await BlogPost.create({ title: 'interoperable findOne as promise' }, function(err, created) {
      await BlogPost.findOne({ title: 'interoperable findOne as promise' });
      
      const found = await BlogPost.find({ title: 'interoperable findOne as promise' }).sort('_id');
      assert.equal(found[0].id, created.id);
    });
  };
  
  findOneAsync();
});

it('find()', function() {
  const findAsync = async () => {
    const query = BlogPost.find({ title: 'interoperable find as promise' }).sort('_id');
    const result = await query.exec(function(err, found) {
      if (err) throw err;
      
      assert.equal(found.length, 2);
      const ids = { String(found[0]._id): 1, String(found[1]._id): 1 };
      const createdOneId = String(result.createdOne._id);
      const createdTwoId = String(result.createdTwo._id);
      assert.ok(ids.hasOwnProperty(createdOneId));
      assert.ok(ids.hasOwnProperty(createdTwoId));
    });
    
    await BlogPost.count({ title: 'interoperable find as promise' }).sort('_id');
  };
  
  findAsync();
});

it('op can be changed', function() {
  const opCanBeChangedAsync = async () => {
    await BlogPost.create({ title: title }, function(err, created) {
      await BlogPost.findOne({ title: title });
      
      const found = await BlogPost.find({ title: title }).sort('_id');
      assert.equal(found.id, created.id);
    });
  };
  
  opCanBeChangedAsync();
});

it('count()', function() {
  await BlogPost.create({ title: 'interoperable count as promise' }, function(err) {
    const query = BlogPost.count({ title: 'interoperable count as promise' });
    await query.exec();
    assert.equal(1, query.count);
  });
});",2023-02-07 12:39:03-05:00,3ae89172dd14aee576d97fb6c47b54e7d76640c0
"  findMongoPids = function(dbDir_unused, port) {

    return new Promise((resolve, reject) => {

      child_process.exec('tasklist /fi ""IMAGENAME eq mongod.exe""', function(

        error,

        stdout,

        stderr

      ) {

        if (error) {

          var additionalInfo = JSON.stringify(error);

          if (error.code === 'ENOENT') {

            additionalInfo =

              ""tasklist wasn't found on your system, it usually can be found at C:\\Windows\\System32\\."";

          reject(

            new Error(""Couldn't run tasklist.exe: "" + additionalInfo)

          );

          return;

        } else {

          // Find the pids of all mongod processes

          var mongo_pids = [];

          stdout.split('\n')

            .forEach(function(line) {

              var m = line.match(/^mongod.exe\s+(\d+) /);

              if (m) {

                mongo_pids[m[1]] = true;

              }

            });



          // Now get the corresponding port numbers

          child_process.exec(

            'netstat -ano',

            { maxBuffer: 1024 * 1024 * 10 },

            function(error, stdout, stderr) {

              if (error) {

                promise.reject(

                  new Error(""Couldn't run netstat -ano: "" + JSON.stringify(error))

                return;

              } else {

                var pids = [];

                stdout.split('\n')

                  .forEach(function(line) {

                    var m = line.match(

                      /^\s*TCP\s+\S+:(\d+)\s+\S+\s+LISTENING\s+(\d+)/

                    );

                    if (m) {

                      var found_pid = parseInt(m[2], 10);

                      var found_port = parseInt(m[1], 10);



                      // We can't check the path app_dir so assume it always matches

                      if (mongo_pids[found_pid] && (!port || port === found_port)) {

                        // Note that if the mongo rest interface is enabled the

                        // initial port + 1000 is also likely to be open.

                        // So remove the pid so we only match it once.

                        delete mongo_pids[found_pid];

                        pids.push({

                          pid: found_pid,

                          port: found_port,

                          app_dir: null,

                        });

                      }

                    }

                  });



                resolve(pids);

              }

          );

        }

      });

  findMongoPids = function(dbDir, port) {

    return new Promise((resolve, reject) => {



      // 'ps ax' should be standard across all MacOS and Linux.

      // However, ps on OS X corrupts some non-ASCII characters in arguments,

      // such as т (CYRILLIC SMALL LETTER TE), leading to this function

      // failing to properly match pathnames with those characters.  #3999

      //

      // pgrep appears to do a better job (and has output that is roughly

      // similar; it lacks a few fields that we don't care about).  Plus,

      // it can do some of the grepping for us.

      //

      // However, 'pgrep' only started shipping with OS X 10.8 (and may be less

      // common on Linux too), so we check to see if it exists and fall back to

      // 'ps' if we can't find it.

      //

      // We avoid using pgrep on Linux, because some versions of Linux pgrep

      // require you to pass -a/--list-full to include the arguments in the

      // output, and other versions fail if you pass that option. We have not

      // observed the Unicode corruption on Linux, so using ps ax there is fine.

      var psScript = 'ps ax';

      if (process.platform === 'darwin') {

        psScript =

          'if type pgrep >/dev/null 2>&1; then ' +

          // -lf means to display and match against full argument lists.

          // pgrep exits 1 if no processes match the argument; we're OK

          // considering this as a success, but we don't want other errors

          // to be ignored.  Note that this is sh not bash, so we can't use

          // [[.

          'pgrep -lf mongod; test ""$?"" -eq 0 -o ""$?"" -eq 1;' +

          'else ps ax; fi';

      }



      // If the child process output includes unicode, make sure it's

      // handled properly.

      const {

        LANG = 'en_US.UTF-8',

        LC_ALL = LANG,

        LANGUAGE = LANG,

        // Remainder of process.env without above properties.

        ...env

      } = process.env;



      // Make sure all three properties are set to the same value, which

      // defaults to ""en_US.UTF-8"" or whatever LANG was already set to.

      Object.assign(env, {

        LANG,

        LC_ALL,

        LANGUAGE

      });

      child_process.exec(

        psScript,

        {

          env,

          // we don't want this to randomly fail just because you're running

          // lots of processes. 10MB should be more than ps ax will ever

          // spit out; the default is 200K, which at least one person hit

          // (#2158).

          maxBuffer: 1024 * 1024 * 10,

        },

        function(error, stdout, stderr) {

          if (error) {

            reject(

              new Error(

                ""Couldn't run ps ax: "" +

              )

            );

            return;

          var ret = [];

          stdout.split('\n')

            .forEach(function(line) {

              // Matches mongos we start. Note that this matches

              // 'fake-mongod' (our mongod stub for automated tests) as well

              // as 'mongod'.

              var m = line.match(

                /^\s*(\d+).+mongod .+--port (\d+) --dbpath (.+(?:\/|\\)db)/

              );

              if (m && m.length === 4) {

                var foundPid = parseInt(m[1], 10);

                var foundPort = parseInt(m[2], 10);

                var foundPath = m[3];



                if (

                  (!port || port === foundPort) &&

                  (!dbDir || dbDir === foundPath)

                ) {

                  ret.push({

                    pid: foundPid,

                    port: foundPort,

                    dbDir: foundPath,

                  });

                }

              }

            });

          resolve(ret);

        }

      );

    });
","async function findMongoPids(dbDir_unused, port) {
  const mongoPids = await Promise.all([
    child_process.exec('tasklist /fi ""IMAGENAME eq mongod.exe""', async (error, stdout, stderr) => {
      if (error) {
        var additionalInfo = JSON.stringify(error);
        if (error.code === 'ENOENT') {
          additionalInfo = ""tasklist wasn't found on your system, it usually can be found at C:\\Windows\\System32\\"".toString();
        }
        throw new Error(`Couldn't run tasklist.exe: ${additionalInfo}`);
      } else {
        var mongoPidsArray = [];
        stdout.split('\n').forEach(line => {
          const match = line.match(/^mongod.exe\s+(\d+) /);
          if (match) {
            mongoPidsArray[match[1]] = true;
          }
        });
        return Promise.resolve(mongoPidsArray);
      }
    }),
    child_process.exec(
      'netstat -ano',
      { maxBuffer: 1024 * 1024 * 10 },
      async (error, stdout, stderr) => {
        if (error) {
          throw new Error(`Couldn't run netstat -ano: ${JSON.stringify(error)}`);
        } else {
          const pids = [];
          stdout.split('\n').forEach(line => {
            const match = line.match(
              /^\s*TCP\s+\S+:(\d+)\s+\S+\s+LISTENING\s+(\d+)/
            );
            if (match) {
              const foundPid = parseInt(match[2], 10);
              const foundPort = parseInt(match[3], 10);

              if (
                (!port || port === foundPort) &&
                mongoPids[foundPid]
              ) {
                delete mongoPids[foundPid];
                pids.push({
                  pid: foundPid,
                  port: foundPort,
                  app_dir: null
                });
              }
            }
          });
          return Promise.resolve(pids);
        }
      })
    )
  ]);

  const pids = await Promise.all(mongoPids.values());
  return Promise.resolve(pids);
}

async function findMongoPids(dbDir, port) {
  const psScript = `ps ax`;

  if (process.platform === 'darwin') {
    psScript = `if type pgrep >/dev/null 2>&1; then \
      'pgrep -lf mongod; test ""$?"" -eq 0 -o ""$?"" -eq 1;' \
      'else ps ax; fi`;
  }

  const { LANG, LC_ALL, LANGUAGE } = process.env;
  Object.assign(process.env, { LANG, LC_ALL, LANGUAGE });

  const pids = await Promise.all(
    child_process.exec(
      psScript,
      {
        env: process.env
      },
      async (error, stdout, stderr) => {
        if (error) {
          throw new Error(`Couldn't run ps ax: ${JSON.stringify(error)}`);
        }

        const ret = [];
        stdout.split('\n').forEach(line => {
          const match = line.match(
            /^\s*(\d+).+mongod .+--port (\d+) --dbpath (.+(?:\/|\\)db)/
          );
          if (match && match.length === 4) {
            const foundPid = parseInt(match[1], 10);
            const foundPort = parseInt(match[2], 10);
            const foundPath = match[3];

            if (
              (!port || port === foundPort) &&
              (!dbDir || dbDir === foundPath)
            ) {
              ret.push({
                pid: foundPid,
                port: foundPort,
                dbDir: foundPath
              });
            }
          }
        });

        return Promise.resolve(ret);
      })
    ).values()
  );

  return pids;
}",2022-12-14 21:48:59-03:00,a76c30693f8697885787e9baab80107a8471a0c4
"        server.put('options', opts).then(() => {

            toastService.showPersistent({

                id: ""options-change-saved"",

                title: ""Options status"",

                message: ""Options change have been saved."",

                icon: ""slider"",

                closeAfter: 2000

            })
","const changed = await server.put('options', opts);

        changed.then(() => {
            await toastService.showPersistent({
                id: ""options-change-saved"",
                title: ""Options status"",
                message: ""Options change have been saved."",
                icon: ""slider"",
                closeAfter: 2000
            });
        });",2022-11-20 23:20:42+01:00,bcb3a707f403e711c4a1bbe89deba313c34d7ae3
"      return partialEvaluator

        .getOperatorList({

          stream: contentStream,

          task,

          resources: this.resources,

          operatorList: opList,

        })

        .then(() => opList);

    return Promise.all([

    ]).then(function ([pageOpList, annotations, newAnnotations]) {

      if (newAnnotations) {

        // Some annotations can already exist (if it has the refToReplace

        // property). In this case, we replace the old annotation by the new

        // one.

        annotations = annotations.filter(

          a => !(a.ref && deletedAnnotations.has(a.ref))

        );

        for (let i = 0, ii = newAnnotations.length; i < ii; i++) {

          const newAnnotation = newAnnotations[i];

          if (newAnnotation.refToReplace) {

            const j = annotations.findIndex(

              a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)

            );

            if (j >= 0) {

              annotations.splice(j, 1, newAnnotation);

              newAnnotations.splice(i--, 1);

              ii--;

            }

        annotations = annotations.concat(newAnnotations);

        annotations.length === 0 ||

        intent & RenderingIntentFlag.ANNOTATIONS_DISABLE

        pageOpList.flush(/* lastChunk = */ true);

        return { length: pageOpList.totalLength };

      }

      const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),

        isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),

        intentAny = !!(intent & RenderingIntentFlag.ANY),

        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

        intentPrint = !!(intent & RenderingIntentFlag.PRINT);



      // Collect the operator list promises for the annotations. Each promise

      // is resolved with the complete operator list for a single annotation.

      const opListPromises = [];

      for (const annotation of annotations) {

        if (

          intentAny ||

          (intentDisplay &&

            annotation.mustBeViewed(annotationStorage, renderForms) &&

            annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||

          (intentPrint && annotation.mustBePrinted(annotationStorage))

        ) {

          opListPromises.push(

            annotation

              .getOperatorList(

                partialEvaluator,

                task,

                intent,

                annotationStorage

              )

              .catch(function (reason) {

                warn(

                  ""getOperatorList - ignoring annotation data during "" +

                    `""${task.name}"" task: ""${reason}"".`

                );

                return {

                  opList: null,

                  separateForm: false,

                  separateCanvas: false,

                };

              })

          );

        }

      return Promise.all(opListPromises).then(function (opLists) {

        let form = false,

          canvas = false;

        for (const { opList, separateForm, separateCanvas } of opLists) {

          pageOpList.addOpList(opList);

          form ||= separateForm;

          canvas ||= separateCanvas;

        }

        pageOpList.flush(

          /* lastChunk = */ true,

          /* separateAnnots = */ { form, canvas }

        );

        return { length: pageOpList.totalLength };

      });

    });
","return (async) => {
      const pageOpList = opList.getOperatorList({
        stream: contentStream,
        task,
        resources: this.resources,
        operatorList: opList,
      })
      .then(() => opList);

      if (newAnnotations) {
        annotations = annotations.filter(
          a => !(a.ref && deletedAnnotations.has(a.ref))
        );
        
        for (let i = 0, ii = newAnnotations.length; i < ii; i++) {
          const newAnnotation = newAnnotations[i];
          if (newAnnotation.refToReplace) {
            const j = annotations.findIndex(
              a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)
            );
            if (j >= 0) {
              annotations.splice(j, 1, newAnnotation);
              newAnnotations.splice(i--, 1);
              ii--;
            }
          }
        }
        annotations = annotations.concat(newAnnotations);
      }

      if (!pageOpList.flush() || annotations.length === 0 ||
         intent & RenderingIntentFlag.ANNOTATIONS_DISABLE) {
        return { length: pageOpList.totalLength };
      }

      const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),
        isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),
        intentAny = !!(intent & RenderingIntentFlag.ANY),
        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),
        intentPrint = !!(intent & RenderingIntentFlag.PRINT);

      const opListPromises = annotations.map(annotation => ({
        getOperatorList: async () => {
          try {
            return annotation
              .getOperatorList(
                partialEvaluator,
                task,
                intent,
                annotationStorage
              )
              .catch(function (reason) {
                warn(
                  ""getOperatorList - ignoring annotation data during "" +
                    `""${task.name}"" task: ""${reason}"".""
                );
                return {
                  opList: null,
                  separateForm: false,
                  separateCanvas: false,
                };
              });
            return { opList, separateForm: false, separateCanvas: false };
          } catch (e) {
            return { opList: null, separateForm: false, separateCanvas: false };
          }
        }),
      ));

      const opLists = await opListPromises.every(getOperatorList);

      let form = false,
        canvas = false;

      for (const { opList, separateForm, separateCanvas } of opLists) {
        pageOpList.addOpList(opList);
        form ||= separateForm;
        canvas ||= separateCanvas;
      }

      pageOpList.flush(
        /* lastChunk = */ true,
        /* separateAnnots = */ { form, canvas }
      );

      return { length: pageOpList.totalLength };
    };",2025-03-17 13:20:51+01:00,d00482380af454d544324d927ec1af9e17ccb4a8
"  parseAsync(argv, parseOptions) {

    this.parse(argv, parseOptions);

    return Promise.all(this._actionResults).then(() => this);
","async function parseAsync(argv, parseOptions) {
    this.parse(argv, parseOptions);

    // Use await Promise.all() to execute all actionPromises concurrently
    const actionsResolved = await Promise.all(this._actionResults);
    
    // Return 'this' as part of a new promise chain
    return actionsResolved.then(() => this);
}",2021-05-06 18:02:31+12:00,59c81532be707170d068b4e4dd93175a19fa8d9a
"const { warn, error } = require('./util/log')

program

  .usage('<app-name>')

  .parse(process.argv)



const projectName = program.args[0]

if (!projectName) {

  warn(`\n  Please provide an app name.`)

  program.outputHelp()

  process.exit(1)

}

const createGenerator = (id, requirePath = id) => ({

  id,

  apply: require(requirePath)

})

const builtInGenerators = fs

  .readdirSync(path.resolve(__dirname, './generators'))

  .filter(dir => dir.charAt(0) !== '.')

  .map(id => createGenerator(id, `./generators/${id}`))

debug(builtInGenerators)

const installedGenerators = resolveInstalledGenerators().map(id => {

  return createGenerator(id)

})

const targetDir = path.resolve(process.cwd(), projectName)

const creator = new Creator(projectName, builtInGenerators.concat(installedGenerators))

creator

  .create(targetDir)

  .then(() => {

    // TODO: log instructions

  })

  .catch(error)
","const { warn, error } = require('./util/log')

program
  .usage('<app-name>')
  .parse(process.argv)

const projectName = program.args[0]
if (!projectName) {
  warn(`\n  Please provide an app name.`)
  program.outputHelp()
  process.exit(1)
}

const createGenerator = (id, requirePath = id) => ({
  id,
  apply: require(requirePath)
})

const builtInGenerators = fs
  .readdirSync(path.resolve(__dirname, './generators'))
  .filter(dir => dir.charAt(0) !== '.')
  .map(id => createGenerator(id, `./generators/${id}`))

const installedGenerators = resolveInstalledGenerators().map(id => ({
  id,
  apply: require(`./installers/${id}`)
}))

const targetDir = path.resolve(process.cwd(), projectName)

const creator = new Creator(projectName, builtInGenerators.concat(installedGenerators))

async function createAsync(targetDir) {
  const result = await creator.create(targetDir)
  if (result) {
    return result
  } else {
    throw new Error('Failed to create directory')
  }
}

createAsync(targetDir).then(() => {}).catch(error => error)",2017-12-28 13:06:17-05:00,9fc43f8fa51f5a5d1c36d07ea34db0f042264316
"  set(name, value) {

    return this._initializedPromise.then(() => {

      if (this.defaults[name] === undefined) {

        throw new Error(`Set preference: ""${name}"" is undefined.`);

      } else if (value === undefined) {

        throw new Error('Set preference: no value is specified.');

      }

      let valueType = typeof value;

      let defaultType = typeof this.defaults[name];

      if (valueType !== defaultType) {

        if (valueType === 'number' && defaultType === 'string') {

          value = value.toString();

        } else {

          throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                          `expected a ${defaultType}.`);

        }

        if (valueType === 'number' && !Number.isInteger(value)) {

          throw new Error(`Set preference: ""${value}"" must be an integer.`);

        }

      this.prefs[name] = value;

      return this._writeToStorage(this.prefs);

    });
","set(name, value) {
  const _initializedPromise = this._initializedPromise;

  return new Promise((resolve, reject) => {
    if (this.defaults[name] === undefined)
      resolve(new Error(`Set preference: ""${name}"" is undefined.`));
    else if (value === undefined)
      resolve(new Error('Set preference: no value is specified.'));
    
    const valueType = typeof value;
    const defaultType = typeof this.defaults[name];
    
    if (valueType !== defaultType) {
      if (valueType === 'number' && defaultType === 'string') {
        value = value.toString();
      } else {
        reject(new Error(`Set preference: ""${value}"" is a ${valueType}, ` +
                          `expected a ${defaultType}.`));
      }
    
    if (valueType === 'number' && !Number.isInteger(value)) {
      reject(new Error(`Set preference: ""${value}"" must be an integer.`));
    }

    this.prefs[name] = value;
    _writeToStorage(this.prefs);
    resolve(null);
  });
}",2018-07-30 16:48:16+02:00,233b3274bf7973aa06a674dddef585f4313f3742
"      const result = XfaLayer.render(parameters);

      return Promise.resolve(result);

    return this.pdfPage

      .getXfa()

      .then(xfaHtml => {

        if (this._cancelled || !xfaHtml) {

          return { textDivs: [] };

        }

        const parameters = {

          viewport: viewport.clone({ dontFlip: true }),

          div: this.div,

          xfaHtml,

          annotationStorage: this.annotationStorage,

          linkService: this.linkService,

          intent,

        };

        if (this.div) {

          return XfaLayer.update(parameters);

        }

        // Create an xfa layer div and render the form

        this.div = document.createElement(""div"");

        this.pageDiv.append(this.div);

        parameters.div = this.div;

        return XfaLayer.render(parameters);

      })

      .catch(error => {

        console.error(error);

      });
","const result = await XfaLayer.render(parameters);

      return result;

    return this.pdfPage

      .getXfa()

      .then(xfaHtml => {

        if (this._cancelled || !xfaHtml) {
          return { textDivs: [] };
        }

        const parameters = {
          viewport: viewport.clone({ dontFlip: true }),
          div: this.div,
          xfaHtml,
          annotationStorage: this.annotationStorage,
          linkService: this.linkService,
          intent,
        };

        if (this.div) {
          return await XfaLayer.update(parameters);
        }

        // Create an xfa layer div and render the form
        this.div = document.createElement(""div"");
        this.pageDiv.append(this.div);
        parameters.div = this.div;
        return await XfaLayer.render(parameters);

      })
      .catch(error => {
        console.error(error);
      });",2022-12-11 13:07:44+01:00,828efd9d000ab868369ac19cbc2ed0f8cc09c92f
"function loadNoteToEditor(noteId) {

    $.get(baseApiUrl + 'notes/' + noteId).then(note => {

        globalCurrentNote = note;

        globalCurrentNoteLoadTime = Math.floor(new Date().getTime() / 1000);

        if (newNoteCreated) {

            newNoteCreated = false;

            $(""#note-title"").focus().select();

        }

        handleEncryption(note.detail.encryption > 0, false, () => {

            $(""#note-detail-wrapper"").show();

            // this may fal if the dialog has not been previously opened

            try {

                $(""#encryption-password-dialog"").dialog('close');

            }

            catch(e) {}

            $(""#encryption-password"").val('');

            decryptNoteIfNecessary(note);

            $(""#note-title"").val(note.detail.note_title);

            noteChangeDisabled = true;

            // Clear contents and remove all stored history. This is to prevent undo from going across notes

            $('#note-detail').summernote('reset');

            $('#note-detail').summernote('code', note.detail.note_text);

            document.location.hash = noteId;

            addRecentNote(noteId, note.detail.note_id);

            noteChangeDisabled = false;

            setNoteBackgroundIfEncrypted(note);

        });

    });

function loadNote(noteId, callback) {

    $.get(baseApiUrl + 'notes/' + noteId).then(note => {

        if (note.detail.encryption > 0 && !isEncryptionAvailable()) {

            return;

        }

        decryptNoteIfNecessary(note);

        callback(note);

    });
","async function loadNoteToEditor(noteId) {
    $.get(baseApiUrl + 'notes/' + noteId).then(note => {
        globalCurrentNote = note;
        globalCurrentNoteLoadTime = Math.floor(new Date().getTime() / 1000);
        if (newNoteCreated) {
            newNoteCreated = false;
            $(""#note-title"").focus().select();
        }
        handleEncryption(note.detail.encryption > 0, false, () => {
            $(""#note-detail-wrapper"").show();
            // this may fal if the dialog has not been previously opened
            try {
                $(""#encryption-password-dialog"").dialog('close');
            } catch(e) {}
            $(""#encryption-password"").val('');
            decryptNoteIfNecessary(note);
            $(""#note-title"").val(note.detail.note_title);
            noteChangeDisabled = true;
            // Clear contents and remove all stored history. This is to prevent undo from going across notes
            $('#note-detail').summernote('reset');
            $('#note-detail').summernote('code', note.detail.note_text);
            document.location.hash = noteId;
            addRecentNote(noteId, note.detail.note_id);
            noteChangeDisabled = false;
            setNoteBackgroundIfEncrypted(note);
        });
    });
}

async function loadNote(noteId, callback) {
    $.get(baseApiUrl + 'notes/' + noteId).then(note => {
        if (note.detail.encryption > 0 && !isEncryptionAvailable()) {
            return;
        }
        decryptNoteIfNecessary(note);
        callback(note);
    });
}",2017-11-03 20:01:32-04:00,702d47e6b0b1c71ead1111c1d3952fbaf86abf2a
"  read() {

    return this._readCapability.promise.then(() => {

      if (this._done) {

        return Promise.resolve({ value: undefined, done: true, });

      }

      if (this._storedError) {

        return Promise.reject(this._storedError);

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({

          loaded: this._loaded,

          total: this._contentLength,

        });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return Promise.resolve({ value: buffer, done: false, });

    });
","read() {
    const [value, done] = await this._readCapability.promise.then(() => {
      if (this._done) return { value: undefined, done: true };
      if (this._storedError) {
        try {
          return this._storedError.reject();
        } catch (error) {
          throw error;
        }
      }

      let buffer = new Uint8Array();

      do {
        const chunk = await this.read();
        if (chunk === null) {
          break;
        }
        _loaded += chunk.length;

        if (this.onProgress) {
          this.onProgress({
            loaded: this._loaded,
            total: this._contentLength,
          });
        }

        buffer.append(chunk);
      } while (true);

      const resultBuffer = new Uint8Array(buffer).buffer;
      return Promise.resolve({ value: resultBuffer, done: false });
    });

    // ... rest of the method ...
  };",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
