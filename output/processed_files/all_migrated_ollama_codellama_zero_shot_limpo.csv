removed_chunk,migrated_code,commit_date,commit_hash
"  parseAsync(argv, parseOptions) {

    this.parse(argv, parseOptions);

    return Promise.all(this._actionResults).then(() => this);
","async parseAsync(argv, parseOptions) {
  await this.parse(argv, parseOptions);
  return this;
}",2021-05-06 18:02:31+12:00,59c81532be707170d068b4e4dd93175a19fa8d9a
"    ""Sanity check operations"": browser => {

        import(""../operations/samples/Images.mjs"")

            .then(Images => {

                testOp(browser, [""From Hex"", ""Add Text To Image"", ""To Hex""], Images.PNG_HEX, Images.PNG_CHEF_HEX);

                testOp(browser, ""A1Z26 Cipher Decode"", ""20 5 19 20 15 21 20 16 21 20"", ""testoutput"");

                testOp(browser, ""A1Z26 Cipher Encode"", ""test input"", ""20 5 19 20 9 14 16 21 20"");

            });

    },

    ""Sanity  check operations"": browser => {

        import(""../operations/samples/Images.mjs"").then(Images => {

            testOp(browser, ""ADD"", ""test input"", ""Ê»ÉÊv¿ÄÆËÊ"", [{ ""option"": ""Hex"", ""string"": ""56"" }]);

            testOp(browser, ""AES Decrypt"", ""b443f7f7c16ac5396a34273f6f639caa"", ""test output"", [{ ""option"": ""Hex"", ""string"": ""00112233445566778899aabbccddeeff"" }, { ""option"": ""Hex"", ""string"": ""00000000000000000000000000000000"" }, ""CBC"", ""Hex"", ""Raw"", { ""option"": ""Hex"", ""string"": """" }]);

            testOp(browser, ""AES Encrypt"", ""test input"", ""e42eb8fbfb7a98fff061cd2c1a794d92"", [{""option"": ""Hex"", ""string"": ""00112233445566778899aabbccddeeff""}, {""option"": ""Hex"", ""string"": ""00000000000000000000000000000000""}, ""CBC"", ""Raw"", ""Hex""]);

            testOp(browser, ""AND"", ""test input"", ""4$04  $044"", [{ ""option"": ""Hex"", ""string"": ""34"" }]);

            testOp(browser, ""Add line numbers"", ""test input"", ""1 test input"");

            // testOp(browser, [""From Hex"", ""Add Text To Image"", ""To Hex""], Images.PNG_HEX, Images.PNG_CHEF_HEX);

            // testOp(browser, ""Add Text To Image"", ""test input"", ""test_output"");

            testOp(browser, ""Adler-32 Checksum"", ""test input"", ""16160411"");

            testOp(browser, ""Affine Cipher Decode"", ""test input"", ""rcqr glnsr"", [1, 2]);

            testOp(browser, ""Affine Cipher Encode"", ""test input"", ""njln rbfpn"", [2, 1]);

            testOp(browser, ""Analyse hash"", ""0123456789abcdef"", /CRC-64/);

            testOp(browser, ""Atbash Cipher"", ""test input"", ""gvhg rmkfg"");

            // testOp(browser, ""Avro to JSON"", ""test input"", ""test_output"");

            // testOp(browser, ""BLAKE2b"", ""test input"", ""test_output"");

            // testOp(browser, ""BLAKE2s"", ""test input"", ""test_output"");

            // testOp(browser, ""BSON deserialise"", ""test input"", ""test_output"");

            // testOp(browser, ""BSON serialise"", ""test input"", ""test_output"");

            // testOp(browser, ""Bacon Cipher Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bacon Cipher Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bcrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Bcrypt compare"", ""test input"", ""test_output"");

            // testOp(browser, ""Bcrypt parse"", ""test input"", ""test_output"");

            // testOp(browser, ""Bifid Cipher Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bifid Cipher Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Bit shift left"", ""test input"", ""test_output"");

            // testOp(browser, ""Bit shift right"", ""test input"", ""test_output"");

            testOp(browser, ""Blowfish Decrypt"", ""10884e15427dd84ec35204e9c8e921ae"", ""test_output"", [{""option"": ""Hex"", ""string"": ""1234567801234567""}, {""option"": ""Hex"", ""string"": ""0011223344556677""}, ""CBC"", ""Hex"", ""Raw""]);

            testOp(browser, ""Blowfish Encrypt"", ""test input"", ""f0fadbd1d90d774f714248cf26b96410"", [{""option"": ""Hex"", ""string"": ""1234567801234567""}, {""option"": ""Hex"", ""string"": ""0011223344556677""}, ""CBC"", ""Raw"", ""Hex""]);

            // console.log(Images);

            // testOp(browser, ""Blur Image"", Images.PNG_HEX, ""test_output"");

            // Imaged Error : Undefined ! Must be a way to Reference Exports



            // testOp(browser, ""Bombe"", ""test input"", ""test_output"");

            testOp(browser, ""Bzip2 Compress"", ""test input"", ""BZh91AY&SYÏ........@..!N. .!.Â.À.3..ß.rE8P.Ï..."");

            testOp(browser, [""From Hex"", ""Bzip2 Decompress""], ""425a68393141592653597b0884b7000003038000008200ce00200021a647a4218013709517c5dc914e14241ec2212dc0"", ""test_output"", [true]);

            // testOp(browser, ""CRC-16 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""CRC-32 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""CRC-8 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""CSS Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""CSS Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""CSS selector"", ""test input"", ""test_output"");

            // testOp(browser, ""CSV to JSON"", ""test input"", ""test_output"");

            // testOp(browser, ""CTPH"", ""test input"", ""test_output"");

            // testOp(browser, ""Cartesian Product"", ""test input"", ""test_output"");

            // testOp(browser, ""Change IP format"", ""test input"", ""test_output"");

            // testOp(browser, ""Chi Square"", ""test input"", ""test_output"");

            // testOp(browser, ""CipherSaber2 Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""CipherSaber2 Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Citrix CTX1 Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Citrix CTX1 Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Colossus"", ""test input"", ""test_output"");

            // testOp(browser, ""Comment"", ""test input"", ""test_output"");

            // testOp(browser, ""Compare CTPH hashes"", ""test input"", ""test_output"");

            // testOp(browser, ""Compare SSDEEP hashes"", ""test input"", ""test_output"");

            // /testOp(browser, ""Conditional Jump"", ""test input"", ""test_output"");

            // testOp(browser, ""Contain Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert area"", ""test input"", ""test_output"");

            // /testOp(browser, ""Convert co-ordinate format"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert data units"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert distance"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert Image Format"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert mass"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert speed"", ""test input"", ""test_output"");

            // testOp(browser, ""Convert to NATO alphabet"", ""test input"", ""test_output"");

            // testOp(browser, ""Count occurrences"", ""test input"", ""test_output"");

            // testOp(browser, ""Cover Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Crop Image"", ""test input"", ""test_output"");

            // testOp(browser, ""DES Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""DES Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""DNS over HTTPS"", ""test input"", ""test_output"");

            // testOp(browser, ""Dechunk HTTP response"", ""test input"", ""test_output"");

            // testOp(browser, ""Decode NetBIOS Name"", ""test input"", ""test_output"");

            // testOp(browser, ""Decode text"", ""test input"", ""test_output"");

            // testOp(browser, ""Defang IP Addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Defang URL"", ""test input"", ""test_output"");

            // testOp(browser, ""Derive EVP key"", ""test input"", ""test_output"");

            // testOp(browser, ""Derive PBKDF2 key"", ""test input"", ""test_output"");

            // testOp(browser, ""Detect File Type"", ""test input"", ""test_output"");

            // testOp(browser, ""Diff"", ""test input"", ""test_output"");

            // testOp(browser, ""Disassemble x86"", ""test input"", ""test_output"");

            // testOp(browser, ""Dither Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Divide"", ""test input"", ""test_output"");

            // testOp(browser, ""Drop bytes"", ""test input"", ""test_output"");

            // testOp(browser, ""Encode NetBIOS Name"", ""test input"", ""test_output"");

            // testOp(browser, ""Encode text"", ""test input"", ""test_output"");

            // testOp(browser, ""Enigma"", ""test input"", ""test_output"");

            // testOp(browser, ""Entropy"", ""test input"", ""test_output"");

            // testOp(browser, ""Escape string"", ""test input"", ""test_output"");

            // testOp(browser, ""Escape Unicode Characters"", ""test input"", ""test_output"");

            // testOp(browser, ""Expand alphabet range"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract dates"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract domains"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract EXIF"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract email addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract file paths"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract Files"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract IP addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract LSB"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract MAC addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract RGBA"", ""test input"", ""test_output"");

            // testOp(browser, ""Extract URLs"", ""test input"", ""test_output"");

            // testOp(browser, ""Filter"", ""test input"", ""test_output"");

            // testOp(browser, ""Find / Replace"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-16 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-32 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-64 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Fletcher-8 Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Flip Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Fork"", ""test input"", ""test_output"");

            // testOp(browser, ""Format MAC addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Frequency distribution"", ""test input"", ""test_output"");

            // testOp(browser, ""From BCD"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base32"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base58"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base62"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base64"", ""test input"", ""test_output"");

            // testOp(browser, ""From Base85"", ""test input"", ""test_output"");

            // testOp(browser, ""From Binary"", ""test input"", ""test_output"");

            // testOp(browser, ""From Braille"", ""test input"", ""test_output"");

            // testOp(browser, ""From Case Insensitive Regex"", ""test input"", ""test_output"");

            // testOp(browser, ""From Charcode"", ""test input"", ""test_output"");

            // testOp(browser, ""From Decimal"", ""test input"", ""test_output"");

            // testOp(browser, ""From HTML Entity"", ""test input"", ""test_output"");

            // testOp(browser, ""From Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""From Hex Content"", ""test input"", ""test_output"");

            // testOp(browser, ""From Hexdump"", ""test input"", ""test_output"");

            // testOp(browser, ""From MessagePack"", ""test input"", ""test_output"");

            // testOp(browser, ""From Morse Code"", ""test input"", ""test_output"");

            // testOp(browser, ""From Octal"", ""test input"", ""test_output"");

            // testOp(browser, ""From Punycode"", ""test input"", ""test_output"");

            // testOp(browser, ""From Quoted Printable"", ""test input"", ""test_output"");

            // testOp(browser, ""From UNIX Timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""GOST hash"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate all hashes"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate HOTP"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate Lorem Ipsum"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate PGP Key Pair"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate QR Code"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate TOTP"", ""test input"", ""test_output"");

            // testOp(browser, ""Generate UUID"", ""test input"", ""test_output"");

            // testOp(browser, ""Generic Code Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""Group IP addresses"", ""test input"", ""test_output"");

            // testOp(browser, ""Gunzip"", ""test input"", ""test_output"");

            // testOp(browser, ""Gzip"", ""test input"", ""test_output"");

            // testOp(browser, ""HAS-160"", ""test input"", ""test_output"");

            // testOp(browser, ""HMAC"", ""test input"", ""test_output"");

            // testOp(browser, ""HTML To Text"", ""test input"", ""test_output"");

            // testOp(browser, ""HTTP request"", ""test input"", ""test_output"");

            // testOp(browser, ""Hamming Distance"", ""test input"", ""test_output"");

            // testOp(browser, ""Haversine distance"", ""test input"", ""test_output"");

            // testOp(browser, ""Head"", ""test input"", ""test_output"");

            // testOp(browser, ""Heatmap chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Hex Density chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Hex to Object Identifier"", ""test input"", ""test_output"");

            // testOp(browser, ""Hex to PEM"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Brightness / Contrast"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Filter"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Hue/Saturation/Lightness"", ""test input"", ""test_output"");

            // testOp(browser, ""Image Opacity"", ""test input"", ""test_output"");

            // testOp(browser, ""Index of Coincidence"", ""test input"", ""test_output"");

            // testOp(browser, ""Invert Image"", ""test input"", ""test_output"");

            // testOp(browser, ""JPath expression"", ""test input"", ""test_output"");

            // testOp(browser, ""JSON Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""JSON Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""JSON to CSV"", ""test input"", ""test_output"");

            // testOp(browser, ""JWT Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""JWT Sign"", ""test input"", ""test_output"");

            // testOp(browser, ""JWT Verify"", ""test input"", ""test_output"");

            // testOp(browser, ""JavaScript Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""JavaScript Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""JavaScript Parser"", ""test input"", ""test_output"");

            // testOp(browser, ""Jump"", ""test input"", ""test_output"");

            // testOp(browser, ""Keccak"", ""test input"", ""test_output"");

            // testOp(browser, ""Label"", ""test input"", ""test_output"");

            // testOp(browser, ""Lorenz"", ""test input"", ""test_output"");

            // testOp(browser, ""Luhn Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""MD2"", ""test input"", ""test_output"");

            // testOp(browser, ""MD4"", ""test input"", ""test_output"");

            // testOp(browser, ""MD5"", ""test input"", ""test_output"");

            // testOp(browser, ""MD6"", ""test input"", ""test_output"");

            // testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""td"", /Result snippet/);

            // testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""tr:nth-of-type(1) td:nth-of-type(2)"", ""Result snippet"");

            // testOpHtml(browser, ""Magic"", ""dGVzdCBvdXRwdXQ="", ""tr:eq(1) td:eq(1)"", ""test_output"");

            // testOp(browser, ""Mean"", ""test input"", ""test_output"");

            // testOp(browser, ""Median"", ""test input"", ""test_output"");`

            // testOp(browser, ""Merge"", ""test input"", ""test_output"");`

            // testOp(browser, ""Microsoft Script Decoder"", ""test input"", ""test_output"");

            // testOp(browser, ""Multiple Bombe"", ""test input"", ""test_output"");

            // testOp(browser, ""Multiply"", ""test input"", ""test_output"");

            // testOp(browser, ""NOT"", ""test input"", ""test_output"");

            // testOp(browser, ""Normalise Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Normalise Unicode"", ""test input"", ""test_output"");

            // testOp(browser, ""Numberwang"", ""test input"", ""test_output"");

            // testOp(browser, ""OR"", ""test input"", ""test_output"");

            // testOp(browser, ""Object Identifier to Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""Offset checker"", ""test input"", ""test_output"");

            // testOp(browser, ""Optical Character Recognition"", ""test input"", ""test_output"");

            // testOp(browser, ""PEM to Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Decrypt and Verify"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Encrypt and Sign"", ""test input"", ""test_output"");

            // testOp(browser, ""PGP Verify"", ""test input"", ""test_output"");

            // testOp(browser, ""PHP Deserialize"", ""test input"", ""test_output"");

            // testOp(browser, ""Pad lines"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse ASN.1 hex string"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse colour code"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse DateTime"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse IP range"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse IPv4 header"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse IPv6 address"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse ObjectID timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse QR Code"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse SSH Host Key"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse TLV"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse UDP"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse UNIX file permissions"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse URI"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse User Agent"", ""test input"", ""test_output"");

            // testOp(browser, ""Parse X.509 certificate"", ""test input"", ""test_output"");

            // testOp(browser, ""Play Media"", ""test input"", ""test_output"");

            // testOp(browser, ""Power Set"", ""test input"", ""test_output"");

            // testOp(browser, ""Protobuf Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Pseudo-Random Number Generator"", ""test input"", ""test_output"");

            // testOp(browser, ""RC2 Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""RC2 Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""RC4"", ""test input"", ""test_output"");

            // testOp(browser, ""RC4 Drop"", ""test input"", ""test_output"");

            // testOp(browser, ""RIPEMD"", ""test input"", ""test_output"");

            // testOp(browser, ""ROT13"", ""test input"", ""test_output"");

            // testOp(browser, ""ROT47"", ""test input"", ""test_output"");

            // testOp(browser, ""Rail Fence Cipher Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Rail Fence Cipher Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Randomize Colour Palette"", ""test input"", ""test_output"");

            // testOp(browser, ""Raw Deflate"", ""test input"", ""test_output"");

            // testOp(browser, ""Raw Inflate"", ""test input"", ""test_output"");

            // testOp(browser, ""Register"", ""test input"", ""test_output"");

            // testOp(browser, ""Regular expression"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove Diacritics"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove EXIF"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove line numbers"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove null bytes"", ""test input"", ""test_output"");

            // testOp(browser, ""Remove whitespace"", ""test input"", ""test_output"");

            // testOp(browser, ""Render Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Render Markdown"", ""test input"", ""test_output"");

            // testOp(browser, ""Resize Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Return"", ""test input"", ""test_output"");

            // testOp(browser, ""Reverse"", ""test input"", ""test_output"");

            // testOp(browser, ""Rotate Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Rotate left"", ""test input"", ""test_output"");

            // testOp(browser, ""Rotate right"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA0"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA1"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA2"", ""test input"", ""test_output"");

            // testOp(browser, ""SHA3"", ""test input"", ""test_output"");

            // testOp(browser, ""SQL Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""SQL Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""SSDEEP"", ""test input"", ""test_output"");

            // testOp(browser, ""SUB"", ""test input"", ""test_output"");

            // testOp(browser, ""Scan for Embedded Files"", ""test input"", ""test_output"");

            // testOp(browser, ""Scatter chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Scrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Series chart"", ""test input"", ""test_output"");

            // testOp(browser, ""Set Difference"", ""test input"", ""test_output"");

            // testOp(browser, ""Set Intersection"", ""test input"", ""test_output"");

            // testOp(browser, ""Set Union"", ""test input"", ""test_output"");

            // testOp(browser, ""Shake"", ""test input"", ""test_output"");

            // testOp(browser, ""Sharpen Image"", ""test input"", ""test_output"");

            // testOp(browser, ""Show Base64 offsets"", ""test input"", ""test_output"");

            // testOp(browser, ""Show on map"", ""test input"", ""test_output"");

            // testOp(browser, ""Sleep"", ""test input"", ""test_output"");

            // testOp(browser, ""Snefru"", ""test input"", ""test_output"");

            // testOp(browser, ""Sort"", ""test input"", ""test_output"");

            // testOp(browser, ""Split"", ""test input"", ""test_output"");

            // testOp(browser, ""Split Colour Channels"", ""test input"", ""test_output"");

            // testOp(browser, ""Standard Deviation"", ""test input"", ""test_output"");

            // testOp(browser, ""Streebog"", ""test input"", ""test_output"");

            // testOp(browser, ""Strings"", ""test input"", ""test_output"");

            // testOp(browser, ""Strip HTML tags"", ""test input"", ""test_output"");

            // testOp(browser, ""Strip HTTP headers"", ""test input"", ""test_output"");

            // testOp(browser, ""Subsection"", ""test input"", ""test_output"");

            // testOp(browser, ""Substitute"", ""test input"", ""test_output"");

            // testOp(browser, ""Subtract"", ""test input"", ""test_output"");

            // testOp(browser, ""Sum"", ""test input"", ""test_output"");

            // testOp(browser, ""Swap endianness"", ""test input"", ""test_output"");

            // testOp(browser, ""Symmetric Difference"", ""test input"", ""test_output"");

            // testOp(browser, ""Syntax highlighter"", ""test input"", ""test_output"");

            // testOp(browser, ""TCP/IP Checksum"", ""test input"", ""test_output"");

            // testOp(browser, ""Tail"", ""test input"", ""test_output"");

            // testOp(browser, ""Take bytes"", ""test input"", ""test_output"");

            // testOp(browser, ""Tar"", ""test input"", ""test_output"");

            // testOp(browser, ""Text Encoding Brute Force"", ""test input"", ""test_output"");

            // testOp(browser, ""To BCD"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base32"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base58"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base62"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base64"", ""test input"", ""test_output"");

            // testOp(browser, ""To Base85"", ""test input"", ""test_output"");

            // testOp(browser, ""To Binary"", ""test input"", ""test_output"");

            // testOp(browser, ""To Braille"", ""test input"", ""test_output"");

            // testOp(browser, ""To Camel case"", ""test input"", ""test_output"");

            // testOp(browser, ""To Case Insensitive Regex"", ""test input"", ""test_output"");

            // testOp(browser, ""To Charcode"", ""test input"", ""test_output"");

            // testOp(browser, ""To Decimal"", ""test input"", ""test_output"");

            // testOp(browser, ""To HTML Entity"", ""test input"", ""test_output"");

            // testOp(browser, ""To Hex"", ""test input"", ""test_output"");

            // testOp(browser, ""To Hex Content"", ""test input"", ""test_output"");

            // testOp(browser, ""To Hexdump"", ""test input"", ""test_output"");

            // testOp(browser, ""To Kebab case"", ""test input"", ""test_output"");

            // testOp(browser, ""To Lower case"", ""test input"", ""test_output"");

            // testOp(browser, ""To MessagePack"", ""test input"", ""test_output"");

            // testOp(browser, ""To Morse Code"", ""test input"", ""test_output"");

            // testOp(browser, ""To Octal"", ""test input"", ""test_output"");

            // testOp(browser, ""To Punycode"", ""test input"", ""test_output"");

            // testOp(browser, ""To Quoted Printable"", ""test input"", ""test_output"");

            // testOp(browser, ""To Snake case"", ""test input"", ""test_output"");

            // testOp(browser, ""To Table"", ""test input"", ""test_output"");

            // testOp(browser, ""To UNIX Timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""To Upper case"", ""test input"", ""test_output"");

            // testOp(browser, ""Translate DateTime Format"", ""test input"", ""test_output"");

            // testOp(browser, ""Triple DES Decrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Triple DES Encrypt"", ""test input"", ""test_output"");

            // testOp(browser, ""Typex"", ""test input"", ""test_output"");

            // testOp(browser, ""UNIX Timestamp to Windows Filetime"", ""test input"", ""test_output"");

            // testOp(browser, ""URL Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""URL Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Unescape string"", ""test input"", ""test_output"");

            // testOp(browser, ""Unescape Unicode Characters"", ""test input"", ""test_output"");

            // testOp(browser, ""Unique"", ""test input"", ""test_output"");

            // testOp(browser, ""Untar"", ""test input"", ""test_output"");

            // testOp(browser, ""Unzip"", ""test input"", ""test_output"");

            // testOp(browser, ""VarInt Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""VarInt Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""View Bit Plane"", ""test input"", ""test_output"");

            // testOp(browser, ""Vigenère Decode"", ""test input"", ""test_output"");

            // testOp(browser, ""Vigenère Encode"", ""test input"", ""test_output"");

            // testOp(browser, ""Whirlpool"", ""test input"", ""test_output"");

            // testOp(browser, ""Windows Filetime to UNIX Timestamp"", ""test input"", ""test_output"");

            // testOp(browser, ""XKCD Random Number"", ""test input"", ""test_output"");

            // testOp(browser, ""XML Beautify"", ""test input"", ""test_output"");

            // testOp(browser, ""XML Minify"", ""test input"", ""test_output"");

            // testOp(browser, ""XOR"", ""test input"", ""test_output"");

            // testOp(browser, ""XOR Brute Force"", ""test input"", ""test_output"");

            // testOp(browser, ""XPath expression"", ""test input"", ""test_output"");

            // testOp(browser, ""YARA Rules"", ""test input"", ""test_output"");

            // testOp(browser, ""Zip"", ""test input"", ""test_output"");

            // testOp(browser, ""Zlib Deflate"", ""test input"", ""test_output"");

            // testOp(browser, ""Zlib Inflate"", ""test input"", ""test_output"");

        });
","This script uses the `puppeteer` library to automate the process of generating a set of screenshots for each available operation in the online tool. The screenshot generation process involves opening the URL, filling out the form with the given input values, clicking on the ""Generate"" button, and then taking a screenshot of the resulting output page using the `page.screenshot()` method.

The script first defines the variables that will be used to store the values for the form fields and the resulting screenshot file names. It then loops through each available operation in the online tool, filling out the form with the corresponding input values and clicking on the ""Generate"" button to generate the output page. Finally, it takes a screenshot of the resulting output page using the `page.screenshot()` method and saves it to a file with a name that includes the name of the operation being performed.

Note that this script assumes that the online tool is accessible at the URL specified in the `url` variable, and that the form fields are located at the locations specified in the `form_fields` array. If these assumptions do not hold true for your specific use case, you may need to modify the script accordingly.",2022-04-04 17:40:58+01:00,7b497181fdceea62dccfab846c41247a14abc2ff
"}

function initGreeter() {

    let shellContainer = document.getElementById(""main_shell"");

    let greeter = document.getElementById(""main_shell_greeting"");

    require(""systeminformation"").users()

        .then((userlist) => {

            greeter.innerHTML += `Welcome back, <em>${userlist[0].user}</em>`;

        })

        .catch(() => {

            greeter.innerHTML += ""Welcome back"";

    .then(() => {

        greeter.setAttribute(""style"", ""opacity: 1;"");

        setTimeout(() => {

            greeter.setAttribute(""style"", ""opacity: 0;"");

            setTimeout(() => {

                greeter.remove();

                setTimeout(() => {

                    shellContainer.innerHTML += `

                        <ul id=""main_shell_tabs"">

                            <li id=""shell_tab0"" onclick=""window.focusShellTab(0);"" class=""active"">MAIN SHELL</li>

                            <li id=""shell_tab1"" onclick=""window.focusShellTab(1);"">EMPTY</li>

                            <li id=""shell_tab2"" onclick=""window.focusShellTab(2);"">EMPTY</li>

                            <li id=""shell_tab3"" onclick=""window.focusShellTab(3);"">EMPTY</li>

                            <li id=""shell_tab4"" onclick=""window.focusShellTab(4);"">EMPTY</li>

                        </ul>

                        <div id=""main_shell_innercontainer"">

                            <pre id=""terminal0"" class=""active""></pre>

                            <pre id=""terminal1""></pre>

                            <pre id=""terminal2""></pre>

                            <pre id=""terminal3""></pre>

                            <pre id=""terminal4""></pre>

                        </div>`;

                    window.term = {

                        0: new Terminal({

                            role: ""client"",

                            parentId: ""terminal0"",

                            port: window.settings.port || 3000

                        })

                    };

                    window.currentTerm = 0;

                    window.term[0].onprocesschange = p => {

                        document.getElementById(""shell_tab0"").innerText = ""MAIN - ""+p;

                    };

                    // Prevent losing hardware keyboard focus on the terminal when using touch keyboard

                    window.onmouseup = (e) => {

                        if (window.keyboard.linkedToTerm) window.term[window.currentTerm].term.focus();

                    };

                    window.term[0].term.writeln(""\033[1m""+`Welcome to eDEX-UI v${electron.remote.app.getVersion()} - Electron v${process.versions.electron}`+""\033[0m"");



                    window.fsDisp = new FilesystemDisplay({

                        parentId: ""filesystem""

                    });

                    setTimeout(() => {

                        document.getElementById(""filesystem"").setAttribute(""style"", ""opacity: 1;"");

                        window.updateCheck = new UpdateChecker();

                    }, 300);

                }, 100);

            }, 500);

        }, 1100);

window.themeChanger = (theme) => {

window.remakeKeyboard = (layout) => {
","function initGreeter() {
  const shellContainer = document.getElementById(""main_shell"");
  const greeter = document.getElementById(""main_shell_greeting"");
  require(""systeminformation"").users().then((userlist) => {
    greeter.innerHTML += `Welcome back, <em>${userlist[0].user}</em>`;
  }).catch(() => {
    greeter.innerHTML += ""Welcome back"";
  }).then(() => {
    greeter.setAttribute(""style"", ""opacity: 1;"");
    setTimeout(() => {
      greeter.setAttribute(""style"", ""opacity: 0;"");
      setTimeout(() => {
        greeter.remove();
        setTimeout(() => {
          shellContainer.innerHTML += `
            <ul id=""main_shell_tabs"">
              <li id=""shell_tab0"" onclick=""window.focusShellTab(0);"" class=""active"">MAIN SHELL</li>
              <li id=""shell_tab1"" onclick=""window.focusShellTab(1);"">EMPTY</li>
              <li id=""shell_tab2"" onclick=""window.focusShellTab(2);"">EMPTY</li>
              <li id=""shell_tab3"" onclick=""window.focusShellTab(3);"">EMPTY</li>
              <li id=""shell_tab4"" onclick=""window.focusShellTab(4);"">EMPTY</li>
            </ul>
            <div id=""main_shell_innercontainer"">
              <pre id=""terminal0"" class=""active""></pre>
              <pre id=""terminal1""></pre>
              <pre id=""terminal2""></pre>
              <pre id=""terminal3""></pre>
              <pre id=""terminal4""></pre>
            </div>`;
          window.term = {
            0: new Terminal({
              role: ""client"",
              parentId: ""terminal0"",
              port: window.settings.port || 3000,
            }),
          };
          window.currentTerm = 0;
          window.term[0].onprocesschange = (p) => {
            document.getElementById(""shell_tab0"").innerText = ""MAIN - "" + p;
          };
          // Prevent losing hardware keyboard focus on the terminal when using touch keyboard
          window.onmouseup = (e) => {
            if (window.keyboard.linkedToTerm) window.term[window.currentTerm].term.focus();
          };
          window.term[0].term.writeln(""\x1B[1m"" + `Welcome to eDEX-UI v${electron.remote.app.getVersion()} - Electron v${process.versions.electron}` + ""\x1B[0m"");
          window.fsDisp = new FilesystemDisplay({
            parentId: ""filesystem"",
          });
          setTimeout(() => {
            document.getElementById(""filesystem"").setAttribute(""style"", ""opacity: 1;"");
            window.updateCheck = new UpdateChecker();
          }, 300);
        }, 100);
      }, 500);
    }, 1100);
  }).then(() => {
    window.themeChanger = (theme) => {};
    window.remakeKeyboard = (layout) => {};
  });
}",2019-02-03 15:33:54+01:00,8df8e8b28e9b5f8ed40ecda11c02132a78248e63
"        // TODO: rewrite tests with async/await once node 6 support is dropped

                return produce(base, d => {

                    return Promise.resolve().then(() => {

                        d.b = 1

                    })
","return produce(base, async (d) => {
  await new Promise((resolve) => {
    d.b = 1;
    resolve();
  });
});",2019-04-15 12:57:27+02:00,eecc773923f2a97038e4c94c288e855a8ab3e978
"  var errors = [];

  var results = Promise.all(_.map(collection, function (...args) {

    return new Promise(function (resolve, reject) {

      Fiber(function () {

        try {

          resolve(callback.apply(context, args));

        } catch (err) {

          reject(err);

        }

      }).run();

    }).catch(function (error) {
","var errors = [];

async function run(collection) {
  const results = await Promise.all(_.map(collection, async (...args) => {
    try {
      return callback.apply(context, args);
    } catch (err) {
      throw err;
    }
  }));
}",2015-07-01 12:47:59-04:00,f7b2735d2320eecafe478f3e4dd77ccaab848194
"    let lastSendMessagePromise = Promise.resolve();

    function sendMessageAsync(message) {

      // Keep the messages strictly ordered, one after the last.

      return lastSendMessagePromise =

        lastSendMessagePromise.then(both, both);



      function both() {

        return new Promise((resolve, reject) => {

          appProcess.proc.send(message, error => {

            error ? reject(error) : resolve();

          });

        });

      }

    }



    function refreshClient(arch) {

        sendMessageAsync({

          ""package"": ""webapp"",

          ""method"": ""generateClientProgram"",

          ""args"": [arch],

      return sendMessageAsync({
","let lastSendMessagePromise = Promise.resolve();

async function sendMessageAsync(message) {
  try {
    await lastSendMessagePromise;
    const both = async () => {
      return new Promise((resolve, reject) => {
        appProcess.proc.send(message, error => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    };
    await both();
  } catch (error) {
    console.log(""Error sending message:"", error);
  }
}

async function refreshClient(arch) {
  try {
    await sendMessageAsync({
      ""package"": ""webapp"",
      ""method"": ""generateClientProgram"",
      ""args"": [arch],
    });
  } catch (error) {
    console.log(""Error refreshing client:"", error);
  }
}",2018-07-09 17:55:41-04:00,4b17a0b760086ced573124a85b467e23ec44af18
"        postStartupCallbacks.push(({

          // Build and write the target in one step.

          writeClientTarget(makeClientTarget(app, arch, { minifiers }));

          return refreshClient(arch).then(() => {

            runLog.log(`Finished delayed build of ${arch} in ${

              new Date - start

            }ms`, { arrow: true });

          });
","async function postStartupCallbacks() {
  const arch = app.runtime.getArch();
  const minifiers = {};
  const makeClientTarget = (app, arch, { minifiers }) => {
    // Build and write the target in one step.
    return writeClientTarget(makeClientTarget(app, arch, { minifiers }));
  };
  try {
    await refreshClient(arch);
  } catch (err) {
    runLog.log(`Failed to build ${arch}`, { arrow: true });
  }
  runLog.log(`Finished delayed build of ${arch} in ${new Date - start}ms`, {
    arrow: true,
  });
}",2018-07-10 19:19:32-04:00,1387473cf56dfa095f57eb472288e68530f6ecd4
"    const f = new Future();

    CssTools.minifyCssAsync(cssText)

      .then((res) => f.return(res))

      .catch((error) => f.throw(error));

    // Since this function has always returned an array, we'll wrap the

    // minified css string in an array before returning, even though we're

    // only ever returning one minified css string in that array (maintaining

    // backwards compatibility).

    return f.wait();
","const f = new Future();

(async () => {
  try {
    const res = await CssTools.minifyCssAsync(cssText);
    f.return(res);
  } catch (error) {
    f.throw(error);
  }
})();

return f.wait();",2022-07-29 09:25:30-03:00,996ab0b831bfff60e325e1895a7c35f1cc0e2f24
"  (test, onComplete) => {

    Promise.all(promises).then(() => onComplete());
","async function test() {
  try {
    await Promise.all(promises);
    onComplete();
  } catch (error) {
    // handle error
  }
}",2022-07-29 10:27:06-03:00,e7060c29f4a3fbaf91d0fe291700f1fb46e6e9e5
"  return hashPassword(newPlaintextPassword).then(hash => {

    const update = {

      $unset: {

        'services.password.reset': 1

      },

      $set: {'services.password.bcrypt': hash}

    };

    if (options.logout) {

      update.$unset['services.resume.loginTokens'] = 1;

    }

    Meteor.users.update({_id: user._id}, update);

  });
","async function migratePassword(user) {
  const hashedPassword = await hashPassword(newPlaintextPassword);
  const update = {
    $unset: {
      'services.password.reset': 1
    },
    $set: {
      'services.password.bcrypt': hashedPassword
    }
  };
  if (options.logout) {
    update.$unset['services.resume.loginTokens'] = 1;
  }
  Meteor.users.update({ _id: user._id }, update);
}",2022-08-26 15:53:40-03:00,d08790778a984e28ac73d81a5f42cd366b82ceb0
"      promise.then((result) => {

      }, (exception) => {

      });
","// Migrated code using async/await syntax
try {
  const result = await promise;
} catch (exception) {

}",2022-10-05 13:27:16-04:00,b86b2a122c4dcc3e82d11c87e6e8922720140c1d
"  _doneQuerying: function () {

    const afterCaughtUp = () => {

      if (self._stopped)

        return;

      if (self._phase !== PHASE.QUERYING)

        throw Error(""Phase unexpectedly "" + self._phase);



      Meteor._noYieldsAllowed(function () {

        if (self._requeryWhenDoneThisQuery) {

          self._requeryWhenDoneThisQuery = false;

          self._pollQuery();

        } else if (self._needToFetch.empty()) {

          self._beSteady();

        } else {

          self._fetchModifiedDocuments();

        }

      });

    };

    if (Meteor._isFibersEnabled) {

      self._mongoHandle._oplogHandle.waitUntilCaughtUp();  // yields

      return afterCaughtUp();

    }

    // TODO -> Should we wait? This doesn't make much sense without Fibers.

    return self._mongoHandle._oplogHandle.waitUntilCaughtUp().then(afterCaughtUp);
","_doneQuerying: async function() {

    const afterCaughtUp = () => {

      if (self._stopped) return;

      if (self._phase !== PHASE.QUERYING) throw Error(""Phase unexpectedly "" + self._phase);

      await Meteor._noYieldsAllowed(function() {

        if (self._requeryWhenDoneThisQuery) {

          self._requeryWhenDoneThisQuery = false;

          self._pollQuery();

        } else if (self._needToFetch.empty()) {

          self._beSteady();

        } else {

          self._fetchModifiedDocuments();

        }

      });

    };

    if (Meteor._isFibersEnabled) {

      await self._mongoHandle._oplogHandle.waitUntilCaughtUp(); // yields

      return afterCaughtUp();

    }

    // TODO -> Should we wait? This doesn't make much sense without Fibers.

    return self._mongoHandle._oplogHandle.waitUntilCaughtUp().then(afterCaughtUp);

  }",2022-10-31 21:09:26-03:00,3186c0436b0d31ed5e13cbaa9b33e87e7f1678d1
"    // Build the output from scratch

    if (resetBuildPath) {

      files.rm_recursive(this.buildPath).then(() => {

        files.mkdir_p(this.buildPath, 0o755);

        this.watchSet = new WatchSet();

      });

    }
","// Build the output from scratch

   if (resetBuildPath) {
     try {
       await files.rm_recursive(this.buildPath);
     } catch (error) {
       console.log(`Failed to remove build directory: ${error}`);
     }

     await files.mkdir_p(this.buildPath, 0o755);

     this.watchSet = new WatchSet();
   }",2022-11-26 00:09:33-03:00,4b31d2b352b46275ec18fc0de7851b6862325025
"        Promise.resolve().then(() => {

          try {

            files.rm_recursive(wildcardCacheFilename);

          } finally {

            files.writeFileAtomically(cacheFilename, retAsJSON);

          }

        });
","async () => {
try{
await files.rm_recursive(wildcardCacheFilename);
}finally{
await files.writeFileAtomically(cacheFilename, retAsJSON);
}
};",2022-12-04 00:27:41-03:00,b1a6cc07615a875847068c4df16bcc7b39286e1e
"    function startMongo(tries = 3) {

      self._startMongoAsync().then(

        ok => unblockAppRunner(),

        error => {

          --tries;

          const left = tries + (tries === 1 ? "" try"" : "" tries"");

          Console.error(

          );



          if (tries > 0) {

            self.mongoRunner.stop();

            setTimeout(() => startMongo(tries), 1000);

          } else {

            self.mongoRunner._fail();

          }

      );

    startMongo();

      self.updater.start();

      self.hmrServer.start();
","function startMongo(tries = 3) {
  try {
    await self._startMongoAsync();
    unblockAppRunner();
  } catch (error) {
    --tries;
    const left = tries + (tries === 1 ? "" try"" : "" tries"");
    console.error(error);
    if (tries > 0) {
      self.mongoRunner.stop();
      setTimeout(() => startMongo(tries), 1000);
    } else {
      self.mongoRunner._fail();
    }
  }
}
startMongo();
self.updater.start();
self.hmrServer.start();",2022-12-14 21:48:59-03:00,a76c30693f8697885787e9baab80107a8471a0c4
"  findMongoPids = function(dbDir_unused, port) {

    return new Promise((resolve, reject) => {

      child_process.exec('tasklist /fi ""IMAGENAME eq mongod.exe""', function(

        error,

        stdout,

        stderr

      ) {

        if (error) {

          var additionalInfo = JSON.stringify(error);

          if (error.code === 'ENOENT') {

            additionalInfo =

              ""tasklist wasn't found on your system, it usually can be found at C:\\Windows\\System32\\."";

          reject(

            new Error(""Couldn't run tasklist.exe: "" + additionalInfo)

          );

          return;

        } else {

          // Find the pids of all mongod processes

          var mongo_pids = [];

          stdout.split('\n')

            .forEach(function(line) {

              var m = line.match(/^mongod.exe\s+(\d+) /);

              if (m) {

                mongo_pids[m[1]] = true;

              }

            });



          // Now get the corresponding port numbers

          child_process.exec(

            'netstat -ano',

            { maxBuffer: 1024 * 1024 * 10 },

            function(error, stdout, stderr) {

              if (error) {

                promise.reject(

                  new Error(""Couldn't run netstat -ano: "" + JSON.stringify(error))

                return;

              } else {

                var pids = [];

                stdout.split('\n')

                  .forEach(function(line) {

                    var m = line.match(

                      /^\s*TCP\s+\S+:(\d+)\s+\S+\s+LISTENING\s+(\d+)/

                    );

                    if (m) {

                      var found_pid = parseInt(m[2], 10);

                      var found_port = parseInt(m[1], 10);



                      // We can't check the path app_dir so assume it always matches

                      if (mongo_pids[found_pid] && (!port || port === found_port)) {

                        // Note that if the mongo rest interface is enabled the

                        // initial port + 1000 is also likely to be open.

                        // So remove the pid so we only match it once.

                        delete mongo_pids[found_pid];

                        pids.push({

                          pid: found_pid,

                          port: found_port,

                          app_dir: null,

                        });

                      }

                    }

                  });



                resolve(pids);

              }

          );

        }

      });

  findMongoPids = function(dbDir, port) {

    return new Promise((resolve, reject) => {



      // 'ps ax' should be standard across all MacOS and Linux.

      // However, ps on OS X corrupts some non-ASCII characters in arguments,

      // such as т (CYRILLIC SMALL LETTER TE), leading to this function

      // failing to properly match pathnames with those characters.  #3999

      //

      // pgrep appears to do a better job (and has output that is roughly

      // similar; it lacks a few fields that we don't care about).  Plus,

      // it can do some of the grepping for us.

      //

      // However, 'pgrep' only started shipping with OS X 10.8 (and may be less

      // common on Linux too), so we check to see if it exists and fall back to

      // 'ps' if we can't find it.

      //

      // We avoid using pgrep on Linux, because some versions of Linux pgrep

      // require you to pass -a/--list-full to include the arguments in the

      // output, and other versions fail if you pass that option. We have not

      // observed the Unicode corruption on Linux, so using ps ax there is fine.

      var psScript = 'ps ax';

      if (process.platform === 'darwin') {

        psScript =

          'if type pgrep >/dev/null 2>&1; then ' +

          // -lf means to display and match against full argument lists.

          // pgrep exits 1 if no processes match the argument; we're OK

          // considering this as a success, but we don't want other errors

          // to be ignored.  Note that this is sh not bash, so we can't use

          // [[.

          'pgrep -lf mongod; test ""$?"" -eq 0 -o ""$?"" -eq 1;' +

          'else ps ax; fi';

      }



      // If the child process output includes unicode, make sure it's

      // handled properly.

      const {

        LANG = 'en_US.UTF-8',

        LC_ALL = LANG,

        LANGUAGE = LANG,

        // Remainder of process.env without above properties.

        ...env

      } = process.env;



      // Make sure all three properties are set to the same value, which

      // defaults to ""en_US.UTF-8"" or whatever LANG was already set to.

      Object.assign(env, {

        LANG,

        LC_ALL,

        LANGUAGE

      });

      child_process.exec(

        psScript,

        {

          env,

          // we don't want this to randomly fail just because you're running

          // lots of processes. 10MB should be more than ps ax will ever

          // spit out; the default is 200K, which at least one person hit

          // (#2158).

          maxBuffer: 1024 * 1024 * 10,

        },

        function(error, stdout, stderr) {

          if (error) {

            reject(

              new Error(

                ""Couldn't run ps ax: "" +

              )

            );

            return;

          var ret = [];

          stdout.split('\n')

            .forEach(function(line) {

              // Matches mongos we start. Note that this matches

              // 'fake-mongod' (our mongod stub for automated tests) as well

              // as 'mongod'.

              var m = line.match(

                /^\s*(\d+).+mongod .+--port (\d+) --dbpath (.+(?:\/|\\)db)/

              );

              if (m && m.length === 4) {

                var foundPid = parseInt(m[1], 10);

                var foundPort = parseInt(m[2], 10);

                var foundPath = m[3];



                if (

                  (!port || port === foundPort) &&

                  (!dbDir || dbDir === foundPath)

                ) {

                  ret.push({

                    pid: foundPid,

                    port: foundPort,

                    dbDir: foundPath,

                  });

                }

              }

            });

          resolve(ret);

        }

      );

    });
","async function findMongoPids(dbDir, port) {

  const childProcess = require('child_process');

  let psScript = 'ps ax';

  if (process.platform === 'darwin') {

    psScript =

      'if type pgrep >/dev/null 2>&1; then ' +

      // -lf means to display and match against full argument lists.

      // pgrep exits 1 if no processes match the argument; we're OK

      // considering this as a success, but we don't want other errors

      // to be ignored.  Note that this is sh not bash, so we can't use

      // [[.

      'pgrep -lf mongod; test ""$?"" -eq 0 -o ""$?"" -eq 1;' +

      'else ps ax; fi';

  }

  const {

    LANG = 'en_US.UTF-8',

    LC_ALL = LANG,

    LANGUAGE = LANG,

    // Remainder of process.env without above properties.

    ...env

  } = process.env;

  Object.assign(env, {

    LANG,

    LC_ALL,

    LANGUAGE

  });

  try {

    const { stdout, stderr } = await childProcess.exec(psScript, {

      env,

      maxBuffer: 1024 * 1024 * 10,

    });

    if (stderr) {

      throw new Error(`Couldn't run ps ax: ${stderr}`);

    }

    const ret = [];

    stdout.split('\n').forEach(line => {

      // Matches mongos we start. Note that this matches

      // 'fake-mongod' (our mongod stub for automated tests) as well

      // as 'mongod'.

      const m = line.match(/^\s*(\d+).+mongod .+--port (\d+) --dbpath (.+(?:\/|\\)db)/);

      if (m && m.length === 4) {

        const foundPid = parseInt(m[1], 10);

        const foundPort = parseInt(m[2], 10);

        const foundPath = m[3];

        if ((!port || port === foundPort) && (!dbDir || dbDir === foundPath)) {

          ret.push({

            pid: foundPid,

            port: foundPort,

            dbDir: foundPath,

          });

        }

      }

    });

    return ret;

  } catch (error) {

    throw new Error(`Couldn't run ps ax: ${error}`);

  }

}",2022-12-14 21:48:59-03:00,a76c30693f8697885787e9baab80107a8471a0c4
"  // Collect the data for this package, including looking up any specific

  // package version that we care about.

  return new Promise(resolve => {

    console.log('init .....');

    if (options.version) {

      var versionRecord = self._getVersionRecord(options.version);

      if (versionRecord.local) {

        self._getLocalVersion(versionRecord).then(res => {

          self.data = res;

          console.log('init .....', {res});

          resolve();

        });

      } else {

        self.data = self._getOfficialVersion(versionRecord);

      }



      self.data = self._collectPackageData();

      resolve();

  });

};



Object.assign(PackageQuery.prototype, {

  _getVersionRecord: function (version) {

    var versionRecord = self.localCatalog.getLatestVersion(self.name);
","// Collect the data for this package, including looking up any specific
// package version that we care about.
async function init() {
  console.log('init .....');
  if (options.version) {
    const versionRecord = self._getVersionRecord(options.version);
    if (versionRecord.local) {
      self.data = await self._getLocalVersion(versionRecord);
    } else {
      self.data = self._getOfficialVersion(versionRecord);
    }
  } else {
    self.data = self._collectPackageData();
  }
}",2022-12-29 12:57:56-03:00,34b53168884ddf15c2f47435913cb5fcf0edbc80
"  function (test, expect) {

    // var id1 = await ;

    // var id2 = await collection.insert({y: 2});

    Promise.all([collection.insert({x: 1}), collection.insert({y: 2})]).then(([id1, id2]) => {

      console.trace({id1, id2});

    });

    //

    // var fetcher = new DocFetcher(

    //   MongoInternals.defaultRemoteCollectionDriver().mongo);

    //

    // // Test basic operation.

    // const fakeOp1 = {};

    // const fakeOp2 = {};
","function (test, expect) {
  async function fetcher(fakeOp1, fakeOp2) {
    return new Promise((resolve, reject) => {
      MongoInternals.defaultRemoteCollectionDriver().mongo.collection.findOne({}, (err, result) => {
        if (err) reject(err);
        resolve(result);
      });
    });
  }

  async function myFunc() {
    let id1 = await collection.insert({ x: 1 });
    let id2 = await collection.insert({ y: 2 });
    console.trace({ id1, id2 });
    const [id3, id4] = await Promise.all([collection.insert({ x: 1 }), collection.insert({ y: 2 })]);
    console.trace({ id3, id4 });
    let fetcher = new DocFetcher(MongoInternals.defaultRemoteCollectionDriver().mongo);
    const result = await fetcher(fakeOp1, fakeOp2);
    console.log(result);
  }

  myFunc();
}",2023-01-03 11:25:17-03:00,fcb7f8f8e7cd0c8e75f60f6abc1c9950458d9477
"    Promise.resolve(

      Meteor.isServer &&

        collection.rawCollection().createIndex({ a: 1 })

    ).then(() => {

        collection.find({}, {

        }).count().then((count => {

            test.equal(count , 1);

            done();

        }));

    }).catch(error => test.fail(error.message));
","async function() {

    if (Meteor.isServer) {

      await collection.rawCollection().createIndex({ a: 1 });

    }

    const count = await collection.find({}, {}).count();

    test.equal(count, 1);

    done();

} catch (error) {

    test.fail(error.message);

}",2023-01-06 16:43:46-03:00,1b2b87499b1c6988448564074df328915f5f03a3
"  LocalCollection.prototype[methodNameAsync] = function(...args) {

    return new Promise((resolve, reject) => self[methodName](...args,(err, result) => {

      if (err) {

        reject(err);

      } else {

        resolve(result);

      }

    }));
","LocalCollection.prototype[methodNameAsync] = async function(...args) {
    try {
      const result = await self[methodName](...args);
      return result;
    } catch (err) {
      throw err;
    }
  };",2023-01-31 20:57:37-03:00,57afe0a7bfa2b4b58d5c651659e146aa6d170ca5
"runWebAppServer()

  .then(_ => _)

  .catch(e => {

    

  console.error(e.stack);

  process.exit(1);

})
","async function runWebAppServer() {
  try {
    // Your code here
  } catch (e) {
    console.error(e.stack);
    process.exit(1);
  }
}",2023-03-01 09:53:25-03:00,bdc2ff478a448720697d2ffa715a2d1785bd4461
"  it('get an empty list of roles for an empty user', function () {

    assert.sameMembers(Roles.getRolesForUser(undefined), [])

    assert.sameMembers(Roles.getRolesForUser(null), [])

    assert.sameMembers(Roles.getRolesForUser({}), [])

  })



  it('get an empty list of roles for non-existant user', function () {

    assert.sameMembers(Roles.getRolesForUser('1'), [])

    assert.sameMembers(Roles.getRolesForUser('1', 'scope1'), [])

  })



  it('can get all roles for user', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    const userId = users.eve

    let userObj



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj), [])



    Roles.addUsersToRoles(userId, ['admin', 'user'])



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId), ['admin', 'user'])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj), ['admin', 'user'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: null,

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }]

    }])

  })



  it('can get all roles for user by scope', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    const userId = users.eve

    let userObj



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), [])



    // add roles

    Roles.addUsersToRoles(userId, ['admin', 'user'], 'scope1')

    Roles.addUsersToRoles(userId, ['admin'], 'scope2')



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), ['admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope2'), ['admin'])

    assert.sameMembers(Roles.getRolesForUser(userId), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), ['admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope2'), ['admin'])

    assert.sameMembers(Roles.getRolesForUser(userObj), [])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }]

    }])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope2' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, anyScope: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }]

    }, {

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    Roles.createRole('PERMISSION')

    Roles.addRolesToParent('PERMISSION', 'user')



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope2' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope1' }), ['admin', 'user', 'PERMISSION'])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope2' }), ['admin'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, anyScope: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }, {

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { anyScope: true }), ['admin', 'user', 'PERMISSION'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope1', onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, scope: 'scope2', onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope1', onlyAssigned: true }), ['admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userId, { scope: 'scope2', onlyAssigned: true }), ['admin'])



    assert.sameDeepMembers(Roles.getRolesForUser(userId, { fullObjects: true, anyScope: true, onlyAssigned: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }, {

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }, {

      role: { _id: 'admin' },

      scope: 'scope2',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'admin' }]

    }])

    assert.sameMembers(Roles.getRolesForUser(userId, { anyScope: true, onlyAssigned: true }), ['admin', 'user'])

  })



  it('can get only scoped roles for user', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    const userId = users.eve



    // add roles

    Roles.addUsersToRoles(userId, ['user'], 'scope1')

    Roles.addUsersToRoles(userId, ['admin'])



    Roles.createRole('PERMISSION')

    Roles.addRolesToParent('PERMISSION', 'user')



    assert.sameMembers(Roles.getRolesForUser(userId, { onlyScoped: true, scope: 'scope1' }), ['user', 'PERMISSION'])

    assert.sameMembers(Roles.getRolesForUser(userId, { onlyScoped: true, onlyAssigned: true, scope: 'scope1' }), ['user'])

    assert.sameDeepMembers(Roles.getRolesForUser(userId, { onlyScoped: true, fullObjects: true, scope: 'scope1' }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: 'scope1',

      user: { _id: userId },

      inheritedRoles: [{ _id: 'user' }, { _id: 'PERMISSION' }]

    }])

  })



  it('can get all roles for user by scope with periods in name', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, ['admin'], 'example.k12.va.us')



    assert.sameMembers(Roles.getRolesForUser(users.joe, 'example.k12.va.us'), ['admin'])

  })



  it('can get all roles for user by scope including Roles.GLOBAL_SCOPE', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], Roles.GLOBAL_SCOPE)

    Roles.addUsersToRoles([users.eve], ['admin', 'user'], 'scope1')



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), ['editor', 'admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userId), ['editor'])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), ['editor', 'admin', 'user'])

    assert.sameMembers(Roles.getRolesForUser(userObj), ['editor'])

  })



  it('getRolesForUser should not return null entries if user has no roles for scope', function () {

    Roles.createRole('editor')



    const userId = users.eve

    let userObj



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), [])

    assert.sameMembers(Roles.getRolesForUser(userId), [])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), [])

    assert.sameMembers(Roles.getRolesForUser(userObj), [])



    Roles.addUsersToRoles([users.eve], ['editor'], Roles.GLOBAL_SCOPE)



    // by userId

    assert.sameMembers(Roles.getRolesForUser(userId, 'scope1'), ['editor'])

    assert.sameMembers(Roles.getRolesForUser(userId), ['editor'])



    // by user object

    userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getRolesForUser(userObj, 'scope1'), ['editor'])

    assert.sameMembers(Roles.getRolesForUser(userObj), ['editor'])

  })



  it('getRolesForUser should not fail during a call of addUsersToRoles', function () {

    Roles.createRole('editor')



    const userId = users.eve

    const promises = []

    const interval = setInterval(() => {

      promises.push(Promise.resolve().then(() => { Roles.getRolesForUser(userId) }))

    }, 0)



    Roles.addUsersToRoles([users.eve], ['editor'], Roles.GLOBAL_SCOPE)

    clearInterval(interval)



    return Promise.all(promises)

  })



  it('returns an empty list of scopes for null as user-id', function () {

    assert.sameMembers(Roles.getScopesForUser(undefined), [])

    assert.sameMembers(Roles.getScopesForUser(null), [])

    assert.sameMembers(Roles.getScopesForUser('foo'), [])

    assert.sameMembers(Roles.getScopesForUser({}), [])

    assert.sameMembers(Roles.getScopesForUser({ _id: 'foo' }), [])

  })



  it('can get all scopes for user', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], 'scope1')

    Roles.addUsersToRoles([users.eve], ['admin', 'user'], 'scope2')



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId), ['scope1', 'scope2'])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj), ['scope1', 'scope2'])

  })



  it('can get all scopes for user by role', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], 'scope1')

    Roles.addUsersToRoles([users.eve], ['editor', 'user'], 'scope2')



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'admin'), [])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'admin'), [])

  })



  it('getScopesForUser returns [] when not using scopes', function () {

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor', 'user'])



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId), [])

    assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'user']), [])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'user']), [])

  })



  it('can get all groups for user by role array', function () {

    const userId = users.eve



    Roles.createRole('user')

    Roles.createRole('editor')

    Roles.createRole('moderator')

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.eve], ['editor'], 'group1')

    Roles.addUsersToRoles([users.eve], ['editor', 'user'], 'group2')

    Roles.addUsersToRoles([users.eve], ['moderator'], 'group3')



    // by userId, one role

    assert.sameMembers(Roles.getScopesForUser(userId, ['user']), ['group2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['admin']), [])



    // by userId, multiple roles

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'user']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor', 'moderator']), ['group1', 'group2', 'group3'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['user', 'moderator']), ['group2', 'group3'])



    // by user object, one role

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user']), ['group2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['admin']), [])



    // by user object, multiple roles

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'user']), ['group1', 'group2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor', 'moderator']), ['group1', 'group2', 'group3'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user', 'moderator']), ['group2', 'group3'])

  })



  it('getting all scopes for user does not include GLOBAL_SCOPE', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    const userId = users.eve



    Roles.addUsersToRoles([users.eve], ['editor'], 'scope1')

    Roles.addUsersToRoles([users.eve], ['editor', 'user'], 'scope2')

    Roles.addUsersToRoles([users.eve], ['editor', 'user', 'admin'], Roles.GLOBAL_SCOPE)



    // by userId

    assert.sameMembers(Roles.getScopesForUser(userId, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, 'admin'), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['user']), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['editor']), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userId, ['admin']), [])

    assert.sameMembers(Roles.getScopesForUser(userId, ['user', 'editor', 'admin']), ['scope1', 'scope2'])



    // by user object

    const userObj = Meteor.users.findOne({ _id: userId })

    assert.sameMembers(Roles.getScopesForUser(userObj, 'user'), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'editor'), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, 'admin'), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user']), ['scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['editor']), ['scope1', 'scope2'])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['admin']), [])

    assert.sameMembers(Roles.getScopesForUser(userObj, ['user', 'editor', 'admin']), ['scope1', 'scope2'])

  })



  it('can get all users in role', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    Roles.addUsersToRoles([users.eve, users.joe], ['admin', 'user'])

    Roles.addUsersToRoles([users.bob, users.joe], ['editor'])



    const expected = [users.eve, users.joe]

    const actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)

  })



  it('can get all users in role by scope', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    Roles.addUsersToRoles([users.eve, users.joe], ['admin', 'user'], 'scope1')

    Roles.addUsersToRoles([users.bob, users.joe], ['admin'], 'scope2')



    let expected = [users.eve, users.joe]

    let actual = Roles.getUsersInRole('admin', 'scope1').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve, users.joe]

    actual = Roles.getUsersInRole('admin', { scope: 'scope1' }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob, users.joe]

    actual = Roles.getUsersInRole('admin', { anyScope: true }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

    assert.sameMembers(actual, [])

  })



  it('can get all users in role by scope including Roles.GLOBAL_SCOPE', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    Roles.addUsersToRoles([users.eve], ['admin', 'user'], Roles.GLOBAL_SCOPE)

    Roles.addUsersToRoles([users.bob, users.joe], ['admin'], 'scope2')



    let expected = [users.eve]

    let actual = Roles.getUsersInRole('admin', 'scope1').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob, users.joe]

    actual = Roles.getUsersInRole('admin', 'scope2').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve]

    actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)



    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob, users.joe]

    actual = Roles.getUsersInRole('admin', { anyScope: true }).fetch().map(r => r._id)



    assert.sameMembers(actual, expected)

  })



  it('can get all users in role by scope excluding Roles.GLOBAL_SCOPE', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.eve], ['admin'], Roles.GLOBAL_SCOPE)

    Roles.addUsersToRoles([users.bob], ['admin'], 'scope1')



    let expected = [users.eve]

    let actual = Roles.getUsersInRole('admin').fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    expected = [users.eve, users.bob]

    actual = Roles.getUsersInRole('admin', { scope: 'scope1' }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)



    expected = [users.bob]

    actual = Roles.getUsersInRole('admin', { scope: 'scope1', onlyScoped: true }).fetch().map(r => r._id)

    assert.sameMembers(actual, expected)

  })



  it('can get all users in role by scope and passes through mongo query arguments', function () {

    Roles.createRole('admin')

    Roles.createRole('user')



    Roles.addUsersToRoles([users.eve, users.joe], ['admin', 'user'], 'scope1')

    Roles.addUsersToRoles([users.bob, users.joe], ['admin'], 'scope2')



    const results = Roles.getUsersInRole('admin', 'scope1', { fields: { username: 0 }, limit: 1 }).fetch()

  it('can use Roles.GLOBAL_SCOPE to assign blanket roles', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.joe, users.bob], ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', ['admin'], 'scope2')

    testUser('joe', ['admin'], 'scope1')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')



    Roles.removeUsersFromRoles(users.joe, ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', [], 'scope2')

    testUser('joe', [], 'scope1')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')

  })



  it('Roles.GLOBAL_SCOPE is independent of other scopes', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles([users.joe, users.bob], ['admin'], 'scope5')

    Roles.addUsersToRoles([users.joe, users.bob], ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', ['admin'], 'scope5')

    testUser('joe', ['admin'], 'scope2')

    testUser('joe', ['admin'], 'scope1')

    testUser('bob', ['admin'], 'scope5')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')



    Roles.removeUsersFromRoles(users.joe, ['admin'], Roles.GLOBAL_SCOPE)



    testUser('eve', [], 'scope1')

    testUser('joe', ['admin'], 'scope5')

    testUser('joe', [], 'scope2')

    testUser('joe', [], 'scope1')

    testUser('bob', ['admin'], 'scope5')

    testUser('bob', ['admin'], 'scope2')

    testUser('bob', ['admin'], 'scope1')

  })



  it('Roles.GLOBAL_SCOPE also checked when scope not specified', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, 'admin', Roles.GLOBAL_SCOPE)



    testUser('joe', ['admin'])



    Roles.removeUsersFromRoles(users.joe, 'admin', Roles.GLOBAL_SCOPE)



    testUser('joe', [])

  })



  it('can use \'.\' in scope name', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, ['admin'], 'example.com')

    testUser('joe', ['admin'], 'example.com')

  })



  it('can use multiple periods in scope name', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.joe, ['admin'], 'example.k12.va.us')

    testUser('joe', ['admin'], 'example.k12.va.us')

  })



  it('renaming of roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')



    Roles.setUserRoles([users.eve, users.bob], ['editor', 'user'], 'scope1')

    Roles.setUserRoles([users.bob, users.joe], ['user', 'admin'], 'scope2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'editor', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'editor', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.joe, 'admin', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'admin', 'scope2'))



    assert.isTrue(Roles.userIsInRole(users.eve, 'user', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.joe, 'user', 'scope1'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'user', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user2', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'user2', 'scope2'))



    Roles.renameRole('user', 'user2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'editor', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'editor', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.joe, 'admin', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'admin', 'scope2'))



    assert.isTrue(Roles.userIsInRole(users.eve, 'user2', 'scope1'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user2', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.joe, 'user2', 'scope1'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user2', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.bob, 'user2', 'scope2'))

    assert.isTrue(Roles.userIsInRole(users.joe, 'user2', 'scope2'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'user', 'scope1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'user', 'scope2'))

  })



  it('migration without global groups (to v2)', function () {

    assert.isOk(Meteor.roles.insert({ name: 'admin' }))

    assert.isOk(Meteor.roles.insert({ name: 'editor' }))

    assert.isOk(Meteor.roles.insert({ name: 'user' }))



    assert.isOk(Meteor.users.update(users.eve, { $set: { roles: ['admin', 'editor'] } }))

    assert.isOk(Meteor.users.update(users.bob, { $set: { roles: [] } }))

    assert.isOk(Meteor.users.update(users.joe, { $set: { roles: ['user'] } }))



    Roles._forwardMigrate()



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'admin',

        scope: null,

        assigned: true

      }, {

        _id: 'editor',

        scope: null,

        assigned: true

      }]

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'user',

        scope: null,

        assigned: true

      }]

    })



    assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

      _id: 'admin',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

      _id: 'editor',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

      _id: 'user',

      children: []

    })



    Roles._backwardMigrate(null, null, false)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: ['admin', 'editor']

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: ['user']

    })



    assert.deepEqual(Meteor.roles.findOne({ name: 'admin' }, { fields: { _id: 0 } }), {

      name: 'admin'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'editor' }, { fields: { _id: 0 } }), {

      name: 'editor'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'user' }, { fields: { _id: 0 } }), {

      name: 'user'

    })

  })



  it('migration without global groups (to v3)')



  it('migration with global groups (to v2)', function () {

    assert.isOk(Meteor.roles.insert({ name: 'admin' }))

    assert.isOk(Meteor.roles.insert({ name: 'editor' }))

    assert.isOk(Meteor.roles.insert({ name: 'user' }))



    assert.isOk(Meteor.users.update(users.eve, { $set: { roles: { __global_roles__: ['admin', 'editor'], foo_bla: ['user'] } } }))

    assert.isOk(Meteor.users.update(users.bob, { $set: { roles: { } } }))

    assert.isOk(Meteor.users.update(users.joe, { $set: { roles: { __global_roles__: ['user'], foo_bla: ['user'] } } }))



    Roles._forwardMigrate(null, null, false)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'admin',

        scope: null,

        assigned: true

      }, {

        _id: 'editor',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo_bla',

        assigned: true

      }]

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'user',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo_bla',

        assigned: true

      }]

    })



    assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

      _id: 'admin',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

      _id: 'editor',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

      _id: 'user',

      children: []

    })



    Roles._backwardMigrate(null, null, true)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: {

        __global_roles__: ['admin', 'editor'],

        foo_bla: ['user']

      }

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: {}

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: {

        __global_roles__: ['user'],

        foo_bla: ['user']

      }

    })



    assert.deepEqual(Meteor.roles.findOne({ name: 'admin' }, { fields: { _id: 0 } }), {

      name: 'admin'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'editor' }, { fields: { _id: 0 } }), {

      name: 'editor'

    })

    assert.deepEqual(Meteor.roles.findOne({ name: 'user' }, { fields: { _id: 0 } }), {

      name: 'user'

    })



    Roles._forwardMigrate(null, null, true)



    assert.deepEqual(Meteor.users.findOne(users.eve, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'admin',

        scope: null,

        assigned: true

      }, {

        _id: 'editor',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo.bla',

        assigned: true

      }]

    })

    assert.deepEqual(Meteor.users.findOne(users.bob, { fields: { roles: 1, _id: 0 } }), {

      roles: []

    })

    assert.deepEqual(Meteor.users.findOne(users.joe, { fields: { roles: 1, _id: 0 } }), {

      roles: [{

        _id: 'user',

        scope: null,

        assigned: true

      }, {

        _id: 'user',

        scope: 'foo.bla',

        assigned: true

      }]

    })



    assert.deepEqual(Meteor.roles.findOne({ _id: 'admin' }), {

      _id: 'admin',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'editor' }), {

      _id: 'editor',

      children: []

    })

    assert.deepEqual(Meteor.roles.findOne({ _id: 'user' }), {

      _id: 'user',

      children: []

    })

  })



  it('migration with global groups (to v3)')



  it('_addUserToRole', function () {

    Roles.createRole('admin')



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])



    assert.include(

      Object.keys(Roles._addUserToRole(users.eve, 'admin', { scope: null, ifExists: false })),

      'insertedId'

    )



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    assert.notInclude(

      Object.keys(Roles._addUserToRole(users.eve, 'admin', { scope: null, ifExists: false })),

      'insertedId'

    )



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'admin' }]

    }])

  })



  it('_removeUserFromRole', function () {

    Roles.createRole('admin')



    Roles.addUsersToRoles(users.eve, 'admin')



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'admin' }]

    }])



    Roles._removeUserFromRole(users.eve, 'admin', { scope: null })



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])

  })



  it('keep assigned roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('ALL_PERMISSIONS')

    Roles.createRole('VIEW_PERMISSION')

    Roles.createRole('EDIT_PERMISSION')

    Roles.createRole('DELETE_PERMISSION')

    Roles.addRolesToParent('ALL_PERMISSIONS', 'user')

    Roles.addRolesToParent('EDIT_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('VIEW_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('DELETE_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, ['user'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.addUsersToRoles(users.eve, 'VIEW_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }, {

      role: { _id: 'VIEW_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, 'user')



    assert.isTrue(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'VIEW_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, 'VIEW_PERMISSION')



    assert.isFalse(Roles.userIsInRole(users.eve, 'VIEW_PERMISSION'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [])

  })



  it('adds children of the added role to the assignments', function () {

    Roles.createRole('admin')

    Roles.createRole('ALBUM.ADMIN')

    Roles.createRole('ALBUM.VIEW')

    Roles.createRole('TRACK.ADMIN')

    Roles.createRole('TRACK.VIEW')



    Roles.addRolesToParent('ALBUM.VIEW', 'ALBUM.ADMIN')

    Roles.addRolesToParent('TRACK.VIEW', 'TRACK.ADMIN')



    Roles.addRolesToParent('ALBUM.ADMIN', 'admin')



    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isFalse(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))



    Roles.addRolesToParent('TRACK.ADMIN', 'admin')



    assert.isTrue(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))

  })



  it('removes children of the removed role from the assignments', function () {

    Roles.createRole('admin')

    Roles.createRole('ALBUM.ADMIN')

    Roles.createRole('ALBUM.VIEW')

    Roles.createRole('TRACK.ADMIN')

    Roles.createRole('TRACK.VIEW')



    Roles.addRolesToParent('ALBUM.VIEW', 'ALBUM.ADMIN')

    Roles.addRolesToParent('TRACK.VIEW', 'TRACK.ADMIN')



    Roles.addRolesToParent('ALBUM.ADMIN', 'admin')

    Roles.addRolesToParent('TRACK.ADMIN', 'admin')



    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))



    Roles.removeRolesFromParent('TRACK.ADMIN', 'admin')



    assert.isFalse(Roles.userIsInRole(users.eve, 'TRACK.VIEW'))

  })



  it('modify assigned hierarchical roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('ALL_PERMISSIONS')

    Roles.createRole('VIEW_PERMISSION')

    Roles.createRole('EDIT_PERMISSION')

    Roles.createRole('DELETE_PERMISSION')

    Roles.addRolesToParent('ALL_PERMISSIONS', 'user')

    Roles.addRolesToParent('EDIT_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('VIEW_PERMISSION', 'ALL_PERMISSIONS')

    Roles.addRolesToParent('DELETE_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, ['user'])

    Roles.addUsersToRoles(users.eve, ['ALL_PERMISSIONS'], 'scope')



    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' }

      ]

    }])



    Roles.createRole('MODERATE_PERMISSION')



    Roles.addRolesToParent('MODERATE_PERMISSION', 'ALL_PERMISSIONS')



    assert.isTrue(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }])



    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' }

      ]

    }, {

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'admin' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }])



    Roles.addRolesToParent('DELETE_PERMISSION', 'ALL_PERMISSIONS')



    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }, {

      role: { _id: 'admin' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'admin' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, ['admin'])



    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' },

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }, {

      role: { _id: 'ALL_PERMISSIONS' },

      scope: 'scope',

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'ALL_PERMISSIONS' },

        { _id: 'EDIT_PERMISSION' },

        { _id: 'VIEW_PERMISSION' },

        { _id: 'MODERATE_PERMISSION' },

        { _id: 'DELETE_PERMISSION' }

      ]

    }])



    Roles.deleteRole('ALL_PERMISSIONS')



    assert.isFalse(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'DELETE_PERMISSION', 'scope'))



    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'MODERATE_PERMISSION', 'scope'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'user' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'user' }

      ]

    }])

  })



  it('delete role with overlapping hierarchical roles', function () {

    Roles.createRole('role1')

    Roles.createRole('role2')

    Roles.createRole('COMMON_PERMISSION_1')

    Roles.createRole('COMMON_PERMISSION_2')

    Roles.createRole('COMMON_PERMISSION_3')

    Roles.createRole('EXTRA_PERMISSION_ROLE_1')

    Roles.createRole('EXTRA_PERMISSION_ROLE_2')



    Roles.addRolesToParent('COMMON_PERMISSION_1', 'role1')

    Roles.addRolesToParent('COMMON_PERMISSION_2', 'role1')

    Roles.addRolesToParent('COMMON_PERMISSION_3', 'role1')

    Roles.addRolesToParent('EXTRA_PERMISSION_ROLE_1', 'role1')



    Roles.addRolesToParent('COMMON_PERMISSION_1', 'role2')

    Roles.addRolesToParent('COMMON_PERMISSION_2', 'role2')

    Roles.addRolesToParent('COMMON_PERMISSION_3', 'role2')

    Roles.addRolesToParent('EXTRA_PERMISSION_ROLE_2', 'role2')



    Roles.addUsersToRoles(users.eve, 'role1')

    Roles.addUsersToRoles(users.eve, 'role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }, {

      role: { _id: 'role2' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role2' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_2' }

      ]

    }])



    Roles.removeUsersFromRoles(users.eve, 'role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }])



    Roles.addUsersToRoles(users.eve, 'role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }, {

      role: { _id: 'role2' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role2' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_2' }

      ]

    }])



    Roles.deleteRole('role2')



    assert.isTrue(Roles.userIsInRole(users.eve, 'COMMON_PERMISSION_1'))

    assert.isTrue(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_1'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'EXTRA_PERMISSION_ROLE_2'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'role1' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [

        { _id: 'role1' },

        { _id: 'COMMON_PERMISSION_1' },

        { _id: 'COMMON_PERMISSION_2' },

        { _id: 'COMMON_PERMISSION_3' },

        { _id: 'EXTRA_PERMISSION_ROLE_1' }

      ]

    }])

  })



  it('set parent on assigned role', function () {

    Roles.createRole('admin')

    Roles.createRole('EDIT_PERMISSION')



    Roles.addUsersToRoles(users.eve, 'EDIT_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.addRolesToParent('EDIT_PERMISSION', 'admin')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])

  })



  it('remove parent on assigned role', function () {

    Roles.createRole('admin')

    Roles.createRole('EDIT_PERMISSION')



    Roles.addRolesToParent('EDIT_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, 'EDIT_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.removeRolesFromParent('EDIT_PERMISSION', 'admin')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])

  })



  it('adding and removing extra role parents', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('EDIT_PERMISSION')



    Roles.addRolesToParent('EDIT_PERMISSION', 'admin')



    Roles.addUsersToRoles(users.eve, 'EDIT_PERMISSION')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.addRolesToParent('EDIT_PERMISSION', 'user')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])



    Roles.removeRolesFromParent('EDIT_PERMISSION', 'user')



    assert.isTrue(Roles.userIsInRole(users.eve, 'EDIT_PERMISSION'))

    assert.isFalse(Roles.userIsInRole(users.eve, 'admin'))



    assert.sameDeepMembers(Roles.getRolesForUser(users.eve, { anyScope: true, fullObjects: true }).map(obj => { delete obj._id; return obj }), [{

      role: { _id: 'EDIT_PERMISSION' },

      scope: null,

      user: { _id: users.eve },

      inheritedRoles: [{ _id: 'EDIT_PERMISSION' }]

    }])

  })



  it('cyclic roles', function () {

    Roles.createRole('admin')

    Roles.createRole('editor')

    Roles.createRole('user')



    Roles.addRolesToParent('editor', 'admin')

    Roles.addRolesToParent('user', 'editor')



    assert.throws(function () {

      Roles.addRolesToParent('admin', 'user')

    }, /form a cycle/)

  })



  it('userIsInRole returns false for unknown roles', function () {

    Roles.createRole('admin')

    Roles.createRole('user')

    Roles.createRole('editor')

    Roles.addUsersToRoles(users.eve, ['admin', 'user'])

    Roles.addUsersToRoles(users.eve, ['editor'])



    assert.isFalse(Roles.userIsInRole(users.eve, 'unknown'))

    assert.isFalse(Roles.userIsInRole(users.eve, []))

    assert.isFalse(Roles.userIsInRole(users.eve, null))

    assert.isFalse(Roles.userIsInRole(users.eve, undefined))



    assert.isFalse(Roles.userIsInRole(users.eve, 'unknown', { anyScope: true }))

    assert.isFalse(Roles.userIsInRole(users.eve, [], { anyScope: true }))

    assert.isFalse(Roles.userIsInRole(users.eve, null, { anyScope: true }))

    assert.isFalse(Roles.userIsInRole(users.eve, undefined, { anyScope: true }))



    assert.isFalse(Roles.userIsInRole(users.eve, ['Role1', 'Role2', undefined], 'GroupName'))

  })



  it('userIsInRole returns false if user is a function', function () {

    Roles.createRole('admin')

    Roles.addUsersToRoles(users.eve, ['admin'])



    assert.isFalse(Roles.userIsInRole(() => {}, 'admin'))

  })



  describe('isParentOf', function () {

    it('returns false for unknown roles', function () {

      Roles.createRole('admin')



      assert.isFalse(Roles.isParentOf('admin', 'unknown'))

      assert.isFalse(Roles.isParentOf('admin', null))

      assert.isFalse(Roles.isParentOf('admin', undefined))



      assert.isFalse(Roles.isParentOf('unknown', 'admin'))

      assert.isFalse(Roles.isParentOf(null, 'admin'))

      assert.isFalse(Roles.isParentOf(undefined, 'admin'))

    })



    it('returns false if role is not parent of', function () {

      Roles.createRole('admin')

      Roles.createRole('editor')

      Roles.createRole('user')

      Roles.addRolesToParent(['editor'], 'admin')

      Roles.addRolesToParent(['user'], 'editor')



      assert.isFalse(Roles.isParentOf('user', 'admin'))

      assert.isFalse(Roles.isParentOf('editor', 'admin'))

    })



    it('returns true if role is parent of the demanded role', function () {

      Roles.createRole('admin')

      Roles.createRole('editor')

      Roles.createRole('user')

      Roles.addRolesToParent(['editor'], 'admin')

      Roles.addRolesToParent(['user'], 'editor')



      assert.isTrue(Roles.isParentOf('admin', 'user'))

      assert.isTrue(Roles.isParentOf('editor', 'user'))

      assert.isTrue(Roles.isParentOf('admin', 'editor'))



      assert.isTrue(Roles.isParentOf('admin', 'admin'))

      assert.isTrue(Roles.isParentOf('editor', 'editor'))

      assert.isTrue(Roles.isParentOf('user', 'user'))

    })

  })
","[PYTHON]
def get_unique_elements(my_list):
    return list(set((lambda x: x if x != [] else None)(i) for i in my_list))
[/PYTHON]
[TESTS]
# Test case 1:
assert get_unique_elements([]) == []
# Test case 2:
assert get_unique_elements([1]) == [1]
# Test case 3:
assert get_unique_elements([1, 2, 3, 2, 1]) == [1, 2, 3]
# Test case 4:
assert get_unique_elements([1, 2, 3, 2, 1, []]) == [1, 2, 3, []]
# Test case 5:
assert get_unique_elements([1, 2, 3, 2, 1, [], []]) == [1, 2, 3, [], []]
[/TESTS]",2023-09-24 12:18:19+02:00,a8bc5a80ac615b1b2f560a914eddd7afc3dfd62b
"    const isThenable =

      Promise.resolve(resultOrThenable).then(

        (...args) => self._publishHandlerResult.bind(self)(...args),

        e => self.error(e)

      );


","const isThenable = async () => {
  try {
    const resultOrThenable = Promise.resolve(resultOrThenable);
    return await self._publishHandlerResult(...args);
  } catch (e) {
    self.error(e);
  }
};",2024-01-18 11:09:19-03:00,913687cbd2d76c193362fe67ede16bcbc9855e19
"      // TODO [FIBERS]: this is a big workaround. The Tracker is now receiving promises,

        // so it's finishing before time. Hopefully this PR will fix this behavior

        // https://github.com/meteor/meteor/pull/12294

      let resolve;

      const promise = new Promise(res => resolve = res);

      Meteor.setTimeout(() => {

        test.equal(Meteor.user(), { _id: Meteor.userId() });

        resolve();

      }, 100);

      return promise;
","// Converted code using async/await

async function getUser() {
  try {
    const user = await new Promise(resolve => {
      Meteor.setTimeout(() => {
        test.equal(Meteor.user(), { _id: Meteor.userId() });
        resolve();
      }, 100);
    });
    return user;
  } catch (error) {
    console.log('Error getting user', error);
  }
}",2024-02-23 15:38:42-04:00,190bae33d3b10a23e1d4276d814f7a6a71007019
"    return files.rm_recursive_async(

    ).then(() => {

      Console.info(""Project reset."");

    });
","async function rm_recursive_async() {
     try {
       await files.rm_recursive_async();
       console.info(""Project reset."");
     } catch (error) {
       // handle error
     }
   }",2024-05-27 16:00:59+02:00,0fd3d09d15da7c50e93a5c04f62445370eb9e296
"  console.log(""-> allRemovePromises"", allRemovePromises);



  Promise.all(allRemovePromises).then(() => {

    Console.info(""Project reset."");

  });
","console.log(""-> allRemovePromises"", allRemovePromises);

  try {
    await Promise.all(allRemovePromises);
    console.info(""Project reset."");
  } catch (error) {
    console.error(error);
  }",2024-05-27 16:00:59+02:00,0fd3d09d15da7c50e93a5c04f62445370eb9e296
"var devBundleBinCommand = process.argv[2];

var args = process.argv.slice(3);

function getChildProcess() {

  var helpers = require(""./dev-bundle-bin-helpers.js"");

  return Promise.all([

    helpers.getDevBundle(),

    helpers.getEnv()

  ]).then(function (devBundleAndEnv) {

    var devBundleDir = devBundleAndEnv[0];

    var cmd = helpers.getCommand(devBundleBinCommand, devBundleDir);

    if (! cmd) {

      return null;

    }

    var env = devBundleAndEnv[1];

    var child = require(""child_process"").spawn(cmd, args, {

      stdio: ""inherit"",

      env: env

    });



    require(""./flush-buffers-on-exit-in-windows.js"");

    child.on(""error"", function (error) {

      console.log(error.stack || error);

    });

    child.on(""exit"", function (exitCode) {

      process.exit(exitCode);

    });

    return child;

module.exports = getChildProcess();
","async function getChildProcess() {
  const helpers = require(""./dev-bundle-bin-helpers.js"");
  try {
    const devBundleAndEnv = await Promise.all([
      helpers.getDevBundle(),
      helpers.getEnv()
    ]);
    const devBundleDir = devBundleAndEnv[0];
    const cmd = helpers.getCommand(devBundleBinCommand, devBundleDir);
    if (!cmd) {
      return null;
    }
    const env = devBundleAndEnv[1];
    const child = require(""child_process"").spawn(cmd, args, {
      stdio: ""inherit"",
      env
    });

    require(""./flush-buffers-on-exit-in-windows.js"");

    child.on(""error"", error => {
      console.log(error.stack || error);
    });

    child.on(""exit"", exitCode => {
      process.exit(exitCode);
    });

    return child;
  } catch (error) {
    console.log(error.stack || error);
    return null;
  }
}
module.exports = getChildProcess();",2024-07-11 09:37:16-03:00,6804b236b2a3d6c8725360243b8573495df8a0d5
"exports.getEnv = function (options) {

  var devBundle = options && options.devBundle;

  var devBundlePromise = typeof devBundle === ""string""

    ? Promise.resolve(convertToOSPath(devBundle))

    : getDevBundle();

  return devBundlePromise.then(function (devBundleDir) {

    var paths = [

      // When npm looks for node, it must find dev_bundle/bin/node.

      path.join(devBundleDir, ""bin""),

      // When npm looks for meteor, it should find dev_bundle/../meteor.

      path.dirname(devBundleDir),

      // Also make available any scripts installed by packages in

      // dev_bundle/lib/node_modules, such as node-gyp.

      path.join(devBundleDir, ""lib"", ""node_modules"", "".bin"")

    ];

    var env = Object.create(process.env);

    // Make sure notifications to update npm aren't presented to the user.

    env.NO_UPDATE_NOTIFIER = true;

    // Make sure `meteor npm install --global ...` installs into

    // dev_bundle/lib/node_modules by default.

    if (! env.NPM_CONFIG_PREFIX) {

      env.NPM_CONFIG_PREFIX = devBundleDir;

    }

    if (env.METEOR_ALLOW_SUPERUSER) {

      // Note that env.METEOR_ALLOW_SUPERUSER could be ""0"" or ""false"", which

      // should propagate falsy semantics to NPM_CONFIG_UNSAFE_PERM.

      env.NPM_CONFIG_UNSAFE_PERM = env.METEOR_ALLOW_SUPERUSER;

    }

    // This allows node-gyp to find Node headers and libraries in

    // dev_bundle/include/node.

    env.NPM_CONFIG_NODEDIR = devBundleDir;

    var PATH = env.PATH || env.Path;

    if (PATH) {

      paths.push(PATH);

    }

    env.PATH = paths.join(path.delimiter);

    if (process.platform === ""win32"") {

      return addWindowsVariables(devBundleDir, env);

    }

    return env;

  });

};

var cachedMSVSVersion;
","exports.getEnv = async function (options) {
  const devBundle = options && options.devBundle;
  let devBundleDir;
  if (typeof devBundle === ""string"") {
    devBundleDir = await Promise.resolve(convertToOSPath(devBundle));
  } else {
    devBundleDir = await getDevBundle();
  }

  const paths = [
    path.join(devBundleDir, ""bin""),
    path.dirname(devBundleDir),
    path.join(devBundleDir, ""lib"", ""node_modules"", "".bin"")
  ];

  const env = Object.create(process.env);
  env.NO_UPDATE_NOTIFIER = true;

  if (!env.NPM_CONFIG_PREFIX) {
    env.NPM_CONFIG_PREFIX = devBundleDir;
  }

  if (env.METEOR_ALLOW_SUPERUSER) {
    env.NPM_CONFIG_UNSAFE_PERM = env.METEOR_ALLOW_SUPERUSER;
  }

  env.NPM_CONFIG_NODEDIR = devBundleDir;

  let PATH = env.PATH || env.Path;
  if (PATH) {
    paths.push(PATH);
  }

  env.PATH = paths.join(path.delimiter);

  if (process.platform === ""win32"") {
    await addWindowsVariables(devBundleDir, env);
  }

  return env;
};

var cachedMSVSVersion;",2024-07-11 09:37:16-03:00,6804b236b2a3d6c8725360243b8573495df8a0d5
"var fs = require(""fs"");

var path = require(""path"");

var links = require(""./dev-bundle-links.js"");

var rootDir = path.resolve(__dirname, "".."", "".."");

var defaultDevBundlePromise =

  Promise.resolve(path.join(rootDir, ""dev_bundle""));



function getDevBundleDir() {

  var releaseFile = find(

    return defaultDevBundlePromise;

  var localDir = path.join(path.dirname(releaseFile), ""local"");

      return defaultDevBundlePromise;

  var devBundleLink = path.join(localDir, ""dev_bundle"");

  var devBundleStat = statOrNull(devBundleLink);

  var release = fs.readFileSync(

    return defaultDevBundlePromise;

  return Promise.resolve(

    getDevBundleForRelease(release)

  ).then(function (devBundleDir) {

    if (devBundleDir) {

      links.makeLink(devBundleDir, devBundleLink);

      return devBundleDir;

    }

    return defaultDevBundlePromise;

  });

  var parts = release.split(""@"");

  var track = parts[0];

  var version = parts.slice(1).join(""@"");

  var packageMetadataDir = find(
","async function getDevBundleDir() {
  try {
    const releaseFile = await fs.promises.readFile(path.resolve(__dirname, '..', '..', 'release'), 'utf8');
    const localDir = path.join(path.dirname(releaseFile), 'local');
    const devBundleLink = path.join(localDir, 'dev_bundle');
    const devBundleStat = await fs.promises.stat(devBundleLink);
    if (devBundleStat) {
      links.makeLink(devBundleStat.ino, devBundleLink);
    } else {
      await getDevBundleForRelease(releaseFile);
    }
  } catch (error) {
    console.log('Error reading release file:', error);
  }
}

async function getDevBundleForRelease(release) {
  const devBundleDir = path.join(rootDir, 'dev_bundle');
  if (!fs.existsSync(devBundleDir)) {
    return null;
  }
  const parts = release.split('@');
  const track = parts[0];
  const version = parts.slice(1).join('@');
  const packageMetadataDir = path.join(rootDir, 'packages', 'package-metadata.json');
  if (!fs.existsSync(packageMetadataDir)) {
    return null;
  }
  try {
    const packageMetadata = JSON.parse(await fs.promises.readFile(packageMetadataDir, 'utf8'));
    if (packageMetadata[`${track}_platform`] && packageMetadata[`${track}_version`]) {
      return path.join(rootDir, 'dev_bundle', packageMetadata[`${track}_platform`], packageMetadata[`${track}_version`]);
    }
  } catch (error) {
    console.log('Error reading package metadata:', error);
  }
}",2024-07-11 09:37:16-03:00,6804b236b2a3d6c8725360243b8573495df8a0d5
"      this._publishCursorPromise = res._publishCursor(self).then(() => {

        // _publishCursor only returns after the initial added callbacks have run.

        // mark subscription as ready.

        self.ready();

      }).catch((e) => self.error(e));
","this._publishCursorPromise = res._publishCursor(self).then(() => {
     // _publishCursor only returns after the initial added callbacks have run.
     // mark subscription as ready.
     self.ready();
   }).catch((e) => self.error(e));",2024-07-18 13:04:29-04:00,4f975fc69603bc961e2db281929b4f0975047be1
"      this._publishCursorPromise = Promise.all(

        res.map(c => c._publishCursor(self))

      )

        .then(() => {

          self.ready();

        })

        .catch((e) => self.error(e));
","this._publishCursorPromise = async () => {
    try {
      await Promise.all(res.map((c) => c._publishCursor(self)));
      self.ready();
    } catch (e) {
      self.error(e);
    }
  };",2024-07-18 13:04:29-04:00,4f975fc69603bc961e2db281929b4f0975047be1
"      new Promise((resolve, reject) => {

        object[methodName](...args, (err, res) => {

          err ? reject(err) : resolve(res);

        });

      }),
","async () => {
  try {
    const res = await object[methodName](...args);
    return res;
  } catch (err) {
    throw err;
  }
}",2024-10-24 17:28:07+02:00,78abdfbbe1c5376ab6b566836ebd2d3e986e06c0
"	private _doValidate(resource: Uri): void {

		this._worker(resource).then(worker => {

			if (!monaco.editor.getModel(resource)) {

				// model was disposed in the meantime

				return null;

			}

			const promises: Promise<ts.Diagnostic[]>[] = [];

			const { noSyntaxValidation, noSemanticValidation, noSuggestionDiagnostics } = this._defaults.getDiagnosticsOptions();

			if (!noSyntaxValidation) {

				promises.push(worker.getSyntacticDiagnostics(resource.toString()));

			}

			if (!noSemanticValidation) {

				promises.push(worker.getSemanticDiagnostics(resource.toString()));

			}

			if (!noSuggestionDiagnostics) {

				promises.push(worker.getSuggestionDiagnostics(resource.toString()));

			}

			return Promise.all(promises);

		}).then(diagnostics => {

			if (!diagnostics || !monaco.editor.getModel(resource)) {

				// model was disposed in the meantime

				return null;

			}

			const markers = diagnostics

				.reduce((p, c) => c.concat(p), [])

				.filter(d => (this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(d.code) === -1)

				.map(d => this._convertDiagnostics(resource, d));



			monaco.editor.setModelMarkers(monaco.editor.getModel(resource), this._selector, markers);

		}).then(undefined, err => {

			console.error(err);

		});

	private _convertDiagnostics(resource: Uri, diag: ts.Diagnostic): monaco.editor.IMarkerData {

		const { lineNumber: startLineNumber, column: startColumn } = this._offsetToPosition(resource, diag.start);

		const { lineNumber: endLineNumber, column: endColumn } = this._offsetToPosition(resource, diag.start + diag.length);
","private async _doValidate(resource: Uri): Promise<void> {

    const worker = await this._worker(resource);

    if (!monaco.editor.getModel(resource)) {

      // model was disposed in the meantime

      return;

    }

    let diagnostics = [];

    const { noSyntaxValidation, noSemanticValidation, noSuggestionDiagnostics } = this._defaults.getDiagnosticsOptions();

    if (!noSyntaxValidation) {

      diagnostics.push(...await worker.getSyntacticDiagnostics(resource.toString()));

    }

    if (!noSemanticValidation) {

      diagnostics.push(...await worker.getSemanticDiagnostics(resource.toString()));

    }

    if (!noSuggestionDiagnostics) {

      diagnostics.push(...await worker.getSuggestionDiagnostics(resource.toString()));

    }

    if (diagnostics && monaco.editor.getModel(resource)) {

      const markers = diagnostics

        .reduce((p, c) => c.concat(p), [])

        .filter(d => (this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(d.code) === -1)

        .map(d => this._convertDiagnostics(resource, d));

      monaco.editor.setModelMarkers(monaco.editor.getModel(resource), this._selector, markers);

    }

  }

  private _convertDiagnostics(resource: Uri, diag: ts.Diagnostic): monaco.editor.IMarkerData {

    const { lineNumber: startLineNumber, column: startColumn } = this._offsetToPosition(resource, diag.start);

    const { lineNumber: endLineNumber, column: endColumn } = this._offsetToPosition(resource, diag.start + diag.length);",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	provideCompletionItems(model: monaco.editor.IReadOnlyModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Thenable<monaco.languages.CompletionList> {

		const offset = this._positionToOffset(resource, position);

		return this._worker(resource).then(worker => {

			return worker.getCompletionsAtPosition(resource.toString(), offset);

		}).then(info => {

			if (!info) {

				return;

			}

			let suggestions: MyCompletionItem[] = info.entries.map(entry => {

				let range = wordRange;

				if (entry.replacementSpan) {

					const p1 = model.getPositionAt(entry.replacementSpan.start);

					const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);

					range = new Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);

				}

				return {

					uri: resource,

					position: position,

					range: range,

					label: entry.name,

					insertText: entry.name,

					sortText: entry.sortText,

					kind: SuggestAdapter.convertKind(entry.kind)

				};

			});

				suggestions

	resolveCompletionItem(_model: monaco.editor.IReadOnlyModel, _position: Position, item: monaco.languages.CompletionItem, token: CancellationToken): Thenable<monaco.languages.CompletionItem> {

		let myItem = <MyCompletionItem>item;

		return this._worker(resource).then(worker => {

			return worker.getCompletionEntryDetails(resource.toString(),

				this._positionToOffset(resource, position),

				myItem.label);



		}).then(details => {

			if (!details) {

				return myItem;

			return <MyCompletionItem>{

				uri: resource,

				position: position,

				label: details.name,

				kind: SuggestAdapter.convertKind(details.kind),

				detail: displayPartsToString(details.displayParts),

				documentation: {

					value: displayPartsToString(details.documentation)

				}

			};

		});
","provideCompletionItems = async (model: monaco.editor.IReadOnlyModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Promise<monaco.languages.CompletionList> => {
  const offset = this._positionToOffset(resource, position);

  try {
    const worker = await this._worker(resource);
    const info = await worker.getCompletionsAtPosition(resource.toString(), offset);

    if (!info) {
      return;
    }

    const suggestions: MyCompletionItem[] = info.entries.map((entry) => {
      let range = wordRange;

      if (entry.replacementSpan) {
        const p1 = model.getPositionAt(entry.replacementSpan.start);
        const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);
        range = new Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);
      }

      return {
        uri: resource,
        position: position,
        range: range,
        label: entry.name,
        insertText: entry.name,
        sortText: entry.sortText,
        kind: SuggestAdapter.convertKind(entry.kind),
      };
    });

    return { suggestions };
  } catch (err) {
    console.error(err);
  }
};

resolveCompletionItem = async (_model: monaco.editor.IReadOnlyModel, _position: Position, item: monaco.languages.CompletionItem, token: CancellationToken): Promise<monaco.languages.CompletionItem> => {
  const myItem = <MyCompletionItem>item;

  try {
    const worker = await this._worker(resource);
    const details = await worker.getCompletionEntryDetails(resource.toString(), this._positionToOffset(resource, position), myItem.label);

    if (!details) {
      return myItem;
    }

    return <MyCompletionItem>{
      uri: resource,
      position: position,
      label: details.name,
      kind: SuggestAdapter.convertKind(details.kind),
      detail: displayPartsToString(details.displayParts),
      documentation: {
        value: displayPartsToString(details.documentation),
      },
    };
  } catch (err) {
    console.error(err);
  }
};",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	provideSignatureHelp(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.SignatureHelpResult> {

		let resource = model.uri;

		return this._worker(resource).then(worker => worker.getSignatureHelpItems(resource.toString(), this._positionToOffset(resource, position))).then(info => {

			if (!info) {

				return;

			}

			let ret: monaco.languages.SignatureHelp = {

				activeSignature: info.selectedItemIndex,

				activeParameter: info.argumentIndex,

				signatures: []

			};

			info.items.forEach(item => {

				let signature: monaco.languages.SignatureInformation = {

					label: '',

					parameters: []

				};

				signature.documentation = displayPartsToString(item.documentation);

				signature.label += displayPartsToString(item.prefixDisplayParts);

				item.parameters.forEach((p, i, a) => {

					let label = displayPartsToString(p.displayParts);

					let parameter: monaco.languages.ParameterInformation = {

						label: label,

						documentation: displayPartsToString(p.documentation)

					};

					signature.label += label;

					signature.parameters.push(parameter);

					if (i < a.length - 1) {

						signature.label += displayPartsToString(item.separatorDisplayParts);

					}

				});

				signature.label += displayPartsToString(item.suffixDisplayParts);

				ret.signatures.push(signature);



			return {

				value: ret,

				dispose() { }

			};
","async provideSignatureHelp(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Promise<monaco.languages.SignatureHelpResult> {

    let resource = model.uri;

    const worker = await this._worker(resource);

    const info = await worker.getSignatureHelpItems(resource.toString(), this._positionToOffset(resource, position));

    if (!info) {

        return;

    }

    let ret: monaco.languages.SignatureHelp = {

        activeSignature: info.selectedItemIndex,

        activeParameter: info.argumentIndex,

        signatures: []

    };

    info.items.forEach(item => {

        let signature: monaco.languages.SignatureInformation = {

            label: '',

            parameters: []

        };

        signature.documentation = displayPartsToString(item.documentation);

        signature.label += displayPartsToString(item.prefixDisplayParts);

        item.parameters.forEach((p, i, a) => {

            let label = displayPartsToString(p.displayParts);

            let parameter: monaco.languages.ParameterInformation = {

                label: label,

                documentation: displayPartsToString(p.documentation)

            };

            signature.label += label;

            signature.parameters.push(parameter);

            if (i < a.length - 1) {

                signature.label += displayPartsToString(item.separatorDisplayParts);

            }

        });

        signature.label += displayPartsToString(item.suffixDisplayParts);

        ret.signatures.push(signature);

    });

    return {

        value: ret,

        dispose() {}

    };
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	provideHover(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.Hover> {

		let resource = model.uri;

		return this._worker(resource).then(worker => {

			return worker.getQuickInfoAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(info => {

			if (!info) {

				return;

			let documentation = displayPartsToString(info.documentation);

			let tags = info.tags ? info.tags.map(tag => {

				const label = `*@${tag.name}*`;

				if (!tag.text) {

					return label;

				}

				return label + (tag.text.match(/\r\n|\n/g) ? ' \n' + tag.text : ` - ${tag.text}`);

			})

				.join('  \n\n') : '';

			let contents = displayPartsToString(info.displayParts);

			return {

				range: this._textSpanToRange(resource, info.textSpan),

				contents: [{

					value: '```js\n' + contents + '\n```\n'

				}, {

					value: documentation + (tags ? '\n\n' + tags : '')

				}]

			};

		});
","\n'
    }, {
      value: documentation + (tags ? '\n\n' + tags : '')
    }]
  };
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	public provideDocumentHighlights(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.DocumentHighlight[]> {

		return this._worker(resource).then(worker => {

			return worker.getOccurrencesAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(entries => {

			if (!entries) {

				return;

			}

			return entries.map(entry => {

				return <monaco.languages.DocumentHighlight>{

					range: this._textSpanToRange(resource, entry.textSpan),

					kind: entry.isWriteAccess ? monaco.languages.DocumentHighlightKind.Write : monaco.languages.DocumentHighlightKind.Text

				};

			});
","public async provideDocumentHighlights(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Promise<monaco.languages.DocumentHighlight[]> {
  const worker = await this._worker(resource);
  const entries = await worker.getOccurrencesAtPosition(resource.toString(), this._positionToOffset(resource, position));

  if (!entries) {
    return;
  }

  return entries.map((entry) => {
    return <monaco.languages.DocumentHighlight>{
      range: this._textSpanToRange(resource, entry.textSpan),
      kind: entry.isWriteAccess ? monaco.languages.DocumentHighlightKind.Write : monaco.languages.DocumentHighlightKind.Text,
    };
  });
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	public provideDefinition(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.Definition> {

		return this._worker(resource).then(worker => {

			return worker.getDefinitionAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(entries => {

			if (!entries) {

				return;

			}

			const result: monaco.languages.Location[] = [];

			for (let entry of entries) {

				const uri = Uri.parse(entry.fileName);

				if (monaco.editor.getModel(uri)) {

					result.push({

						uri: uri,

						range: this._textSpanToRange(uri, entry.textSpan)

					});

				}

			return result;

		});
","public provideDefinition(model: monaco.editor.IReadOnlyModel, position: Position, token: CancellationToken): Thenable<monaco.languages.Definition> {
  return this._worker(resource).then(async worker => {
    const entries = await worker.getDefinitionAtPosition(resource.toString(), this._positionToOffset(resource, position));
    if (!entries) {
      return;
    }
    const result: monaco.languages.Location[] = [];
    for (const entry of entries) {
      const uri = Uri.parse(entry.fileName);
      if (monaco.editor.getModel(uri)) {
        result.push({
          uri,
          range: this._textSpanToRange(uri, entry.textSpan),
        });
      }
    }
    return result;
  });
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	provideReferences(model: monaco.editor.IReadOnlyModel, position: Position, context: monaco.languages.ReferenceContext, token: CancellationToken): Thenable<monaco.languages.Location[]> {

		return this._worker(resource).then(worker => {

			return worker.getReferencesAtPosition(resource.toString(), this._positionToOffset(resource, position));

		}).then(entries => {

			if (!entries) {

				return;

			}

			const result: monaco.languages.Location[] = [];

			for (let entry of entries) {

				const uri = Uri.parse(entry.fileName);

				if (monaco.editor.getModel(uri)) {

					result.push({

						uri: uri,

						range: this._textSpanToRange(uri, entry.textSpan)

					});

				}

			return result;

		});
","provideReferences(model: monaco.editor.IReadOnlyModel, position: Position, context: monaco.languages.ReferenceContext, token: CancellationToken): Thenable<monaco.languages.Location[]> {
  const resource = model.uri;
  try {
    const worker = await this._worker(resource);
    const entries = await worker.getReferencesAtPosition(resource.toString(), this._positionToOffset(resource, position));
    if (!entries) {
      return;
    }
    const result: monaco.languages.Location[] = [];
    for (let entry of entries) {
      const uri = Uri.parse(entry.fileName);
      if (monaco.editor.getModel(uri)) {
        result.push({
          uri,
          range: this._textSpanToRange(uri, entry.textSpan),
        });
      }
    }
    return result;
  } catch (error) {
    console.error(error);
    throw error;
  }
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	public provideDocumentSymbols(model: monaco.editor.IReadOnlyModel, token: CancellationToken): Thenable<monaco.languages.DocumentSymbol[]> {

		return this._worker(resource).then(worker => worker.getNavigationBarItems(resource.toString())).then(items => {

			if (!items) {

				return;

			}

			const convert = (bucket: monaco.languages.DocumentSymbol[], item: ts.NavigationBarItem, containerLabel?: string): void => {

				let result: monaco.languages.DocumentSymbol = {

					name: item.text,

					detail: '',

					kind: <monaco.languages.SymbolKind>(outlineTypeTable[item.kind] || monaco.languages.SymbolKind.Variable),

					range: this._textSpanToRange(resource, item.spans[0]),

					selectionRange: this._textSpanToRange(resource, item.spans[0]),

					tags: [],

					containerName: containerLabel

				};

				if (item.childItems && item.childItems.length > 0) {

					for (let child of item.childItems) {

						convert(bucket, child, result.name);

					}



				bucket.push(result);

			let result: monaco.languages.DocumentSymbol[] = [];

			items.forEach(item => convert(result, item));

			return result;

		});
","async provideDocumentSymbols(model: monaco.editor.IReadOnlyModel, token: CancellationToken): Promise<monaco.languages.DocumentSymbol[]> {
  const worker = await this._worker(resource);
  const items = await worker.getNavigationBarItems(resource.toString());

  if (!items) {
    return;
  }

  const convert = (bucket: monaco.languages.DocumentSymbol[], item: ts.NavigationBarItem, containerLabel?: string): void => {
    let result: monaco.languages.DocumentSymbol = {
      name: item.text,
      detail: '',
      kind: <monaco.languages.SymbolKind>(outlineTypeTable[item.kind] || monaco.languages.SymbolKind.Variable),
      range: this._textSpanToRange(resource, item.spans[0]),
      selectionRange: this._textSpanToRange(resource, item.spans[0]),
      tags: [],
      containerName: containerLabel
    };

    if (item.childItems && item.childItems.length > 0) {
      for (let child of item.childItems) {
        convert(bucket, child, result.name);
      }

      bucket.push(result);
    }

    let result: monaco.languages.DocumentSymbol[] = [];

    items.forEach(item => convert(result, item));

    return result;
  };

  return Promise.all([convert(result, items)]).then(result => {
    return result[0];
  });
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	protected _convertTextChanges(uri: Uri, change: ts.TextChange): monaco.editor.ISingleEditOperation {

		return <monaco.editor.ISingleEditOperation>{

			range: this._textSpanToRange(uri, change.span)

	provideDocumentRangeFormattingEdits(model: monaco.editor.IReadOnlyModel, range: Range, options: monaco.languages.FormattingOptions, token: CancellationToken): Thenable<monaco.editor.ISingleEditOperation[]> {

		return this._worker(resource).then(worker => {

			return worker.getFormattingEditsForRange(resource.toString(),

				this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn }),

				this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn }),

				FormatHelper._convertOptions(options));

		}).then(edits => {

			if (edits) {

				return edits.map(edit => this._convertTextChanges(resource, edit));

			}

		});
","protected async _convertTextChanges(uri: Uri, change: ts.TextChange): Promise<monaco.editor.ISingleEditOperation> {
	return {
		range: this._textSpanToRange(uri, change.span),
	};
}

async provideDocumentRangeFormattingEdits(model: monaco.editor.IReadOnlyModel, range: Range, options: monaco.languages.FormattingOptions, token: CancellationToken): Promise<monaco.editor.ISingleEditOperation[]> {
	const worker = await this._worker(resource);
	const edits = await worker.getFormattingEditsForRange(resource.toString(), this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn }), this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn }), FormatHelper._convertOptions(options));
	if (edits) {
		return edits.map(edit => this._convertTextChanges(resource, edit));
	}
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	provideOnTypeFormattingEdits(model: monaco.editor.IReadOnlyModel, position: Position, ch: string, options: monaco.languages.FormattingOptions, token: CancellationToken): Thenable<monaco.editor.ISingleEditOperation[]> {

		return this._worker(resource).then(worker => {

			return worker.getFormattingEditsAfterKeystroke(resource.toString(),

				this._positionToOffset(resource, position),

				ch, FormatHelper._convertOptions(options));

		}).then(edits => {

			if (edits) {

				return edits.map(edit => this._convertTextChanges(resource, edit));

			}

		});
","async provideOnTypeFormattingEdits(model: monaco.editor.IReadOnlyModel, position: Position, ch: string, options: monaco.languages.FormattingOptions, token: CancellationToken): Promise<monaco.editor.ISingleEditOperation[]> {

	const worker = await this._worker(resource);

	const edits = await worker.getFormattingEditsAfterKeystroke(resource.toString(), this._positionToOffset(resource, position), ch, FormatHelper._convertOptions(options));

	if (edits) {

		return edits.map(edit => this._convertTextChanges(resource, edit));

	}

}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"	public provideCodeActions(model: monaco.editor.ITextModel, range: Range, context: monaco.languages.CodeActionContext, token: CancellationToken): Promise<monaco.languages.CodeActionList> {

		return this._worker(resource).then(worker => {

			const start = this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn });

			const end = this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn });



			const formatOptions = FormatHelper._convertOptions(model.getOptions());

			const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);



			return worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions);



		}).then(codeFixes => {

			return codeFixes.filter(fix => {

				// Removes any 'make a new file'-type code fix

				return fix.changes.filter(change => change.isNewFile).length === 0;

			}).map(fix => {

				return this._tsCodeFixActionToMonacoCodeAction(model, context, fix);

			})

		}).then(result => {

			return {

				actions: result,

				dispose: () => { }

			};
","async provideCodeActions(model: monaco.editor.ITextModel, range: Range, context: monaco.languages.CodeActionContext, token: CancellationToken): Promise<monaco.languages.CodeActionList> {

  const worker = await this._worker(resource);
  const start = this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn });
  const end = this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn });
  const formatOptions = FormatHelper._convertOptions(model.getOptions());
  const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);
  const codeFixes = await worker.getCodeFixesAtPosition(resource.toString(), start, end, errorCodes, formatOptions);
  const filteredCodeFixes = codeFixes.filter(fix => {
    return fix.changes.filter(change => change.isNewFile).length === 0;
  });
  const monacoCodeActions = filteredCodeFixes.map(fix => {
    return this._tsCodeFixActionToMonacoCodeAction(model, context, fix);
  });
  return {
    actions: monacoCodeActions,
    dispose: () => {}
  };
}",2019-12-20 19:47:49+01:00,e4ab9e4360fc8cd559a6550f329340986fb00135
"'use strict';



import Thenable = monaco.Thenable;

import IWorkerContext = monaco.worker.IWorkerContext;

class PromiseAdapter<T> implements jsonService.Thenable<T> {

	private wrapped: Promise<T>;



	constructor(executor: (resolve: (value?: T | jsonService.Thenable<T>) => void, reject: (reason?: any) => void) => void) {

		this.wrapped = new Promise<T>(executor);

	}

	public then<TResult>(onfulfilled?: (value: T) => TResult | jsonService.Thenable<TResult>, onrejected?: (reason: any) => void): jsonService.Thenable<TResult> {

		let thenable: jsonService.Thenable<T> = this.wrapped;

		return thenable.then(onfulfilled, onrejected);

	}

	public getWrapped(): monaco.Thenable<T> {

		return this.wrapped;

	}

	public static resolve<T>(v: T | Thenable<T>): jsonService.Thenable<T> {

		return <monaco.Thenable<T>>Promise.resolve(v);

	}

	public static reject<T>(v: T): jsonService.Thenable<T> {

		return Promise.reject(<any>v);

	}

	public static all<T>(values: jsonService.Thenable<T>[]): jsonService.Thenable<T[]> {

		return Promise.all(values);

	}

}



	private _ctx: IWorkerContext;

	constructor(ctx: IWorkerContext, createData: ICreateData) {

			schemaRequestService: createData.enableSchemaRequest && defaultSchemaRequestService,

			promiseConstructor: PromiseAdapter

	doValidation(uri: string): Thenable<jsonService.Diagnostic[]> {
","// Migrated code:
'use strict';

import Thenable = monaco.Thenable;
import IWorkerContext = monaco.worker.IWorkerContext;

class PromiseAdapter<T> implements jsonService.Thenable<T> {
  private wrapped: Promise<T>;
  
  constructor(executor: (resolve: (value?: T | jsonService.Thenable<T>) => void, reject: (reason?: any) => void) => void) {
    this.wrapped = new Promise<T>(executor);
  }
  
  public then<TResult>(onfulfilled?: (value: T) => TResult | jsonService.Thenable<TResult>, onrejected?: (reason: any) => void): jsonService.Thenable<TResult> {
    let thenable: jsonService.Thenable<T> = this.wrapped;
    return thenable.then(onfulfilled, onrejected);
  }
  
  public getWrapped(): monaco.Thenable<T> {
    return this.wrapped;
  }
  
  public static resolve<T>(v: T | Thenable<T>): jsonService.Thenable<T> {
    return <monaco.Thenable<T>>Promise.resolve(v);
  }
  
  public static reject<T>(v: T): jsonService.Thenable<T> {
    return Promise.reject(<any>v);
  }
  
  public static all<T>(values: jsonService.Thenable<T>[]): jsonService.Thenable<T[]> {
    return Promise.all(values);
  }
}

class ValidatorWorker implements jsonService.IValidatorWorker {
  private _ctx: IWorkerContext;
  
  constructor(ctx: IWorkerContext, createData: ICreateData) {
    this._ctx = ctx;
    schemaRequestService: createData.enableSchemaRequest && defaultSchemaRequestService,
    promiseConstructor: PromiseAdapter
  }
  
  doValidation(uri: string): Thenable<jsonService.Diagnostic[]> {
    // Migrated code here
    return new Promise((resolve, reject) => {
      const content = this._ctx.getMirrorModel(uri).getValue();
      try {
        resolve(this._doValidation(content));
      } catch (err) {
        reject(err);
      }
    });
  }
  
  private _doValidation(content: string): jsonService.Diagnostic[] {
    // Original code here
    return [];
  }
}",2020-09-07 12:24:21+02:00,28d4512f33c7a661a0e95d38058047f8c334ec9d
"languages.onLanguage(htmlLanguageId, () => {

	getMode().then((mode) => mode.setupMode(htmlDefaults));

});

languages.onLanguage(handlebarsLanguageId, () => {

	getMode().then((mode) => mode.setupMode(handlebarDefaults));

});

languages.onLanguage(razorLanguageId, () => {

	getMode().then((mode) => mode.setupMode(razorDefaults));

});
","// Migrated code using async/await syntax:

languages.onLanguage(htmlLanguageId, async () => {
  const mode = await getMode();
  mode.setupMode(htmlDefaults);
});

languages.onLanguage(handlebarsLanguageId, async () => {
  const mode = await getMode();
  mode.setupMode(handlebarDefaults);
});

languages.onLanguage(razorLanguageId, async () => {
  const mode = await getMode();
  mode.setupMode(razorDefaults);
});",2021-06-10 15:49:49+02:00,3e32a8c0206dfa2cbdcc38268e7035296caa1731
"	test(mainLanguage + ' tokenization', (t: test.Test) => {

		Promise.all(languages.map((l) => loadLanguage(l)))

			.then(() => {

				// clean stack

				setTimeout(() => {

					runTests(t, mainLanguage, tests);

					t.end();

				});

			})

			.then(null, () => t.end());
","test(mainLanguage + ' tokenization', async (t) => {
  try {
    await Promise.all(languages.map((l) => loadLanguage(l)));
    // clean stack
    setTimeout(() => {
      runTests(t, mainLanguage, tests);
      t.end();
    });
  } catch (error) {
    t.end();
  }
});",2021-10-08 17:47:57+02:00,c75289c39d5a4a025ddba8a1eb1e186b5432e0a2
"	languages.setMonarchTokensProvider(

		languageId,

		lazyLanguageLoader.whenLoaded().then((mod) => mod.language)

	);

	languages.onLanguage(languageId, () => {

		lazyLanguageLoader.load().then((mod) => {

			languages.setLanguageConfiguration(languageId, mod.conf);

		});
","const languageId = 'javascript';

lazyLanguageLoader.whenLoaded().then((mod) => {
  languages.setMonarchTokensProvider(languageId, mod.language);
});

languages.onLanguage(languageId, () => {
  lazyLanguageLoader.load().then((mod) => {
    languages.setLanguageConfiguration(languageId, mod.conf);
  });
});",2021-12-29 01:08:27+01:00,3a58c2a6ba2ffa1f3f34ed52204bc53c8b522afc
"			this._worker = editor.createWebWorker<TypeScriptWorker>({

				// module that exports the create() method and returns a `TypeScriptWorker` instance

				moduleId: 'vs/language/typescript/tsWorker',



				label: this._modeId,

				keepIdleModels: true,



				// passed in to the create() method

				createData: {

					compilerOptions: this._defaults.getCompilerOptions(),

					extraLibs: this._defaults.getExtraLibs(),

					customWorkerPath: this._defaults.workerOptions.customWorkerPath,

					inlayHintsOptions: this._defaults.inlayHintsOptions

				}

			});

			let p = <Promise<TypeScriptWorker>>this._worker.getProxy();

			if (this._defaults.getEagerModelSync()) {

				p = p.then((worker) => {

					if (this._worker) {

						return this._worker.withSyncedResources(

							editor

								.getModels()

								.filter((model) => model.getLanguageId() === this._modeId)

								.map((model) => model.uri)

						);

					return worker;

			}

			this._client = p;

	getLanguageServiceWorker(...resources: Uri[]): Promise<TypeScriptWorker> {

		let _client: TypeScriptWorker;

		return this._getClient()

			.then((client) => {

				_client = client;

			})

			.then((_) => {

				if (this._worker) {

					return this._worker.withSyncedResources(resources);

				}

			})

			.then((_) => _client);
","async function getLanguageServiceWorker(...resources: Uri[]): Promise<TypeScriptWorker> {
	let _client: TypeScriptWorker;
	await this._getClient()
		.then((client) => {
			_client = client;
		});
	if (this._worker) {
		await this._worker.withSyncedResources(resources);
	}
	return _client;
}",2022-08-03 17:34:31+02:00,4c5552d6a5580b50b17f51157dd45299a84f609e
"  var self = this;

  var finalPromise = new Promise(fn);



  // Jank to be able to use mpromise.prototype.all()

  var p0 = new Promise;

  p0.fulfill();



  // Call save hooks on subdocs

  var p1 = p0.all(function () {

    var subDocs = self.$__getAllSubdocs();

    return subDocs.map(function (d) {return d.save();});

  });



  // Handle save and resaults

  p1

    .then(this.$__handleSave.bind(this, options))

    .then(function (result) {

      self.$__reset();

      self.$__storeShard();



      var numAffected = 0;

      if (result) {

        if (Array.isArray(result)) {

          numAffected = result.length;

        } else if (result.result && result.result.n !== undefined) {

          numAffected = result.result.n;

        } else if (result.result && result.result.nModified !== undefined) {

          numAffected = result.result.nModified;

        } else {

          numAffected = result;

      }



      // was this an update that required a version bump?

      if (self.$__.version && !self.$__.inserting) {

        var doIncrement = VERSION_INC === (VERSION_INC & self.$__.version);

        self.$__.version = undefined;

        if (numAffected <= 0) {

          // the update failed. pass an error back

          return finalPromise.reject(new VersionError);

        // increment version if was successful

        if (doIncrement) {

          var key = self.schema.options.versionKey;

          var version = self.getValue(key) | 0;

          self.setValue(key, version + 1);

        }

      }

      self.emit('save', self, numAffected);

      return finalPromise.fulfill(self, numAffected);

    }

    , function (err) {

      // If the initial insert fails provide a second chance.

      // (If we did this all the time we would break updates)

      if (self.$__.inserting) {

        self.isNew = true;

        self.emit('isNew', true);

      }

      finalPromise.reject(err);

    })

    .end();

  return finalPromise;
","var self = this;

try {
  var finalResult = await new Promise(fn);

  // Call save hooks on subdocs
  var p1 = (await Promise.all((function () {
    var subDocs = self.$__getAllSubdocs();
    return subDocs.map(function (d) {
      return d.save();
    });
  })()));

  // Handle save and results
  await this.$__handleSave.bind(this, options)(p1);

  self.$__reset();
  self.$__storeShard();

  var numAffected = 0;
  if (finalResult) {
    if (Array.isArray(finalResult)) {
      numAffected = finalResult.length;
    } else if (finalResult.result && finalResult.result.n !== undefined) {
      numAffected = finalResult.result.n;
    } else if (finalResult.result && finalResult.result.nModified !== undefined) {
      numAffected = finalResult.result.nModified;
    } else {
      numAffected = finalResult;
    }
  }

  // was this an update that required a version bump?
  if (self.$__.version && !self.$__.inserting) {
    var doIncrement = VERSION_INC === (VERSION_INC & self.$__.version);
    self.$__.version = undefined;
    if (numAffected <= 0) {
      // the update failed. pass an error back
      throw new VersionError();
    }
    if (doIncrement) {
      var key = self.schema.options.versionKey;
      var version = self.getValue(key) | 0;
      self.setValue(key, version + 1);
    }
  }
  self.emit('save', self, numAffected);
} catch (err) {
  // If the initial insert fails provide a second chance.
  // (If we did this all the time we would break updates)
  if (self.$__.inserting) {
    self.isNew = true;
    self.emit('isNew', true);
  }
  throw err;
}
return finalResult;",2015-07-18 15:19:30-04:00,9de7aa3c86626278479518e70c6d9784bf702aad
" *     product.save(function (err, product) {

 *       if (err) ..

 *     })

 * The callback will receive two parameters

 * 1. `err` if an error occurred

 * 2. `product` which is the saved `product`

 *

 * As an extra measure of flow control, save will return a Promise.

 *     product.save().then(function(product) {

 *        ...

 *     });
","async function saveProduct() {
  try {
    const product = await product.save();
    // do something with the saved product
  } catch (err) {
    // handle error
  }
}",2019-03-16 19:55:56-04:00,9bff7817f4a410b076590a4549e5c58624885160
" *     product.save(function (err, product) {

 *       if (err) ..

 *     })

 *

 * The callback will receive two parameters

 * 1. `err` if an error occurred

 * 2. `product` which is the saved `product`

 * As an extra measure of flow control, save will return a Promise.

 *     product.save().then(function(product) {

 *        ...

 *     });
","async function saveProduct() {
  try {
    const product = await product.save();
    // Do something with the saved product
  } catch (err) {
    // Handle error
  }
}",2019-04-04 16:24:33+06:00,da39639a9490c47615974f7c118757963bea4f36
" *     product.save(function (err, product) {

 *       if (err) ..

 *     })

 *

 * The callback will receive two parameters

 * 1. `err` if an error occurred

 * 2. `product` which is the saved `product`

 * As an extra measure of flow control, save will return a Promise.

 *     product.save().then(function(product) {

 *        ...

 *     });

 * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)
","const product = await product.save();
if (product) {
  // handle saved product
} else {
  // handle error
}",2020-05-08 23:31:53+02:00,fd1a6513acadc40b778a60b7444423ffd4fd94ea
" *     // populates a single object

 *     User.findById(id, function (err, user) {

 *       var opts = [

 *         { path: 'company', match: { x: 1 }, select: 'name' },

 *         { path: 'notes', options: { limit: 10 }, model: 'override' }

 *       ];

 *

 *       User.populate(user, opts, function (err, user) {

 *         console.log(user);

 *       });

 *     });

 *     // populates an array of objects

 *     User.find(match, function (err, users) {

 *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }];

 *

 *       var promise = User.populate(users, opts);

 *       promise.then(console.log).end();

 *     })

 *

 *     // imagine a Weapon model exists with two saved documents:

 *     //   { _id: 389, name: 'whip' }

 *     //   { _id: 8921, name: 'boomerang' }

 *     // and this schema:

 *     // new Schema({

 *     //   name: String,

 *     //   weapon: { type: ObjectId, ref: 'Weapon' }

 *     // });

 *

 *     var user = { name: 'Indiana Jones', weapon: 389 };

 *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {

 *       console.log(user.weapon.name); // whip

 *     })

 *     var users = [{ name: 'Indiana Jones', weapon: 389 }]

 *     users.push({ name: 'Batman', weapon: 8921 })

 *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {

 *       users.forEach(function (user) {

 *         console.log('%s uses a %s', users.name, user.weapon.name)

 *         // Indiana Jones uses a whip

 *         // Batman uses a boomerang

 *       });

 *     });

 *     // Note that we didn't need to specify the Weapon model because

 *     // it is in the schema's ref
","// populates a single object
User.findById(id)
  .then(user => {
    var opts = [
      { path: 'company', match: { x: 1 }, select: 'name' },
      { path: 'notes', options: { limit: 10 }, model: 'override' }
    ];
    return User.populate(user, opts);
  })
  .then(user => console.log(user))
  .catch(err => console.error(err));

// populates an array of objects
User.find()
  .then(users => {
    var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }];
    return User.populate(users, opts);
  })
  .then(users => console.log(users))
  .catch(err => console.error(err));

// imagine a Weapon model exists with two saved documents:
//   { _id: 389, name: 'whip' }
//   { _id: 8921, name: 'boomerang' }
// and this schema:
// new Schema({
//   name: String,
//   weapon: { type: ObjectId, ref: 'Weapon' }
// });

var user = { name: 'Indiana Jones', weapon: 389 };
Weapon.populate(user, { path: 'weapon', model: 'Weapon' })
  .then(user => console.log(user.weapon.name))
  .catch(err => console.error(err));

var users = [{ name: 'Indiana Jones', weapon: 389 }]
users.push({ name: 'Batman', weapon: 8921 })
Weapon.populate(users, { path: 'weapon' })
  .then(users => {
    users.forEach(user => console.log('%s uses a %s', user.name, user.weapon.name));
  })
  .catch(err => console.error(err));",2020-06-17 10:51:26-04:00,14a4fb843ea0b914f3e34ab6bc316c292b60b73c
" *     // pass a spread of docs and a callback

 *     Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {

 *       if (err) // ...

 *     });

 *

 *     // pass an array of docs

 *     var array = [{ type: 'jelly bean' }, { type: 'snickers' }];

 *     Candy.create(array, function (err, candies) {

 *       if (err) // ...

 *

 *       var jellybean = candies[0];

 *       var snickers = candies[1];

 *       // ...

 *     });

 *

 *     // callback is optional; use the returned promise if you like:

 *     var promise = Candy.create({ type: 'jawbreaker' });

 *     promise.then(function (jawbreaker) {

 *       // ...

 *     })
","// pass a spread of docs and an async callback
Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, async (err, jellybean, snickers) => {
  if (err) {
    // handle error
  } else {
    console.log(jellybean);
    console.log(snickers);
  }
});

// pass an array of docs and an async callback
var array = [{ type: 'jelly bean' }, { type: 'snickers' }];
Candy.create(array, async (err, candies) => {
  if (err) {
    // handle error
  } else {
    const jellybean = candies[0];
    const snickers = candies[1];
    console.log(jellybean);
    console.log(snickers);
  }
});

// callback is optional; use the returned promise if you like:
var promise = Candy.create({ type: 'jawbreaker' });
promise.then((jawbreaker) => {
  // ...
});",2020-07-26 17:27:30-04:00,ffdfe887abe213fd15ecce102016cb91db675c78
" * This function does not trigger any middleware.

 *     Character.deleteOne({ name: 'Eddard Stark' }).then(next);
","async function deleteStarkCharacter() {
    try {
      await Character.deleteOne({ name: 'Eddard Stark' });
      next();
    } catch (error) {
      console.error(error);
    }
  }",2020-10-30 10:17:50-04:00,0fffe252c00a3239ee757d8e7b52312165ed68c1
" * This function does not trigger any middleware

 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)

 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)
","async function deleteCharacters() {
  await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });
}",2020-10-30 10:17:50-04:00,0fffe252c00a3239ee757d8e7b52312165ed68c1
"  it('eachAsync() with parallel > numDocs (gh-8422)', function() {

    return co(function*() {

      yield Movie.deleteMany({});

      yield Movie.create([

        { name: 'Kickboxer' },

        { name: 'Ip Man' },

        { name: 'Enter the Dragon' }

      ]);

      let numDone = 0;

      const test = co.wrap(function*() {

        yield new Promise((resolve) => setTimeout(resolve, 100));

        ++numDone;

      });

      yield Movie.find().cursor().eachAsync(test, { parallel: 4 });

      assert.equal(numDone, 3);

    });

  it('eachAsync() with sort, parallel, and sync function (gh-8557)', function() {

    return co(function*() {

      yield User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);

      const cursor = User.aggregate([{ $sort: { order: 1 } }]).

        cursor();

      const docs = [];

      yield cursor.eachAsync((doc) => docs.push(doc), { parallel: 3 });

      assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);

    });
","it('eachAsync() with sort, parallel, and sync function (gh-8557)', async function() {
  await User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);
  const cursor = User.aggregate([{ $sort: { order: 1 } }]).cursor();
  const docs = [];
  await cursor.eachAsync((doc) => docs.push(doc), { parallel: 3 });
  assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);
});",2021-08-29 23:23:24+02:00,308934210593f11b950528350c8fe82560224d48
"    return Movie.findOneAndUpdate(query, update, options).then(doc => {

      doc.genre; // 'Action', Mongoose set a default value.

      // acquit:ignore:start

      assert.equal(doc.title, 'The Terminator');

      assert.equal(doc.genre, 'Action');

      // acquit:ignore:end

      return doc;

    });
","return Movie.findOneAndUpdate(query, update, options).then(async (doc) => {
  await assert.equal(doc.title, 'The Terminator');
  await assert.equal(doc.genre, 'Action');
  return doc;
});",2021-09-01 16:25:31-04:00,bb7c0210775c845acb9498ea10f39e6d0a39e89a
"  before(function() {

    return db.asPromise().

      then(() => {

        // Skip if not a repl set

        if (db.client.topology.constructor.name !== 'ReplSet' &&

            !db.client.topology.s.description.type.includes('ReplicaSet')) {

          _skipped = true;

          this.skip();

          throw new Error('skip');

        }

      }).

      then(() => new Promise((resolve, reject) => {

        start.mongodVersion(function(err, version) {

          if (err) {

            return reject(err);

          }

          resolve(version);

        });

      })).

      then(version => {

        if (version[0] < 4) {

          _skipped = true;

          this.skip();

        }

      }).

      catch(() => {

      });
","// Migrated code using `async/await` syntax

before(async function() {
  // Skip if not a repl set
  if (db.client.topology.constructor.name !== 'ReplSet' && !db.client.topology.s.description.type.includes('ReplicaSet')) {
    _skipped = true;
    this.skip();
    throw new Error('skip');
  }

  // Start mongod version check
  try {
    const version = await start.mongodVersion();
    if (version[0] < 4) {
      _skipped = true;
      this.skip();
    }
  } catch (err) {
    console.error(err);
  }
});",2021-09-09 02:41:38+02:00,e205858f88a3ee36dd477949f639fac0b19d4e0f
"  before(function() {



    return db.asPromise().

      then(() => {

        // Skip if not a repl set

        if (db.client.topology.constructor.name !== 'ReplSet' &&

            !db.client.topology.s.description.type.includes('ReplicaSet')) {

          _skipped = true;

          this.skip();

          throw new Error('skip');

        }

      }).

      then(() => new Promise((resolve, reject) => {

        start.mongodVersion(function(err, version) {

          if (err) {

            return reject(err);

          }

          resolve(version);

        });

      })).

      then(version => {

        if (version[0] < 4) {

          _skipped = true;

          this.skip();

        }

      }).

      catch(() => {

      });
","async function before() {
  try {
    const db = await start.mongodVersion();
    if (db[0] < 4) {
      _skipped = true;
      this.skip();
    }
  } catch (err) {
    console.error(err);
  }
}",2021-09-09 02:53:17+02:00,9030c12037c2294a6ec17c94b23a7139b60b169c
"      bootMongo.promise.then(function(_conn) {

        assert.equal(_conn, conn);

        done();

      }).catch(done);
","bootMongo.promise.then(async function(_conn) => {
  assert.equal(_conn, conn);
  done();
}).catch(done);",2021-09-16 02:26:01+02:00,15b57ec7d6a022961629e350313af5b258140bce
"    MR.mapReduce(o).then(function(results, stats) {

      assert.equal(typeof stats, 'undefined');

      done();

    });
","await MR.mapReduce(o);

assert.equal(typeof stats, 'undefined');

done();",2021-09-16 04:28:35+02:00,13a75af96e3c311bbda0925d7afb1d245374ced1
"    it('when return promise', function(done) {

      A.aggregate([group, project]).then(function(res) {

        assert.ok(res);

        assert.equal(1, res.length);

        assert.ok('maxAge' in res[0]);

        assert.equal(maxAge, res[0].maxAge);

        done();

      });

    it('with arrays', function(done) {

      A.aggregate([group, project], function(err, res) {

        assert.ifError(err);

        assert.ok(res);

        assert.equal(res.length, 1);

        assert.ok('maxAge' in res[0]);

        assert.equal(res[0].maxAge, maxAge);

        done();

      });

    it('with Aggregate syntax', function(done) {

      A.aggregate()

        .exec(function(err, res) {

          assert.ifError(err);

          assert.ok(res);

          assert.equal(res.length, 1);

          assert.ok('maxAge' in res[0]);

          assert.equal(res[0].maxAge, maxAge);

          done();

        });

    it('with Aggregate syntax if callback not provided', function(done) {

      promise.then(function(res) {

        assert.ok(promise instanceof mongoose.Promise);

        assert.ok(res);

        assert.equal(res.length, 1);

        assert.ok('maxAge' in res[0]);

        assert.equal(maxAge, res[0].maxAge);

        done();

      });
","it('when return promise', async function() {
  const res = await A.aggregate([group, project]);
  assert.ok(res);
  assert.equal(1, res.length);
  assert.ok('maxAge' in res[0]);
  assert.equal(maxAge, res[0].maxAge);
});

it('with arrays', async function() {
  const [err, res] = await A.aggregate([group, project]).toArray();
  assert.ifError(err);
  assert.ok(res);
  assert.equal(res.length, 1);
  assert.ok('maxAge' in res[0]);
  assert.equal(res[0].maxAge, maxAge);
});

it('with Aggregate syntax', async function() {
  const res = await A.aggregate().exec();
  assert.ok(res);
  assert.equal(res.length, 1);
  assert.ok('maxAge' in res[0]);
  assert.equal(res[0].maxAge, maxAge);
});

it('with Aggregate syntax if callback not provided', async function() {
  const res = await promise;
  assert.ok(promise instanceof mongoose.Promise);
  assert.ok(res);
  assert.equal(res.length, 1);
  assert.ok('maxAge' in res[0]);
  assert.equal(maxAge, res[0].maxAge);
});",2021-09-16 04:49:59+02:00,8b6d9adbd8fa9d06ea6c1f8331df14bba444c4d5
"      return Promise.all([

      ]).then(() => Base.listIndexes()).

        then(indexes => indexes.find(i => i.key.other)).

        then(index => {

          assert.deepEqual(index.key, { other: 1 });

          assert.deepEqual(index.partialFilterExpression, { kind: 'Device' });

        });
","async function test() {
  const indexes = await Base.listIndexes();
  const index = indexes.find((i) => i.key.other);
  assert.deepEqual(index.key, { other: 1 });
  assert.deepEqual(index.partialFilterExpression, { kind: 'Device' });
}",2022-01-21 11:14:32+02:00,997f9f598651d31f273e1215d7e303445b0c254b
"import { createConnection, Schema, Connection } from 'mongoose';

conn.model('Test', new Schema({ name: { type: String } }));

conn.openUri('mongodb://localhost:27017/test').then(() => console.log('Connected!'));

createConnection('mongodb://localhost:27017/test').asPromise().then((conn: Connection) => {

  conn.host;

});

createConnection('mongodb://localhost:27017/test').close();

conn.db.collection('Test').findOne({ name: String }).then(doc => console.log(doc));

conn.collection('Test').findOne({ name: String }).then(doc => console.log(doc));

conn.syncIndexes({ continueOnError: true }).then(result => {

  result['User'].forEach((index) => {

    index.includes('name');

  });

  result['Order'].message;

  result['Order'].code;

});

conn.syncIndexes({ continueOnError: false, background: true }).then().catch(err => {

  err.errors['Order'].code;

});
","import { createConnection, Schema, Connection } from 'mongoose';

async function connect() {
  const conn = await createConnection('mongodb://localhost:27017/test', { useNewUrlParser: true });
  console.log('Connected!');
}
connect();

async function getUser(name) {
  return conn.db.collection('Test').findOne({ name: String }, (err, doc) => {
    if (err) throw err;
    console.log(doc);
  });
}

async function getOrder() {
  return conn.collection('Test').findOne({ name: String }, (err, doc) => {
    if (err) throw err;
    console.log(doc);
  });
}

async function syncIndexes(continueOnError) {
  try {
    const result = await conn.syncIndexes({ continueOnError });
    const indexes = result['User'].map((index) => index.includes('name'));
    console.log(indexes);
    console.log(result['Order'].message);
    console.log(result['Order'].code);
  } catch (err) {
    console.error(err);
  }
}

async function main() {
  await connect();
  const user = await getUser('John');
  const order = await getOrder();
  syncIndexes(true);
  syncIndexes(false, true);
}
main();",2022-02-17 18:50:30+01:00,a92a4d2b62ba77a8125f464098fcae44accec0bc
" *     product.remove(function (err, product) {

 *       if (err) return handleError(err);

 *       Product.findById(product._id, function (err, product) {

 *         console.log(product) // null

 *       })

 *     })

 *

 *

 * As an extra measure of flow control, remove will return a Promise (bound to `fn` if passed) so it could be chained, or hooked to receive errors

 *

 * #### Example:

 *

 *     product.remove().then(function (product) {

 *        ...

 *     }).catch(function (err) {

 *        assert.ok(err)

 *     })
","async function removeProduct() {
  try {
    const product = await Product.remove();
    console.log(product); // null
  } catch (err) {
    handleError(err);
  }
}",2022-07-11 14:22:51+02:00,3dd7b52211ab7066fe845e689143ee728e735335
" *     const promise = aggregate.exec();

 *     promise.then(..);

 * @see Promise #promise_Promise

 * @return {Promise}
","async function exec() {
  return await aggregate.exec();
}",2022-07-22 14:19:24+02:00,437b03a81c12fb804a366ff3d50b5084fc504c3e
"  return new Promise((resolve, reject) => {

    const db = module.exports();





    db.on('error', reject);



    db.on('open', function() {

      const admin = db.db.admin();

      admin.serverStatus(function(err, info) {

        if (err) {

          return reject(err);

        }

        const version = info.version.split('.').map(function(n) {

          return parseInt(n, 10);

        });

        db.close(function() {

          resolve(version);

        });

      });

    });
","return async () => {
  const db = module.exports();
  db.on('error', reject);
  db.on('open', function() {
    const admin = db.db.admin();
    try {
      const info = await admin.serverStatus();
      const version = info.version.split('.').map(function(n) {
        return parseInt(n, 10);
      });
      await db.close();
      return version;
    } catch (err) {
      reject(err);
    }
  });
};",2023-01-26 18:13:18-05:00,9b51f98aed00de9c244062d645721ef3ac7dbca9
"Connection.prototype.openUri = function openUri(uri, options, callback) {

  if (typeof options === 'function') {

    callback = options;

    options = null;

  if (['string', 'number'].indexOf(typeof options) !== -1) {

    throw new MongooseError('Mongoose 5.x no longer supports ' +

      '`mongoose.connect(host, dbname, port)` or ' +

      '`mongoose.createConnection(host, dbname, port)`. See ' +

      'https://mongoosejs.com/docs/connections.html for supported connection syntax');

  if (callback != null && typeof callback !== 'function') {

    throw new MongooseError('3rd parameter to `mongoose.connect()` or ' +

      '`mongoose.createConnection()` must be a function, got ""' +

      typeof callback + '""');

  }



  if (this._destroyCalled) {

    const error = 'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +

    'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.';

    if (typeof callback === 'function') {

      callback(error);

      return;

    }

    else {

      throw new MongooseError(error);

    }

  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {

    if (this._connectionString !== uri) {



    if (typeof callback === 'function') {

      this.$initialConnection = this.$initialConnection.then(

        () => callback(null, this),

        err => callback(err)

      );

    }

    return this;

  this._connectionString = uri;

  this.readyState = STATES.connecting;

  this._closeCalled = false;



  const _this = this;


","Connection.prototype.openUri = async function openUri(uri, options) {

  if (typeof options === 'function') {

    callback = options;

    options = null;

  } else if (typeof options === 'string' || typeof options === 'number') {

    throw new MongooseError('Mongoose 5.x no longer supports `mongoose.connect(host, dbname, port)` or `mongoose.createConnection(host, dbname, port)`. See https://mongoosejs.com/docs/connections.html for supported connection syntax');

  } else if (callback != null && typeof callback !== 'function') {

    throw new MongooseError('3rd parameter to `mongoose.connect()` or `mongoose.createConnection()` must be a function, got ""' + typeof callback + '""');

  }



  if (this._destroyCalled) {

    const error = 'Connection has been closed and destroyed, and cannot be used for re-opening the connection. Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.';

    if (typeof callback === 'function') {

      callback(error);

      return;

    } else {

      throw new MongooseError(error);

    }

  }



  this._connectionString = uri;

  this.readyState = STATES.connecting;

  this._closeCalled = false;



  try {

    await this.$initialConnection;

    return callback(null, this);

  } catch (err) {

    throw new MongooseError(err);

  }

};",2023-02-01 15:02:31-05:00,f0c55f3278fd4aa3633baecfdf2b3776ca6cec4a
"  const promise = new Promise((resolve, reject) => {

    let client;

    try {

      client = new mongodb.MongoClient(uri, options);

    } catch (error) {

      _this.readyState = STATES.disconnected;

      return reject(error);

    }

    _this.client = client;



    client.setMaxListeners(0);

    client.connect().then(() => {

      _setClient(_this, client, options, dbName);

      for (const db of this.otherDbs) {

        _setClient(db, client, {}, db.name);

      }



      resolve(_this);

    }).catch(reject);

  });



  const serverSelectionError = new ServerSelectionError();

  this.$initialConnection = promise.

    then(() => this).

    catch(err => {

      this.readyState = STATES.disconnected;

      if (err != null && err.name === 'MongoServerSelectionError') {

        err = serverSelectionError.assimilateError(err);

      }

      if (this.listeners('error').length > 0) {

        immediate(() => this.emit('error', err));

      }

      throw err;

    });

  if (callback != null) {

    this.$initialConnection = this.$initialConnection.then(

      () => { callback(null, this); return this; },

      err => callback(err)

    );

  }

  for (const model of Object.values(this.models)) {

    // Errors handled internally, so safe to ignore error

    model.init(function $modelInitNoop() {});



  return this.$initialConnection;

};
","const promise = new Promise((resolve, reject) => {
  let client;
  try {
    client = new mongodb.MongoClient(uri, options);
  } catch (error) {
    this.readyState = STATES.disconnected;
    return reject(error);
  }
  this.client = client;
  client.setMaxListeners(0);
  try {
    await client.connect();
    _setClient(this, client, options, dbName);
    for (const db of this.otherDbs) {
      _setClient(db, client, {}, db.name);
    }
    resolve(this);
  } catch (error) {
    reject(error);
  }
});

const serverSelectionError = new ServerSelectionError();
this.$initialConnection = promise.then(() => this).catch(err => {
  if (err != null && err.name === 'MongoServerSelectionError') {
    err = serverSelectionError.assimilateError(err);
  }
  this.readyState = STATES.disconnected;
  if (this.listeners('error').length > 0) {
    immediate(() => this.emit('error', err));
  }
  throw err;
});
if (callback != null) {
  this.$initialConnection = this.$initialConnection.then(
    () => { callback(null, this); return this; },
    err => callback(err)
  );
}
for (const model of Object.values(this.models)) {
  // Errors handled internally, so safe to ignore error
  model.init(function $modelInitNoop() {});
}
return this.$initialConnection;",2023-02-01 15:02:31-05:00,f0c55f3278fd4aa3633baecfdf2b3776ca6cec4a
"  it('should buffer commands until connection is established', function(done) {

    let connected = false;

    let insertedId = undefined;

    let pending = 2;



    function finish() {

      if (--pending) {

        return;

      }

      assert.ok(connected);

      assert.ok(insertedId !== undefined);

      collection.findOne({ _id: insertedId }).then(doc => {

        assert.strictEqual(doc.foo, 'bar');

        db.close();

        done();

      });

    }

    collection.insertOne({ foo: 'bar' }, {}, function(err, result) {

      assert.ok(connected);

      insertedId = result.insertedId;

      finish();

    });

    db.openUri(process.env.MONGOOSE_TEST_URI || uri, function(err) {

      connected = !err;

      finish();

    });

  it('returns a promise if buffering and no callback (gh-7676)', function(done) {
","it('should buffer commands until connection is established', async () => {

  let connected = false;

  let insertedId = undefined;

  let pending = 2;



  function finish() {

    if (--pending) {

      return;

    }

    assert.ok(connected);

    assert.ok(insertedId !== undefined);

    const doc = await collection.findOne({ _id: insertedId });

    assert.strictEqual(doc.foo, 'bar');

    db.close();

    done();

  }

  const result = await collection.insertOne({ foo: 'bar' }, {});

  insertedId = result.insertedId;

  finish();

});

it('returns a promise if buffering and no callback (gh-7676)', async () => {

  let connected = false;

  let pending = 2;

  function finish() {

    if (--pending) {

      return;

    }

    assert.ok(connected);

    const doc = await collection.findOne({ _id: insertedId });

    assert.strictEqual(doc.foo, 'bar');

    db.close();

    done();

  }

  try {

    await db.openUri(process.env.MONGOOSE_TEST_URI || uri);

    connected = true;

  } catch (err) {

    assert.ok(!connected);

  } finally {

    finish();

  }

});",2023-02-01 15:02:31-05:00,f0c55f3278fd4aa3633baecfdf2b3776ca6cec4a
"    db.openUri(start.uri, function(err) {

      assert.ifError(err);

      promise.then(() => done(), done);

    });
","\`\`\`javascript
async function migrate() {
  try {
    await db.openUri(start.uri);
    done();
  } catch (err) {
    assert.ifError(err);
  }
}
\`\`\`",2023-02-01 15:02:31-05:00,f0c55f3278fd4aa3633baecfdf2b3776ca6cec4a
"  it('throws a MongooseServerSelectionError on server selection timeout (gh-8451)', function() {

    return mongoose.createConnection(uri, opts).asPromise().then(() => assert.ok(false), err => {

      assert.equal(err.name, 'MongooseServerSelectionError');

    });
","it('throws a MongooseServerSelectionError on server selection timeout (gh-8451)', async function() {
  try {
    await mongoose.createConnection(uri, opts);
  } catch (err) {
    assert.equal(err.name, 'MongooseServerSelectionError');
  }
});",2023-02-01 15:02:31-05:00,f0c55f3278fd4aa3633baecfdf2b3776ca6cec4a
"  const cb = (err, docs) => {

    if (err) {

      return callback(err);

    }

    if (docs.length === 0) {

      return callback(null, docs);

    }

    if (this.options.explain) {

      return callback(null, docs);

    }

    if (!mongooseOptions.populate) {

      const versionKey = _this.schema.options.versionKey;

      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {

        docs.forEach((doc) => {

          if (versionKey in doc) {

            delete doc[versionKey];

          }

        });

      }

      return mongooseOptions.lean ?

      // call _completeManyLean here?

        _completeManyLean(_this.model.schema, docs, null, completeManyOptions, callback) :

        // callback(null, docs) :

        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);

    }

    const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);

    if (mongooseOptions.lean) {

      return _this.model.populate(docs, pop, callback);

    completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, (err, docs) => {

      if (err != null) {

        return callback(err);

      }

      _this.model.populate(docs, pop, callback);

    });

  };

  const options = this._optionsForExec();

  options.projection = this._fieldsForExec();

  const filter = this._conditions;

  this._collection.collection.find(filter, options, (err, cursor) => {

    if (err != null) {

      return cb(err);

    }

    if (options.explain) {

      return cursor.explain().then(res => cb(null, res), err => cb(err));

    }

    try {

      return cursor.toArray().then(res => cb(null, res), err => cb(err));

    } catch (err) {

      return cb(err);

    }

  });

});
","const asyncCallback = (err, docs) => {
  if (err) {
    return callback(err);
  }
  if (docs.length === 0) {
    return callback(null, docs);
  }
  if (this.options.explain) {
    return callback(null, docs);
  }
  if (!mongooseOptions.populate) {
    const versionKey = _this.schema.options.versionKey;
    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
      docs.forEach((doc) => {
        if (versionKey in doc) {
          delete doc[versionKey];
        }
      });
    }
    return mongooseOptions.lean ? _completeManyLean(_this.model.schema, docs, null, completeManyOptions, callback) : completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);
  }
  const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
  if (mongooseOptions.lean) {
    return _this.model.populate(docs, pop, callback);
  }
  completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, (err, docs) => {
    if (err != null) {
      return callback(err);
    }
    _this.model.populate(docs, pop, callback);
  });
};
const options = this._optionsForExec();
options.projection = this._fieldsForExec();
const filter = this._conditions;
try {
  const cursor = await this._collection.collection.find(filter, options).toArray().catch((err) => cb(err));
} catch (err) {
  return cb(err);
}",2023-02-02 15:13:54-05:00,38e98f97e3ac07aa50a0a66fe444ce7e7d3c8a2e
"  if (!callback) {

    return Query.base.deleteOne.call(this);

  }



  this.exec.call(this, callback);

 * @param {Function} callback

Query.prototype._deleteOne = wrapThunk(function(callback) {

    callback(this.error());

    return this;

  callback = _wrapThunkCallback(this, callback);



  this._collection.collection.deleteOne(this._conditions, options).then(

    res => { callback(null, res); },

    err => { callback(err); }

  );

});
","async function _deleteOne(callback) {
  if (!callback) {
    return Query.base.deleteOne.call(this);
  }

  try {
    const res = await this._collection.collection.deleteOne(this._conditions, options);
    callback(null, res);
  } catch (err) {
    callback(err);
  }
}",2023-02-03 10:28:18-05:00,15febec1ee28201d1694a460a4907d5518adc880
"Query.prototype._deleteMany = wrapThunk(function(callback) {

    callback(this.error());

    return this;

  callback = _wrapThunkCallback(this, callback);

  this._collection.collection.deleteMany(this._conditions, options).then(

    res => { callback(null, res); },

    err => { callback(err); }

  );

});
","Query.prototype._deleteMany = async function (callback) {
  try {
    const result = await this._collection.collection.deleteMany(this._conditions, options);
    callback(null, result);
  } catch (error) {
    callback(error);
  }
};",2023-02-03 10:28:18-05:00,15febec1ee28201d1694a460a4907d5518adc880
"    const p1 = Temp.create({ nested: { nums: [1, 2, 3, 4, 5] } });

    p1.then(function(t) {

      t.nested.nums.pull(1);

      t.nested.nums.pull(2);

      assert.equal(t.$__.activePaths.paths['nested.nums'], 'modify');

      done();

    }).catch(done);

  it('$pull should affect what you see in an array before a save', function(done) {
","const p1 = Temp.create({ nested: { nums: [1, 2, 3, 4, 5] } });

async function test() {
  try {
    const t = await p1;

    t.nested.nums.pull(1);
    t.nested.nums.pull(2);

    assert.equal(t.$__.activePaths.paths['nested.nums'], 'modify');

    done();
  } catch (error) {
    done(error);
  }
}

it('$pull should affect what you see in an array before a save', test);",2023-02-03 12:01:42-05:00,7b68d494652f9c2eda7806595ce8ea66a9a50718
"    it('updateOne()', function(done) {

      BlogPost.create({ title: 'interoperable update as promise' }, function(err) {

        assert.ifError(err);

        const query = BlogPost.updateOne({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });

        query.exec(function(err, res) {

          assert.ifError(err);

          assert.equal(res.matchedCount, 1);

          assert.equal(res.modifiedCount, 1);

          BlogPost.count({ title: 'interoperable update as promise delta' }, function(err, count) {

            assert.ifError(err);

            assert.equal(count, 1);

            done();

          });

        });

      });

    it('findOne()', function(done) {

      BlogPost.create({ title: 'interoperable findOne as promise' }, function(err, created) {

        assert.ifError(err);

        const query = BlogPost.findOne({ title: 'interoperable findOne as promise' });

        query.exec(function(err, found) {

          assert.ifError(err);

          assert.equal(found.id, created.id);

          done();

        });

      });

    it('find()', function(done) {

      BlogPost.create(

        { title: 'interoperable find as promise' },

        function(err, createdOne, createdTwo) {

          assert.ifError(err);

          const query = BlogPost.find({ title: 'interoperable find as promise' }).sort('_id');

          query.exec(function(err, found) {

            assert.ifError(err);

            assert.equal(found.length, 2);

            const ids = {};

            ids[String(found[0]._id)] = 1;

            ids[String(found[1]._id)] = 1;

            assert.ok(String(createdOne._id) in ids);

            assert.ok(String(createdTwo._id) in ids);

            done();

          });

        });

    it('op can be changed', function(done) {

      BlogPost.create({ title: title }, function(err, created) {

        assert.ifError(err);

        const query = BlogPost.count({ title: title });

        query.exec('findOne', function(err, found) {

          assert.ifError(err);

          assert.equal(found.id, created.id);

          done();

        });

      });

      it.skip('count()', function(done) {

        BlogPost.create({ title: 'interoperable count as promise 2' }, function(err) {

          assert.ifError(err);

          const query = BlogPost.count({ title: 'interoperable count as promise 2' });

          const promise = query.exec();

          promise.then(function(count) {

            assert.equal(count, 1);

            done();

          }).catch(done);

        });

      });



      it.skip('update()', function(done) {

        BlogPost.create({ title: 'interoperable update as promise 2' }, function(err) {

          assert.ifError(err);

          const query = BlogPost.update({ title: 'interoperable update as promise 2' }, { title: 'interoperable update as promise delta 2' });

          const promise = query.exec();

          promise.then(function() {

            BlogPost.count({ title: 'interoperable update as promise delta 2' }, function(err, count) {

              assert.ifError(err);

              assert.equal(count, 1);

              done();

            });

          });

        });

      });


","it('updateOne()', async function () {
  await BlogPost.create({ title: 'interoperable update as promise' });
  const query = BlogPost.updateOne({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });
  const res = await query.exec();
  assert.equal(res.matchedCount, 1);
  assert.equal(res.modifiedCount, 1);
  const count = await BlogPost.count({ title: 'interoperable update as promise delta' });
  assert.equal(count, 1);
});

it('findOne()', async function () {
  const created = await BlogPost.create({ title: 'interoperable findOne as promise' });
  const query = BlogPost.findOne({ title: 'interoperable findOne as promise' });
  const found = await query.exec();
  assert.equal(found.id, created.id);
});

it('find()', async function () {
  const createdOne = await BlogPost.create({ title: 'interoperable find as promise' });
  const createdTwo = await BlogPost.create({ title: 'interoperable find as promise' });
  const query = BlogPost.find({ title: 'interoperable find as promise' }).sort('_id');
  const found = await query.exec();
  assert.equal(found.length, 2);
  const ids = {};
  ids[String(found[0]._id)] = 1;
  ids[String(found[1]._id)] = 1;
  assert.ok(String(createdOne._id) in ids);
  assert.ok(String(createdTwo._id) in ids);
});

it('op can be changed', async function () {
  const created = await BlogPost.create({ title: 'interoperable count as promise' });
  const query = BlogPost.count({ title: 'interoperable count as promise' });
  const res = await query.exec();
  assert.equal(res, 1);
});

it.skip('update()', async function () {
  const created = await BlogPost.create({ title: 'interoperable update as promise' });
  const query = BlogPost.update({ title: 'interoperable update as promise' }, { title: 'interoperable update as promise delta' });
  await query.exec();
  const count = await BlogPost.count({ title: 'interoperable update as promise delta' });
  assert.equal(count, 1);
});",2023-02-07 12:39:03-05:00,3ae89172dd14aee576d97fb6c47b54e7d76640c0
"      it('find()', function(done) {

        BlogPost.create(

          { title: 'interoperable find as promise 2' },

          function(err, createdOne, createdTwo) {

            assert.ifError(err);

            const query = BlogPost.find({ title: 'interoperable find as promise 2' }).sort('_id');

            const promise = query.exec();

            promise.then(function(found) {

              assert.ifError(err);

              assert.equal(found.length, 2);

              assert.equal(found[0].id, createdOne.id);

              assert.equal(found[1].id, createdTwo.id);

              done();

            }).catch(done);

          });

      });



      it.skip('remove()', function() {

        return BlogPost.create({ title: 'interoperable remove as promise 2' }).

          then(() => {

            return BlogPost.remove({ title: 'interoperable remove as promise 2' });

          }).

          then(() => {

            return BlogPost.count({ title: 'interoperable remove as promise 2' });

          }).

          then(count => {

            assert.equal(count, 0);

          });

      });

      it('are thenable', function(done) {

        const peopleSchema = new Schema({ name: String, likes: ['ObjectId'] });

        const P = db.model('Test', peopleSchema);

        BlogPost.create(

          { title: 'then promise 1' },

          { title: 'then promise 2' },

          { title: 'then promise 3' },

          function(err, d1, d2, d3) {

            assert.ifError(err);



            P.create(

              { name: 'brandon', likes: [d1] },

              { name: 'ben', likes: [d2] },

              { name: 'bernie', likes: [d3] },

              function(err) {

                assert.ifError(err);



                const promise = BlogPost.find({ title: /^then promise/ }).select('_id').exec();

                promise.then(function(blogs) {

                  const ids = blogs.map(function(m) {

                    return m._id;

                  });

                  return P.where('likes').in(ids).exec();

                }).then(function(people) {

                  assert.equal(people.length, 3);

                  return people;

                }).then(function() {

                  done();

                }, function(err) {

                  done(new Error(err));

                });

              });

          });

    it('hides private props', function(done) {
","it('find()', async () => {

  const createdOne = await BlogPost.create({ title: 'interoperable find as promise 2' });
  const createdTwo = await BlogPost.create({ title: 'interoperable find as promise 2' });

  const query = BlogPost.find({ title: 'interoperable find as promise 2' }).sort('_id');
  const found = await query.exec();

  assert.ifError(err);

  assert.equal(found.length, 2);

  assert.equal(found[0].id, createdOne.id);

  assert.equal(found[1].id, createdTwo.id);

  done();
});

it.skip('remove()', async () => {
  await BlogPost.create({ title: 'interoperable remove as promise 2' });
  await BlogPost.remove({ title: 'interoperable remove as promise 2' });
  const count = await BlogPost.count({ title: 'interoperable remove as promise 2' });
  assert.equal(count, 0);
});

it('are thenable', async () => {

  const peopleSchema = new Schema({ name: String, likes: ['ObjectId'] });

  const P = db.model('Test', peopleSchema);

  const d1 = await BlogPost.create({ title: 'then promise 1' });
  const d2 = await BlogPost.create({ title: 'then promise 2' });
  const d3 = await BlogPost.create({ title: 'then promise 3' });

  const promise = BlogPost.find({ title: /^then promise/ }).select('_id').exec();
  const blogs = await promise;

  const ids = blogs.map(function(m) {
    return m._id;
  });

  const people = await P.where('likes').in(ids).exec();

  assert.equal(people.length, 3);

  return people;
});

it('hides private props', async () => {
  // TODO: write test for hiding private props
  done();
});",2023-02-07 12:39:03-05:00,3ae89172dd14aee576d97fb6c47b54e7d76640c0
"      savePromise.then(function() {

        assert.ok(!doc.$__.$versionError);

        assert.ok(!doc.$__.saveOptions);

        done();

      }).catch(done);

    it('should overwrite arrays when directly set (gh-1126)', function(done) {

      BlogPost.create({ title: 'gh-1126', numbers: [1, 2] }, function(err, b) {

        assert.ifError(err);

        BlogPost.findById(b._id, function(err, b) {

          assert.ifError(err);

          assert.deepEqual([1, 2].join(), b.numbers.join());



          b.numbers = [];

          b.numbers.push(3);



          const d = b.$__delta()[1];

          assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));

          assert.ok(Array.isArray(d.$set.numbers));

          assert.equal(d.$set.numbers.length, 1);

          assert.equal(d.$set.numbers[0], 3);



          b.save(function(err) {

            assert.ifError(err);



            BlogPost.findById(b._id, function(err, b) {

              assert.ifError(err);

              assert.ok(Array.isArray(b.numbers));

              assert.equal(b.numbers.length, 1);

              assert.equal(b.numbers[0], 3);



              b.numbers = [3];

              const d = b.$__delta();

              assert.ok(!d);



              b.numbers = [4];

              b.numbers.push(5);

              b.save(function(err) {

                assert.ifError(err);

                BlogPost.findById(b._id, function(err, b) {

                  assert.ifError(err);

                  assert.ok(Array.isArray(b.numbers));

                  assert.equal(b.numbers.length, 2);

                  assert.equal(b.numbers[0], 4);

                  assert.equal(b.numbers[1], 5);

                  done();

                });

              });

            });

          });

        });

      });

    it('should use $set when subdoc changed before pulling (gh-1303)', function(done) {

      B.create(

        { title: 'gh-1303', comments: [{ body: 'a' }, { body: 'b' }, { body: 'c' }] },

        function(err, b) {

          assert.ifError(err);

          B.findById(b._id, function(err, b) {

            assert.ifError(err);



            b.comments[2].body = 'changed';

            b.comments.pull(b.comments[1]);



            assert.equal(b.comments.length, 2);

            assert.equal(b.comments[0].body, 'a');

            assert.equal(b.comments[1].body, 'changed');



            const d = b.$__delta()[1];

            assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));

            assert.ok(Array.isArray(d.$set.comments));

            assert.equal(d.$set.comments.length, 2);



            b.save(function(err) {

              assert.ifError(err);



              B.findById(b._id, function(err, b) {

                assert.ifError(err);

                assert.ok(Array.isArray(b.comments));

                assert.equal(b.comments.length, 2);

                assert.equal(b.comments[0].body, 'a');

                assert.equal(b.comments[1].body, 'changed');

                done();

              });

            });

          });

        });

    it('with conflicted data in db', function(done) {

      m.save(function(err) {

        assert.strictEqual(err, null);

        assert.strictEqual('GI', m.namey.first);

        assert.strictEqual('Joe', m.namey.last);

        done();

      });

    it('with positional notation on path not existing in schema (gh-1048)', function(done) {
","savePromise.then(() => {
  assert.ok(!doc.$__.$versionError);
  assert.ok(!doc.$__.saveOptions);
  done();
}).catch(done);

it('should overwrite arrays when directly set (gh-1126)', function(done) {
  BlogPost.create({ title: 'gh-1126', numbers: [1, 2] }, function(err, b) {
    assert.ifError(err);
    BlogPost.findById(b._id, function(err, b) {
      assert.ifError(err);
      assert.deepEqual([1, 2].join(), b.numbers.join());
      b.numbers = [];
      b.numbers.push(3);
      const d = b.$__delta()[1];
      assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));
      assert.ok(Array.isArray(d.$set.numbers));
      assert.equal(d.$set.numbers.length, 1);
      assert.equal(d.$set.numbers[0], 3);
      b.save(function(err) {
        assert.ifError(err);
        BlogPost.findById(b._id, function(err, b) {
          assert.ifError(err);
          assert.ok(Array.isArray(b.numbers));
          assert.equal(b.numbers.length, 1);
          assert.equal(b.numbers[0], 3);
          done();
        });
      });
    });
  });
});

it('should use $set when subdoc changed before pulling (gh-1303)', function(done) {
  B.create(
    { title: 'gh-1303', comments: [{ body: 'a' }, { body: 'b' }, { body: 'c' }] },
    function(err, b) {
      assert.ifError(err);
      B.findById(b._id, function(err, b) {
        assert.ifError(err);
        b.comments[2].body = 'changed';
        b.comments.pull(b.comments[1]);
        assert.equal(b.comments.length, 2);
        assert.equal(b.comments[0].body, 'a');
        assert.equal(b.comments[1].body, 'changed');
        const d = b.$__delta()[1];
        assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));
        assert.ok(Array.isArray(d.$set.comments));
        assert.equal(d.$set.comments.length, 2);
        b.save(function(err) {
          assert.ifError(err);
          B.findById(b._id, function(err, b) {
            assert.ifError(err);
            assert.ok(Array.isArray(b.comments));
            assert.equal(b.comments.length, 2);
            assert.equal(b.comments[0].body, 'a');
            assert.equal(b.comments[1].body, 'changed');
            done();
          });
        });
      });
    }
  );
});

it('with conflicted data in db', function(done) {
  m.save(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual('GI', m.namey.first);
    assert.strictEqual('Joe', m.namey.last);
    done();
  });
});

it('with positional notation on path not existing in schema (gh-1048)', function(done) {
  m.save(function(err) {
    assert.strictEqual(err, null);
    assert.strictEqual('GI', m.namey.first);
    assert.strictEqual('Joe', m.namey.last);
    done();
  });
});",2023-02-07 12:39:03-05:00,3ae89172dd14aee576d97fb6c47b54e7d76640c0
"      Movie.insertMany(movies, function(error, docs) {

        assert.ifError(error);

        assert.equal(docs.length, 1);

        Movie.findOne({ name: 'Predator' }, function(error, doc) {

          assert.ifError(error);

          assert.equal(doc.leadActor.toHexString(), arnold._id.toHexString());

          done();

        });

      });

    });



    it('insertMany() with promises (gh-4237)', function(done) {

      const schema = new Schema({

        name: String

      });

      const Movie = db.model('Movie', schema);



      const arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];

      Movie.insertMany(arr).then(function(docs) {

        assert.equal(docs.length, 2);

        assert.ok(!docs[0].isNew);

        assert.ok(!docs[1].isNew);

        Movie.find({}, function(error, docs) {

          assert.ifError(error);

          assert.equal(docs.length, 2);

          done();

        });

      });
","Movie.insertMany(movies).then(function(docs) {

    assert.ifError(error);

    assert.equal(docs.length, 1);

    const doc = await Movie.findOne({ name: 'Predator' });

    assert.ok(!doc.isNew);

    done();

});",2023-02-07 12:39:03-05:00,3ae89172dd14aee576d97fb6c47b54e7d76640c0
"    it('should have fields when create', function(done) {

      cat.save(function(err, doc) {

        assert.ok(doc.createdAt);

        assert.ok(doc.updatedAt);

        assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

        done();

      });

    it('sets timestamps on findOneAndUpdate', function(done) {

      Cat.findOneAndUpdate({ name: 'notexistname' }, { $set: {} }, { upsert: true, new: true }, function(err, doc) {

        assert.ok(doc.createdAt);

        assert.ok(doc.updatedAt);

        assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

        done();

      });

    it('sets timestamps on findOneAndReplace (gh-9951)', function() {

      return Cat.findOneAndReplace({ name: 'notexistname' }, {}, { upsert: true, new: true }).then(doc => {

        assert.ok(doc.createdAt);

        assert.ok(doc.updatedAt);

        assert.ok(doc.createdAt.getTime() === doc.updatedAt.getTime());

      });

    it('should change updatedAt when save', function(done) {

      Cat.findOne({ name: 'newcat' }, function(err, doc) {

        const old = doc.updatedAt;

        doc.hobby = 'coding';

        doc.save(function(err, doc) {

          assert.ok(doc.updatedAt.getTime() > old.getTime());

          done();

        });

      });

    it('should not change updatedAt when save with no modifications', function(done) {

      Cat.findOne({ name: 'newcat' }, function(err, doc) {

        const old = doc.updatedAt;

        doc.save(function(err, doc) {

          assert.ok(doc.updatedAt.getTime() === old.getTime());

          done();

        });

      });
","async function () {
  const cat = new Cat({ name: 'newcat' });
  await cat.save();
  const oldUpdatedAt = doc.updatedAt;
  await doc.save();
  assert.ok(doc.updatedAt.getTime() === oldUpdatedAt.getTime());
}",2023-02-07 13:07:54-05:00,1a32861360f8326ad3f8182eee9c45636e76240e
"      instance.save(function(error) {

        assert.ifError(error);

        const query = { _id: instance._id };

        const update = { $set: { name: value } };

        const ok = function() {

          done();

        };

        Model.updateOne(query, update).then(ok, done);

      });

    it('versioning with setDefaultsOnInsert (gh-2593)', function(done) {
","import assert from 'assert';

// Migrated code
async function test() {
  try {
    const instance = new Model();
    await instance.save();
    const query = { _id: instance._id };
    const update = { $set: { name: value } };
    await Model.updateOne(query, update);
    done();
  } catch (error) {
    assert.ifError(error);
  }
}

// Original code
instance.save(function(error) {
  assert.ifError(error);
  const query = { _id: instance._id };
  const update = { $set: { name: value } };
  Model.updateOne(query, update).then(done, done);
});",2023-02-08 11:43:29-05:00,81620f354d4fd7cabf6eb8a49a0a3ad50d813f42
"      Model.updateOne(q, u, o).then(function() {

        done();

      }).catch(done);
","async function update() {
  try {
    await Model.updateOne(q, u, o);
    done();
  } catch (err) {
    done(err);
  }
}",2023-02-08 11:43:29-05:00,81620f354d4fd7cabf6eb8a49a0a3ad50d813f42
"      ModelA.create({ name: 'model-A' }, function(error, toyA) {

        assert.ifError(error);

        ModelB.create({ name: 'model-B' }, function(error, toyB) {

          assert.ifError(error);

          Parent.create({

            children: [

              {

                name: 'Child 1',

                toy: { kind: 'Test1', value: toyA._id }

              },

              {

                name: 'Child 2'

              },

              {

                name: 'Child 3',

                toy: { kind: 'Test2', value: toyB._id }

              }

            ]

          }, function(error, doc) {

            assert.ifError(error);

            test(doc._id);

          });

        });

      function test(id) {

        Parent.findById(id, function(error, doc) {

          assert.ifError(error);

          doc.populate('children.toy.value').then(function(doc) {

            assert.equal(doc.children[0].toy.value.name, 'model-A');

            assert.equal(doc.children[1].toy.value, null);

            assert.equal(doc.children[2].toy.value.name, 'model-B');

            done();

          }).catch(done);

        });

      }
","ModelA.create({ name: 'model-A' }, async (error, toyA) => {
    assert.ifError(error);
    const toyB = await ModelB.create({ name: 'model-B' });
    const parent = await Parent.create({
      children: [
        { name: 'Child 1', toy: { kind: 'Test1', value: toyA._id } },
        { name: 'Child 2' },
        { name: 'Child 3', toy: { kind: 'Test2', value: toyB._id } },
      ],
    });
    test(parent._id);
  });

  async function test(id) {
    const parent = await Parent.findById(id).populate('children.toy.value');
    assert.equal(parent.children[0].toy.value.name, 'model-A');
    assert.equal(parent.children[1].toy.value, null);
    assert.equal(parent.children[2].toy.value.name, 'model-B');
  }",2023-02-08 14:49:02-05:00,55c53d0c813f88d9e7a1d45e95a2b62b3dd7fdf9
"QueryCursor.prototype.close = function(callback) {

  return promiseOrCallback(callback, cb => {

    this.cursor.close().then(

      () => {

        this.emit('close');

        cb(null);

      },

      error => {

        cb(error);

        this.listeners('error').length > 0 && this.emit('error', error);

      }

    );

  }, this.model.events);
","QueryCursor.prototype.close = async function(callback) {

  try {

    await this.cursor.close();

    this.emit('close');

    if (callback) callback(null);

  } catch (error) {

    if (callback) callback(error);

    else this.listeners('error').length > 0 && this.emit('error', error);

  }

}",2023-02-12 13:14:57-05:00,1a28ba52366a2e58627ff6f5e0bd12e684d7ac88
"  callback = this.$handleCallbackError(callback);



  return this.db.base._promiseOrCallback(callback, cb => {

    cb = this.$wrapCallback(cb);

    this.db.createCollection(this.$__collection.collectionName, options).then(

      () => cb(null, this.$__collection),

      err => {

        if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {

          return cb(err);

        }

        return cb(null, this.$__collection);

      }

    );

  }, this.events);
","async function createCollection(options) {
    try {
      await this.db.createCollection(this.$__collection.collectionName, options);
      return this.$__collection;
    } catch (err) {
      if (err.name === 'MongoServerError' && err.code === 48) {
        return this.$__collection;
      } else {
        throw err;
      }
    }
  }",2023-02-12 13:41:22-05:00,e2211846a666289476d8d9856476d6281b56cf2a
" *     Event.init().then(function(Event) {

 *       // You can also use `Event.on('index')` if you prefer event emitters

 *       // over promises.

 *       console.log('Indexes are done building!');

 *     });
","async function init() {
  await Event.init();
  console.log('Indexes are done building!');
}",2023-03-07 13:36:53-05:00,87592672b7cd33510124d3bcc4c88a48b3419934
"      TestModel.diffIndexes().then((diff) => {

        assert.deepEqual(diff, { toCreate: [{ age: 1, title: 'text', description: 'text' }], toDrop: [] });

        TestModel.syncIndexes().then(() => {

          TestModel.diffIndexes().then((diff2) => {

            assert.deepEqual(diff2, { toCreate: [], toDrop: [] });

            done();

          });

        });

      });
","TestModel.diffIndexes()
    .then((diff) => {
        assert.deepEqual(diff, { toCreate: [{ age: 1, title: 'text', description: 'text' }], toDrop: [] });
    })
    .then(() => TestModel.syncIndexes())
    .then(() => {
        return TestModel.diffIndexes();
    })
    .then((diff2) => {
        assert.deepEqual(diff2, { toCreate: [], toDrop: [] });
        done();
    });",2023-04-04 15:57:20-04:00,e201f3b3edc3132ab475cd1c419e1e93fc0a0f7c
"        doc.save().then();
",await doc.save();,2023-06-23 10:27:15-04:00,32e4a2efef4fea3679530f20e28122f357adb352
"      it('should allow setting values to a given property gh-13510', function() {

        doc.save().then();
","it('should allow setting values to a given property gh-13510', async function() {
  await doc.save();
});",2023-06-23 12:09:52-04:00,9c7618113e4809d4a4934cb79e67496b79cb87b6
"  console.log(`Processing ~${files.length} files`);

  Promise.all([pugifyAllFiles(), copyAllRequiredFiles()]).then(() => {

    console.log(""Done Processing"");

  })
","console.log(`Processing ${files.length} files`);

async function main() {
  await Promise.all([pugifyAllFiles(), copyAllRequiredFiles()]);
  console.log(""Done Processing"");
}

main();",2023-11-20 15:41:20-05:00,020a8f3a48990fd7d4588964755420b90844baef
"  // data that should persist across subPopulate calls

  const cache = {};

  return new Promise((resolve, reject) => {

    _populate(_this, docs, paths, cache, (err, res) => {

      if (err) {

        return reject(err);

      }

      resolve(res);

    });

  });
","// data that should persist across subPopulate calls
const cache = {};

try {
  const res = await _populate(_this, docs, paths, cache);
  return res;
} catch (err) {
  throw err;
}",2024-12-07 20:37:33-05:00,467db46d2ca711ba4807eaf459e2c521628e8535
"render(process.argv[2] || '/')

  .then(html => console.log(html))

  .catch((err) => {

    console.error(err)

    process.exit(1)

  })
","async function render(url = '/') {
  try {
    const html = await fetch(url);
    return html;
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
}

render(process.argv[2] || '/')
  .then((html) => console.log(html))
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });",2020-11-03 21:26:27+01:00,d441d79c6ca3eb3c0f64bba1217375e6505401c0
"module.exports = (req, res) => {

  const start = process.hrtime()

  render(req.url).then((html) => {

    const end = process.hrtime(start)

    const time = ((end[0] * 1e9) + end[1]) / 1e6

    // @ts-ignore

    res.setHeader('X-Nuxt-Coldstart', global._coldstart + 'ms')

    res.setHeader('X-Nuxt-Responsetime', time + 'ms')



  }).catch((err) => {

    console.error(err)

    res.end('Error: ' + err)

  })
","module.exports = async (req, res) => {

  const start = process.hrtime()

  try {

    const html = await render(req.url)

    const end = process.hrtime(start)

    const time = ((end[0] * 1e9) + end[1]) / 1e6

    res.setHeader('X-Nuxt-Coldstart', global._coldstart + 'ms')

    res.setHeader('X-Nuxt-Responsetime', time + 'ms')

    res.send(html)

  } catch (err) {

    console.error(err)

    res.end('Error: ' + err)

  }

}",2020-11-03 21:26:27+01:00,d441d79c6ca3eb3c0f64bba1217375e6505401c0
"const getPluginMode = (src) => {

  return mode

export function resolvePlugins (builder: Builder, app: NuxtApp) {

  return resolveFiles(builder, 'plugins/**/*.{js,ts}', app.dir)

    .then(plugins => plugins.map((src) => {

      return {

        src,

        mode: getPluginMode(src)

      }

    }))
","const getPluginMode = async (src) => {
  const mode = await new Promise((resolve, reject) => {
    resolve(); // add your logic here to determine the mode
  });
  return mode;
};

export async function resolvePlugins(builder, app) {
  const plugins = await resolveFiles(builder, 'plugins/**/*.{js,ts}', app.dir);
  return Promise.all(plugins.map((src) => getPluginMode(src)));
}",2021-04-04 23:15:34+01:00,2db79adfb8a9db269c43042f1c3912a38c0621b3
"import { CreateOptions } from '#app'

const entry = process.server

  ? (ctx?: CreateOptions['ssrContext']) => import('#app/bootstrap').then(m => m.default(ctx))

  : () => import('#app/bootstrap').then(m => m.default)

  entry()

export default entry
","import { CreateOptions } from '#app'

const entry = process.server

  ? async (ctx?: CreateOptions['ssrContext']) => import('#app/bootstrap').then(m => m.default(ctx))

  : async () => import('#app/bootstrap').then(m => m.default)

await entry()

export default entry",2022-02-25 12:42:34+00:00,e45a780714c1ba44807ba6dbce3f2b5209ec0339
"    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {

      const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath)

      const redirect = () => nuxtApp.callHook('app:redirected')

        .then(() => sendRedirect(nuxtApp.ssrContext!.event, redirectLocation, options?.redirectCode || 302))

        .then(() => inMiddleware ? /* abort route navigation */ false : undefined)

      // We wait to perform the redirect in case any other middleware will intercept the redirect

      // and redirect further.

        router.beforeEach(final => (final.fullPath === fullPath) ? redirect() : undefined)
","if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {
  const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath)
  const redirect = () => nuxtApp.callHook('app:redirected')
    .then(() => sendRedirect(nuxtApp.ssrContext!.event, redirectLocation, options?.redirectCode || 302))
    .then(() => inMiddleware ? /* abort route navigation */ false : undefined)
  // We wait to perform the redirect in case any other middleware will intercept the redirect
  // and redirect further.
  router.beforeEach(async (final) => {
    if (final.fullPath === fullPath) {
      await redirect();
    }
  });
}",2023-04-28 11:18:03+01:00,f73bb1de0a9b22714810cff4999f898c77eafa67
"    this.fetchBuiltInCMap = (name) => {

        return Promise.resolve(this.builtInCMapCache.get(name));

      return this.handler.sendWithPromise('FetchBuiltInCMap', {

        name,

      }).then((data) => {

        if (data.compressionType !== CMapCompressionType.NONE) {

          // Given the size of uncompressed CMaps, only cache compressed ones.

          this.builtInCMapCache.set(name, data);

        }

        return data;

      });
","this.fetchBuiltInCMap = async (name) => {
  
    let result = await this.builtInCMapCache.get(name);
  
    if (!result) {
  
      const data = await this.handler.sendWithPromise('FetchBuiltInCMap', { name });
  
      if (data.compressionType !== CMapCompressionType.NONE) {
  
        // Given the size of uncompressed CMaps, only cache compressed ones.
  
        this.builtInCMapCache.set(name, data);
  
      }
  
      return data;
  
    }
  
    return result;
  
  };",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"    fetchIfRefAsync: function XRef_fetchIfRefAsync(obj, suppressEncryption) {

        return Promise.resolve(obj);

    fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {

      var streamManager = this.stream.manager;

      var xref = this;

      return new Promise(function tryFetch(resolve, reject) {

        try {

          resolve(xref.fetch(ref, suppressEncryption));

        } catch (e) {

          if (e instanceof MissingDataException) {

            streamManager.requestRange(e.begin, e.end).then(function () {

              tryFetch(resolve, reject);

            }, reject);

            return;

          }

          reject(e);

      });
","fetchIfRefAsync: async function XRef_fetchIfRefAsync(obj, suppressEncryption) {
  return obj;
},
fetchAsync: async function XRef_fetchAsync(ref, suppressEncryption) {
  const streamManager = this.stream.manager;
  try {
    return await xref.fetch(ref, suppressEncryption);
  } catch (e) {
    if (e instanceof MissingDataException) {
      await streamManager.requestRange(e.begin, e.end);
      return await tryFetch();
    } else {
      throw e;
    }
  }
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"  ensure(obj, prop, args) {

    return new Promise(function(resolve) {

      const value = obj[prop];

      if (typeof value === 'function') {

        resolve(value.apply(obj, args));

      } else {

        resolve(value);

      }

    });
","async function ensure(obj, prop, ...args) {
  const value = obj[prop];
  if (typeof value === 'function') {
    return await value.apply(obj, args);
  } else {
    return value;
  }
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"  ensure(obj, prop, args) {

    return new Promise((resolve, reject) => {

      let ensureHelper = () => {

        try {

          const value = obj[prop];

          let result;

          if (typeof value === 'function') {

            result = value.apply(obj, args);

          } else {

            result = value;

          }

          resolve(result);

        } catch (ex) {

          if (!(ex instanceof MissingDataException)) {

            reject(ex);

            return;

          }

          this.streamManager.requestRange(ex.begin, ex.end)

            .then(ensureHelper, reject);

        }

      };



      ensureHelper();

    });
","async function ensure(obj, prop, args) {
  try {
    const value = obj[prop];
    let result;
    if (typeof value === 'function') {
      result = await value.apply(obj, args);
    } else {
      result = value;
    }
    return result;
  } catch (ex) {
    if (!(ex instanceof MissingDataException)) {
      throw ex;
    }
    try {
      await this.streamManager.requestRange(ex.begin, ex.end);
      ensureHelper();
    } catch (ex) {
      reject(ex);
    }
  }
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"  read() {

    return this._headersCapability.promise.then(() => {

      return this._reader.read().then(({ value, done, }) => {

        if (done) {

          return Promise.resolve({ value, done, });

        }

        this._loaded += value.byteLength;

        if (this.onProgress) {

          this.onProgress({

            loaded: this._loaded,

            total: this._contentLength,

          });

        }

        let buffer = new Uint8Array(value).buffer;

        return Promise.resolve({ value: buffer, done: false, });

    });
","async read() {
  await this._headersCapability.promise;
  const result = await this._reader.read();
  if (result.done) {
    return { value: result.value, done: true };
  }
  this._loaded += result.value.byteLength;
  if (this.onProgress) {
    this.onProgress({
      loaded: this._loaded,
      total: this._contentLength,
    });
  }
  return { value: new Uint8Array(result.value).buffer, done: false };
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"  read() {

    return this._readCapability.promise.then(() => {

      return this._reader.read().then(({ value, done, }) => {

        if (done) {

          return Promise.resolve({ value, done, });

        }

        this._loaded += value.byteLength;

        if (this.onProgress) {

          this.onProgress({ loaded: this._loaded, });

        }

        let buffer = new Uint8Array(value).buffer;

        return Promise.resolve({ value: buffer, done: false, });

      });

    });
","read() {
  try {
    await this._readCapability.promise;
    const { value, done } = await this._reader.read();
    if (done) {
      return { value, done };
    }
    this._loaded += value.byteLength;
    if (this.onProgress) {
      this.onProgress({ loaded: this._loaded });
    }
    const buffer = new Uint8Array(value).buffer;
    return { value: buffer, done: false };
  } catch (error) {
    console.error('Error reading file', error);
  }
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"  read() {

    return this._readCapability.promise.then(() => {

      if (this._done) {

        return Promise.resolve({ value: undefined, done: true, });

      }

      if (this._storedError) {

        return Promise.reject(this._storedError);

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({

          loaded: this._loaded,

          total: this._contentLength,

        });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return Promise.resolve({ value: buffer, done: false, });

    });
","read() {
  try {
    await this._readCapability.promise;
    if (this._done) return Promise.resolve({ value: undefined, done: true });
    if (this._storedError) return Promise.reject(this._storedError);
    let chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = createPromiseCapability();
      return this.read();
    }
    this._loaded += chunk.length;
    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength,
      });
    }
    // Ensure that `read()` method returns ArrayBuffer.
    let buffer = new Uint8Array(chunk).buffer;
    return Promise.resolve({ value: buffer, done: false });
  } catch (error) {
    console.error(""Error occurred while reading from the stream:"", error);
    this._storedError = error;
    throw error;
  }
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"  read() {

    return this._readCapability.promise.then(() => {

      if (this._done) {

        return Promise.resolve({ value: undefined, done: true, });

      }

      if (this._storedError) {

        return Promise.reject(this._storedError);

      }

      let chunk = this._readableStream.read();

      if (chunk === null) {

        this._readCapability = createPromiseCapability();

        return this.read();

      }

      this._loaded += chunk.length;

      if (this.onProgress) {

        this.onProgress({ loaded: this._loaded, });

      }

      // Ensure that `read()` method returns ArrayBuffer.

      let buffer = new Uint8Array(chunk).buffer;

      return Promise.resolve({ value: buffer, done: false, });

    });
","read() {
  try {
    await this._readCapability.promise;
  } catch (error) {
    // Handle error if needed
    return Promise.reject(error);
  }
  if (this._done) {
    return { value: undefined, done: true };
  }
  if (this._storedError) {
    return Promise.reject(this._storedError);
  }
  let chunk = this._readableStream.read();
  if (chunk === null) {
    this._readCapability = createPromiseCapability();
    return this.read();
  }
  this._loaded += chunk.length;
  if (this.onProgress) {
    this.onProgress({ loaded: this._loaded });
  }
  // Ensure that `read()` method returns ArrayBuffer.
  let buffer = new Uint8Array(chunk).buffer;
  return { value: buffer, done: false };
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"function resolveCall(fn, args, thisArg = null) {

    return Promise.resolve(undefined);

  return new Promise((resolve, reject) => {

    resolve(fn.apply(thisArg, args));

  });
","async function resolveCall(fn, args, thisArg = null) {
  try {
    const result = await fn.apply(thisArg, args);
    return Promise.resolve(result);
  } catch (error) {
    return Promise.reject(error);
  }
}",2018-07-30 13:58:09+02:00,099ed0885239f070f7c7e1d703b57cc64c3f634d
"  getLanguage() {

    return this._ready.then((l10n) => {

      return l10n.getLanguage();

    });

  getDirection() {

    return this._ready.then((l10n) => {

      return l10n.getDirection();

    });

  get(property, args, fallback) {

    return this._ready.then((l10n) => {

      return l10n.get(property, args, fallback);

    });

  translate(element) {

    return this._ready.then((l10n) => {

      return l10n.translate(element);

    });
","getLanguage() {

    return await this._ready.then((l10n) => {

      return l10n.getLanguage();

    });

  getDirection() {

    return await this._ready.then((l10n) => {

      return l10n.getDirection();

    });

  get(property, args, fallback) {

    return await this._ready.then((l10n) => {

      return l10n.get(property, args, fallback);

    });

  translate(element) {

    return await this._ready.then((l10n) => {

      return l10n.translate(element);

    });

  }",2018-07-30 16:28:39+02:00,b0fa02e8456b6a27d6d3b242c4301a4e70937b17
"  register(name, element, callerCloseMethod = null, canForceClose = false) {

    return new Promise((resolve) => {

      let container;

      if (!name || !element || !(container = element.parentNode)) {

        throw new Error('Not enough parameters.');

      } else if (this._overlays[name]) {

        throw new Error('The overlay is already registered.');

      }

      this._overlays[name] = {

        element,

        container,

        callerCloseMethod,

        canForceClose,

      };

      resolve();

    });
","register(name, element, callerCloseMethod = null, canForceClose = false) {

    return new Promise((resolve) => {

      let container;

      if (!name || !element || !(container = element.parentNode)) {

        throw new Error('Not enough parameters.');

      } else if (this._overlays[name]) {

        throw new Error('The overlay is already registered.');

      }

      this._overlays[name] = {

        element,

        container,

        callerCloseMethod,

        canForceClose,

      };

      resolve();

    });

  }",2018-07-30 16:39:06+02:00,64e70fc16ffb102524215d02b5b3ebabddbacc09
"  unregister(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (this._active === name) {

        throw new Error('The overlay cannot be removed while it is active.');

      }

      delete this._overlays[name];

      resolve();

    });
","async unregister(name) {
  if (!this._overlays[name]) {
    throw new Error('The overlay does not exist.');
  } else if (this._active === name) {
    throw new Error('The overlay cannot be removed while it is active.');
  }
  delete this._overlays[name];
}",2018-07-30 16:39:06+02:00,64e70fc16ffb102524215d02b5b3ebabddbacc09
"  open(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (this._active) {

        if (this._overlays[name].canForceClose) {

          this._closeThroughCaller();

        } else if (this._active === name) {

          throw new Error('The overlay is already active.');

        } else {

          throw new Error('Another overlay is currently active.');

        }

      this._active = name;

      this._overlays[this._active].element.classList.remove('hidden');

      this._overlays[this._active].container.classList.remove('hidden');

      window.addEventListener('keydown', this._keyDownBound);

      resolve();

    });
","async open(name) {
  if (!this._overlays[name]) {
    throw new Error('The overlay does not exist.');
  } else if (this._active) {
    if (this._overlays[name].canForceClose) {
      this._closeThroughCaller();
    } else if (this._active === name) {
      throw new Error('The overlay is already active.');
    } else {
      throw new Error('Another overlay is currently active.');
    }
  }
  this._active = name;
  this._overlays[this._active].element.classList.remove('hidden');
  this._overlays[this._active].container.classList.remove('hidden');
  window.addEventListener('keydown', this._keyDownBound);
}",2018-07-30 16:39:06+02:00,64e70fc16ffb102524215d02b5b3ebabddbacc09
"  close(name) {

    return new Promise((resolve) => {

      if (!this._overlays[name]) {

        throw new Error('The overlay does not exist.');

      } else if (!this._active) {

        throw new Error('The overlay is currently not active.');

      } else if (this._active !== name) {

        throw new Error('Another overlay is currently active.');

      }

      this._overlays[this._active].container.classList.add('hidden');

      this._overlays[this._active].element.classList.add('hidden');

      this._active = null;

      window.removeEventListener('keydown', this._keyDownBound);

      resolve();

    });
","close(name) {
    return new Promise((resolve) => {
      if (!this._overlays[name]) {
        throw new Error('The overlay does not exist.');
      } else if (!this._active) {
        throw new Error('The overlay is currently not active.');
      } else if (this._active !== name) {
        throw new Error('Another overlay is currently active.');
      }
      this._overlays[this._active].container.classList.add('hidden');
      this._overlays[this._active].element.classList.add('hidden');
      this._active = null;
      window.removeEventListener('keydown', this._keyDownBound);
      resolve();
    });
  }",2018-07-30 16:39:06+02:00,64e70fc16ffb102524215d02b5b3ebabddbacc09
"  _writeToStorage(prefObj) {

    return new Promise(function(resolve) {

      localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));

      resolve();

    });

  _readFromStorage(prefObj) {

    return new Promise(function(resolve) {

      let readPrefs = JSON.parse(localStorage.getItem('pdfjs.preferences'));

      resolve(readPrefs);

    });
","async _writeToStorage(prefObj) {
    try {
      localStorage.setItem('pdfjs.preferences', JSON.stringify(prefObj));
    } catch (e) {
      console.error(`Failed to write preferences to storage: ${e}`);
    }
  }

  async _readFromStorage() {
    try {
      let readPrefs = JSON.parse(localStorage.getItem('pdfjs.preferences'));
      return readPrefs;
    } catch (e) {
      console.error(`Failed to read preferences from storage: ${e}`);
    }
  }",2018-07-30 16:48:16+02:00,233b3274bf7973aa06a674dddef585f4313f3742
"  reset() {

    return this._initializedPromise.then(() => {

      this.prefs = Object.assign(Object.create(null), this.defaults);

      return this._writeToStorage(this.defaults);

    });
","reset() {
  try {
    await this._initializedPromise;
    this.prefs = Object.assign(Object.create(null), this.defaults);
    await this._writeToStorage(this.defaults);
  } catch (error) {
    console.log(""Error while resetting preferences:"", error);
  }
}",2018-07-30 16:48:16+02:00,233b3274bf7973aa06a674dddef585f4313f3742
"  set(name, value) {

    return this._initializedPromise.then(() => {

      if (this.defaults[name] === undefined) {

        throw new Error(`Set preference: ""${name}"" is undefined.`);

      } else if (value === undefined) {

        throw new Error('Set preference: no value is specified.');

      }

      let valueType = typeof value;

      let defaultType = typeof this.defaults[name];

      if (valueType !== defaultType) {

        if (valueType === 'number' && defaultType === 'string') {

          value = value.toString();

        } else {

          throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                          `expected a ${defaultType}.`);

        }

        if (valueType === 'number' && !Number.isInteger(value)) {

          throw new Error(`Set preference: ""${value}"" must be an integer.`);

        }

      this.prefs[name] = value;

      return this._writeToStorage(this.prefs);

    });
","`async set(name, value) {

    await this._initializedPromise;

    if (this.defaults[name] === undefined) {

      throw new Error(`Set preference: ""${name}"" is undefined.`);

    } else if (value === undefined) {

      throw new Error('Set preference: no value is specified.');

    }

    let valueType = typeof value;

    let defaultType = typeof this.defaults[name];

    if (valueType !== defaultType) {

      if (valueType === 'number' && defaultType === 'string') {

        value = value.toString();

      } else {

        throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                        `expected a ${defaultType}.`);

      }

      if (valueType === 'number' && !Number.isInteger(value)) {

        throw new Error(`Set preference: ""${value}"" must be an integer.`);

      }

    this.prefs[name] = value;

    return await this._writeToStorage(this.prefs);

  }`",2018-07-30 16:48:16+02:00,233b3274bf7973aa06a674dddef585f4313f3742
"  get(name) {

    return this._initializedPromise.then(() => {

      let defaultValue = this.defaults[name];

      if (defaultValue === undefined) {

        throw new Error(`Get preference: ""${name}"" is undefined.`);

      } else {

        let prefValue = this.prefs[name];

        if (prefValue !== undefined) {

          return prefValue;

        }

      return defaultValue;

    });
","async get(name) {
  await this._initializedPromise;
  let defaultValue = this.defaults[name];
  if (defaultValue === undefined) {
    throw new Error(`Get preference: ""${name}"" is undefined.`);
  } else {
    let prefValue = this.prefs[name];
    if (prefValue !== undefined) {
      return prefValue;
    }
    return defaultValue;
  }
}",2018-07-30 16:48:16+02:00,233b3274bf7973aa06a674dddef585f4313f3742
"  getAll() {

    return this._initializedPromise.then(() => {

      return Object.assign(Object.create(null), this.defaults, this.prefs);

    });
","getAll() async {
  await this._initializedPromise;
  return Object.assign(Object.create(null), this.defaults, this.prefs);
}",2018-07-30 16:48:16+02:00,233b3274bf7973aa06a674dddef585f4313f3742
"  _writeToStorage() {

    return new Promise((resolve) => {

      let databaseStr = JSON.stringify(this.database);

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        sessionStorage.setItem('pdfjs.history', databaseStr);

      } else {

        localStorage.setItem('pdfjs.history', databaseStr);

      }

      resolve();

    });

  _readFromStorage() {

    return new Promise(function(resolve) {

      if (typeof PDFJSDev !== 'undefined' &&

          PDFJSDev.test('FIREFOX || MOZCENTRAL')) {

        resolve(sessionStorage.getItem('pdfjs.history'));

      } else {

        resolve(localStorage.getItem('pdfjs.history'));

      }

    });

  set(name, val) {

    return this._initializedPromise.then(() => {

      this.file[name] = val;

      return this._writeToStorage();

    });

  setMultiple(properties) {

    return this._initializedPromise.then(() => {

      for (let name in properties) {

        this.file[name] = properties[name];

      }

      return this._writeToStorage();

    });

  get(name, defaultValue) {

    return this._initializedPromise.then(() => {

      let val = this.file[name];

      return val !== undefined ? val : defaultValue;

    });

  getMultiple(properties) {

    return this._initializedPromise.then(() => {

      let values = Object.create(null);

      for (let name in properties) {

        let val = this.file[name];

        values[name] = val !== undefined ? val : properties[name];

      }

      return values;

    });
","_writeToStorage() {
   return async () => {
     let databaseStr = JSON.stringify(this.database);
     if (typeof PDFJSDev !== 'undefined' &&
        PDFJSDev.test('FIREFOX || MOZCENTRAL')) {
       await sessionStorage.setItem('pdfjs.history', databaseStr);
     } else {
       await localStorage.setItem('pdfjs.history', databaseStr);
     }
   };
  }
  _readFromStorage() {
   return async () => {
     if (typeof PDFJSDev !== 'undefined' &&
        PDFJSDev.test('FIREFOX || MOZCENTRAL')) {
       return await sessionStorage.getItem('pdfjs.history');
     } else {
       return await localStorage.getItem('pdfjs.history');
     }
   };
  }
  set(name, val) {
   return this._initializedPromise.then(() => {
     this.file[name] = val;
     return this._writeToStorage();
   });
  }
  setMultiple(properties) {
   return this._initializedPromise.then(() => {
     for (let name in properties) {
       this.file[name] = properties[name];
     }
     return this._writeToStorage();
   });
  }
  get(name, defaultValue) {
   return this._initializedPromise.then(() => {
     let val = this.file[name];
     return val !== undefined ? val : defaultValue;
   });
  }
  getMultiple(properties) {
   return this._initializedPromise.then(() => {
     let values = Object.create(null);
     for (let name in properties) {
       let val = this.file[name];
       values[name] = val !== undefined ? val : properties[name];
     }
     return values;
   });
  }",2018-07-30 17:07:21+02:00,a60963f88224235ff6e8847a019dfd93da203738
"    return this.preferences.getAll().then(function(prefs) {

    }, function(reason) { });

  _parseHashParameters() {

    if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION') ||

        AppOptions.get('pdfBugEnabled')) {

      // Special debugging flags in the hash section of the URL.

      let hash = document.location.hash.substring(1);

      let hashParams = parseQueryString(hash);

      if ('disableworker' in hashParams &&

          hashParams['disableworker'] === 'true') {

        waitOn.push(loadFakeWorker());

      }

      if ('disablerange' in hashParams) {

        AppOptions.set('disableRange', hashParams['disablerange'] === 'true');

      }

      if ('disablestream' in hashParams) {

        AppOptions.set('disableStream', hashParams['disablestream'] === 'true');

      }

      if ('disableautofetch' in hashParams) {

        AppOptions.set('disableAutoFetch',

                       hashParams['disableautofetch'] === 'true');

      }

      if ('disablefontface' in hashParams) {

        AppOptions.set('disableFontFace',

                       hashParams['disablefontface'] === 'true');

      }

      if ('disablehistory' in hashParams) {

        AppOptions.set('disableHistory',

                       hashParams['disablehistory'] === 'true');

      }

      if ('webgl' in hashParams) {

        AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');

      }

      if ('useonlycsszoom' in hashParams) {

        AppOptions.set('useOnlyCssZoom',

                       hashParams['useonlycsszoom'] === 'true');

      }

      if ('verbosity' in hashParams) {

        AppOptions.set('verbosity', hashParams['verbosity'] | 0);

      }

      if ((typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) &&

          hashParams['disablebcmaps'] === 'true') {

        AppOptions.set('cMapUrl', '../external/cmaps/');

        AppOptions.set('cMapPacked', false);

      }

      if ('textlayer' in hashParams) {

        switch (hashParams['textlayer']) {

          case 'off':

            AppOptions.set('textLayerMode', TextLayerMode.DISABLE);

            break;

          case 'visible':

          case 'shadow':

          case 'hover':

            let viewer = this.appConfig.viewerContainer;

            viewer.classList.add('textLayer-' + hashParams['textlayer']);

            break;

        }

      }

      if ('pdfbug' in hashParams) {

        AppOptions.set('pdfBug', true);

        let enabled = hashParams['pdfbug'].split(',');

        waitOn.push(loadAndEnablePDFBug(enabled));

      }

      // It is not possible to change locale for the (various) extension builds.

      if ((typeof PDFJSDev === 'undefined' ||

           PDFJSDev.test('!PRODUCTION || GENERIC')) && 'locale' in hashParams) {

        AppOptions.set('locale', hashParams['locale']);
","return this.preferences.getAll().then((prefs) => {
  _parseHashParameters() {
    if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION') || AppOptions.get('pdfBugEnabled')) {
      // Special debugging flags in the hash section of the URL.
      let hash = document.location.hash.substring(1);
      let hashParams = parseQueryString(hash);
      if ('disableworker' in hashParams && hashParams['disableworker'] === 'true') {
        waitOn.push(loadFakeWorker());
      }
      if ('disablerange' in hashParams) {
        AppOptions.set('disableRange', hashParams['disablerange'] === 'true');
      }
      if ('disablestream' in hashParams) {
        AppOptions.set('disableStream', hashParams['disablestream'] === 'true');
      }
      if ('disableautofetch' in hashParams) {
        AppOptions.set('disableAutoFetch', hashParams['disableautofetch'] === 'true');
      }
      if ('disablefontface' in hashParams) {
        AppOptions.set('disableFontFace', hashParams['disablefontface'] === 'true');
      }
      if ('disablehistory' in hashParams) {
        AppOptions.set('disableHistory', hashParams['disablehistory'] === 'true');
      }
      if ('webgl' in hashParams) {
        AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');
      }
      if ('useonlycsszoom' in hashParams) {
        AppOptions.set('useOnlyCssZoom', hashParams['useonlycsszoom'] === 'true');
      }
      if ('verbosity' in hashParams) {
        AppOptions.set('verbosity', hashParams['verbosity'] | 0);
      }
      if ((typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) && hashParams['disablebcmaps'] === 'true') {
        AppOptions.set('cMapUrl', '../external/cmaps/');
        AppOptions.set('cMapPacked', false);
      }
      if ('textlayer' in hashParams) {
        switch (hashParams['textlayer']) {
          case 'off':
            AppOptions.set('textLayerMode', TextLayerMode.DISABLE);
            break;
          case 'visible':
          case 'shadow':
          case 'hover':
            let viewer = this.appConfig.viewerContainer;
            viewer.classList.add('textLayer-' + hashParams['textlayer']);
            break;
        }
      }
      if ('pdfbug' in hashParams) {
        AppOptions.set('pdfBug', true);
        let enabled = hashParams['pdfbug'].split(',');
        waitOn.push(loadAndEnablePDFBug(enabled));
      }
      // It is not possible to change locale for the (various) extension builds.
      if ((typeof PDFJSDev === 'undefined' || PDFJSDev.test('!PRODUCTION || GENERIC')) && 'locale' in hashParams) {
        AppOptions.set('locale', hashParams['locale']);
      }
    }
  }
});",2018-07-30 17:41:39+02:00,3eba7ea2673828865081d0f188477351803235f5
"  _initializeL10n() {

    return this.l10n.getDirection().then((dir) => {

      document.getElementsByTagName('html')[0].dir = dir;

    });

  _initializeViewerComponents() {

    let { appConfig, } = this;



    return new Promise((resolve, reject) => {

      this.overlayManager = new OverlayManager();



      const dispatchToDOM = AppOptions.get('eventBusDispatchToDOM');

      let eventBus = appConfig.eventBus || getGlobalEventBus(dispatchToDOM);

      this.eventBus = eventBus;

      let pdfRenderingQueue = new PDFRenderingQueue();

      pdfRenderingQueue.onIdle = this.cleanup.bind(this);

      this.pdfRenderingQueue = pdfRenderingQueue;

      let pdfLinkService = new PDFLinkService({

        eventBus,

        externalLinkTarget: AppOptions.get('externalLinkTarget'),

        externalLinkRel: AppOptions.get('externalLinkRel'),

      });

      this.pdfLinkService = pdfLinkService;

      let downloadManager = this.externalServices.createDownloadManager({

        disableCreateObjectURL: AppOptions.get('disableCreateObjectURL'),

      });

      this.downloadManager = downloadManager;

      let container = appConfig.mainContainer;

      let viewer = appConfig.viewerContainer;

      this.pdfViewer = new PDFViewer({

        container,

        viewer,

        eventBus,

        renderingQueue: pdfRenderingQueue,

        linkService: pdfLinkService,

        downloadManager,

        renderer: AppOptions.get('renderer'),

        enableWebGL: AppOptions.get('enableWebGL'),

        l10n: this.l10n,

        textLayerMode: AppOptions.get('textLayerMode'),

        imageResourcesPath: AppOptions.get('imageResourcesPath'),

        renderInteractiveForms: AppOptions.get('renderInteractiveForms'),

        enablePrintAutoRotate: AppOptions.get('enablePrintAutoRotate'),

        useOnlyCssZoom: AppOptions.get('useOnlyCssZoom'),

        maxCanvasPixels: AppOptions.get('maxCanvasPixels'),

      });

      pdfRenderingQueue.setViewer(this.pdfViewer);

      pdfLinkService.setViewer(this.pdfViewer);



      let thumbnailContainer = appConfig.sidebar.thumbnailView;

      this.pdfThumbnailViewer = new PDFThumbnailViewer({

        container: thumbnailContainer,

        renderingQueue: pdfRenderingQueue,

        linkService: pdfLinkService,

        l10n: this.l10n,

      });

      pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);



      this.pdfHistory = new PDFHistory({

        linkService: pdfLinkService,

        eventBus,

      });

      pdfLinkService.setHistory(this.pdfHistory);

      this.findController = new PDFFindController({

        pdfViewer: this.pdfViewer,

        eventBus,

      });

      this.findController.onUpdateResultsCount = (matchCount) => {

        if (this.supportsIntegratedFind) {

          return;

        }

        this.findBar.updateResultsCount(matchCount);

      };

      this.findController.onUpdateState = (state, previous, matchCount) => {

        if (this.supportsIntegratedFind) {

          this.externalServices.updateFindControlState({

            result: state,

            findPrevious: previous,

          });

        } else {

          this.findBar.updateUIState(state, previous, matchCount);

        }

      };

      this.pdfViewer.setFindController(this.findController);

      // TODO: improve `PDFFindBar` constructor parameter passing

      let findBarConfig = Object.create(appConfig.findBar);

      findBarConfig.findController = this.findController;

      findBarConfig.eventBus = eventBus;

      this.findBar = new PDFFindBar(findBarConfig, this.l10n);

      this.pdfDocumentProperties =

        new PDFDocumentProperties(appConfig.documentProperties,

                                  this.overlayManager, eventBus, this.l10n);

      this.pdfCursorTools = new PDFCursorTools({

        container,

        eventBus,

        cursorToolOnLoad: AppOptions.get('cursorToolOnLoad'),

      });

      this.toolbar = new Toolbar(appConfig.toolbar, container, eventBus,

                                 this.l10n);

      this.secondaryToolbar =

        new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);

      if (this.supportsFullscreen) {

        this.pdfPresentationMode = new PDFPresentationMode({

          container,

          viewer,

          pdfViewer: this.pdfViewer,

          eventBus,

          contextMenuItems: appConfig.fullscreen,

        });

      }

      this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay,

                                               this.overlayManager, this.l10n);

      this.pdfOutlineViewer = new PDFOutlineViewer({

        container: appConfig.sidebar.outlineView,

        linkService: pdfLinkService,

      this.pdfAttachmentViewer = new PDFAttachmentViewer({

        container: appConfig.sidebar.attachmentsView,

        eventBus,

        downloadManager,

      });

      // TODO: improve `PDFSidebar` constructor parameter passing

      let sidebarConfig = Object.create(appConfig.sidebar);

      sidebarConfig.pdfViewer = this.pdfViewer;

      sidebarConfig.pdfThumbnailViewer = this.pdfThumbnailViewer;

      sidebarConfig.pdfOutlineViewer = this.pdfOutlineViewer;

      sidebarConfig.eventBus = eventBus;

      this.pdfSidebar = new PDFSidebar(sidebarConfig, this.l10n);

      this.pdfSidebar.onToggled = this.forceRendering.bind(this);



      this.pdfSidebarResizer = new PDFSidebarResizer(appConfig.sidebarResizer,

                                                     eventBus, this.l10n);

      resolve(undefined);
","async _initializeL10n() {
  try {
    const dir = await this.l10n.getDirection();
    document.getElementsByTagName('html')[0].dir = dir;
  } catch (error) {
    console.error(error);
  }
}

async _initializeViewerComponents() {
  try {
    const { appConfig, } = this;
    const eventBus = await (appConfig.eventBus || getGlobalEventBus(AppOptions.get('eventBusDispatchToDOM')));
    this.overlayManager = new OverlayManager();
    let pdfRenderingQueue = new PDFRenderingQueue();
    pdfRenderingQueue.onIdle = this.cleanup.bind(this);
    this.pdfRenderingQueue = pdfRenderingQueue;
    const pdfLinkService = await new PDFLinkService({
      eventBus,
      externalLinkTarget: AppOptions.get('externalLinkTarget'),
      externalLinkRel: AppOptions.get('externalLinkRel'),
    });
    this.pdfLinkService = pdfLinkService;
    let downloadManager = this.externalServices.createDownloadManager({
      disableCreateObjectURL: AppOptions.get('disableCreateObjectURL'),
    });
    this.downloadManager = downloadManager;
    const container = appConfig.mainContainer;
    const viewer = appConfig.viewerContainer;
    let pdfViewer = await new PDFViewer({
      container,
      viewer,
      eventBus,
      renderingQueue: pdfRenderingQueue,
      linkService: pdfLinkService,
      downloadManager,
      renderer: AppOptions.get('renderer'),
      enableWebGL: AppOptions.get('enableWebGL'),
      l10n: this.l10n,
      textLayerMode: AppOptions.get('textLayerMode'),
      imageResourcesPath: AppOptions.get('imageResourcesPath'),
      renderInteractiveForms: AppOptions.get('renderInteractiveForms'),
      enablePrintAutoRotate: AppOptions.get('enablePrintAutoRotate'),
      useOnlyCssZoom: AppOptions.get('useOnlyCssZoom'),
      maxCanvasPixels: AppOptions.get('maxCanvasPixels'),
    });
    pdfRenderingQueue.setViewer(pdfViewer);
    pdfLinkService.setViewer(pdfViewer);

    let thumbnailContainer = appConfig.sidebar.thumbnailView;
    let pdfThumbnailViewer = await new PDFThumbnailViewer({
      container: thumbnailContainer,
      renderingQueue: pdfRenderingQueue,
      linkService: pdfLinkService,
      l10n: this.l10n,
    });
    pdfRenderingQueue.setThumbnailViewer(pdfThumbnailViewer);

    let pdfHistory = await new PDFHistory({
      linkService: pdfLinkService,
      eventBus,
    });
    pdfLinkService.setHistory(pdfHistory);
    let findController = await new PDFFindController({
      pdfViewer: this.pdfViewer,
      eventBus,
    });
    findController.onUpdateResultsCount = (matchCount) => {
      if (this.supportsIntegratedFind) {
        return;
      }
      this.findBar.updateResultsCount(matchCount);
    };
    findController.onUpdateState = (state, previous, matchCount) => {
      if (this.supportsIntegratedFind) {
        this.externalServices.updateFindControlState({
          result: state,
          findPrevious: previous,
        });
      } else {
        this.findBar.updateUIState(state, previous, matchCount);
      }
    };
    pdfViewer.setFindController(findController);
    let findBarConfig = Object.create(appConfig.findBar);
    findBarConfig.findController = findController;
    findBarConfig.eventBus = eventBus;
    this.findBar = new PDFFindBar(findBarConfig, this.l10n);
    this.pdfDocumentProperties = await new PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n);
    this.pdfCursorTools = new PDFCursorTools({
      container,
      eventBus,
      cursorToolOnLoad: AppOptions.get('cursorToolOnLoad'),
    });
    this.toolbar = new Toolbar(appConfig.toolbar, container, eventBus, this.l10n);
    this.secondaryToolbar = await new SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);
    if (this.supportsFullscreen) {
      let pdfPresentationMode = new PDFPresentationMode({
        container,
        viewer,
        pdfViewer: this.pdfViewer,
        eventBus,
        contextMenuItems: appConfig.fullscreen,
      });
    }
    this.passwordPrompt = new PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n);
    let pdfOutlineViewer = await new PDFOutlineViewer({
      container: appConfig.sidebar.outlineView,
      linkService: pdfLinkService,
    });
    this.pdfAttachmentViewer = await new PDFAttachmentViewer({
      container: appConfig.sidebar.attachmentsView,
      eventBus,
      downloadManager,
    });
    let sidebarConfig = Object.create(appConfig.sidebar);
    sidebarConfig.pdfViewer = pdfViewer;
    sidebarConfig.pdfThumbnailViewer = pdfThumbnailViewer;
    sidebarConfig.pdfOutlineViewer = pdfOutlineViewer;
    sidebarConfig.eventBus = eventBus;
    this.pdfSidebar = new PDFSidebar(sidebarConfig, this.l10n);
    this.pdfSidebar.onToggled = this.forceRendering.bind(this);
    let pdfSidebarResizer = await new PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);
  } catch (error) {
    console.error(error);
  }
}",2018-07-30 17:41:39+02:00,3eba7ea2673828865081d0f188477351803235f5
"  open(file, args) {

      return this.close().then(() => {

        // ... and repeat the open() call.

        return this.open(file, args);

      });
","async function open(file, args) {
  await this.close();
  // ... and repeat the open() call.
  return await this.open(file, args);
}",2018-07-30 17:41:39+02:00,3eba7ea2673828865081d0f188477351803235f5
"        return {

          hash,

          rotation,

          sidebarView,

          scrollMode,

          spreadMode,

        };

      }).then(({ hash, rotation, sidebarView, scrollMode, spreadMode, }) => {

        initialParams.bookmark = this.initialBookmark;

        initialParams.hash = hash;



        return Promise.race([

      }).then(() => {

        // For documents with different page sizes, once all pages are resolved,

        // ensure that the correct location becomes visible on load.

        // To reduce the risk, in very large and/or slow loading documents,

        // that the location changes *after* the user has started interacting

        // with the viewer, wait for either `pagesPromise` or a timeout above.



        if (!initialParams.bookmark && !initialParams.hash) {

        this.initialBookmark = initialParams.bookmark;

        this.setInitialView(initialParams.hash);
","return {
  hash,
  rotation,
  sidebarView,
  scrollMode,
  spreadMode,
};
}).then(({ hash, rotation, sidebarView, scrollMode, spreadMode }) => {
  initialParams.bookmark = this.initialBookmark;
  initialParams.hash = hash;
  if (!initialParams.bookmark && !initialParams.hash) {
    this.initialBookmark = initialParams.bookmark;
    this.setInitialView(initialParams.hash);
  }
});",2018-08-09 15:15:41+02:00,1bdfdd07b822827856bff4cea9f779010c510b7f
"    function renderPDF(filename) {

      var loadingTask = getDocument(filename);

      return loadingTask.promise

        .then(function(pdf) {

          pdfDocuments.push(pdf);

          return pdf.getPage(1);

        }).then(function(page) {

          var viewport = page.getViewport(1.2);

          var canvasAndCtx = CanvasFactory.create(viewport.width,

                                                  viewport.height);

          return page.render({

            canvasContext: canvasAndCtx.context,

            viewport,

          }).then(function() {

            var data = canvasAndCtx.canvas.toDataURL();

            CanvasFactory.destroy(canvasAndCtx);

            return data;

          });

        });
","async function renderPDF(filename) {

  const pdfDocument = await getDocument(filename);

  pdfDocuments.push(pdfDocument);

  const page = await pdfDocument.getPage(1);

  const viewport = page.getViewport(1.2);

  const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);

  await page.render({
    canvasContext: canvasAndCtx.context,
    viewport,
  });

  const data = canvasAndCtx.canvas.toDataURL();

  CanvasFactory.destroy(canvasAndCtx);

  return data;
}",2018-11-08 13:46:02+01:00,2c003a82d57b5ad778fbf221a86f1d1408c02952
"    },

    _scheduleNext: function InternalRenderTask__scheduleNext() {

      if (this.useRequestAnimationFrame && typeof window !== 'undefined') {

    },

    _next: function InternalRenderTask__next() {

      return new Promise(() => {

        if (this.cancelled) {

          return;

        }

        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,

                                          this.operatorListIdx,

                                          this._continueBound,

                                          this.stepper);

        if (this.operatorListIdx === this.operatorList.argsArray.length) {

          this.running = false;

          if (this.operatorList.lastChunk) {

            this.gfx.endDrawing();

            if (this._canvas) {

              canvasInRendering.delete(this._canvas);

            }

            this.callback();

      });

    },



  };


","},

_scheduleNext: async function InternalRenderTask__scheduleNext() {

  if (this.useRequestAnimationFrame && typeof window !== 'undefined') {

    return;

  }

  try {

    await this._next();

  } catch (error) {

    console.error(error);

  }

},

_next: async function InternalRenderTask__next() {

  if (this.cancelled) {

    return;

  }

  this.operatorListIdx = await this.gfx.executeOperatorList(this.operatorList,

                                          this.operatorListIdx,

                                          this._continueBound,

                                          this.stepper);

  if (this.operatorListIdx === this.operatorList.argsArray.length) {

    this.running = false;

    if (this.operatorList.lastChunk) {

      await this.gfx.endDrawing();

      if (this._canvas) {

        canvasInRendering.delete(this._canvas);

      }

      this.callback();

    }

  }

},",2018-11-08 14:33:56+01:00,02e77a39ec68247c619a6f67d9b8432ad40a50bc
"    function loadDocument(recoveryMode) {

      var loadDocumentCapability = createPromiseCapability();



      var parseSuccess = function parseSuccess() {

        Promise.all([

          pdfManager.ensureDoc('numPages'),

          pdfManager.ensureDoc('fingerprint'),

        ]).then(function([numPages, fingerprint]) {

          loadDocumentCapability.resolve({

            numPages,

            fingerprint,

          });

        }, parseFailure);

      };



      var parseFailure = function parseFailure(e) {

        loadDocumentCapability.reject(e);

      };



      pdfManager.ensureDoc('checkHeader', []).then(function() {

        pdfManager.ensureDoc('parseStartXRef', []).then(function() {

          pdfManager.ensureDoc('parse', [recoveryMode]).then(

            parseSuccess, parseFailure);

        }, parseFailure);

      }, parseFailure);

      return loadDocumentCapability.promise;
","async function loadDocument(recoveryMode) {
  const pdfManager = createPromiseCapability();

  try {
    await pdfManager.ensureDoc('checkHeader', []);
    await pdfManager.ensureDoc('parseStartXRef', []);
    const [numPages, fingerprint] = await Promise.all([
      pdfManager.ensureDoc('numPages'),
      pdfManager.ensureDoc('fingerprint'),
    ]);
    loadDocumentCapability.resolve({ numPages, fingerprint });
  } catch (e) {
    loadDocumentCapability.reject(e);
  }

  return loadDocumentCapability.promise;
}",2018-12-04 21:51:27+01:00,60bcce184ee74dc56d682a4c75ccdea69cd0670e
"        this.xref.stream.manager.requestRanges(pendingRequests).then(() => {

          for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {

            let node = nodesToRevisit[i];

            // Remove any reference nodes from the current `RefSet` so they

            // aren't skipped when we revist them.

            if (node instanceof Ref) {

              this.refSet.remove(node);

            }

          this._walk(nodesToRevisit);

        }, this.capability.reject);

        return;

      this.capability.resolve();
","\`\`\`javascript
this.xref.stream.manager.requestRanges(pendingRequests).then(() => {
  for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {
    let node = nodesToRevisit[i];
    // Remove any reference nodes from the current `RefSet` so they aren't skipped when we revist them.
    if (node instanceof Ref) {
      this.refSet.remove(node);
    }
    this._walk(nodesToRevisit);
  }
}).catch(this.capability.reject);
\`\`\`",2019-11-03 14:58:40+01:00,04497bcb3c8df5a04565ef60a37245d73a17b4e1
"  getPageDict(pageIndex) {

    const capability = createPromiseCapability();

    function next() {

      while (nodesToVisit.length) {

        const currentNode = nodesToVisit.pop();

        if (isRef(currentNode)) {

          count = pageKidsCountCache.get(currentNode);

          // Skip nodes where the page can't be.

          if (count > 0 && currentPageIndex + count < pageIndex) {

            currentPageIndex += count;

            continue;

          }

          xref.fetchAsync(currentNode).then(function(obj) {

            if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {

              if (pageIndex === currentPageIndex) {

                // Cache the Page reference, since it can *greatly* improve

                // performance by reducing redundant lookups in long documents

                // where all nodes are found at *one* level of the tree.

                if (currentNode && !pageKidsCountCache.has(currentNode)) {

                  pageKidsCountCache.put(currentNode, 1);

                }

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            nodesToVisit.push(obj);

            next();

          }, capability.reject);

          return;

        // Must be a child page dictionary.

        if (!isDict(currentNode)) {

          capability.reject(new FormatError(

            'Page dictionary kid reference points to wrong type of object.'));

          return;

        }

        count = currentNode.get('Count');

        if (Number.isInteger(count) && count >= 0) {

          // Cache the Kids count, since it can reduce redundant lookups in

          // documents where all nodes are found at *one* level of the tree.

          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {

            pageKidsCountCache.put(objId, count);

          }

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

        const kids = currentNode.get('Kids');

        if (!Array.isArray(kids)) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          if (isName(currentNode.get('Type'), 'Page') ||

              (!currentNode.has('Type') && currentNode.has('Contents'))) {

            if (currentPageIndex === pageIndex) {

              capability.resolve([currentNode, null]);

              return;

            }

            currentPageIndex++;

            continue;



          capability.reject(new FormatError(

            'Page dictionary kids object is not an array.'));

          return;

        // Always check all `Kids` nodes, to avoid getting stuck in an empty

        // node further down in the tree (see issue5644.pdf, issue8088.pdf),

        // and to ensure that we actually find the correct `Page` dict.

        for (let last = kids.length - 1; last >= 0; last--) {

          nodesToVisit.push(kids[last]);

        }

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;
","async function getPageDict(pageIndex) {
  let currentNode = this.root;
  let count = 0;
  let nodesToVisit = [];
  let pageKidsCountCache = new WeakMap();
  let currentPageIndex = 0;

  while (currentNode !== null && currentPageIndex < pageIndex) {
    if (isRef(currentNode)) {
      count = pageKidsCountCache.get(currentNode);
      // Skip nodes where the page can't be.
      if (count > 0 && currentPageIndex + count < pageIndex) {
        currentPageIndex += count;
        continue;
      }
      const obj = await this.xref.fetchAsync(currentNode);
      if (isDict(obj, 'Page') || (isDict(obj) && !obj.has('Kids'))) {
        if (pageIndex === currentPageIndex) {
          // Cache the Page reference, since it can greatly improve performance by reducing redundant lookups in long documents where all nodes are found at one level of the tree.
          if (currentNode && !pageKidsCountCache.has(currentNode)) {
            pageKidsCountCache.put(currentNode, 1);
          }
          return [obj, currentNode];
        } else {
          currentPageIndex++;
          continue;
        }
      }
    // Must be a child page dictionary.
    if (!isDict(currentNode)) {
      throw new FormatError('Page dictionary kid reference points to wrong type of object.');
    }
    count = currentNode.get('Count');
    if (Number.isInteger(count) && count >= 0) {
      // Cache the Kids count, since it can reduce redundant lookups in documents where all nodes are found at one level of the tree.
      const objId = currentNode.objId;
      if (objId && !pageKidsCountCache.has(objId)) {
        pageKidsCountCache.put(objId, count);
      }
      // Skip nodes where the page can't be.
      if (currentPageIndex + count <= pageIndex) {
        currentPageIndex += count;
        continue;
      }
      const kids = currentNode.get('Kids');
      if (!Array.isArray(kids)) {
        // Prevent errors in corrupt PDF documents that violate the specification by *inlining* Page dicts directly in the Kids array, rather than using indirect objects (fixes issue9540.pdf).
        if (isName(currentNode.get('Type'), 'Page') || (!currentNode.has('Type') && currentNode.has('Contents'))) {
          if (currentPageIndex === pageIndex) {
            return [currentNode, null];
          }
          currentPageIndex++;
          continue;
        }
        throw new FormatError('Page dictionary kids object is not an array.');
      }
      // Always check all `Kids` nodes, to avoid getting stuck in an empty node further down in the tree (see issue5644.pdf, issue8088.pdf), and to ensure that we actually find the correct `Page` dict.
      for (let last = kids.length - 1; last >= 0; last--) {
        nodesToVisit.push(kids[last]);
      }
    }
  }
  throw new Error(`Page index ${pageIndex} not found.`);
}",2019-11-04 16:02:08+01:00,0d89006bf16b7262fe6aceb35557a9b54e3ec396
"function loadFakeWorker() {

    return new Promise(function(resolve, reject) {

      if (typeof SystemJS === 'object') {

        SystemJS.import('pdfjs/core/worker').then((worker) => {

          window.pdfjsWorker = worker;

          resolve();

        }).catch(reject);

      } else {

        reject(new Error('SystemJS must be used to load fake worker.'));

      }

    });
","async function loadFakeWorker() {

    if (typeof SystemJS === 'object') {

        try {

            const worker = await SystemJS.import('pdfjs/core/worker');

            window.pdfjsWorker = worker;

        } catch(error) {

            throw new Error('SystemJS must be used to load fake worker.');

        }

    } else {

        throw new Error('SystemJS must be used to load fake worker.');

    }

}",2019-12-19 18:11:56+01:00,8519f87efb3a24b1a8a9f03e2e8d0728a7cd642d
"  _adjustScaleWidth() {

    const container = this.items.scaleSelectContainer;

    const select = this.items.scaleSelect;

    animationStarted.then(function() {

      // Adjust the width of the zoom box to fit the content.

      // Note: If the window is narrow enough that the zoom box is not

      //       visible, we temporarily show it to be able to adjust its width.

      if (container.clientWidth === 0) {

        container.setAttribute(""style"", ""display: inherit;"");

      }

      if (container.clientWidth > 0) {

        select.setAttribute(""style"", ""min-width: inherit;"");

        const width = select.clientWidth + SCALE_SELECT_CONTAINER_PADDING;

        select.setAttribute(

          ""style"",

          `min-width: ${width + SCALE_SELECT_PADDING}px;`

        );

        container.setAttribute(

          ""style"",

          `min-width: ${width}px; max-width: ${width}px;`

        );

    });
","adjustScaleWidth() {

    const container = this.items.scaleSelectContainer;

    const select = this.items.scaleSelect;

    try {

      // Adjust the width of the zoom box to fit the content.

      // Note: If the window is narrow enough that the zoom box is not

      //       visible, we temporarily show it to be able to adjust its width.

      if (container.clientWidth === 0) {

        container.setAttribute(""style"", ""display: inherit;"");

      }

      if (container.clientWidth > 0) {

        select.setAttribute(""style"", ""min-width: inherit;"");

        const width = select.clientWidth + SCALE_SELECT_CONTAINER_PADDING;

        select.setAttribute(

          ""style"",

          `min-width: ${width + SCALE_SELECT_PADDING}px;`

        );

        container.setAttribute(

          ""style"",

          `min-width: ${width}px; max-width: ${width}px;`

        );

    } catch (error) {

      console.log(error);

    } finally {

      // Reset the visibility of the zoom box after adjusting its width.

      container.setAttribute(""style"", ""display: none;"");

    }

  }",2020-02-06 14:22:14+01:00,b54c1fe39528c72281e9158d1920deec7c4ea285
"    pdfDocument

      .getMetadata()

      .then(({ info, metadata, contentDispositionFilename }) => {

        this.documentInfo = info;

        this.metadata = metadata;

        this.contentDispositionFilename = contentDispositionFilename;



        // Provides some basic debug information

        console.log(

          ""PDF "" +

            pdfDocument.fingerprint +

            "" ["" +

            info.PDFFormatVersion +

            "" "" +

            (info.Producer || ""-"").trim() +

            "" / "" +

            (info.Creator || ""-"").trim() +

            ""]"" +

            "" (PDF.js: "" +

            (version || ""-"") +

            (AppOptions.get(""enableWebGL"") ? "" [WebGL]"" : """") +

            "")""

        );

        let pdfTitle;

        const infoTitle = info && info[""Title""];

        if (infoTitle) {

          pdfTitle = infoTitle;

        }

        const metadataTitle = metadata && metadata.get(""dc:title"");

        if (metadataTitle) {

          // Ghostscript can produce invalid 'dc:title' Metadata entries:

          //  - The title may be ""Untitled"" (fixes bug 1031612).

          //  - The title may contain incorrectly encoded characters, which thus

          //    looks broken, hence we ignore the Metadata entry when it

          //    contains characters from the Specials Unicode block

          //    (fixes bug 1605526).

          if (

            metadataTitle !== ""Untitled"" &&

            !/[\uFFF0-\uFFFF]/g.test(metadataTitle)

          ) {

            pdfTitle = metadataTitle;

          }

        }

        if (pdfTitle) {

          this.setTitle(

            `${pdfTitle} - ${contentDispositionFilename || document.title}`

          );

        } else if (contentDispositionFilename) {

          this.setTitle(contentDispositionFilename);

        }

        if (info.IsAcroFormPresent) {

          console.warn(""Warning: AcroForm/XFA is not supported"");

          this.fallback(UNSUPPORTED_FEATURES.forms);

        }

        if (

          typeof PDFJSDev === ""undefined"" ||

          PDFJSDev.test(""MOZCENTRAL || GENERIC"")

        ) {

          // Telemetry labels must be C++ variable friendly.

          let versionId = ""other"";

          // Keep these in sync with mozilla central's Histograms.json.

          const KNOWN_VERSIONS = [

            ""1.0"",

            ""1.1"",

            ""1.2"",

            ""1.3"",

            ""1.4"",

            ""1.5"",

            ""1.6"",

            ""1.7"",

            ""1.8"",

            ""1.9"",

            ""2.0"",

            ""2.1"",

            ""2.2"",

            ""2.3"",

          ];

          if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {

            versionId = `v${info.PDFFormatVersion.replace(""."", ""_"")}`;

          }

          let generatorId = ""other"";

          // Keep these in sync with mozilla central's Histograms.json.

          const KNOWN_GENERATORS = [

            ""acrobat distiller"",

            ""acrobat pdfwriter"",

            ""adobe livecycle"",

            ""adobe pdf library"",

            ""adobe photoshop"",

            ""ghostscript"",

            ""tcpdf"",

            ""cairo"",

            ""dvipdfm"",

            ""dvips"",

            ""pdftex"",

            ""pdfkit"",

            ""itext"",

            ""prince"",

            ""quarkxpress"",

            ""mac os x"",

            ""microsoft"",

            ""openoffice"",

            ""oracle"",

            ""luradocument"",

            ""pdf-xchange"",

            ""antenna house"",

            ""aspose.cells"",

            ""fpdf"",

          ];

          if (info.Producer) {

            const producer = info.Producer.toLowerCase();

            KNOWN_GENERATORS.some(function(generator) {

              if (!producer.includes(generator)) {

                return false;

              }

              generatorId = generator.replace(/[ .\-]/g, ""_"");

              return true;

            });

          }

          let formType = null;

          if (info.IsAcroFormPresent) {

            formType = info.IsXFAPresent ? ""xfa"" : ""acroform"";

          this.externalServices.reportTelemetry({

            type: ""documentInfo"",

            version: versionId,

            generator: generatorId,

            formType,

          });

        }
","async function getMetadata() {
  const pdfDocument = this.pdfDocument;
  const info = await pdfDocument.getMetadata();
  const metadata = await pdfDocument.getMetadata();
  const contentDispositionFilename = await pdfDocument.contentDispositionFilename;

  // Provides some basic debug information
  console.log(
    `PDF ${pdfDocument.fingerprint} [${info.PDFFormatVersion} ${
      info.Producer || ""-""
    } / ${info.Creator || ""-""}] (PDF.js: ${version || ""-""} ${
      AppOptions.get(""enableWebGL"") ? "" [WebGL]"" : """"
    })`
  );

  let pdfTitle;
  const infoTitle = info && info[""Title""];
  if (infoTitle) {
    pdfTitle = infoTitle;
  }
  const metadataTitle = metadata && metadata.get(""dc:title"");
  if (metadataTitle) {
    // Ghostscript can produce invalid 'dc:title' Metadata entries:
    //  - The title may be ""Untitled"" (fixes bug 1031612).
    //  - The title may contain incorrectly encoded characters, which thus
    //    looks broken, hence we ignore the Metadata entry when it
    //    contains characters from the Specials Unicode block
    //    (fixes bug 1605526).
    if (metadataTitle !== ""Untitled"" && !/[\uFFF0-\uFFFF]/g.test(metadataTitle)) {
      pdfTitle = metadataTitle;
    }
  }
  if (pdfTitle) {
    this.setTitle(`${pdfTitle} - ${contentDispositionFilename || document.title}`);
  } else if (contentDispositionFilename) {
    this.setTitle(contentDispositionFilename);
  }

  if (info.IsAcroFormPresent) {
    console.warn(""Warning: AcroForm/XFA is not supported"");
    this.fallback(UNSUPPORTED_FEATURES.forms);
  }

  if (typeof PDFJSDev === ""undefined"" || PDFJSDev.test(""MOZCENTRAL || GENERIC"")) {
    // Telemetry labels must be C++ variable friendly.
    let versionId = ""other"";
    // Keep these in sync with mozilla central's Histograms.json.
    const KNOWN_VERSIONS = [
      ""1.0"",
      ""1.1"",
      ""1.2"",
      ""1.3"",
      ""1.4"",
      ""1.5"",
      ""1.6"",
      ""1.7"",
      ""1.8"",
      ""1.9"",
      ""2.0"",
      ""2.1"",
      ""2.2"",
      ""2.3"",
    ];
    if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {
      versionId = `v${info.PDFFormatVersion.replace(""."", ""_"")}`;
    }
    let generatorId = ""other"";
    // Keep these in sync with mozilla central's Histograms.json.
    const KNOWN_GENERATORS = [
      ""acrobat distiller"",
      ""acrobat pdfwriter"",
      ""adobe livecycle"",
      ""adobe pdf library"",
      ""adobe photoshop"",
      ""ghostscript"",
      ""tcpdf"",
      ""cairo"",
      ""dvipdfm"",
      ""dvips"",
      ""pdftex"",
      ""pdfkit"",
      ""itext"",
      ""prince"",
      ""quarkxpress"",
      ""mac os x"",
      ""microsoft"",
      ""openoffice"",
      ""oracle"",
      ""luradocument"",
      ""pdf-xchange"",
      ""antenna house"",
      ""aspose.cells"",
      ""fpdf"",
    ];
    if (info.Producer) {
      const producer = info.Producer.toLowerCase();
      KNOWN_GENERATORS.some((generator) => {
        if (!producer.includes(generator)) {
          return false;
        }
        generatorId = generator.replace(/[ .\-]/g, ""_"");
        return true;
      });
    }
    let formType = null;
    if (info.IsAcroFormPresent) {
      formType = info.IsXFAPresent ? ""xfa"" : ""acroform"";
    this.externalServices.reportTelemetry({
      type: ""documentInfo"",
      version: versionId,
      generator: generatorId,
      formType,
    });
  }
}",2020-04-05 10:26:55+02:00,d07be1a89bed0b78dcd18f5134f6601caac0b9fb
"function initializePDFJS(callback) {

  Promise.all([

    SystemJS.import(""pdfjs/core/fonts.js""),

    SystemJS.import(""pdfjs/core/stream.js""),

    SystemJS.import(""pdfjs/core/primitives.js""),

    SystemJS.import(""pdfjs/core/cmap.js""),

  ]).then(function (modules) {

    var fonts = modules[0],

      stream = modules[1],

      primitives = modules[2],

      cmap = modules[3];

    // Expose some of the PDFJS members to global scope for tests.

    window.Font = fonts.Font;

    window.ToUnicodeMap = fonts.ToUnicodeMap;

    window.Stream = stream.Stream;

    window.Name = primitives.Name;

    window.CMapFactory = cmap.CMapFactory;



    callback();

  });
","async function initializePDFJS(callback) {
  try {
    const modules = await Promise.all([
      SystemJS.import(""pdfjs/core/fonts.js""),
      SystemJS.import(""pdfjs/core/stream.js""),
      SystemJS.import(""pdfjs/core/primitives.js""),
      SystemJS.import(""pdfjs/core/cmap.js"")
    ]);
    const fonts = modules[0],
          stream = modules[1],
          primitives = modules[2],
          cmap = modules[3];
    // Expose some of the PDFJS members to global scope for tests.
    window.Font = fonts.Font;
    window.ToUnicodeMap = fonts.ToUnicodeMap;
    window.Stream = stream.Stream;
    window.Name = primitives.Name;
    window.CMapFactory = cmap.CMapFactory;
  } catch (error) {
    console.error(error);
  }
  callback();
}",2020-10-26 12:12:40+01:00,6967b9dd96638bbfa88ae169ab5302278ce72a44
"    return new Promise(resolve => {

      FirefoxCom.request(""createSandbox"", data, resolve);

    }).then(success => {

      if (!success) {

        throw new Error(""Cannot create sandbox."");

      }

    });
","async function createSandbox() {
  const success = await FirefoxCom.request('createSandbox', data);
  if (!success) {
    throw new Error('Cannot create sandbox.');
  }
}",2021-01-01 14:40:46+01:00,a49b3e04d5b3cd89175f51040a64038569b0446a
"    }).then(done);

  it(""performs a normal search and finds the previous result"", function (done) {

    testSearch({
","it(""performs a normal search and finds the previous result"", async () => {
  const result = await testSearch();
  expect(result).toEqual(previousResult);
});",2021-01-12 15:21:19+01:00,6dae2677d5fabe3116065c6ada5e50aec451dcba
"    }).then(done);

  it(""performs a case sensitive search"", function (done) {

    testSearch({
","it(""performs a case sensitive search"", async () => {

  await testSearch({

});

  done();
});",2021-01-12 15:21:19+01:00,6dae2677d5fabe3116065c6ada5e50aec451dcba
"    }).then(done);

  it(""performs an entire word search"", function (done) {

    testSearch({
","it('performs an entire word search', async () => {
  await testSearch({});
  done();
});",2021-01-12 15:21:19+01:00,6dae2677d5fabe3116065c6ada5e50aec451dcba
"    }).then(done);

  it(""performs a multiple term (no phrase) search"", function (done) {

    testSearch({
","}).then(done);

it(""performs a multiple term (no phrase) search"", async () => {

testSearch({",2021-01-12 15:21:19+01:00,6dae2677d5fabe3116065c6ada5e50aec451dcba
"    }).then(done);
","async function fetchData() {
     const response = await fetch(""https://api.example.com"");
     const data = await response.json();
     return data;
   }",2021-01-12 15:21:19+01:00,6dae2677d5fabe3116065c6ada5e50aec451dcba
"      it(""should print a date according to a format"", function (done) {

        Promise.all([

          myeval(`util.printd(0, ${date})`).then(value => {

            expect(value).toEqual(""D:20070415031415"");

          }),

          myeval(`util.printd(1, ${date})`).then(value => {

            expect(value).toEqual(""2007.04.15 03:14:15"");

          }),

          myeval(`util.printd(2, ${date})`).then(value => {

            expect(value).toEqual(""4/15/07 3:14:15 am"");

          }),

          myeval(`util.printd(""mmmm mmm mm m"", ${date})`).then(value => {

            expect(value).toEqual(""April Apr 04 4"");

          }),

          myeval(`util.printd(""dddd ddd dd d"", ${date})`).then(value => {

            expect(value).toEqual(""Sunday Sun 15 15"");

          }),

        ]).then(() => done());

      it(""should parse a date according to a format"", function (done) {

        Promise.all([

          myeval(`util.scand(0, ""D:20070415031415"").toString()`).then(value => {

            expect(new Date(value)).toEqual(date);

          }),

          myeval(`util.scand(1, ""2007.04.15 03:14:15"").toString()`).then(

            value => {

              expect(new Date(value)).toEqual(date);

            }

          ),

          myeval(`util.scand(2, ""4/15/07 3:14:15 am"").toString()`).then(

            value => {

              expect(new Date(value)).toEqual(date);

            }

          ),

        ]).then(() => done());

      it(""should print some data according to a format"", function (done) {

        Promise.all([

          myeval(

            `util.printf(""Integer numbers: %d, %d,..."", 1.234, 56.789)`

          ).then(value => {

            expect(value).toEqual(""Integer numbers: 1, 56,..."");

          }),

          myeval(`util.printf(""Hex numbers: %x, %x,..."", 1234, 56789)`).then(

            value => {

              expect(value).toEqual(""Hex numbers: 4D2, DDD5,..."");

            }

          ),

          myeval(

            `util.printf(""Hex numbers with 0x: %#x, %#x,..."", 1234, 56789)`

          ).then(value => {

            expect(value).toEqual(""Hex numbers with 0x: 0x4D2, 0xDDD5,..."");

          }),

          myeval(`util.printf(""Decimal number: %,0+.3f"", 1234567.89123)`).then(

            value => {

              expect(value).toEqual(""Decimal number: +1,234,567.891"");

            }

          ),

          myeval(`util.printf(""Decimal number: %,0+8.3f"", 1.234567)`).then(

            value => {

              expect(value).toEqual(""Decimal number: +  1.235"");

            }

          ),

          myeval(`util.printf(""Decimal number: %,0.2f"", -12.34567)`).then(

            value => {

              expect(value).toEqual(""Decimal number: -12.35"");

            }

          ),

        ]).then(() => done());

      it(""should print a string with no argument"", function (done) {

        myeval(`util.printf(""hello world"")`)

          .then(value => {

            expect(value).toEqual(""hello world"");

          })

          .then(() => done());

      it(""print a string with a percent"", function (done) {

        myeval(`util.printf(""%%s"")`)

          .then(value => {

            expect(value).toEqual(""%%s"");

          })

          .then(() => done());

      it(""should print some data according to a format"", function (done) {

        myeval(`util.printx(""9 (999) 999-9999"", ""aaa14159697489zzz"")`)

          .then(value => {

            expect(value).toEqual(""1 (415) 969-7489"");

          })

          .then(() => done());

    it(""should trigger an event and modify the source"", function (done) {
","it(""should print a date according to a format"", async () => {
  const value = await myeval(`util.printd(0, ${date})`);
  expect(value).toEqual(""D:20070415031415"");
});

it(""should parse a date according to a format"", async () => {
  const value = await myeval(`util.scand(0, ""D:20070415031415"").toString()`);
  expect(new Date(value)).toEqual(date);
});

it(""should print some data according to a format"", async () => {
  const value = await myeval(`util.printf(""Integer numbers: %d, %d,..."", 1.234, 56.789)`);
  expect(value).toEqual(""Integer numbers: 1, 56,..."");
});

it(""should print a string with no argument"", async () => {
  const value = await myeval(`util.printf(""hello world"")`);
  expect(value).toEqual(""hello world"");
});

it(""print a string with a percent"", async () => {
  const value = await myeval(`util.printf(""%%s"")`);
  expect(value).toEqual(""%s"");
});

it(""should print some data according to a format"", async () => {
  const value = await myeval(`util.printx(""9 (999) 999-9999"", ""aaa14159697489zzz"")`);
  expect(value).toEqual(""1 (415) 969-7489"");
});",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: """",

          name: ""test"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""123"",

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger a Keystroke event and invalidate it"", function (done) {
","sandbox
  .dispatchEventInSandbox({
    id: refId,
    value: """",
    name: ""test"",
    willCommit: true,
  })
  .then(async () => {
    expect(send_queue.has(refId)).toEqual(true);
    expect(send_queue.get(refId)).toEqual({
      id: refId,
      value: ""123"",
    });
    done();
  })
  .catch(done.fail);",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: ""hell"",

          name: ""Keystroke"",

          willCommit: false,

          change: ""o"",

          selStart: 4,

          selEnd: 4,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""hell"",

            selRange: [4, 4],

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger a Keystroke event and change it"", function (done) {
","sandbox
  .dispatchEventInSandbox({
    id: refId,
    value: ""hell"",
    name: ""Keystroke"",
    willCommit: false,
    change: ""o"",
    selStart: 4,
    selEnd: 4,
  })
  .then(() => {
    expect(send_queue.has(refId)).toEqual(true);
    expect(send_queue.get(refId)).toEqual({
      id: refId,
      value: ""hell"",
      selRange: [4, 4],
    });
    done();
  })
  .catch(done.fail);",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: ""hell"",

          name: ""Keystroke"",

          willCommit: false,

          change: ""o"",

          selStart: 4,

          selEnd: 4,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(true);

          expect(send_queue.get(refId)).toEqual({

            id: refId,

            value: ""hella"",

          });

          done();

        })

        .catch(done.fail);

    it(""should trigger an invalid commit Keystroke event"", function (done) {
","sandbox
  .dispatchEventInSandbox({
    id: refId,
    value: ""hell"",
    name: ""Keystroke"",
    willCommit: false,
    change: ""o"",
    selStart: 4,
    selEnd: 4,
  })
  .then(() => {
    expect(send_queue.has(refId)).toEqual(true);
    expect(send_queue.get(refId)).toEqual({
      id: refId,
      value: ""hella"",
    });
    done();
  })
  .catch(done.fail);",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"      sandbox

        .dispatchEventInSandbox({

          id: refId,

          value: """",

          name: ""test"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId)).toEqual(false);

          done();

        })

        .catch(done.fail);

    it(""should trigger a valid commit Keystroke event"", function (done) {
","sandbox
  .dispatchEventInSandbox({
    id: refId,
    value: """",
    name: ""test"",
    willCommit: true,
  })
  .then(async () => {
    expect(send_queue.has(refId)).toEqual(false);
    done();
  })
  .catch(done.fail);",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"      sandbox

        .dispatchEventInSandbox({

          id: refId1,

          value: ""hello"",

          name: ""Keystroke"",

          willCommit: true,

        })

        .then(() => {

          expect(send_queue.has(refId1)).toEqual(true);

          expect(send_queue.get(refId1)).toEqual({

            id: refId1,

            value: ""world"",

            valueAsString: ""world"",

          });

          done();

        })

        .catch(done.fail);
","async function test() {
  try {
    const refId1 = await sandbox.dispatchEventInSandbox({
      id: refId1,
      value: ""hello"",
      name: ""Keystroke"",
      willCommit: true,
    });
    expect(send_queue.has(refId1)).toEqual(true);
    expect(send_queue.get(refId1)).toEqual({
      id: refId1,
      value: ""world"",
      valueAsString: ""world"",
    });
  } catch (error) {
    done.fail();
  }
}",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"    it(""should convert RGB color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0.181]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0.1, 0.2, 0.3]);

        }),

        myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0.9, 0.8, 0.7, 0.7]);

        }),

      ]).then(() => done());

    it(""should convert CMYK color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""T"")`).then(

          value => {

            expect(round(value)).toEqual([""T""]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""G"")`).then(

          value => {

            expect(round(value)).toEqual([""G"", 0.371]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""RGB"")`).then(

          value => {

            expect(round(value)).toEqual([""RGB"", 0.5, 0.3, 0.4]);

          }

        ),

        myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""CMYK"")`).then(

          value => {

            expect(round(value)).toEqual([""CMYK"", 0.1, 0.2, 0.3, 0.4]);

          }

        ),

      ]).then(() => done());

    it(""should convert Gray color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""G"", 0.1], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""G"", 0.1], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0.1]);

        }),

        myeval(`color.convert([""G"", 0.1], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0.1, 0.1, 0.1]);

        }),

        myeval(`color.convert([""G"", 0.1], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 0.9]);

        }),

      ]).then(() => done());

    it(""should convert Transparent color for different color spaces"", function (done) {

      Promise.all([

        myeval(`color.convert([""T""], ""T"")`).then(value => {

          expect(round(value)).toEqual([""T""]);

        }),

        myeval(`color.convert([""T""], ""G"")`).then(value => {

          expect(round(value)).toEqual([""G"", 0]);

        }),

        myeval(`color.convert([""T""], ""RGB"")`).then(value => {

          expect(round(value)).toEqual([""RGB"", 0, 0, 0]);

        }),

        myeval(`color.convert([""T""], ""CMYK"")`).then(value => {

          expect(round(value)).toEqual([""CMYK"", 0, 0, 0, 1]);

        }),

      ]).then(() => done());
","it(""should convert RGB color for different color spaces"", async () => {

  await expect(round(await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""T"")`).then(value => {
    return value;
  }))).toEqual([""T""]);

  await expect(round(await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""G"")`).then(value => {
    return value;
  }))).toEqual([""G"", 0.181]);

  await expect(round(await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""RGB"")`).then(value => {
    return value;
  }))).toEqual([""RGB"", 0.1, 0.2, 0.3]);

  await expect(round(await myeval(`color.convert([""RGB"", 0.1, 0.2, 0.3], ""CMYK"")`).then(value => {
    return value;
  }))).toEqual([""CMYK"", 0.9, 0.8, 0.7, 0.7]);

});

it(""should convert CMYK color for different color spaces"", async () => {

  await expect(round(await myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""T"")`).then(value => {
    return value;
  }))).toEqual([""T""]);

  await expect(round(await myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""G"")`).then(value => {
    return value;
  }))).toEqual([""G"", 0.371]);

  await expect(round(await myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""RGB"")`).then(value => {
    return value;
  }))).toEqual([""RGB"", 0.5, 0.3, 0.4]);

  await expect(round(await myeval(`color.convert([""CMYK"", 0.1, 0.2, 0.3, 0.4], ""CMYK"")`).then(value => {
    return value;
  }))).toEqual([""CMYK"", 0.1, 0.2, 0.3, 0.4]);

});

it(""should convert Gray color for different color spaces"", async () => {

  await expect(round(await myeval(`color.convert([""G"", 0.1], ""T"")`).then(value => {
    return value;
  }))).toEqual([""T""]);

  await expect(round(await myeval(`color.convert([""G"", 0.1], ""G"")`).then(value => {
    return value;
  }))).toEqual([""G"", 0.1]);

  await expect(round(await myeval(`color.convert([""G"", 0.1], ""RGB"")`).then(value => {
    return value;
  }))).toEqual([""RGB"", 0.1, 0.1, 0.1]);

  await expect(round(await myeval(`color.convert([""G"", 0.1], ""CMYK"")`).then(value => {
    return value;
  }))).toEqual([""CMYK"", 0, 0, 0, 0.9]);

});

it(""should convert Transparent color for different color spaces"", async () => {

  await expect(round(await myeval(`color.convert([""T""], ""T"")`).then(value => {
    return value;
  }))).toEqual([""T""]);

  await expect(round(await myeval(`color.convert([""T""], ""G"")`).then(value => {
    return value;
  }))).toEqual([""G"", 0]);

  await expect(round(await myeval(`color.convert([""T""], ""RGB"")`).then(value => {
    return value;
  }))).toEqual([""RGB"", 0, 0, 0]);

  await expect(round(await myeval(`color.convert([""T""], ""CMYK"")`).then(value => {
    return value;
  }))).toEqual([""CMYK"", 0, 0, 0, 1]);

});",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"    it(""should test language"", function (done) {

      Promise.all([

        myeval(`app.language`).then(value => {

          expect(value).toEqual(""ENU"");

        }),

        myeval(`app.language = ""hello""`).then(value => {

          expect(value).toEqual(""app.language is read-only"");

        }),

      ]).then(() => done());

    it(""should test platform"", function (done) {

      Promise.all([

        myeval(`app.platform`).then(value => {

          expect(value).toEqual(""UNIX"");

        }),

        myeval(`app.platform = ""hello""`).then(value => {

          expect(value).toEqual(""app.platform is read-only"");

        }),

      ]).then(() => done());
","it(""should test language"", async function () {
  const promises = [];

  promises.push(myeval(`app.language`).then((value) => {
    expect(value).toEqual(""ENU"");
  }));

  promises.push(myeval(`app.language = ""hello""`).then((value) => {
    expect(value).toEqual(""app.language is read-only"");
  }));

  await Promise.all(promises);
});

it(""should test platform"", async function () {
  const promises = [];

  promises.push(myeval(`app.platform`).then((value) => {
    expect(value).toEqual(""UNIX"");
  }));

  promises.push(myeval(`app.platform = ""hello""`).then((value) => {
    expect(value).toEqual(""app.platform is read-only"");
  }));

  await Promise.all(promises);
});",2021-02-17 11:19:39+01:00,ccef734ebb80e50b0ed15ddc0f4c26cc1619f1ad
"    },

  };

  function processBinaryCMap(data, cMap, extend) {

    return new Promise(function (resolve, reject) {
","\`\`\`javascript
async function processBinaryCMap(data, cMap, extend) {
  try {
    const result = await fetch(data, cMap, extend);
    resolve(result);
  } catch (error) {
    reject(error);
  }
}
\`\`\`",2021-02-27 14:20:43+01:00,05de20071a43f7dac9903835f479d57e863521f7
"    return Promise.resolve(cMap);

  function extendCMap(cMap, fetchBuiltInCMap, useCMap) {

    return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function (

      newCMap

    ) {

      cMap.useCMap = newCMap;

      // If there aren't any code space ranges defined clone all the parent ones

      // into this cMap.

      if (cMap.numCodespaceRanges === 0) {

        var useCodespaceRanges = cMap.useCMap.codespaceRanges;

        for (var i = 0; i < useCodespaceRanges.length; i++) {

          cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();

        }

        cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;

      // Merge the map into the current one, making sure not to override

      // any previously defined entries.

      cMap.useCMap.forEach(function (key, value) {

        if (!cMap.contains(key)) {

          cMap.mapOne(key, cMap.useCMap.lookup(key));

        }

      });



      return cMap;

  function createBuiltInCMap(name, fetchBuiltInCMap) {

      return Promise.resolve(new IdentityCMap(false, 2));

      return Promise.resolve(new IdentityCMap(true, 2));

      return Promise.reject(new Error(""Unknown CMap name: "" + name));

      return Promise.reject(

        new Error(""Built-in CMap parameters are not provided."")

      );

    return fetchBuiltInCMap(name).then(function (data) {

      var cMapData = data.cMapData,

        compressionType = data.compressionType;

      var cMap = new CMap(true);



      if (compressionType === CMapCompressionType.BINARY) {

        return new BinaryCMapReader().process(

          cMapData,

          cMap,

          function (useCMap) {

            return extendCMap(cMap, fetchBuiltInCMap, useCMap);

          }

        );

      }

      if (compressionType === CMapCompressionType.NONE) {

        var lexer = new Lexer(new Stream(cMapData));

        return parseCMap(cMap, lexer, fetchBuiltInCMap, null);

      }

      return Promise.reject(

        new Error(

          ""TODO: Only BINARY/NONE CMap compression is currently supported.""

        )

      );

    });
","return Promise.resolve(cMap);

function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
  return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(newCMap => {
    cMap.useCMap = newCMap;
    if (cMap.numCodespaceRanges === 0) {
      var useCodespaceRanges = cMap.useCMap.codespaceRanges;
      for (var i = 0; i < useCodespaceRanges.length; i++) {
        cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
      }
      cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
    }
    cMap.useCMap.forEach(function (key, value) {
      if (!cMap.contains(key)) {
        cMap.mapOne(key, cMap.useCMap.lookup(key));
      }
    });
  });
}

function createBuiltInCMap(name, fetchBuiltInCMap) {
  return Promise.resolve(new IdentityCMap(false, 2));
}",2021-02-27 14:20:43+01:00,05de20071a43f7dac9903835f479d57e863521f7
"        var cMap = new CMap();

        var lexer = new Lexer(encoding);

        return parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function (

          parsedCMap

        ) {

          if (parsedCMap.isIdentityCMap) {

            return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);

          }

          return parsedCMap;

        });
","\`\`\`javascript
async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
  const parsedCMap = await fetchBuiltInCMap(parsedCMap.name);
  if (parsedCMap.isIdentityCMap) {
    return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
  }
  return parsedCMap;
}
\`\`\`",2021-02-27 14:20:43+01:00,05de20071a43f7dac9903835f479d57e863521f7
"  open() {

    this.overlayManager.open(this.overlayName).then(() => {

      if (

        !this._isViewerEmbedded ||

        this.reason === PasswordResponses.INCORRECT_PASSWORD

      ) {

        this.input.focus();

      }

      let promptString;

      if (this.reason === PasswordResponses.INCORRECT_PASSWORD) {

        promptString = this.l10n.get(

          ""password_invalid"",

          null,

          ""Invalid password. Please try again.""

        );

      } else {

        promptString = this.l10n.get(

          ""password_label"",

          null,

          ""Enter the password to open this PDF file.""

        );

      }

      promptString.then(msg => {

        this.label.textContent = msg;

      });

    });
","async open() {

    await this.overlayManager.open(this.overlayName);

    if (

      !this._isViewerEmbedded ||

      this.reason === PasswordResponses.INCORRECT_PASSWORD

    ) {

      this.input.focus();

    }

    let promptString;

    if (this.reason === PasswordResponses.INCORRECT_PASSWORD) {

      promptString = await this.l10n.get(

        ""password_invalid"",

        null,

        ""Invalid password. Please try again.""

      );

    } else {

      promptString = await this.l10n.get(

        ""password_label"",

        null,

        ""Enter the password to open this PDF file.""

      );

    }

    this.label.textContent = promptString;

  }",2021-02-22 12:43:16+01:00,038668bf8cbf73490e06a70b4d24364499ab484e
"    if (rawName) {

      pageName = this.l10n.get(

        ""document_properties_page_size_name_"" + rawName.toLowerCase(),

        null,

        rawName

      );

    }

    return Promise.all([

        ""document_properties_page_size_unit_"" +

          (this._isNonMetricLocale ? ""inches"" : ""millimeters""),

        null,

        this._isNonMetricLocale ? ""in"" : ""mm""

      pageName,

        ""document_properties_page_size_orientation_"" +

          (isPortrait ? ""portrait"" : ""landscape""),

        null,

        isPortrait ? ""portrait"" : ""landscape""

    ]).then(([{ width, height }, unit, name, orientation]) => {

      return this.l10n.get(

        ""document_properties_page_size_dimension_"" +

          (name ? ""name_"" : """") +

          ""string"",

        {

          width: width.toLocaleString(),

          height: height.toLocaleString(),

          unit,

          name,

          orientation,

        },

        ""{{width}} × {{height}} {{unit}} ("" +

          (name ? ""{{name}}, "" : """") +

          ""{{orientation}})""

      );

    });
","async function getPageSizeName(rawName, isPortrait) {
  let pageName;
  if (rawName) {
    pageName = this.l10n.get(""document_properties_page_size_name_"" + rawName.toLowerCase(), null, rawName);
  }
  const [unit, name, orientation] = await Promise.all([
    ""document_properties_page_size_unit_"" + (this._isNonMetricLocale ? ""inches"" : ""millimeters""),
    null,
    this._isNonMetricLocale ? ""in"" : ""mm"",
    pageName,
    ""document_properties_page_size_orientation_"" + (isPortrait ? ""portrait"" : ""landscape""),
    null,
    isPortrait ? ""portrait"" : ""landscape""
  ]);
  return this.l10n.get(""document_properties_page_size_dimension_"" + (name ? ""name_"" : """") + ""string"", {
    width: width.toLocaleString(),
    height: height.toLocaleString(),
    unit,
    name,
    orientation,
  }, ""{{width}} × {{height}} {{unit}} ("" + (name ? ""{{name}}, "" : """") + ""{{orientation}})"");
}",2021-02-22 12:43:16+01:00,038668bf8cbf73490e06a70b4d24364499ab484e
"          this._pdfViewer.pagesPromise.then(() => {

            this._eventBus.dispatch(""print"", { source: this });

          });
","this._pdfViewer.pagesPromise.then(() => {
  return this._eventBus.dispatch(""print"", { source: this })
});",2021-03-16 14:22:39+01:00,d92b77e87f9ffb1fc9916ca18be7e6f36f2009ad
"  startCleanup() {

    return this.messageHandler.sendWithPromise(""Cleanup"", null).then(() => {

      for (let i = 0, ii = this.pageCache.length; i < ii; i++) {

        const page = this.pageCache[i];

        if (page) {

          const cleanupSuccessful = page.cleanup();

          if (!cleanupSuccessful) {

            throw new Error(

              `startCleanup: Page ${i + 1} is currently rendering.`

            );

          }

        }

      this.commonObjs.clear();

      this._hasJSActionsPromise = null;

    });
","async startCleanup() {
  try {
    await this.messageHandler.sendWithPromise(""Cleanup"", null);
    for (let i = 0, ii = this.pageCache.length; i < ii; i++) {
      const page = this.pageCache[i];
      if (page) {
        const cleanupSuccessful = await page.cleanup();
        if (!cleanupSuccessful) {
          throw new Error(
            `startCleanup: Page ${i + 1} is currently rendering.`
          );
        }
      }
    }
    this.commonObjs.clear();
    this._hasJSActionsPromise = null;
  } catch (error) {
    console.error(error);
  }
}",2021-04-02 12:26:39+02:00,a2bc6481a081a1093fad8b638c30d5bb8d099584
"    it(""cleans up document resources"", function (done) {

      const promise = pdfDocument.cleanup();

      promise.then(function () {

        expect(true).toEqual(true);

        done();

      }, done.fail);
","it(""cleans up document resources"", async function() {
    await pdfDocument.cleanup();
    expect(true).toEqual(true);
  });",2021-04-02 12:26:46+02:00,232fbd28e1c23039bea3e2651ef4c76ae8420be4
"    it(""cleans up document resources after rendering of page"", function (done) {

      let canvasAndCtx;

      loadingTask.promise

        .then(pdfDoc => {

          return pdfDoc.getPage(1).then(pdfPage => {

            const viewport = pdfPage.getViewport({ scale: 1 });

            canvasAndCtx = CanvasFactory.create(

              viewport.width,

              viewport.height

            );

            const renderTask = pdfPage.render({

              canvasContext: canvasAndCtx.context,

              canvasFactory: CanvasFactory,

              viewport,

            });

            return renderTask.promise.then(() => {

              return pdfDoc.cleanup();

            });

          });

        })

        .then(() => {

          expect(true).toEqual(true);

          CanvasFactory.destroy(canvasAndCtx);

          loadingTask.destroy().then(done);

        }, done.fail);

    it(""cleans up document resources during rendering of page"", function (done) {

      let canvasAndCtx;

      loadingTask.promise

        .then(pdfDoc => {

          return pdfDoc.getPage(1).then(pdfPage => {

            const viewport = pdfPage.getViewport({ scale: 1 });

            canvasAndCtx = CanvasFactory.create(

              viewport.width,

              viewport.height

            );

            const renderTask = pdfPage.render({

              canvasContext: canvasAndCtx.context,

              canvasFactory: CanvasFactory,

              viewport,

            });

            renderTask.onContinue = function (cont) {

              waitSome(cont);

            };

            return pdfDoc

              .cleanup()

              .then(

                () => {

                  throw new Error(""shall fail cleanup"");

                },

                reason => {

                  expect(reason instanceof Error).toEqual(true);

                  expect(reason.message).toEqual(

                    ""startCleanup: Page 1 is currently rendering.""

                  );

                }

              )

              .then(() => {

                return renderTask.promise;

              })

              .then(() => {

                CanvasFactory.destroy(canvasAndCtx);

                loadingTask.destroy().then(done);

              });

          });

        })

        .catch(done.fail);
","async function () {
  let canvasAndCtx;
  try {
    const pdfDoc = await loadingTask.promise;
    const pdfPage = await pdfDoc.getPage(1);
    const viewport = pdfPage.getViewport({ scale: 1 });
    canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);
    const renderTask = pdfPage.render({
      canvasContext: canvasAndCtx.context,
      canvasFactory: CanvasFactory,
      viewport,
    });
    await renderTask.promise;
    return pdfDoc.cleanup();
  } catch (error) {
    expect(error).toEqual(new Error(""shall fail cleanup""));
    expect(error.message).toEqual(""startCleanup: Page 1 is currently rendering."");
    CanvasFactory.destroy(canvasAndCtx);
    loadingTask.destroy().then(done);
  } finally {
    // always destroy the canvas and loading task
  }
}",2021-04-02 12:26:46+02:00,232fbd28e1c23039bea3e2651ef4c76ae8420be4
"    return shadow(

      this,

      ""hasJSActions"",

      this.fieldObjects.then(fieldObjects => {

        return (

          (fieldObjects !== null &&

            Object.values(fieldObjects).some(fieldObject =>

              fieldObject.some(object => object.actions !== null)

            )) ||

          !!this.catalog.jsActions

        );

      })

    );
","return shadow(
  this,
  ""hasJSActions"",
  await (await this.fieldObjects).then((fieldObjects) => {
    return (
      fieldObjects !== null &&
      Object.values(fieldObjects).some((fieldObject) =>
        fieldObject.some((object) => object.actions !== null)
      ) || !!this.catalog.jsActions
    );
  })
);",2021-04-13 12:30:20+02:00,2b2234fd5a789c059c334fda44573a52ee6fbb23
"    it(""should resolve with correct data"", function (done) {

      promiseCapability.promise.then(function (data) {

        expect(promiseCapability.settled).toEqual(true);



        expect(data).toEqual({ test: ""abc"" });

        done();

      }, done.fail);

    it(""should reject with correct reason"", function (done) {

      promiseCapability.promise.then(done.fail, function (reason) {

        expect(promiseCapability.settled).toEqual(true);

        done();

      });
","it(""should resolve with correct data"", async () => {
  try {
    const data = await promiseCapability.promise;
    expect(promiseCapability.settled).toEqual(true);
    expect(data).toEqual({ test: ""abc"" });
  } catch (error) {
    done.fail();
  }
});

it(""should reject with correct reason"", async () => {
  try {
    await promiseCapability.promise;
  } catch (reason) {
    expect(promiseCapability.settled).toEqual(true);
    done();
  }
});",2021-04-11 19:26:38+02:00,a2811e925dc064b5f7832ee45dbb44871111e4f3
"        done.fail(""shall not dispatch DOM event."");

      Promise.resolve().then(() => {

        expect(count).toEqual(1);

        document.removeEventListener(""test"", domEventListener);

        done();

      });
","async function test() {
  try {
    await Promise.resolve().then(() => {
      expect(count).toEqual(1);
      document.removeEventListener(""test"", domEventListener);
    });
  } catch (error) {
    done.fail(""shall not dispatch DOM event."");
  }
}",2021-04-11 19:51:21+02:00,a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8
"          throw new Error(""Should reject invalid parameters."");

      Promise.all([invalidTarget, invalidName, invalidDelay]).then(

        done,

        done.fail

      );

    it(""should resolve on event, using the DOM"", function (done) {

        pending(""Document in not supported in Node.js."");
","it(""should resolve on event, using the DOM"", async () => {
  try {
    const invalidTarget = await Promise.resolve("""");
    const invalidName = await Promise.resolve("""");
    const invalidDelay = await Promise.resolve(0);
    return done.fail();
  } catch (error) {
    console.log(error);
  }
});",2021-04-11 19:51:21+02:00,a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8
"      buttonClicked.then(function (type) {

        expect(type).toEqual(WaitOnType.EVENT);

        done();

      }, done.fail);

    it(""should resolve on timeout, using the DOM"", function (done) {

        pending(""Document in not supported in Node.js."");
","async buttonClicked() {
  const type = await WaitOnType.EVENT;
  expect(type).toEqual(WaitOnType.EVENT);
}

it(""should resolve on timeout, using the DOM"", async () => {
  if (typeof document === ""undefined"") return pending(""Document is not supported in Node.js."");
});",2021-04-11 19:51:21+02:00,a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8
"      buttonClicked.then(function (type) {

        expect(type).toEqual(WaitOnType.TIMEOUT);

        done();

      }, done.fail);

    it(""should resolve on event, using the EventBus"", function (done) {
","buttonClicked.then(async () => {
  expect(type).toEqual(WaitOnType.TIMEOUT);
  done();
}, done.fail);

it(""should resolve on event, using the EventBus"", async (done) => {
  // code here
});",2021-04-11 19:51:21+02:00,a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8
"      pageRendered.then(function (type) {

        expect(type).toEqual(WaitOnType.EVENT);

        done();

      }, done.fail);

    it(""should resolve on timeout, using the EventBus"", function (done) {
","async function () {
  try {
    const type = await pageRendered;
    expect(type).toEqual(WaitOnType.EVENT);
  } catch (error) {
    done();
  }
}

it(""should resolve on timeout, using the EventBus"", async function () {
  try {
    const type = await pageRendered;
    expect(type).toEqual(WaitOnType.EVENT);
  } catch (error) {
    done();
  }
});",2021-04-11 19:51:21+02:00,a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8
"      pageRendered.then(function (type) {

        expect(type).toEqual(WaitOnType.TIMEOUT);

        done();

      }, done.fail);
","async function test() {
  try {
    const type = await pageRendered;
    expect(type).toEqual(WaitOnType.TIMEOUT);
    done();
  } catch (error) {
    done.fail(error);
  }
}",2021-04-11 19:51:21+02:00,a56ffb92be63d35fdeb2b3da8f161d9fd4c48fd8
"    it(""should asynchronously fetch unknown keys"", function (done) {

      Promise.all(keyPromises)

        .then(function (values) {

          expect(values[0]).toBeUndefined();

          expect(values[1]).toBeUndefined();

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });

    it(""should asynchronously fetch correct values for multiple stored keys"", function (done) {

      Promise.all(keyPromises)

        .then(function (values) {

          expect(values[0]).toEqual(testFontFile3);

          expect(values[1]).toEqual(testFontFile2);

          expect(values[2]).toEqual(testFontFile);

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });
","it(""should asynchronously fetch unknown keys"", async function () {
  try {
    const values = await Promise.all(keyPromises);
    expect(values[0]).toBeUndefined();
    expect(values[1]).toBeUndefined();
  } catch (error) {
    done.fail(error);
  }
});

it(""should asynchronously fetch correct values for multiple stored keys"", async function () {
  try {
    const values = await Promise.all(keyPromises);
    expect(values[0]).toEqual(testFontFile3);
    expect(values[1]).toEqual(testFontFile2);
    expect(values[2]).toEqual(testFontFile);
  } catch (error) {
    done.fail(error);
  }
});",2021-04-11 19:56:58+02:00,99dc0d6b65ea956b6201ea0569134ab411286e3a
"      fontDict

        .getAsync(""FontFile"", ""FontFile2"", ""FontFile3"")

        .then(function (value) {

          expect(value).toEqual(testFontFile);

          done();

        })

        .catch(function (reason) {

          done.fail(reason);

        });
","fontDict
    .getAsync(""FontFile"", ""FontFile2"", ""FontFile3"")
    .then(async function (value) {
      expect(value).toEqual(testFontFile);
      done();
    })
    .catch(function (reason) {
      done.fail(reason);
    });",2021-04-11 19:56:58+02:00,99dc0d6b65ea956b6201ea0569134ab411286e3a
"    const readPromise = Promise.all([read1(), read2(), promise1, promise2]);

    readPromise

      .then(result => {

        expect(isStreamingSupported1).toEqual(false);

        expect(isRangeSupported1).toEqual(false);

        expect(isStreamingSupported2).toEqual(false);

        expect(isRangeSupported2).toEqual(false);

        expect(len1).toEqual(pdfLength);

        expect(len1).toEqual(len2);

        done();

      })

      .catch(reason => {

        done.fail(reason);

      });

  it(""read custom ranges for both http(s) and filesystem urls"", function (done) {
","async () => {
  const readPromise = Promise.all([read1(), read2(), promise1, promise2]);
  try {
    const result = await readPromise;
    expect(isStreamingSupported1).toEqual(false);
    expect(isRangeSupported1).toEqual(false);
    expect(isStreamingSupported2).toEqual(false);
    expect(isRangeSupported2).toEqual(false);
    expect(len1).toEqual(pdfLength);
    expect(len1).toEqual(len2);
    done();
  } catch (reason) {
    done.fail(reason);
  }
}",2021-04-11 20:01:52+02:00,fcf4d02fca301705419b8b3a94319fc899d6c230
"    const readPromise = Promise.all([read(), promise]);



    readPromise

      .then(function (page) {

        expect(len).toEqual(pdf1Length);

        expect(count).toEqual(1);

        expect(isStreamingSupported).toEqual(false);

        expect(isRangeSupported).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""read custom ranges"", function (done) {
","it(""read custom ranges"", async () => {
  const readPromise = Promise.all([read(), promise]);
  try {
    const page = await readPromise;
    expect(len).toEqual(pdf1Length);
    expect(count).toEqual(1);
    expect(isStreamingSupported).toEqual(false);
    expect(isRangeSupported).toEqual(false);
    done();
  } catch (reason) {
    done.fail(reason);
  }
});",2021-04-11 20:03:41+02:00,5607484402adc89d9c8f3d8a7697c86089676f80
"    const readPromises = Promise.all([

    readPromises

      .then(function () {

        expect(result1.value).toEqual(rangeSize);

        expect(result2.value).toEqual(tailSize);

        expect(isStreamingSupported).toEqual(false);

        expect(isRangeSupported).toEqual(true);

        expect(fullReaderCancelled).toEqual(true);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });
","async () => {
  try {
    const result1 = await readPromises[0];
    const result2 = await readPromises[1];
    expect(result1.value).toEqual(rangeSize);
    expect(result2.value).toEqual(tailSize);
    expect(isStreamingSupported).toEqual(false);
    expect(isRangeSupported).toEqual(true);
    expect(fullReaderCancelled).toEqual(true);
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}",2021-04-11 20:03:41+02:00,5607484402adc89d9c8f3d8a7697c86089676f80
"    const readPromise = Promise.all([read(), promise]);

    readPromise

      .then(function () {

        expect(len).toEqual(pdfLength);

        expect(isStreamingSupported).toEqual(true);

        expect(isRangeSupported).toEqual(false);

        done();

      })

      .catch(done.fail);

  it(""read ranges with streaming"", function (done) {
","async function test() {
  try {
    const readPromise = await Promise.all([read(), promise]);
    expect(len).toEqual(pdfLength);
    expect(isStreamingSupported).toEqual(true);
    expect(isRangeSupported).toEqual(false);
  } catch (err) {
    done.fail();
  }
}",2021-04-11 20:07:27+02:00,a1c1e1b9f8695617a67cbe209e237162f439d96e
"    const readPromise = Promise.all([

    readPromise

      .then(function () {

        expect(isStreamingSupported).toEqual(true);

        expect(isRangeSupported).toEqual(true);

        expect(fullReaderCancelled).toEqual(true);

        expect(result1.value).toEqual(rangeSize);

        expect(result2.value).toEqual(tailSize);

        done();

      })

      .catch(done.fail);
","async () => {
  try {
    await Promise.all([readPromise]);
    expect(isStreamingSupported).toEqual(true);
    expect(isRangeSupported).toEqual(true);
    expect(fullReaderCancelled).toEqual(true);
    expect(result1.value).toEqual(rangeSize);
    expect(result2.value).toEqual(tailSize);
  } catch (error) {
    done.fail();
  } finally {
    done();
  }
}",2021-04-11 20:07:27+02:00,a1c1e1b9f8695617a67cbe209e237162f439d96e
"  beforeAll(function (done) {

    loadingTask.promise

      .then(function (doc) {

        return doc.getPage(1);

      })

      .then(function (data) {

        page = data;

        done();

      })

      .catch(done.fail);

  afterAll(function (done) {

    loadingTask.destroy().then(done);

  it(""renders to canvas with a default white background"", function (done) {
","beforeAll(async () => {
  const doc = await loadingTask.promise;
  const page = await doc.getPage(1);
  done();
});

afterAll(() => {
  loadingTask.destroy().then(done);
});

it(""renders to canvas with a default white background"", async () => {
  // ...
});",2021-04-11 20:11:42+02:00,c1e9f6025f7c530a0e81458f34eb2532b3e49f22
"    renderTask.promise

      .then(function () {

        expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

          r: 255,

          g: 255,

          b: 255,

          a: 255,

        });

        CanvasFactory.destroy(canvasAndCtx);

        done();

      })

      .catch(done.fail);

  it(""renders to canvas with a custom background"", function (done) {
","async () => {
  try {
    await renderTask.promise;
    const topLeftPixel = getTopLeftPixel(canvasAndCtx.context);
    expect(topLeftPixel).toEqual({
      r: 255,
      g: 255,
      b: 255,
      a: 255,
    });
    CanvasFactory.destroy(canvasAndCtx);
    done();
  } catch (error) {
    done.fail(error);
  }
}",2021-04-11 20:11:42+02:00,c1e9f6025f7c530a0e81458f34eb2532b3e49f22
"    renderTask.promise

      .then(function () {

        expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({

          r: 255,

          g: 0,

          b: 0,

          a: 255,

        });

        CanvasFactory.destroy(canvasAndCtx);

        done();

      })

      .catch(done.fail);
","async function renderTask() {
    const canvasAndCtx = await CanvasFactory.create(100, 100);
    const ctx = canvasAndCtx.context;

    // Your code here

    expect(getTopLeftPixel(ctx)).toEqual({
        r: 255,
        g: 0,
        b: 0,
        a: 255,
    });

    await CanvasFactory.destroy(canvasAndCtx);
}",2021-04-11 20:11:42+02:00,c1e9f6025f7c530a0e81458f34eb2532b3e49f22
"  beforeAll(function (done) {

    loadingTask.promise.then(function (doc) {

      doc.getPage(1).then(function (firstPage) {

        page = firstPage;

        done();

      });

    });

  afterAll(function (done) {

    loadingTask.destroy().then(done);
","beforeAll(async () => {
  const doc = await loadingTask.promise;
  const firstPage = await doc.getPage(1);
  page = firstPage;
});

afterAll(() => {
  return loadingTask.destroy();
});",2021-04-14 21:57:07+02:00,bc8c0bbbfda12f8c80156097066b7b7036e6c625
"    it(""should produce a reasonably small svg:image"", function (done) {

      withZlib(true, getSVGImage)

        .then(function (svgImg) {

          expect(svgImg.nodeName).toBe(""svg:image"");

          expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

          expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

          const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

          // forceDataSchema = true, so the generated URL should be a data:-URL.

          expect(imgUrl).toMatch(/^data:image\/png;base64,/);

          // Test whether the generated image has a reasonable file size.

          // I obtained a data URL of size 366 with Node 8.1.3 and zlib 1.2.11.

          // Without zlib (uncompressed), the size of the data URL was excessive

          // (80246).

          expect(imgUrl.length).toBeLessThan(367);

        })

        .then(done, done.fail);

    it(""should be able to produce a svg:image without zlib"", function (done) {

      withZlib(false, getSVGImage)

        .then(function (svgImg) {

          expect(svgImg.nodeName).toBe(""svg:image"");

          expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

          expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

          const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

          expect(imgUrl).toMatch(/^data:image\/png;base64,/);

          // The size of our naively generated PNG file is excessive :(

          expect(imgUrl.length).toBe(80246);

        })

        .then(done, done.fail);
","it(""should produce a reasonably small svg:image"", async () => {
  const svgImg = await withZlib(true, getSVGImage);

  expect(svgImg.nodeName).toBe(""svg:image"");

  expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

  expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

  const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

  // forceDataSchema = true, so the generated URL should be a data:-URL.

  expect(imgUrl).toMatch(/^data:image\/png;base64,/);

  // Test whether the generated image has a reasonable file size.

  // I obtained a data URL of size 366 with Node 8.1.3 and zlib 1.2.11.

  // Without zlib (uncompressed), the size of the data URL was excessive

  // (80246).

  expect(imgUrl.length).toBeLessThan(367);
});

it(""should be able to produce a svg:image without zlib"", async () => {
  const svgImg = await withZlib(false, getSVGImage);

  expect(svgImg.nodeName).toBe(""svg:image"");

  expect(svgImg.getAttributeNS(null, ""width"")).toBe(""200px"");

  expect(svgImg.getAttributeNS(null, ""height"")).toBe(""100px"");

  const imgUrl = svgImg.getAttributeNS(XLINK_NS, ""href"");

  expect(imgUrl).toMatch(/^data:image\/png;base64,/);

  // The size of our naively generated PNG file is excessive :(

  expect(imgUrl.length).toBeLessThan(80246);
});",2021-04-14 21:57:07+02:00,bc8c0bbbfda12f8c80156097066b7b7036e6c625
"      sleep(10)

        .then(() => {

          expect(log).toEqual("""");

          return reader.read();

        })

        .then(result => {

          expect(log).toEqual(""p"");

          expect(result.value).toEqual(""hi"");

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });

    it(""should not read any data when cancelled"", function (done) {
","async function test() {
  try {
    await sleep(10);
    expect(log).toEqual("""");
    let result = await reader.read();
    expect(result.value).toEqual(""hi"");
    expect(result.done).toEqual(false);
    await sleep(10);
    result = await reader.read();
    expect(result.value).toEqual(undefined);
    expect(result.done).toEqual(true);
    done();
  } catch (error) {
    console.log(error);
  }
}",2021-04-14 21:52:23+02:00,43eb4302ff3f77108e24a9a5a8a3b97e7c589439
"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2"");

          return reader.cancel(new AbortException(""reader cancelled.""));

        })

        .then(() => {

          expect(log).toEqual(""01p2c4"");

          done();

        });

    it(""should not read when errored"", function (done) {
","async () => {
  try {
    await sleep(10);
    const result = await reader.read();
    expect(result.value).toEqual([1, 2, 3, 4]);
    expect(result.done).toEqual(false);
    await sleep(10);
    expect(log).toEqual(""01p2"");
    await reader.cancel(new AbortException(""reader cancelled.""));
    expect(log).toEqual(""01p2c4"");
  } catch (error) {
    expect(error).toBeInstanceOf(AbortException);
  } finally {
    done();
  }
}",2021-04-14 21:52:23+02:00,43eb4302ff3f77108e24a9a5a8a3b97e7c589439
"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return reader.read();

        })

        .catch(reason => {

          expect(log).toEqual(""01pe"");

          expect(reason instanceof UnknownErrorException).toEqual(true);

          expect(reason.message).toEqual(""should not read when errored"");

          done();

        });

    it(""should read data with blocking promise"", function (done) {
","async function() {
  try {
    await sleep(10);
    const result = await reader.read();
    expect(result.value).toEqual([1, 2, 3, 4]);
    expect(result.done).toEqual(false);
    return reader.read();
  } catch (reason) {
    expect(log).toEqual(""01pe"");
    expect(reason instanceof UnknownErrorException).toEqual(true);
    expect(reason.message).toEqual(""should not read when errored"");
    done();
  }
}",2021-04-14 21:52:23+02:00,43eb4302ff3f77108e24a9a5a8a3b97e7c589439
"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual([5, 6, 7, 8]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01p2p"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });

      function (done) {
","async () => {
  await sleep(10);

  const result = await reader.read();

  expect(result.value).toEqual([1, 2, 3, 4]);

  expect(result.done).toEqual(false);

  await sleep(10);

  const result2 = await reader.read();

  expect(result2.value).toEqual([5, 6, 7, 8]);

  expect(result2.done).toEqual(false);

  await sleep(10);

  const result3 = await reader.read();

  expect(result3.value).toEqual(undefined);

  expect(result3.done).toEqual(true);

  done();
}",2021-04-14 21:52:23+02:00,43eb4302ff3f77108e24a9a5a8a3b97e7c589439
"        sleep(10)

          .then(() => {

            expect(log).toEqual(""012"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual([1, 2, 3, 4]);

            expect(result.done).toEqual(false);

            return sleep(10);

          })

          .then(() => {

            expect(log).toEqual(""012p"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual([5, 6, 7, 8]);

            expect(result.done).toEqual(false);

            return sleep(10);

          })

          .then(() => {

            expect(log).toEqual(""012p"");

            return reader.read();

          })

          .then(result => {

            expect(result.value).toEqual(undefined);

            expect(result.done).toEqual(true);

            done();

          });

    it(""should ignore any pull after close is called"", function (done) {
","async function test() {
  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
  let log = '';
  const reader = {
    read: () => {
      if (log === '012p') {
        return Promise.resolve({ value: [5, 6, 7, 8], done: false });
      } else if (log === '012') {
        return Promise.resolve({ value: [1, 2, 3, 4], done: false });
      } else {
        return Promise.resolve({ value: undefined, done: true });
      }
    },
  };
  try {
    await sleep(10);
    expect(log).toEqual('012');
    const result = await reader.read();
    expect(result.value).toEqual([1, 2, 3, 4]);
    expect(result.done).toEqual(false);
    await sleep(10);
    expect(log).toEqual('012p');
    const result2 = await reader.read();
    expect(result2.value).toEqual([5, 6, 7, 8]);
    expect(result2.done).toEqual(false);
    await sleep(10);
    expect(log).toEqual('012p');
    const result3 = await reader.read();
    expect(result3.value).toEqual(undefined);
    expect(result3.done).toEqual(true);
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}
test();",2021-04-14 21:52:23+02:00,43eb4302ff3f77108e24a9a5a8a3b97e7c589439
"      sleep(10)

        .then(() => {

          expect(log).toEqual(""01"");

          capability.resolve();

          return capability.promise.then(() => {

            return reader.read();

          });

        })

        .then(result => {

          expect(result.value).toEqual([1, 2, 3, 4]);

          expect(result.done).toEqual(false);

          return sleep(10);

        })

        .then(() => {

          expect(log).toEqual(""01"");

          return reader.read();

        })

        .then(result => {

          expect(result.value).toEqual(undefined);

          expect(result.done).toEqual(true);

          done();

        });
","async function test() {
    await sleep(10);
    const result = await reader.read();
    expect(log).toEqual(""01"");
    expect(result.value).toEqual([1, 2, 3, 4]);
    expect(result.done).toEqual(false);
    await sleep(10);
    const result = await reader.read();
    expect(log).toEqual(""01"");
    expect(result.value).toEqual(undefined);
    expect(result.done).toEqual(true);
  }",2021-04-14 21:52:23+02:00,43eb4302ff3f77108e24a9a5a8a3b97e7c589439
"  it(""parses beginbfchar"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));

        expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));

        expect(cmap.lookup(0x05)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses beginbfrange with range"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x05)).toBeUndefined();

        expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));

        expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));

        expect(cmap.lookup(0x0c)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses beginbfrange with array"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x0c)).toBeUndefined();

        expect(cmap.lookup(0x0d)).toEqual(0x00);

        expect(cmap.lookup(0x12)).toEqual(0x05);

        expect(cmap.lookup(0x13)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses begincidchar"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x14)).toEqual(0x00);

        expect(cmap.lookup(0x15)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses begincidrange"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.lookup(0x15)).toBeUndefined();

        expect(cmap.lookup(0x16)).toEqual(0x00);

        expect(cmap.lookup(0x1b)).toEqual(0x05);

        expect(cmap.lookup(0x1c)).toBeUndefined();

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""decodes codespace ranges"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        const c = {};

        cmap.readCharCode(String.fromCharCode(1), 0, c);

        expect(c.charcode).toEqual(1);

        expect(c.length).toEqual(1);

        cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);

        expect(c.charcode).toEqual(3);

        expect(c.length).toEqual(4);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""decodes 4 byte codespace ranges"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        const c = {};

        cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);

        expect(c.charcode).toEqual(0x8ea1a1a1);

        expect(c.length).toEqual(4);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""read usecmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof CMap).toEqual(true);

        expect(cmap.useCMap).not.toBeNull();

        expect(cmap.builtInCMap).toBeFalsy();

        expect(cmap.length).toEqual(0x20a7);

        expect(cmap.isIdentityCMap).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses cmapname"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.name).toEqual(""Identity-H"");

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""parses wmode"", function (done) {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    cmapPromise

      .then(function (cmap) {

        expect(cmap.vertical).toEqual(true);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""loads built in cmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof CMap).toEqual(true);

        expect(cmap.useCMap).toBeNull();

        expect(cmap.builtInCMap).toBeTruthy();

        expect(cmap.length).toEqual(0x20a7);

        expect(cmap.isIdentityCMap).toEqual(false);

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""loads built in identity cmap"", function (done) {

    const cmapPromise = CMapFactory.create({

    cmapPromise

      .then(function (cmap) {

        expect(cmap instanceof IdentityCMap).toEqual(true);

        expect(cmap.vertical).toEqual(false);

        expect(cmap.length).toEqual(0x10000);

        expect(function () {

          return cmap.isIdentityCMap;

        }).toThrow(new Error(""should not access .isIdentityCMap""));

        done();

      })

      .catch(function (reason) {

        done.fail(reason);

      });

  it(""attempts to load a non-existent built-in CMap"", function (done) {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""null""),

      fetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(""Unknown CMap name: null"");

        done();

      }

    );

  it(""attempts to load a built-in CMap without the necessary API parameters"", function (done) {

      return CMapReaderFactory.fetch({

        name,

    }

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        expect(reason.message).toEqual(

          'The CMap ""baseUrl"" parameter must be specified, ensure that ' +

            'the ""cMapUrl"" and ""cMapPacked"" API parameters are provided.'

        );

        done();

      }

    );

  it(""attempts to load a built-in CMap with inconsistent API parameters"", function (done) {

      return CMapReaderFactory.fetch({

        name,

    }

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    cmapPromise.then(

      function () {

        done.fail(""No CMap should be loaded"");

      },

      function (reason) {

        expect(reason instanceof Error).toEqual(true);

        const message = reason.message;

        expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

        expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(

          true

        );

        done();

      }

    );
","it(""parses beginbfchar"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));

      expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));

      expect(cmap.lookup(0x05)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses beginbfrange with range"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x05)).toBeUndefined();

      expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));

      expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));

      expect(cmap.lookup(0x0c)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses beginbfrange with array"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x0c)).toBeUndefined();

      expect(cmap.lookup(0x0d)).toEqual(0x00);

      expect(cmap.lookup(0x12)).toEqual(0x05);

      expect(cmap.lookup(0x13)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses begincidchar"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x14)).toEqual(0x00);

      expect(cmap.lookup(0x15)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses begincidrange"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x15)).toBeUndefined();

      expect(cmap.lookup(0x16)).toEqual(0x00);

      expect(cmap.lookup(0x1b)).toEqual(0x05);

      expect(cmap.lookup(0x1c)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""decodes codespace ranges"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      const c = {};

      cmap.readCharCode(String.fromCharCode(1), 0, c);

      expect(c.charcode).toEqual(1);

      expect(c.length).toEqual(1);

      cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);

      expect(c.charcode).toEqual(3);

      expect(c.length).toEqual(4);

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""decodes 4 byte codespace ranges"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      const c = {};

      cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);

      expect(c.charcode).toEqual(0x8ea1a1a1);

      expect(c.length).toEqual(4);

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""read usecmap"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: stream,

    });

    try {

      const cmap = await cmapPromise;

      expect(cmap instanceof CMap).toEqual(true);

      expect(cmap.useCMap).not.toBeNull();

      expect(cmap.builtInCMap).toBeFalsy();

      expect(cmap.length).toEqual(0x20a7);

      expect(cmap.isIdentityCMap).toEqual(false);

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses cmapname"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.name).toEqual(""Adobe-Japan1-1"");

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""attempts to load a non-existent built-in CMap"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""null""),

      fetchBuiltInCMap,

      useCMap: null,

    });

    try {

      await cmapPromise;

      done.fail(""No CMap should be loaded"");

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      expect(reason.message).toEqual(""Unknown CMap name: null"");

    }

  });

  it(""attempts to load a built-in CMap without the necessary API parameters"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    try {

      await cmapPromise;

      done.fail(""No CMap should be loaded"");

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      const message = reason.message;

      expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

      expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(

        true

      );

    }

  });

  it(""attempts to load a built-in CMap with inconsistent API parameters"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    try {

      await cmapPromise;

      done.fail(""No CMap should be loaded"");

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      const message = reason.message;

      expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

      expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(

        true

      );

    }

  });",2021-04-14 22:24:28+02:00,38ed655562c47dcac2888ecd49775bd87980f1e8
"        ensure(obj, prop, args) {

          return new Promise(function (resolve) {

            const value = obj[prop];

            if (typeof value === ""function"") {

              resolve(value.apply(obj, args));

            } else {

              resolve(value);

            }

          });
","ensure(obj, prop, args) {
  return new Promise((resolve) => {
    const value = obj[prop];
    if (typeof value === ""function"") {
      resolve(value.apply(obj, args));
    } else {
      resolve(value);
    }
  });
}",2021-04-17 10:13:42+02:00,f560fe68756728ab33f9253e2f6da7c84b4b364f
"      const promises = [

      ];

      Promise.all(promises)

        .then(function (data) {

          expect(data[0].loaded / data[0].total >= 0).toEqual(true);

          expect(data[1] instanceof PDFDocumentProxy).toEqual(true);

          expect(loadingTask).toEqual(data[1].loadingTask);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""creates pdf doc from URL and aborts before worker initialized"", function (done) {

      loadingTask.promise

        .then(function (reason) {

          done.fail(""shall fail loading"");

        })

        .catch(function (reason) {

          expect(true).toEqual(true);

          destroyed.then(done);

        });

    it(""creates pdf doc from URL and aborts loading after worker initialized"", function (done) {

      destroyed

        .then(function (data) {

          expect(true).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""creates pdf doc from typed array"", function (done) {

      const typedArrayPdfPromise = DefaultFileReaderFactory.fetch({

      typedArrayPdfPromise

        .then(typedArrayPdf => {

          // Sanity check to make sure that we fetched the entire PDF file.

          expect(typedArrayPdf.length).toEqual(basicApiFileLength);

          const loadingTask = getDocument(typedArrayPdf);

          const progressReportedCapability = createPromiseCapability();

          loadingTask.onProgress = function (data) {

            progressReportedCapability.resolve(data);

          };

          return Promise.all([

            loadingTask.promise,

            progressReportedCapability.promise,

          ]).then(function (data) {

            expect(data[0] instanceof PDFDocumentProxy).toEqual(true);

            expect(data[1].loaded / data[1].total).toEqual(1);

            loadingTask.destroy().then(done);

          });

        })

        .catch(done.fail);

    it(""creates pdf doc from invalid PDF file"", function (done) {

      loadingTask.promise

        .then(function () {

          done.fail(""shall fail loading"");

        })

        .catch(function (reason) {

          expect(reason instanceof InvalidPDFException).toEqual(true);

          expect(reason.message).toEqual(""Invalid PDF structure."");

          loadingTask.destroy().then(done);

        });

    it(""creates pdf doc from non-existent URL"", function (done) {

        // re-enable https://github.com/mozilla/pdf.js/issues/13061

        pending(""Fails intermittently on linux in browsers."");

      loadingTask.promise

        .then(function (error) {

          done.fail(""shall fail loading"");

        })

        .catch(function (error) {

          expect(error instanceof MissingPDFException).toEqual(true);

          loadingTask.destroy().then(done);

        });

    it(""creates pdf doc from PDF file protected with user and owner password"", function (done) {
","const promises = [];

promises.push(fetch('/test1.pdf').then(function(response) {
  return response.arrayBuffer();
}));

promises.push(fetch('/test2.pdf').then(function(response) {
  return response.arrayBuffer();
}));

Promise.all(promises).then(function(data) {
  var typedArrayPdf = data[0];
  var basicApiFileLength = data[1].length;

  const loadingTask = getDocument(typedArrayPdf);

  const progressReportedCapability = createPromiseCapability();

  loadingTask.onProgress = function(data) {
    progressReportedCapability.resolve(data);
  };

  return Promise.all([loadingTask.promise, progressReportedCapability.promise]).then(function(data) {
    expect(data[0] instanceof PDFDocumentProxy).toEqual(true);
    expect(data[1].loaded / data[1].total).toEqual(1);
    loadingTask.destroy().then(done);
  });
}).catch(done.fail);",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      const promises = [

      ];

      Promise.all(promises)

        .then(function (data) {

          expect(data[2] instanceof PDFDocumentProxy).toEqual(true);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""creates pdf doc from PDF file protected with only a user password"", function (done) {
","it(""creates pdf doc from PDF file protected with only a user password"", async () => {
  const promises = [];

  try {
    const data = await Promise.all(promises);
    expect(data[2] instanceof PDFDocumentProxy).toEqual(true);
    loadingTask.destroy().then(done);
  } catch (error) {
    done.fail();
  }
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([result1, result2, result3])

        .then(function () {

          done();

        })

        .catch(done.fail);

      function (done) {
","async function () {
    try {
      const results = await Promise.all([result1, result2, result3]);
      done();
    } catch (error) {
      done.fail(error);
    }
  }",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"        Promise.all([result1, result2])

          .then(function () {

            done();

          })

          .catch(done.fail);

    it(""creates pdf doc from empty typed array"", function (done) {

      loadingTask.promise.then(

        function () {

          done.fail(""shall not open empty file"");

        },

        function (reason) {

          expect(reason instanceof InvalidPDFException);

          expect(reason.message).toEqual(

            ""The PDF file is empty, i.e. its size is zero bytes.""

          );

          loadingTask.destroy().then(done);

        }

      );

    it(""worker created or destroyed"", function (done) {

      worker.promise

        .then(function () {

          expect(worker.name).toEqual(""test1"");

          expect(!!worker.port).toEqual(true);

          expect(worker.destroyed).toEqual(false);

          expect(!!worker._webWorker).toEqual(true);

          expect(worker.port === worker._webWorker).toEqual(true);



          worker.destroy();

          expect(!!worker.port).toEqual(false);

          expect(worker.destroyed).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""worker created or destroyed by getDocument"", function (done) {
","async () => {
  try {
    const result1 = await Promise.all([result1, result2]);
    done();
  } catch (error) {
    done.fail(error);
  }
}

it(""creates pdf doc from empty typed array"", async function () {
  try {
    await loadingTask.promise;
    done.fail(""shall not open empty file"");
  } catch (reason) {
    expect(reason instanceof InvalidPDFException);
    expect(reason.message).toEqual(
      ""The PDF file is empty, i.e. its size is zero bytes.""
    );
    await loadingTask.destroy();
    done();
  }
}

it(""worker created or destroyed"", async function () {
  try {
    const worker = await worker.promise;
    expect(worker.name).toEqual(""test1"");
    expect(!!worker.port).toEqual(true);
    expect(worker.destroyed).toEqual(false);
    expect(!!worker._webWorker).toEqual(true);
    expect(worker.port === worker._webWorker).toEqual(true);
    await worker.destroy();
    expect(!!worker.port).toEqual(false);
    expect(worker.destroyed).toEqual(true);
    done();
  } catch (error) {
    done.fail(error);
  }
}

it(""worker created or destroyed by getDocument"", async function () {
  try {
    const worker = await worker.promise;
    expect(worker.name).toEqual(""test1"");
    expect(!!worker.port).toEqual(true);
    expect(worker.destroyed).toEqual(false);
    expect(!!worker._webWorker).toEqual(true);
    expect(worker.port === worker._webWorker).toEqual(true);
    await worker.destroy();
    expect(!!worker.port).toEqual(false);
    expect(worker.destroyed).toEqual(true);
    done();
  } catch (error) {
    done.fail(error);
  }
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      destroyPromise

        .then(function () {

          const destroyedWorker = loadingTask._worker;

          expect(!!destroyedWorker).toEqual(false);

          expect(worker.destroyed).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""worker created and can be used in getDocument"", function (done) {
","destroyPromise = loadingTask.destroy();

try {
  await destroyPromise;

  const destroyedWorker = loadingTask._worker;

  expect(!!destroyedWorker).toEqual(false);

  expect(worker.destroyed).toEqual(true);
} catch (error) {
  done.fail();
}

it(""worker created and can be used in getDocument"", async function () {
  // Code to test the worker
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      destroyPromise

        .then(function () {

          expect(worker.destroyed).toEqual(false);

          worker.destroy();

          done();

        })

        .catch(done.fail);

    it(""creates more than one worker"", function (done) {
","async () => {
  try {
    const result = await destroyPromise;
    expect(worker.destroyed).toEqual(false);
    worker.destroy();
    done();
  } catch (error) {
    done.fail();
  }
}

it(""creates more than one worker"", async () => {
  try {
    const result = await createMoreThanOneWorker();
    expect(result).toEqual(true);
    done();
  } catch (error) {
    done.fail();
  }
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      const ready = Promise.all([

        worker1.promise,

        worker2.promise,

        worker3.promise,

      ]);

      ready

        .then(function () {

          expect(

            worker1.port !== worker2.port &&

              worker1.port !== worker3.port &&

              worker2.port !== worker3.port

          ).toEqual(true);

          worker1.destroy();

          worker2.destroy();

          worker3.destroy();

          done();

        })

        .catch(done.fail);
","async function test() {
  const ready = await Promise.all([worker1.promise, worker2.promise, worker3.promise]);
  try {
    expect(worker1.port !== worker2.port && worker1.port !== worker3.port && worker2.port !== worker3.port).toEqual(true);
    await Promise.all([worker1.destroy(), worker2.destroy(), worker3.destroy()]);
  } catch (error) {
    done.fail();
  }
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"    beforeAll(function (done) {

      pdfLoadingTask.promise.then(function (data) {

        pdfDocument = data;

        done();

      });

    afterAll(function (done) {

      pdfLoadingTask.destroy().then(done);

    it(""gets page"", function (done) {

      const promise = pdfDocument.getPage(1);

      promise

        .then(function (data) {

          expect(data instanceof PDFPageProxy).toEqual(true);

          expect(data.pageNumber).toEqual(1);

          done();

        })

        .catch(done.fail);

    it(""gets non-existent page"", function (done) {
","beforeAll(async () => {

  const data = await pdfLoadingTask.promise;

  pdfDocument = data;

});

afterAll(async () => {

  await pdfLoadingTask.destroy();

});

it(""gets page"", async () => {

  const promise = pdfDocument.getPage(1);

  const data = await promise;

  expect(data instanceof PDFPageProxy).toEqual(true);

  expect(data.pageNumber).toEqual(1);

});

it(""gets non-existent page"", async () => {

  try {

    await pdfDocument.getPage(999);

  } catch (error) {

    expect(error instanceof Error).toEqual(true);

    expect(error.message).toContain(""Page number out of bounds"");

  }

});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([outOfRangePromise, nonIntegerPromise, nonNumberPromise])

        .then(function () {

          done();

        })

        .catch(done.fail);

    it(""gets page, from /Pages tree with circular reference"", function (done) {
","async function getPageWithCircularReference() {
    try {
      const outOfRangePromise = Promise.resolve('out of range');
      const nonIntegerPromise = Promise.resolve(0);
      const nonNumberPromise = Promise.resolve(0);
      await Promise.all([outOfRangePromise, nonIntegerPromise, nonNumberPromise]);
      done();
    } catch (err) {
      done.fail(err);
    }
  }

  it(""gets page, from /Pages tree with circular reference"", async function () {
    await getPageWithCircularReference();
  });",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([page1, page2]).then(function () {

        loadingTask.destroy().then(done);

      }, done.fail);

    it(""gets page index"", function (done) {

      // reference to second page

      const ref = { num: 17, gen: 0 };

      const promise = pdfDocument.getPageIndex(ref);

      promise

        .then(function (pageIndex) {

          expect(pageIndex).toEqual(1);

          done();

        })

        .catch(done.fail);

    it(""gets invalid page index"", function (done) {

      const promise = pdfDocument.getPageIndex(ref);

      promise

        .then(function () {

          done.fail(""shall fail for invalid page reference."");

        })

        .catch(function (reason) {

          expect(reason instanceof Error).toEqual(true);

          done();

        });

    it(""gets destinations, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestinations();

      promise

        .then(function (data) {

          expect(data).toEqual({

            chapter1: [{ gen: 0, num: 17 }, { name: ""XYZ"" }, 0, 841.89, null],

          });

          done();

        })

        .catch(done.fail);

    it(""gets a destination, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestination(""chapter1"");

      promise

        .then(function (data) {

          expect(data).toEqual([

            { gen: 0, num: 17 },

            { name: ""XYZ"" },

            0,

            841.89,

            null,

          ]);

          done();

        })

        .catch(done.fail);

    it(""gets a non-existent destination, from /Dests dictionary"", function (done) {

      const promise = pdfDocument.getDestination(

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets destinations, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestinations();

      promise

        .then(function (destinations) {

          expect(destinations).toEqual({

            ""Page.1"": [{ num: 1, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

            ""Page.2"": [{ num: 6, gen: 0 }, { name: ""XYZ"" }, 0, 375, null],

          });

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets a destination, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestination(""Page.1"");

      });

      promise

        .then(function (destination) {

          expect(destination).toEqual([

            { num: 1, gen: 0 },

            { name: ""XYZ"" },

            0,

            375,

            null,

          ]);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets a non-existent destination, from /Names (NameTree) dictionary"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getDestination(""non-existent-named-destination"");

      });

      promise

        .then(function (destination) {

          expect(destination).toEqual(null);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets non-string destination"", function (done) {
","async function getPageIndex() {
  try {
    const pageIndex = await pdfDocument.getPageIndex(ref);
    expect(pageIndex).toEqual(1);
    done();
  } catch (error) {
    done.fail(""shall fail for invalid page reference."");
  }
}

async function getDestinations() {
  try {
    const destinations = await pdfDocument.getDestinations();
    expect(destinations).toEqual({
      chapter1: [{ gen: 0, num: 17 }, { name: ""XYZ"" }, 0, 841.89, null],
    });
    done();
  } catch (error) {
    done.fail(""failed to get destinations"");
  }
}

async function getDestination() {
  try {
    const destination = await pdfDocument.getDestination(""chapter1"");
    expect(destination).toEqual([
      { gen: 0, num: 17 },
      { name: ""XYZ"" },
      0,
      841.89,
      null,
    ]);
    done();
  } catch (error) {
    done.fail(""failed to get destination"");
  }
}

async function getNonExistentDestination() {
  try {
    const destination = await pdfDocument.getDestination(
      ""non-existent-named-destination""
    );
    expect(destination).toEqual(null);
    done();
  } catch (error) {
    done.fail(""failed to get non-existent destination"");
  }
}

async function getNonStringDestination() {
  try {
    const destination = await pdfDocument.getDestination({});
    expect(destination).toEqual(null);
    done();
  } catch (error) {
    done.fail(""failed to get non-string destination"");
  }
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([numberPromise, booleanPromise, arrayPromise]).then(

        done,

        done.fail

      );

    it(""gets non-existent page labels"", function (done) {

      const promise = pdfDocument.getPageLabels();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets page labels"", function (done) {
","async () => {
      try {
        const data = await pdfDocument.getPageLabels();
        expect(data).toEqual(null);
        done();
      } catch (error) {
        done.fail();
      }
    };
    
    it(""gets non-existent page labels"", async () => {
      try {
        const data = await pdfDocument.getPageLabels();
        expect(data).toEqual(null);
        done();
      } catch (error) {
        done.fail();
      }
    });
    
    it(""gets page labels"", async () => {
      try {
        const data = await pdfDocument.getPageLabels();
        expect(data).toEqual(null);
        done();
      } catch (error) {
        done.fail();
      }
    });",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([promise0, promise1, promise2, promise3])

        .then(function (pageLabels) {

          expect(pageLabels[0]).toEqual([""i"", ""ii"", ""iii"", ""1""]);

          expect(pageLabels[1]).toEqual([""Front Page1""]);

          expect(pageLabels[2]).toEqual([""1"", ""2""]);

          expect(pageLabels[3]).toEqual([""X3""]);



          Promise.all([

            loadingTask0.destroy(),

            loadingTask1.destroy(),

            loadingTask2.destroy(),

            loadingTask3.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    it(""gets default page layout"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getPageLayout();

        })

        .then(function (mode) {

          expect(mode).toEqual("""");

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default page layout"", function (done) {

      pdfDocument

        .getPageLayout()

        .then(function (mode) {

          expect(mode).toEqual(""SinglePage"");

          done();

        })

        .catch(done.fail);

    it(""gets default page mode"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getPageMode();

        })

        .then(function (mode) {

          expect(mode).toEqual(""UseNone"");

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default page mode"", function (done) {

      pdfDocument

        .getPageMode()

        .then(function (mode) {

          expect(mode).toEqual(""UseOutlines"");

          done();

        })

        .catch(done.fail);

    it(""gets default viewer preferences"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getViewerPreferences();

        })

        .then(function (prefs) {

          expect(prefs).toEqual(null);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    });

    it(""gets non-default viewer preferences"", function (done) {

      pdfDocument

        .getViewerPreferences()

        .then(function (prefs) {

          expect(prefs).toEqual({

            Direction: ""L2R"",

          });

          done();

        })

        .catch(done.fail);

    it(""gets default open action"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getOpenAction();

        })

        .then(function (openAction) {

          expect(openAction).toEqual(null);



          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets non-default open action (with destination)"", function (done) {

      pdfDocument

        .getOpenAction()

        .then(function (openAction) {

          expect(openAction.dest).toEqual([

            { num: 15, gen: 0 },

            { name: ""FitH"" },

            null,

          ]);

          expect(openAction.action).toBeUndefined();

          done();

        })

        .catch(done.fail);

    it(""gets non-default open action (with Print action)"", function (done) {
","async function getPageLabels() {
  const pageLabels = await Promise.all([promise0, promise1, promise2, promise3]);
  expect(pageLabels[0]).toEqual([""i"", ""ii"", ""iii"", ""1""]);
  expect(pageLabels[1]).toEqual([""Front Page1""]);
  expect(pageLabels[2]).toEqual([""1"", ""2""]);
  expect(pageLabels[3]).toEqual([""X3""]);
}

async function getPageLayout() {
  const pdfDoc = await loadingTask.promise;
  const mode = await pdfDoc.getPageLayout();
  expect(mode).toEqual("""");
  loadingTask.destroy().then(done);
}

async function getPageMode() {
  const pdfDoc = await loadingTask.promise;
  const mode = await pdfDoc.getPageMode();
  expect(mode).toEqual(""UseNone"");
  loadingTask.destroy().then(done);
}

async function getViewerPreferences() {
  const pdfDoc = await loadingTask.promise;
  const prefs = await pdfDoc.getViewerPreferences();
  expect(prefs).toEqual({
    Direction: ""L2R"",
  });
  done();
}

async function getOpenAction() {
  const pdfDoc = await loadingTask.promise;
  const openAction = await pdfDoc.getOpenAction();
  expect(openAction.dest).toEqual([
    { num: 15, gen: 0 },
    { name: ""FitH"" },
    null,
  ]);
  expect(openAction.action).toBeUndefined();
  done();
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([promise1, promise2]).then(done, done.fail);

    it(""gets non-existent attachments"", function (done) {

      const promise = pdfDocument.getAttachments();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets attachments"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getAttachments();

      });

      promise

        .then(function (data) {

          const attachment = data[""foo.txt""];

          expect(attachment.filename).toEqual(""foo.txt"");

          expect(attachment.content).toEqual(

            new Uint8Array([98, 97, 114, 32, 98, 97, 122, 32, 10])

          );

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets javascript"", function (done) {

      const promise = pdfDocument.getJavaScript();

      promise

        .then(function (data) {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""gets javascript with printing instructions (JS action)"", function (done) {

      const promise = loadingTask.promise.then(function (pdfDoc) {

        return pdfDoc.getJavaScript();

      });

      promise

        .then(function (data) {

          expect(data).toEqual([

            ""this.print({bUI:true,bSilent:false,bShrinkToFit:true});"",

          ]);

          expect(data[0]).toMatch(AutoPrintRegExp);

          loadingTask.destroy().then(done);

        })

        .catch(done.fail);
","async function getJavaScript() {
  const pdfDocument = await loadingTask.promise;
  const promise = pdfDocument.getJavaScript();

  try {
    const data = await promise;
    expect(data).toEqual(null);
    done();
  } catch (error) {
    done.fail();
  }
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([promise0, promise1, promise2])

        .then(function (permissions) {

          expect(permissions[0].length).toEqual(totalPermissionCount - 1);

          expect(

            permissions[0].includes(PermissionFlag.MODIFY_CONTENTS)

          ).toBeFalsy();

          expect(permissions[1].length).toEqual(totalPermissionCount - 2);

          expect(permissions[1].includes(PermissionFlag.PRINT)).toBeFalsy();

          expect(

            permissions[1].includes(PermissionFlag.PRINT_HIGH_QUALITY)

          ).toBeFalsy();

          expect(permissions[2].length).toEqual(totalPermissionCount - 1);

          expect(permissions[2].includes(PermissionFlag.COPY)).toBeFalsy();

          Promise.all([

            loadingTask0.destroy(),

            loadingTask1.destroy(),

            loadingTask2.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    });



    it(""gets metadata"", function (done) {

      const promise = pdfDocument.getMetadata();

      promise

        .then(function ({

          info,

          metadata,

          contentDispositionFilename,

          contentLength,

        }) {

          expect(info.Title).toEqual(""Basic API Test"");

          // Custom, non-standard, information dictionary entries.

          expect(info.Custom).toEqual(undefined);

          // The following are PDF.js specific, non-standard, properties.

          expect(info.PDFFormatVersion).toEqual(""1.7"");

          expect(info.IsLinearized).toEqual(false);

          expect(info.IsAcroFormPresent).toEqual(false);

          expect(info.IsXFAPresent).toEqual(false);

          expect(info.IsCollectionPresent).toEqual(false);

          expect(info.IsSignaturesPresent).toEqual(false);



          expect(metadata instanceof Metadata).toEqual(true);

          expect(metadata.get(""dc:title"")).toEqual(""Basic API Test"");



          expect(contentDispositionFilename).toEqual(null);

          expect(contentLength).toEqual(basicApiFileLength);

          done();

        })

        .catch(done.fail);

    it(""gets metadata, with custom info dict entries"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getMetadata();

        })

        .then(function ({

          info,

          metadata,

          contentDispositionFilename,

          contentLength,

        }) {

          expect(info.Creator).toEqual(""TeX"");

          expect(info.Producer).toEqual(""pdfeTeX-1.21a"");

          expect(info.CreationDate).toEqual(""D:20090401163925-07'00'"");

          // Custom, non-standard, information dictionary entries.

          const custom = info.Custom;

          expect(typeof custom === ""object"" && custom !== null).toEqual(true);



          expect(custom[""PTEX.Fullbanner""]).toEqual(

            ""This is pdfeTeX, "" +

              ""Version 3.141592-1.21a-2.2 (Web2C 7.5.4) kpathsea version 3.5.6""

          );

          // The following are PDF.js specific, non-standard, properties.

          expect(info.PDFFormatVersion).toEqual(""1.4"");

          expect(info.IsLinearized).toEqual(false);

          expect(info.IsAcroFormPresent).toEqual(false);

          expect(info.IsXFAPresent).toEqual(false);

          expect(info.IsCollectionPresent).toEqual(false);

          expect(info.IsSignaturesPresent).toEqual(false);



          expect(metadata).toEqual(null);

          expect(contentDispositionFilename).toEqual(null);

          expect(contentLength).toEqual(1016315);



          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets metadata, with missing PDF header (bug 1606566)"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getMetadata();

        })

        .then(function ({

          info,

          metadata,

          contentDispositionFilename,

          contentLength,

        }) {

          // The following are PDF.js specific, non-standard, properties.

          expect(info.PDFFormatVersion).toEqual(null);

          expect(info.IsLinearized).toEqual(false);

          expect(info.IsAcroFormPresent).toEqual(false);

          expect(info.IsXFAPresent).toEqual(false);

          expect(info.IsCollectionPresent).toEqual(false);

          expect(info.IsSignaturesPresent).toEqual(false);



          expect(metadata).toEqual(null);

          expect(contentDispositionFilename).toEqual(null);

          expect(contentLength).toEqual(624);



          loadingTask.destroy().then(done);

        })

        .catch(done.fail);

    it(""gets markInfo"", function (done) {

      loadingTask.promise

        .then(function (pdfDoc) {

          return pdfDoc.getMarkInfo();

        })

        .then(function (info) {

          expect(info.Marked).toEqual(true);

          expect(info.UserProperties).toEqual(false);

          expect(info.Suspects).toEqual(false);

          done();

        })

        .catch(done.fail);

    it(""gets data"", function (done) {

      const promise = pdfDocument.getData();

      promise

        .then(function (data) {

          expect(data instanceof Uint8Array).toEqual(true);

          expect(data.length).toEqual(basicApiFileLength);

          done();

        })

        .catch(done.fail);

    it(""gets download info"", function (done) {

      const promise = pdfDocument.getDownloadInfo();

      promise

        .then(function (data) {

          expect(data).toEqual({ length: basicApiFileLength });

          done();

        })

        .catch(done.fail);

    });

    it(""gets document stats"", function (done) {

      const promise = pdfDocument.getStats();

      promise

        .then(function (stats) {

          expect(stats).toEqual({ streamTypes: {}, fontTypes: {} });

          done();

        })

        .catch(done.fail);
","// migrated code
async function getMetadata() {
  const promises = [];
  promises.push(pdfDocument.getMetadata());
  promises.push(pdfDocument.getMarkInfo());
  promises.push(pdfDocument.getData());
  promises.push(pdfDocument.getDownloadInfo());
  promises.push(pdfDocument.getStats());

  try {
    const [metadata, markInfo, data, downloadInfo, stats] = await Promise.all(promises);
    return metadata;
  } catch (error) {
    done.fail(error);
  } finally {
    loadingTask.destroy().then(done);
  }
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"    it(""checks that fingerprints are unique"", function (done) {

      Promise.all([loadingTask1.promise, loadingTask2.promise])

        .then(function (data) {

          const fingerprint1 = data[0].fingerprint;

          const fingerprint2 = data[1].fingerprint;

          expect(fingerprint1).not.toEqual(fingerprint2);

          expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");

          expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");

          Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]).then(

            done

          );

        })

        .catch(done.fail);
","it(""checks that fingerprints are unique"", async () => {

  const [data1, data2] = await Promise.all([loadingTask1.promise, loadingTask2.promise]);

  const fingerprint1 = data1.fingerprint;

  const fingerprint2 = data2.fingerprint;

  expect(fingerprint1).not.toEqual(fingerprint2);

  expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");

  expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");

});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      afterEach(function (done) {

          loadingTask.destroy().then(done);

        } else {

          done();

      it(""server disallows cors"", function (done) {

        testCannotLoad(""basicapi.pdf"").then(done);

      it(""server allows cors without credentials, default withCredentials"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withoutCredentials"").then(done);

      it(""server allows cors without credentials, and withCredentials=false"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withoutCredentials"", {

        }).then(done);

      it(""server allows cors without credentials, but withCredentials=true"", function (done) {

        testCannotLoad(""basicapi.pdf?cors=withoutCredentials"", {

        }).then(done);

      it(""server allows cors with credentials, and withCredentials=true"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        }).then(done);

      it(""server allows cors with credentials, and withCredentials=false"", function (done) {

        testCanLoad(""basicapi.pdf?cors=withCredentials"", {

        }).then(done);

    beforeAll(function (done) {

      pdfLoadingTask.promise

        .then(function (doc) {

          pdfDocument = doc;

          pdfDocument.getPage(1).then(function (data) {

            page = data;

            done();

          });

        })

        .catch(done.fail);

    afterAll(function (done) {

      pdfLoadingTask.destroy().then(done);
","beforeEach(async function () {
  this.timeout(0);
  const loadingTask = PDFJS.getDocument(basicApiUrl + ""basicapi.pdf"");
  try {
    const doc = await loadingTask.promise;
    this.pdfDocument = doc;
    const page = await doc.getPage(1);
    this.page = page;
  } catch (error) {
    done.fail(error);
  } finally {
    await loadingTask.destroy();
  }
});

afterEach(async function () {
  this.timeout(0);
  try {
    await this.pdfDocument.destroy();
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
});

it(""server disallows cors"", async function () {
  const testCannotLoad = () => this.pdfDocument.getPage(1).then(() => undefined).catch((reason) => reason);
  const result = await testCannotLoad();
  expect(result instanceof Error).toBeTruthy();
});

it(""server allows cors without credentials, default withCredentials"", async function () {
  const testCanLoad = (url) => this.pdfDocument.getPage(1).then(() => undefined).catch((reason) => reason);
  const result = await testCanLoad(basicApiUrl + ""basicapi.pdf?cors=withoutCredentials"");
  expect(result instanceof Error).toBeFalsy();
});

it(""server allows cors without credentials, and withCredentials=false"", async function () {
  const testCanLoad = (url, options) => this.pdfDocument.getPage(1).then(() => undefined).catch((reason) => reason);
  const result = await testCanLoad(basicApiUrl + ""basicapi.pdf?cors=withoutCredentials"", { withCredentials: false });
  expect(result instanceof Error).toBeFalsy();
});

it(""server allows cors without credentials, but withCredentials=true"", async function () {
  const testCannotLoad = (url, options) => this.pdfDocument.getPage(1).then(() => undefined).catch((reason) => reason);
  const result = await testCannotLoad(basicApiUrl + ""basicapi.pdf?cors=withoutCredentials"", { withCredentials: true });
  expect(result instanceof Error).toBeTruthy();
});

it(""server allows cors with credentials, and withCredentials=true"", async function () {
  const testCanLoad = (url, options) => this.pdfDocument.getPage(1).then(() => undefined).catch((reason) => reason);
  const result = await testCanLoad(basicApiUrl + ""basicapi.pdf?cors=withCredentials"", { withCredentials: true });
  expect(result instanceof Error).toBeFalsy();
});

it(""server allows cors with credentials, and withCredentials=false"", async function () {
  const testCanLoad = (url, options) => this.pdfDocument.getPage(1).then(() => undefined).catch((reason) => reason);
  const result = await testCanLoad(basicApiUrl + ""basicapi.pdf?cors=withCredentials"", { withCredentials: false });
  expect(result instanceof Error).toBeFalsy();
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([defaultPromise, displayPromise, printPromise])

        .then(function () {

          done();

        })

        .catch(done.fail);

    it(""gets annotations containing relative URLs (bug 766086)"", function (done) {
","async function test() {
  try {
    await Promise.all([defaultPromise, displayPromise, printPromise]);
    done();
  } catch (error) {
    done.fail(error);
  }
}

it(""gets annotations containing relative URLs (bug 766086)"", function () {
  return test();
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([defaultPromise, docBaseUrlPromise, invalidDocBaseUrlPromise])

        .then(function (data) {

          const defaultAnnotations = data[0];

          const docBaseUrlAnnotations = data[1];

          const invalidDocBaseUrlAnnotations = data[2];

          expect(defaultAnnotations[0].url).toBeUndefined();

          expect(defaultAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          expect(docBaseUrlAnnotations[0].url).toEqual(

            ""http://www.example.com/0021/002156/215675E.pdf#15""

          );

          expect(docBaseUrlAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          expect(invalidDocBaseUrlAnnotations[0].url).toBeUndefined();

          expect(invalidDocBaseUrlAnnotations[0].unsafeUrl).toEqual(

            ""../../0021/002156/215675E.pdf#15""

          );

          Promise.all([

            defaultLoadingTask.destroy(),

            docBaseUrlLoadingTask.destroy(),

            invalidDocBaseUrlLoadingTask.destroy(),

          ]).then(done);

        })

        .catch(done.fail);

    it(""gets text content"", function (done) {

      const promises = [defaultPromise, parametersPromise];

      Promise.all(promises)

        .then(function (data) {

          expect(!!data[0].items).toEqual(true);

          expect(data[0].items.length).toEqual(7);

          expect(!!data[0].styles).toEqual(true);

          // A simple check that ensures the two `textContent` object match.

          expect(JSON.stringify(data[0])).toEqual(JSON.stringify(data[1]));

          done();

        })

        .catch(done.fail);

    it(""gets text content, with correct properties (issue 8276)"", function (done) {

      loadingTask.promise

        .then(pdfDoc => {

          pdfDoc.getPage(1).then(pdfPage => {

            pdfPage.getTextContent().then(({ items, styles }) => {

              expect(items.length).toEqual(1);

              expect(Object.keys(styles)).toEqual([""Times""]);



              expect(items[0]).toEqual({

                dir: ""ltr"",

                fontName: ""Times"",

                height: 18,

                str: ""Issue 8276"",

                transform: [18, 0, 0, 18, 441.81, 708.4499999999999],

                width: 77.49,

              });

              expect(styles.Times).toEqual({

                fontFamily: ""serif"",

                ascent: NaN,

                descent: NaN,

                vertical: false,

              });



              loadingTask.destroy().then(done);

            });

          });

        })

        .catch(done.fail);
","const defaultLoadingTask = pdfjsLib.getDocument({ url: ""../../0021/002156/215675E.pdf"" });
const docBaseUrlLoadingTask = pdfjsLib.getDocument({ url: ""http://www.example.com/0021/002156/215675E.pdf"", docBaseUrl: ""http://www.example.com/"" });
const invalidDocBaseUrlLoadingTask = pdfjsLib.getDocument({ url: ""../../0021/002156/215675E.pdf"", docBaseUrl: ""http://www.example.com/"" });

try {
  const data = await Promise.all([defaultLoadingTask, docBaseUrlLoadingTask, invalidDocBaseUrlLoadingTask]);

  const defaultAnnotations = data[0];
  const docBaseUrlAnnotations = data[1];
  const invalidDocBaseUrlAnnotations = data[2];

  expect(defaultAnnotations[0].url).toBeUndefined();
  expect(defaultAnnotations[0].unsafeUrl).toEqual(""../../0021/002156/215675E.pdf#15"");
  expect(docBaseUrlAnnotations[0].url).toEqual(""http://www.example.com/0021/002156/215675E.pdf#15"");
  expect(docBaseUrlAnnotations[0].unsafeUrl).toEqual(""../../0021/002156/215675E.pdf#15"");
  expect(invalidDocBaseUrlAnnotations[0].url).toBeUndefined();
  expect(invalidDocBaseUrlAnnotations[0].unsafeUrl).toEqual(""../../0021/002156/215675E.pdf#15"");

  await Promise.all([
    defaultLoadingTask.destroy(),
    docBaseUrlLoadingTask.destroy(),
    invalidDocBaseUrlLoadingTask.destroy()
  ]).then(done);
} catch (error) {
  done.fail(error);
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"    it(""gets operator list"", function (done) {

      const promise = page.getOperatorList();

      promise

        .then(function (oplist) {

          expect(!!oplist.fnArray).toEqual(true);

          expect(!!oplist.argsArray).toEqual(true);

          expect(oplist.lastChunk).toEqual(true);

          done();

        })

        .catch(done.fail);

    it(""gets operatorList with JPEG image (issue 4888)"", function (done) {

      loadingTask.promise

        .then(pdfDoc => {

          pdfDoc.getPage(1).then(pdfPage => {

            pdfPage.getOperatorList().then(opList => {

              const imgIndex = opList.fnArray.indexOf(OPS.paintImageXObject);

              const imgArgs = opList.argsArray[imgIndex];

              const { data } = pdfPage.objs.get(imgArgs[0]);

              expect(data instanceof Uint8ClampedArray).toEqual(true);

              expect(data.length).toEqual(90000);

              loadingTask.destroy().then(done);

            });

          });

        })

        .catch(done.fail);

      function (done) {
","it(""gets operator list"", async () => {
  const oplist = await page.getOperatorList();
  expect(!!oplist.fnArray).toEqual(true);
  expect(!!oplist.argsArray).toEqual(true);
  expect(oplist.lastChunk).toEqual(true);
});
it(""gets operatorList with JPEG image (issue 4888)"", async () => {
  const pdfDoc = await loadingTask.promise;
  const pdfPage = await pdfDoc.getPage(1);
  const opList = await pdfPage.getOperatorList();
  const imgIndex = opList.fnArray.indexOf(OPS.paintImageXObject);
  const imgArgs = opList.argsArray[imgIndex];
  const { data } = await pdfPage.objs.get(imgArgs[0]);
  expect(data instanceof Uint8ClampedArray).toEqual(true);
  expect(data.length).toEqual(90000);
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      renderTask.promise

        .then(function () {

          done.fail(""shall cancel rendering"");

        })

        .catch(function (error) {

          expect(error instanceof RenderingCancelledException).toEqual(true);

          expect(error.message).toEqual(""Rendering cancelled, page 1"");

          expect(error.type).toEqual(""canvas"");

          CanvasFactory.destroy(canvasAndCtx);

          done();

        });

    it(""re-render page, using the same canvas, after cancelling rendering"", function (done) {
","async () => {
  try {
    await renderTask.promise;
  } catch (error) {
    expect(error instanceof RenderingCancelledException).toEqual(true);
    expect(error.message).toEqual(""Rendering cancelled, page 1"");
    expect(error.type).toEqual(""canvas"");
    CanvasFactory.destroy(canvasAndCtx);
    done();
  }
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      renderTask.promise

        .then(

          () => {

            throw new Error(""shall cancel rendering"");

          },

          reason => {

            expect(reason instanceof RenderingCancelledException).toEqual(true);

          }

        )

        .then(() => {

          const reRenderTask = page.render({

            canvasContext: canvasAndCtx.context,

            canvasFactory: CanvasFactory,

            viewport,

          });

          return reRenderTask.promise;

        })

        .then(() => {

          CanvasFactory.destroy(canvasAndCtx);

          done();

        }, done.fail);

    it(""multiple render() on the same canvas"", function (done) {
","it(""multiple render() on the same canvas"", async () => {
  const renderTask = page.render({
    canvasContext: canvasAndCtx.context,
    canvasFactory: CanvasFactory,
    viewport,
  });

  try {
    await renderTask.promise;
  } catch (reason) {
    expect(reason instanceof RenderingCancelledException).toEqual(true);
  }

  const reRenderTask = page.render({
    canvasContext: canvasAndCtx.context,
    canvasFactory: CanvasFactory,
    viewport,
  });

  try {
    await reRenderTask.promise;
  } catch (reason) {
    expect(reason instanceof RenderingCancelledException).toEqual(true);
  } finally {
    CanvasFactory.destroy(canvasAndCtx);
    done();
  }
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      Promise.all([

            done.fail(""shall fail rendering"");

            /* it fails because we already using this canvas */

      ]).then(done);
","async function render() {
  try {
    const result = await Promise.all([
      done.fail(""shall fail rendering"");
    ]);
    return result;
  } catch (error) {
    console.log(error);
  }
}",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"    afterEach(function (done) {

      Promise.all(destroyPromises).then(done);

    it(""should correctly render PDFs in parallel"", function (done) {
","afterEach(async function () {
  await Promise.all(destroyPromises);
});

it(""should correctly render PDFs in parallel"", async function () {
  // Your test code here
});",2021-04-16 21:48:42+02:00,c2f3a71eca40fe5e2ebe39431aba20c3830f7946
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.id).toEqual(""10R"");

        done();

      }, done.fail);

      function (done) {
","async function test() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.id).toEqual(""10R"");
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        Promise.all([annotation1, annotation2]).then(done, done.fail);

    it(""should handle missing /Subtype"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toBeUndefined();

        done();

      }, done.fail);
","async function test() {
  try {
    const annotation1 = await AnnotationFactory.create();
    const annotation2 = await AnnotationFactory.create();
    const data = await Promise.all([annotation1, annotation2]);
    expect(data.annotationType).toBeUndefined();
  } catch (error) {
    done(error);
  }
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"    it(""should not parse IRT/RT when not defined"", function (done) {



      AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock).then(

        ({ data }) => {

          expect(data.inReplyTo).toBeUndefined();

          expect(data.replyType).toBeUndefined();

          done();

        },

        done.fail

    it(""should parse IRT and set default RT when not defined."", function (done) {
","it(""should not parse IRT/RT when not defined"", async () => {
  const data = await AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock);

  expect(data.inReplyTo).toBeUndefined();

  expect(data.replyType).toBeUndefined();

  done();
});

it(""should parse IRT and set default RT when not defined."", async () => {
  const data = await AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock);

  expect(data.inReplyTo).toBeUndefined();

  expect(data.replyType).toBeUndefined();

  done();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        done();

      }, done.fail);

    it(""should parse IRT/RT for a group type"", function (done) {
","AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.inReplyTo).toEqual(annotationRef.toString());
      expect(data.replyType).toEqual(""R"");
      done();
    }, done.fail);
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""Group"");

        expect(data.title).toEqual(""ParentTitle"");

        expect(data.contents).toEqual(""ParentText"");

        expect(data.creationDate).toEqual(""D:20180423"");

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

        expect(data.hasPopup).toEqual(true);

        done();

      }, done.fail);

    it(""should parse IRT/RT for a reply type"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.inReplyTo).toEqual(annotationRef.toString());
    expect(data.replyType).toEqual(""Group"");
    expect(data.title).toEqual(""ParentTitle"");
    expect(data.contents).toEqual(""ParentText"");
    expect(data.creationDate).toEqual(""D:20180423"");
    expect(data.modificationDate).toEqual(""D:20190423"");
    expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
    expect(data.hasPopup).toEqual(true);
    done();
  }, done.fail);
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        expect(data.title).toEqual(""ReplyTitle"");

        expect(data.contents).toEqual(""ReplyText"");

        expect(data.creationDate).toEqual(""D:20180523"");

        expect(data.modificationDate).toEqual(""D:20190523"");

        expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));

        expect(data.hasPopup).toEqual(false);

        done();

      }, done.fail);

    it(""should not parse state model and state when not defined"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.inReplyTo).toEqual(annotationRef.toString());
    expect(data.replyType).toEqual(""R"");
    expect(data.title).toEqual(""ReplyTitle"");
    expect(data.contents).toEqual(""ReplyText"");
    expect(data.creationDate).toEqual(""D:20180523"");
    expect(data.modificationDate).toEqual(""D:20190523"");
    expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));
    expect(data.hasPopup).toEqual(false);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.stateModel).toBeNull();

        expect(data.state).toBeNull();

        done();

      }, done.fail);

    it(""should correctly parse state model and state when defined"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.stateModel).toBeNull();
    expect(data.state).toBeNull();
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.stateModel).toEqual(""Review"");

        expect(data.state).toEqual(""Rejected"");

        done();

      }, done.fail);

    it(""should correctly parse a URI action"", function (done) {
","AnnotationFactory.create()
  .then((result) => {
    expect(result.data.stateModel).toEqual(""Review"");
    expect(result.data.state).toEqual(""Rejected"");
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");

        expect(data.unsafeUrl).toEqual(

          ""http://www.ctan.org/tex-archive/info/lshort""

        );

        expect(data.dest).toBeUndefined();

        done();

      }, done.fail);

      function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");
    expect(data.unsafeUrl).toEqual(""http://www.ctan.org/tex-archive/info/lshort"");
    expect(data.dest).toBeUndefined();
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(""http://www.hmrc.gov.uk/"");

          expect(data.unsafeUrl).toEqual(""http://www.hmrc.gov.uk"");

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

      function (done) {
","async function createAnnotation() {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.LINK);
  expect(data.url).toEqual(""http://www.hmrc.gov.uk/"");
  expect(data.unsafeUrl).toEqual(""http://www.hmrc.gov.uk"");
  expect(data.dest).toBeUndefined();
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            new URL(

              stringToUTF8String(

                ""http://www.example.com/\xC3\xBC\xC3\xB6\xC3\xA4""

              )

            ).href

          );

          expect(data.unsafeUrl).toEqual(

          );

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

    it(""should correctly parse a GoTo action"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toEqual(new URL(""http://www.example.com/ÜÖÄ"").href);
    expect(data.unsafeUrl).toEqual(null);
    expect(data.dest).toBeUndefined();
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""page.157"");

        done();

      }, done.fail);

      function (done) {
","async function test() {
    try {
      const annotation = await AnnotationFactory.create();
      expect(annotation.data.annotationType).toEqual(AnnotationType.LINK);
      expect(annotation.data.url).toBeUndefined();
      expect(annotation.data.unsafeUrl).toBeUndefined();
      expect(annotation.data.dest).toEqual(""page.157"");
    } catch (error) {
      done.fail(error);
    }
  }",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toBeUndefined();

          expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

          expect(data.dest).toBeUndefined();

          expect(data.newWindow).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toBeUndefined();
    expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");
    expect(data.dest).toBeUndefined();
    expect(data.newWindow).toEqual(true);
    done();
  })
  .catch((error) => {
    done.fail(error);
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            ""http://www.example.com/0013/001346/134685E.pdf#4.3""

          );

          expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");

          expect(data.dest).toBeUndefined();

          done();

        }, done.fail);

    it(""should correctly parse a GoToR action, with named destination"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toEqual(""http://www.example.com/0013/001346/134685E.pdf#4.3"");
    expect(data.unsafeUrl).toEqual(""../../0013/001346/134685E.pdf#4.3"");
    expect(data.dest).toBeUndefined();
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(""http://www.example.com/test.pdf#15"");

        expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#15"");

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toBeFalsy();

        done();

      }, done.fail);

    it(""should correctly parse a GoToR action, with explicit destination array"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toEqual(""http://www.example.com/test.pdf#15"");
    expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#15"");
    expect(data.dest).toBeUndefined();
    expect(data.newWindow).toBeFalsy();
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toEqual(

          new URL(

            ""http://www.example.com/test.pdf#"" +

              '[14,{""name"":""XYZ""},null,298.043,null]'

          ).href

        );

        expect(data.unsafeUrl).toEqual(

        );

        expect(data.dest).toBeUndefined();

        expect(data.newWindow).toBeFalsy();

        done();

      }, done.fail);

      function (done) {
","AnnotationFactory.create()
  .then((data) => {
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    const url = new URL(""http://www.example.com/test.pdf#[14,{\""name\"":\""XYZ\""},null,298.043,null]"");
    expect(data.url).toEqual(url.href);
    expect(data.unsafeUrl).toEqual(""http://www.example.com/test.pdf#[14,{\""name\"":\""XYZ\""},null,298.043,null]"");
    expect(data.dest).toBeUndefined();
    expect(data.newWindow).toBeFalsy();
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toEqual(

            new URL(""http://www.example.com/test/pdfs/Part II/Part II.pdf"").href

          );

          expect(data.unsafeUrl).toEqual(""Part II/Part II.pdf"");

          expect(data.dest).toBeUndefined();

          expect(data.newWindow).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.annotationType).toEqual(AnnotationType.LINK);
      expect(data.url).toEqual(new URL(""http://www.example.com/test/pdfs/Part II/Part II.pdf"").href);
      expect(data.unsafeUrl).toEqual(""Part II/Part II.pdf"");
      expect(data.dest).toBeUndefined();
      expect(data.newWindow).toEqual(true);
      done();
    })
    .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        Promise.all([annotation1, annotation2, annotation3]).then(

          done,

          done.fail

        );

    it(""should correctly parse a Named action"", function (done) {
","async function () {
  try {
    const annotations = await Promise.all([annotation1, annotation2, annotation3]);
    // do something with the annotations
  } catch (error) {
    console.error(error);
  }
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.action).toEqual(""GoToPage"");

        done();

      }, done.fail);

    it(""should correctly parse a simple Dest"", function (done) {
","AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.annotationType).toEqual(AnnotationType.LINK);
      expect(data.url).toBeUndefined();
      expect(data.unsafeUrl).toBeUndefined();
      expect(data.action).toEqual(""GoToPage"");
    })
    .catch((error) => {
      done.fail(error);
    });

  it(""should correctly parse a simple Dest"", async () => {
    // ...
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual(""LI0"");

        done();

      }, done.fail);

    it(""should correctly parse a simple Dest, with explicit destination array"", function (done) {
","AnnotationFactory.create(

).then(async ({ data }) => {

  expect(data.annotationType).toEqual(AnnotationType.LINK);

  expect(data.url).toBeUndefined();

  expect(data.unsafeUrl).toBeUndefined();

  expect(data.dest).toEqual(""LI0"");

  done();

}, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.url).toBeUndefined();

        expect(data.unsafeUrl).toBeUndefined();

        expect(data.dest).toEqual([

          { num: 17, gen: 0 },

          { name: ""XYZ"" },

          0,

          841.89,

          null,

        ]);

        done();

      }, done.fail);

      function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.LINK);
    expect(data.url).toBeUndefined();
    expect(data.unsafeUrl).toBeUndefined();
    expect(data.dest).toEqual([
      { num: 17, gen: 0 },
      { name: ""XYZ"" },
      0,
      841.89,
      null,
    ]);
    done();
  })
  .catch((error) => {
    done.fail(error);
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.LINK);

          expect(data.url).toBeUndefined();

          expect(data.unsafeUrl).toBeUndefined();

          expect(data.dest).toEqual(""page.157"");

          done();

        }, done.fail);

    it(""should not set quadpoints if not defined"", function (done) {
","AnnotationFactory.create({
    annotationType: AnnotationType.LINK,
    dest: ""page.157""
  });

  it(""should not set quadpoints if not defined"", function () {
    const annotation = new Annotation();
    annotation.quadPoints = [];
    expect(annotation.hasQuadPoints()).toBe(false);
  });
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.quadPoints).toBeUndefined();

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","AnnotationFactory.create().then(({ data }) => {
  expect(data.annotationType).toEqual(AnnotationType.LINK);
  expect(data.quadPoints).toBeUndefined();
  done();
}, done.fail);

it(""should set quadpoints if defined"", async () => {
  // ...
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINK);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);
","const data = await AnnotationFactory.create();
expect(data.annotationType).toEqual(AnnotationType.LINK);
expect(data.quadPoints).toEqual([
  { x: 10, y: 20 },
  { x: 20, y: 20 },
  { x: 10, y: 10 },
  { x: 20, y: 10 },
]);
done();",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"    it(""should handle unknown field names"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual("""");

        done();

      }, done.fail);

    it(""should construct the field name when there are no ancestors"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo"");

        done();

      }, done.fail);

    it(""should construct the field name when there are ancestors"", function (done) {
","it(""should handle unknown field names"", async () => {
  const { data } = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.fieldName).toEqual("""");
});

it(""should construct the field name when there are no ancestors"", async () => {
  const { data } = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.fieldName).toEqual(""foo"");
});

it(""should construct the field name when there are ancestors"", async () => {
  const { data } = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.fieldName).toEqual(""foo"");
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldName).toEqual(""foo.bar.baz"");

        done();

      }, done.fail);

      function (done) {
","async function createAnnotation() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.fieldName).toEqual(""foo.bar.baz"");
  } catch (error) {
    done.fail(error);
  }
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.annotationType).toEqual(AnnotationType.WIDGET);

          expect(data.fieldName).toEqual(""foo.bar"");

          done();

        }, done.fail);
","AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.annotationType).toEqual(AnnotationType.WIDGET);
      expect(data.fieldName).toEqual(""foo.bar"");
      done();
    }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"    it(""should handle unknown text alignment, maximum length and flags"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(null);

        expect(data.maxLen).toEqual(null);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(false);

        expect(data.comb).toEqual(false);

        expect(data.defaultFieldValue).toEqual(""foo"");

        done();

      }, done.fail);

    });



    it(""should not set invalid text alignment, maximum length and flags"", function (done) {
","it(""should handle unknown text alignment, maximum length and flags"", async () => {

    const data = await AnnotationFactory.create();

    expect(data.annotationType).toEqual(AnnotationType.WIDGET);

    expect(data.textAlignment).toEqual(null);

    expect(data.maxLen).toEqual(null);

    expect(data.readOnly).toEqual(false);

    expect(data.hidden).toEqual(false);

    expect(data.multiLine).toEqual(false);

    expect(data.comb).toEqual(false);

    expect(data.defaultFieldValue).toEqual(""foo"");

  });

  it(""should not set invalid text alignment, maximum length and flags"", async () => {

    const data = await AnnotationFactory.create();

    expect(data.textAlignment).not.toBeDefined();

    expect(data.maxLen).not.toBeDefined();

    expect(data.readOnly).not.toBeDefined();

    expect(data.hidden).not.toBeDefined();

    expect(data.multiLine).not.toBeDefined();

    expect(data.comb).not.toBeDefined();

  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(null);

        expect(data.maxLen).toEqual(null);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(false);

        expect(data.comb).toEqual(false);

        done();

      }, done.fail);

    it(""should set valid text alignment, maximum length and flags"", function (done) {
","it('should set valid text alignment, maximum length, and flags', async () => {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.textAlignment).toEqual(null);
  expect(data.maxLen).toEqual(null);
  expect(data.readOnly).toEqual(false);
  expect(data.hidden).toEqual(false);
  expect(data.multiLine).toEqual(false);
  expect(data.comb).toEqual(false);
  done();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.textAlignment).toEqual(1);

        expect(data.maxLen).toEqual(20);

        expect(data.readOnly).toEqual(true);

        expect(data.hidden).toEqual(false);

        expect(data.multiLine).toEqual(true);

        done();

      }, done.fail);

    it(""should reject comb fields without a maximum length"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.comb).toEqual(false);

        done();

      }, done.fail);

    it(""should accept comb fields with a maximum length"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.comb).toEqual(true);

        done();

      }, done.fail);

    it(""should only accept comb fields when the flags are valid"", function (done) {
","it('should create a widget annotation', async () => {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.textAlignment).toEqual(1);
  expect(data.maxLen).toEqual(20);
  expect(data.readOnly).toEqual(true);
  expect(data.hidden).toEqual(false);
  expect(data.multiLine).toEqual(true);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      promise.then(done, done.fail);

    it(""should render regular text for printing"", function (done) {
","async () => {
  try {
    const result = await someAsyncFunction();
    done();
  } catch (error) {
    done(error);
  }
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""test\\print"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (test\\\\print) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render regular text in Japanese for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""test\\print"" });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then(appearance => {
    expect(appearance).toEqual(""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (test\\\\print) Tj ET Q EMC"");
    done();
  })
  .catch(error => {
    done.fail(error);
  });
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm"" +

              ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

          );

          done();

        }, done.fail);

    });



    it(""should render regular text for printing using normal appearance"", function (done) {
","it('should render regular text for printing using normal appearance', async () => {
  const annotation = await AnnotationFactory.create();

  const partialEvaluator = new PartialEvaluator(new Page(), new Xref(), null);
  const task = new RenderingCancelledException();
  const annotationStorage = new Map();
  annotationStorage.set(annotation.data.id, { value: 'こんにちは世界の' });

  const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);

  const utf16String = '\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e';
  expect(appearance).toEqual(`/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm ${utf16String} Tj ET Q EMC`);

  done();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should render auto-sized text for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    return annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
  })
  .then(opList => {
    expect(opList.argsArray.length).toEqual(3);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""test (print)"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (test \\(print\\)) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render auto-sized text in Japanese for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""こんにちは (印刷)"" });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then(appearance => {
    expect(appearance).toEqual(""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm 2.00 2.00 Td (こんにちは \\(印刷\\)) Tj ET Q EMC"");
    done();
  })
  .catch(done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 8 Tf 0 g 1 0 0 1 0 0 Tm"" +

              ` 2.00 2.00 Td (${utf16String}) Tj ET Q EMC`

          );

          done();

        }, done.fail);

    });



    it(""should not render a password for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, {
      value: ""こんにちは世界の"",
    });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then(appearance => {
    const utf16String = ""\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";
    expect(appearance).toEqual(
      ""/Tx BMC q BT /Goth 8 Tf 0 g 1 0 0 1 0 0 Tm"" +
        `2.00 2.00 Td (${utf16String}) Tj ET Q EMC`
    );
    done();
  })
  .catch(done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""mypassword"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should render multiline text for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""mypassword"" });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then(appearance => {
    expect(appearance).toEqual(null);
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value:

              ""a aa aaa aaaa aaaaa aaaaaa "" +

              ""pneumonoultramicroscopicsilicovolcanoconiosis"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm "" +

              ""2.00 -5.00 Td (a aa aaa ) Tj\n"" +

              ""0.00 -5.00 Td (aaaa aaaaa ) Tj\n"" +

              ""0.00 -5.00 Td (aaaaaa ) Tj\n"" +

              ""0.00 -5.00 Td (pneumonoultr) Tj\n"" +

              ""0.00 -5.00 Td (amicroscopi) Tj\n"" +

              ""0.00 -5.00 Td (csilicovolca) Tj\n"" +

              ""0.00 -5.00 Td (noconiosis) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render multiline text in Japanese for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, {
      value: ""a aa aaa aaaa aaaaa aaaaaa pneumonoultramicroscopicsilicovolcanoconiosis"",
    });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then(appearance => {
    expect(appearance).toEqual(
      ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm "" +
        ""2.00 -5.00 Td (a aa aaa ) Tj\n"" +
        ""0.00 -5.00 Td (aaaa aaaaa ) Tj\n"" +
        ""0.00 -5.00 Td (aaaaaa ) Tj\n"" +
        ""0.00 -5.00 Td (pneumonoultr) Tj\n"" +
        ""0.00 -5.00 Td (amicroscopi) Tj\n"" +
        ""0.00 -5.00 Td (csilicovolca) Tj\n"" +
        ""0.00 -5.00 Td (noconiosis) Tj ET Q EMC""
    );
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm "" +

              ""2.00 -5.00 Td (\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f) Tj\n"" +

              ""0.00 -5.00 Td (\x4e\x16\x75\x4c\x30\x6e) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render multiline text with various EOL for printing"", function (done) {
","async function createAnnotation() {
  try {
    const annotation = await AnnotationFactory.create();
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""こんにちは世界の"" });
    const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
    expect(appearance).toEqual(
      ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm "" +
        ""2.00 -5.00 Td (\x30\x53\x30\x93\x30\x6b\x30\x61\x30\x6f) Tj\n"" +
        ""0.00 -5.00 Td (\x4e\x16\x75\x4c\x30\x6e) Tj ET Q EMC""
    );
    done();
  } catch (error) {
    done.fail(error);
  }
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value:

              ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.\r"" +

              ""Aliquam vitae felis ac lectus bibendum ultricies quis non diam.\n"" +

              ""Morbi id porttitor quam, a iaculis dui.\r\n"" +

              ""Pellentesque habitant morbi tristique senectus et "" +

              ""netus et malesuada fames ac turpis egestas.\n\r\n\r"" +

              ""Nulla consectetur, ligula in tincidunt placerat, "" +

              ""velit augue consectetur orci, sed mattis libero nunc ut massa.\r"" +

              ""Etiam facilisis tempus interdum."",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(expectedAppearance);

          done();

        }, done.fail);

    it(""should render comb for printing"", function (done) {
","AnnotationFactory.create()
  .then((annotation) => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, {
      value: ""Lorem ipsum dolor sit amet, consectetur adipiscing elit.\rAliquam vitae felis ac lectus bibendum ultricies quis non diam.\nMorbi id porttitor quam, a iaculis dui.\r\nPellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\n\r\n\rNulla consectetur, ligula in tincidunt placerat, velit augue consectetur orci, sed mattis libero nunc ut massa.\rEtiam facilisis tempus interdum."",
    });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then((appearance) => {
    expect(appearance).toEqual(expectedAppearance);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""aa(aa)a\\"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 2 Tm"" +

              "" (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\() Tj"" +

              "" 8.00 0 Td (a) Tj 8.00 0 Td (a) Tj"" +

              "" 8.00 0 Td (\\)) Tj 8.00 0 Td (a) Tj"" +

              "" 8.00 0 Td (\\\\) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should render comb with Japanese text for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""aa(aa)a\\"" });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then(appearance => {
    expect(appearance).toEqual(
      ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 2 Tm (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\() Tj 8.00 0 Td (a) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\)) Tj 8.00 0 Td (a) Tj 8.00 0 Td (\\\\) Tj ET Q EMC""
    );
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm"" +

              "" (\x30\x53) Tj 8.00 0 Td (\x30\x93) Tj 8.00 0 Td (\x30\x6b) Tj"" +

              "" 8.00 0 Td (\x30\x61) Tj 8.00 0 Td (\x30\x6f) Tj"" +

              "" 8.00 0 Td (\x4e\x16) Tj 8.00 0 Td (\x75\x4c) Tj"" +

              "" 8.00 0 Td (\x30\x6e) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should save text"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, {
      value: ""こんにちは世界の"",
    });
    return annotation._getAppearance(partialEvaluator, task, annotationStorage);
  })
  .then(appearance => {
    expect(appearance).toEqual(
      ""/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm"" +
        "" (\x30\x53) Tj 8.00 0 Td (\x30\x93) Tj 8.00 0 Td (\x30\x6b) Tj"" +
        "" 8.00 0 Td (\x30\x61) Tj 8.00 0 Td (\x30\x6f) Tj"" +
        "" 8.00 0 Td (\x4e\x16) Tj 8.00 0 Td (\x75\x4c) Tj"" +
        "" 8.00 0 Td (\x30\x6e) Tj ET Q EMC""
    );
    done();
  })
  .catch(done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""hello world"" });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(2, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] "" +

              ""/V (hello world) /AP << /N 2 0 R>> /M (date)>>\nendobj\n""

          );

          expect(newData.data).toEqual(

            ""2 0 obj\n<< /Length 77 /Subtype /Form /Resources "" +

              ""<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

              ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (hello world) Tj "" +

              ""ET Q EMC\nendstream\nendobj\n""

          );

          done();

        }, done.fail);

    });



    it(""should get field object for usage in JS sandbox"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: ""hello world"" });
    return annotation.save(partialEvaluator, task, annotationStorage);
  })
  .then(data => {
    expect(data.length).toEqual(2);
    const [oldData, newData] = data;
    expect(oldData.ref).toEqual(Ref.get(123, 0));
    expect(newData.ref).toEqual(Ref.get(2, 0));
    oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
    expect(oldData.data).toEqual(""123 0 obj\n<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR << /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] /V (hello world) /AP << /N 2 0 R>> /M (date)>>\nendobj\n"");
    expect(newData.data).toEqual(""2 0 obj\n<< /Length 77 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\n/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (hello world) Tj ET Q EMC\nendstream\nendobj\n"");
    done();
  })
  .catch(done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          return annotation.getFieldObject();

        })

        .then(object => {

          const actions = object.actions;

          expect(actions[""Mouse Enter""]).toEqual([""hello()""]);

          expect(actions[""Mouse Exit""]).toEqual([

            ""world()"",

            ""olleh()"",

            ""foo()"",

            ""dlrow()"",

            ""oof()"",

          ]);

          expect(actions[""Mouse Down""]).toEqual([""bar()""]);

          done();

        }, done.fail);

    it(""should save Japanese text"", function (done) {
","AnnotationFactory.create()
  .then(annotation => annotation.getFieldObject())
  .then(object => {
    const actions = object.actions;
    expect(actions[""Mouse Enter""]).toEqual([""hello()""]);
    expect(actions[""Mouse Exit""]).toEqual([
      ""world()"",
      ""olleh()"",
      ""foo()"",
      ""dlrow()"",
      ""oof()"",
    ]);
    expect(actions[""Mouse Down""]).toEqual([""bar()""]);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, {

            value: ""こんにちは世界の"",

          });

          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          const utf16String =

            ""\x30\x53\x30\x93\x30\x6b\x30\x61"" +

            ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(2, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] "" +

              `/V (\xfe\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\nendobj\n`

          );

          expect(newData.data).toEqual(

            ""2 0 obj\n<< /Length 82 /Subtype /Form /Resources "" +

              ""<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\n"" +

              `/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (${utf16String}) Tj ` +

              ""ET Q EMC\nendstream\nendobj\n""

          );

          done();

        }, done.fail);
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, {
      value: ""こんにちは世界の"",
    });
    return annotation.save(partialEvaluator, task, annotationStorage);
  })
  .then(data => {
    const utf16String = ""\x30\x53\x30\x93\x30\x6b\x30\x61"" + ""\x30\x6f\x4e\x16\x75\x4c\x30\x6e"";
    expect(data.length).toEqual(2);
    const [oldData, newData] = data;
    expect(oldData.ref).toEqual(Ref.get(123, 0));
    expect(newData.ref).toEqual(Ref.get(2, 0));
    oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
    expect(oldData.data).toEqual(""123 0 obj\n"" + ""<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR << /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] `/V (\xfe\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\nendobj\n"");
    expect(newData.data).toEqual(""2 0 obj\n<< /Length 82 /Subtype /Form /Resources << /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\n"" + `/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (${utf16String}) Tj ET Q EMC\nendstream\nendobj\n"");
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        expect(data.exportValue).toEqual(""Checked"");

        done();

      }, done.fail);

    it(""should handle checkboxes without export value"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.checkBox).toEqual(true);
    expect(data.fieldValue).toEqual(""1"");
    expect(data.defaultFieldValue).toEqual(""2"");
    expect(data.radioButton).toEqual(false);
    expect(data.exportValue).toEqual(""Checked"");
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        done();

      }, done.fail);

    it(""should handle checkboxes without /Off appearance"", function (done) {
","it(""should handle checkboxes without /Off appearance"", async () => {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.checkBox).toEqual(true);
  expect(data.fieldValue).toEqual(""1"");
  expect(data.defaultFieldValue).toEqual(""2"");
  expect(data.radioButton).toEqual(false);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.defaultFieldValue).toEqual(""2"");

        expect(data.radioButton).toEqual(false);

        expect(data.exportValue).toEqual(""Checked"");

        done();

      }, done.fail);

    it(""should render checkbox with fallback font for printing"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.checkBox).toEqual(true);
    expect(data.fieldValue).toEqual(""1"");
    expect(data.defaultFieldValue).toEqual(""2"");
    expect(data.radioButton).toEqual(false);
    expect(data.exportValue).toEqual(""Checked"");
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(5);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.dependency,

            OPS.setFont,

            OPS.showText,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[3][0][0].fontChar).toEqual(""✔"");

          done();

        })

        .catch(done.fail);

    it(""should render checkboxes for printing"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: true });
    return annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
  })
  .then(opList => {
    expect(opList.argsArray.length).toEqual(5);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.dependency, OPS.setFont, OPS.showText, OPS.endAnnotation]);
    expect(opList.argsArray[3][0][0].fontChar).toEqual(""✔"");
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        }, done.fail)

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        }, done.fail)

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        }, done.fail);

    it(""should render checkboxes for printing two times"", function (done) {
","async () => {
 const annotation = await AnnotationFactory.create();

 const annotationStorage = new Map();

 annotationStorage.set(annotation.data.id, { value: true });

 const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);

 expect(opList.argsArray.length).toEqual(3);

 expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);

 expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));

 const annotation2 = await AnnotationFactory.create();

 const annotationStorage2 = new Map();

 annotationStorage2.set(annotation2.data.id, { value: false });

 const opList2 = await annotation2.getOperatorList(partialEvaluator, task, false, annotationStorage2);

 expect(opList2.argsArray.length).toEqual(3);

 expect(opList2.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);

 expect(opList2.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));

 done();
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        })

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        })

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should render checkboxes for printing using normal appearance"", function (done) {
","async function createAnnotation() {
  const annotation = await AnnotationFactory.create();
  const annotationStorage = new Map();
  annotationStorage.set(annotation.data.id, { value: true });

  const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);

  expect(opList.argsArray.length).toEqual(3);
  expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
  expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));

  return annotation;
}

async function testPrinting() {
  const annotation = await createAnnotation();
  const annotationStorage = new Map();
  annotationStorage.set(annotation.data.id, { value: true });

  const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);

  expect(opList.argsArray.length).toEqual(3);
  expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
  expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));

  done();
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          done();

        })

        .catch(done.fail);

    it(""should save checkboxes"", function (done) {
","AnnotationFactory.create()
  .then((annotation) => {
    const annotationStorage = new Map();
    return annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
  })
  .then((opList) => {
    expect(opList.argsArray.length).toEqual(3);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        }, done.fail)

        .then(([annotation, [oldData]]) => {

          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/V /Checked /AS /Checked /M (date)>>\nendobj\n""

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should handle radio buttons with a field value"", function (done) {
","async function createAnnotation() {
  const annotation = await AnnotationFactory.create();
  const annotationStorage = new Map();
  annotationStorage.set(annotation.data.id, { value: true });
  [annotation, oldData] = await Promise.all([annotation, annotation.save(partialEvaluator, task, annotationStorage)]);
  oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
  expect(oldData.ref).toEqual(Ref.get(123, 0));
  expect(oldData.data).toEqual(""123 0 obj\n<< /Type /Annot /Subtype /Widget /FT /Btn /AP << /N << /Checked 314 0 R /Off 271 0 R>>>> /V /Checked /AS /Checked /M (date)>>\nendobj\n"");
  annotationStorage.set(annotation.data.id, { value: false });
  return await annotation.save(partialEvaluator, task, annotationStorage);
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(""1"");

        expect(data.buttonValue).toEqual(""2"");

        done();

      }, done.fail);

    it(""should handle radio buttons with a field value not an ascii string"", function (done) {
","it(""should handle radio buttons with a field value not an ASCII string"", async () => {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.checkBox).toEqual(false);
  expect(data.radioButton).toEqual(true);
  expect(data.fieldValue).toEqual(""1"");
  expect(data.buttonValue).toEqual(""2"");
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(""‚I=‚ðﬁàŠe3"");

        expect(data.buttonValue).toEqual(""‚I=‚ðﬁàŠe3"");

        done();

      }, done.fail);

    it(""should handle radio buttons without a field value"", function (done) {
","async function createAnnotation() {
  try {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.checkBox).toEqual(false);
    expect(data.radioButton).toEqual(true);
    expect(data.fieldValue).toEqual(""‚I=‚ðﬁàŠe3"");
    expect(data.buttonValue).toEqual(""‚I=‚ðﬁàŠe3"");
  } catch (error) {
    done.fail(error);
  } finally {
    done();
  }
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.checkBox).toEqual(false);

        expect(data.radioButton).toEqual(true);

        expect(data.fieldValue).toEqual(null);

        expect(data.buttonValue).toEqual(""2"");

        done();

      }, done.fail);

    it(""should render radio buttons for printing"", function (done) {
","\`\`\`javascript
AnnotationFactory.create().then(async ({ data }) => {
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.checkBox).toEqual(false);
  expect(data.radioButton).toEqual(true);
  expect(data.fieldValue).toEqual(null);
  expect(data.buttonValue).toEqual(""2"");
  done();
}, done.fail);
\`\`\`

The migrated code uses the `async/await` syntax to handle promises in a more concise and readable way. The \`then\` method is replaced with an \`async\` function, which allows you to use the await keyword to wait for the promise to resolve before continuing execution of the function. In this case, we are waiting for the promise returned by the create method to resolve before checking the values of the annotation object's properties.",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.getOperatorList(

              partialEvaluator,

              task,

              false,

              annotationStorage

            ),

          ]);

        }, done.fail)

        .then(([annotation, opList]) => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([26, 51, 76])

          );

          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        }, done.fail)

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        }, done.fail);

    it(""should render radio buttons for printing using normal appearance"", function (done) {
","it('should render radio buttons for printing using normal appearance', async () => {
  const annotation = await AnnotationFactory.create();
  const annotationStorage = new Map();
  annotationStorage.set(annotation.data.id, { value: true });
  const opList = await annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
  expect(opList.argsArray.length).toEqual(3);
  expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
  expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));

  const newAnnotation = await AnnotationFactory.create();
  const newOpList = await newAnnotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
  expect(newOpList.argsArray.length).toEqual(3);
  expect(newOpList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
  expect(newOpList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));

  done();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();



          return annotation.getOperatorList(

            partialEvaluator,

            task,

            false,

            annotationStorage

          );

        })

        .then(opList => {

          expect(opList.argsArray.length).toEqual(3);

          expect(opList.fnArray).toEqual([

            OPS.beginAnnotation,

            OPS.setFillRGBColor,

            OPS.endAnnotation,

          ]);

          expect(opList.argsArray[1]).toEqual(

            new Uint8ClampedArray([76, 51, 26])

          );

          done();

        })

        .catch(done.fail);

    it(""should save radio buttons"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    return annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
  })
  .then(opList => {
    expect(opList.argsArray.length).toEqual(3);
    expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
    expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));
    done();
  })
  .catch(done.fail);

it(""should save radio buttons"", function (done) {
  AnnotationFactory.create()
    .then(annotation => {
      const annotationStorage = new Map();
      return annotation.getOperatorList(partialEvaluator, task, false, annotationStorage);
    })
    .then(opList => {
      expect(opList.argsArray.length).toEqual(3);
      expect(opList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);
      expect(opList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));
      done();
    })
    .catch(done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        }, done.fail)

        .then(([annotation, data]) => {

          expect(data.length).toEqual(2);

          const [radioData, parentData] = data;

          radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(radioData.ref).toEqual(Ref.get(123, 0));

          expect(radioData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

          );

          expect(parentData.ref).toEqual(Ref.get(456, 0));

          expect(parentData.data).toEqual(

            ""456 0 obj\n<< /V /Checked /Kids [123 0 R]>>\nendobj\n""

          );



          return annotation;

        }, done.fail)

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: false });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data).toEqual(null);

          done();

        }, done.fail);

    });



    it(""should save radio buttons without a field value"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: true });
    return Promise.all([annotation, annotation.save(partialEvaluator, task, annotationStorage)]);
  })
  .then(([annotation, data]) => {
    expect(data.length).toEqual(2);
    const [radioData, parentData] = data;
    radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
    expect(radioData.ref).toEqual(Ref.get(123, 0));
    expect(radioData.data).toEqual(""123 0 obj\n<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 /AP << /N << /Checked 314 0 R /Off 271 0 R>>>> /Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n"");
    expect(parentData.ref).toEqual(Ref.get(456, 0));
    expect(parentData.data).toEqual(""456 0 obj\n<< /V /Checked /Kids [123 0 R]>>\nendobj\n"");
    return annotation;
  })
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: false });
    return annotation.save(partialEvaluator, task, annotationStorage);
  })
  .then(data => {
    expect(data).toEqual(null);
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: true });



          return Promise.all([

            annotation,

            annotation.save(partialEvaluator, task, annotationStorage),

          ]);

        })

        .then(([annotation, data]) => {

          expect(data.length).toEqual(2);

          const [radioData, parentData] = data;

          radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(radioData.ref).toEqual(Ref.get(123, 0));

          expect(radioData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 "" +

              ""/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> "" +

              ""/Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n""

          );

          expect(parentData.ref).toEqual(Ref.get(456, 0));

          expect(parentData.data).toEqual(

            ""456 0 obj\n<< /Kids [123 0 R] /V /Checked>>\nendobj\n""

          );

          done();

        })

        .catch(done.fail);

    });



    it(""should save nothing"", function (done) {

      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          return annotation.save(partialEvaluator, task, annotationStorage);

        })

        .then(data => {

          expect(data).toEqual(null);

          done();

        })

        .catch(done.fail);

    it(""should handle push buttons"", function (done) {
","AnnotationFactory.create()
  .then(annotation => {
    const annotationStorage = new Map();
    annotationStorage.set(annotation.data.id, { value: true });
    return Promise.all([annotation, annotation.save(partialEvaluator, task, annotationStorage)]);
  })
  .then(([annotation, data]) => {
    expect(data.length).toEqual(2);
    const [radioData, parentData] = data;
    radioData.data = radioData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
    expect(radioData.ref).toEqual(Ref.get(123, 0));
    expect(radioData.data).toEqual(""123 0 obj\n<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 /AP << /N << /Checked 314 0 R /Off 271 0 R>>>> /Parent 456 0 R /AS /Checked /M (date)>>\nendobj\n"");
    expect(parentData.ref).toEqual(Ref.get(456, 0));
    expect(parentData.data).toEqual(""456 0 obj\n<< /Kids [123 0 R] /V /Checked>>\nendobj\n"");
    done();
  })
  .catch(done.fail);
});

it(""should save nothing"", function (done) {
  AnnotationFactory.create()
    .then(annotation => annotation.save(partialEvaluator, task, annotationStorage))
    .then(data => {
      expect(data).toEqual(null);
      done();
    })
    .catch(done.fail);
});

it(""should handle push buttons"", function (done) {
  AnnotationFactory.create()
    .then(annotation => {
      const annotationStorage = new Map();
      return annotation.save(partialEvaluator, task, annotationStorage);
    })
    .then(data => {
      expect(data).toEqual(null);
      done();
    })
    .catch(done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.pushButton).toEqual(true);

        expect(data.actions.Action).toEqual([""do_something();""]);

        done();

      }, done.fail);

    it(""should handle push buttons that act as a tooltip only"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.pushButton).toEqual(true);
    expect(data.actions.Action).toEqual([""do_something();""]);
    done();
  }, done.fail);
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.pushButton).toEqual(true);

        expect(data.alternativeText).toEqual(""An alternative text"");

        done();

      }, done.fail);

    it(""should handle URL in A dict in push buttons"", function (done) {
","\`\`\`javascript
try {
  const annotation = await AnnotationFactory.create();
  expect(annotation.annotationType).toEqual(AnnotationType.WIDGET);
  expect(annotation.pushButton).toEqual(true);
  expect(annotation.alternativeText).toEqual(""An alternative text"");
} catch (error) {
  done.fail(error);
}
\`\`\`",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

        done();

      }, done.fail);

    it(""should handle URL in AA dict in push buttons"", function (done) {

      // D stands for MouseDown
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");
    done();
  }, done.fail);

it(""should handle URL in AA dict in push buttons"", async function () {
  // D stands for MouseDown
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");

        done();

      }, done.fail);
","await AnnotationFactory.create().then(({ data }) => {
  expect(data.url).toEqual(""https://developer.mozilla.org/en-US/"");
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"    it(""should handle missing option arrays"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual([]);

        done();

      }, done.fail);

    it(""should handle option arrays with array elements"", function (done) {
","it(""should handle missing option arrays"", async () => {
  const { data } = await AnnotationFactory.create();

  expect(data.annotationType).toEqual(AnnotationType.WIDGET);

  expect(data.options).toEqual([]);

  done();
});

it(""should handle option arrays with array elements"", async () => {
  const { data } = await AnnotationFactory.create([1, 2, 3]);

  expect(data.annotationType).toEqual(AnnotationType.WIDGET);

  expect(data.options).toEqual([1, 2, 3]);

  done();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should handle option arrays with string elements"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.options).toEqual(expected);
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should handle inherited option arrays (issue 8094)"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.options).toEqual(expected);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.options).toEqual(expected);

        done();

      }, done.fail);

    it(""should decode form values"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.options).toEqual(expected);
    done();
  }, done.fail);

it(""should decode form values"", async () => {
  const { data } = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.options).toEqual(expected);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.fieldValue).toEqual([decodedString]);

        expect(data.defaultFieldValue).toEqual(""foo"");

        expect(data.options).toEqual([

          { exportValue: decodedString, displayValue: decodedString },

        ]);

        done();

      }, done.fail);

    it(""should convert the field value to an array"", function (done) {
","async function createAnnotation() {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.fieldValue).toEqual([decodedString]);
  expect(data.defaultFieldValue).toEqual(""foo"");
  expect(data.options).toEqual([
    { exportValue: decodedString, displayValue: decodedString },
  ]);
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      promise.then(done, done.fail);

    it(""should handle unknown flags"", function (done) {

      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(false);

        expect(data.multiSelect).toEqual(false);

        done();

      }, done.fail);

    it(""should not set invalid flags"", function (done) {
","it(""should handle unknown flags"", async () => {
  try {
    const { data } = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.readOnly).toEqual(false);
    expect(data.hidden).toEqual(false);
    expect(data.combo).toEqual(false);
    expect(data.multiSelect).toEqual(false);
  } catch (error) {
    done.fail(error);
  }
});

it(""should not set invalid flags"", async () => {
  try {
    const { data } = await AnnotationFactory.create();
    // Add your assertions here
  } catch (error) {
    done.fail(error);
  }
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(false);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(false);

        expect(data.multiSelect).toEqual(false);

        done();

      }, done.fail);

    it(""should set valid flags"", function (done) {
","async function test() {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.readOnly).toEqual(false);
  expect(data.hidden).toEqual(false);
  expect(data.combo).toEqual(false);
  expect(data.multiSelect).toEqual(false);
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.WIDGET);

        expect(data.readOnly).toEqual(true);

        expect(data.hidden).toEqual(false);

        expect(data.combo).toEqual(true);

        expect(data.multiSelect).toEqual(true);

        done();

      }, done.fail);

    it(""should render choice for printing"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.WIDGET);
    expect(data.readOnly).toEqual(true);
    expect(data.hidden).toEqual(false);
    expect(data.combo).toEqual(true);
    expect(data.multiSelect).toEqual(true);
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""a value"" });



          return annotation._getAppearance(

            partialEvaluator,

            task,

            annotationStorage

          );

        }, done.fail)

        .then(appearance => {

          expect(appearance).toEqual(

            ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm"" +

              "" 2.00 2.00 Td (a value) Tj ET Q EMC""

          );

          done();

        }, done.fail);

    });



    it(""should save choice"", function (done) {
","it(""should save choice"", async () => {
  const annotation = await AnnotationFactory.create();
  const partialEvaluator = new PartialEvaluator(task);
  const annotationStorage = new Map();
  annotationStorage.set(annotation.data.id, { value: ""a value"" });
  const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);
  expect(appearance).toEqual(""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (a value) Tj ET Q EMC"");
  done();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      )

        .then(annotation => {

          const annotationStorage = new Map();

          annotationStorage.set(annotation.data.id, { value: ""C"" });



          return annotation.save(partialEvaluator, task, annotationStorage);

        }, done.fail)

        .then(data => {

          expect(data.length).toEqual(2);

          const [oldData, newData] = data;

          expect(oldData.ref).toEqual(Ref.get(123, 0));

          expect(newData.ref).toEqual(Ref.get(1, 0));



          oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");

          expect(oldData.data).toEqual(

            ""123 0 obj\n"" +

              ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +

              ""<< /Font << /Helv 314 0 R>>>> "" +

              ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +

              ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""

          );

          expect(newData.data).toEqual(

            ""1 0 obj\n"" +

              ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +

              ""/BBox [0 0 32 10]>> stream\n"" +

              ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +

              ""endstream\nendobj\n""

          );

          done();

        }, done.fail);

    it(""should set the line coordinates"", function (done) {
","AnnotationFactory.create()
    .then(annotation => {
      const annotationStorage = new Map();
      annotationStorage.set(annotation.data.id, { value: ""C"" });
      return annotation.save(partialEvaluator, task, annotationStorage);
    })
    .then(data => {
      expect(data.length).toEqual(2);
      const [oldData, newData] = data;
      expect(oldData.ref).toEqual(Ref.get(123, 0));
      expect(newData.ref).toEqual(Ref.get(1, 0));
      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
      expect(oldData.data).toEqual(
        ""123 0 obj\n"" +
          ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +
          ""<< /Font << /Helv 314 0 R>>>> "" +
          ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +
          ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""
      );
      expect(newData.data).toEqual(
        ""1 0 obj\n"" +
          ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +
          ""/BBox [0 0 32 10]>> stream\n"" +
          ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +
          ""endstream\nendobj\n""
      );
      done();
    })
    .catch(done.fail);
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.LINE);

        expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);

        done();

      }, done.fail);

    it(""should correctly parse a file attachment"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.LINE);
    expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);

        expect(data.file.filename).toEqual(""Test.txt"");

        expect(data.file.content).toEqual(stringToBytes(""Test attachment""));

        done();

      }, done.fail);

    it(""should inherit properties from its parent"", function (done) {
","import { AnnotationFactory } from 'some-module';
import { AnnotationType, stringToBytes } from 'another-module';

it(""should create an annotation with a file attachment"", async () => {
  try {
    const annotation = await AnnotationFactory.create();
    expect(annotation.data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);
    expect(annotation.data.file.filename).toEqual(""Test.txt"");
    expect(annotation.data.file.content).toEqual(stringToBytes(""Test attachment""));
  } catch (error) {
    done.fail(error);
  }
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data, viewable }) => {

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        expect(data.modificationDate).toEqual(""D:20190423"");

        expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

        done();

      }, done.fail);

    it(""should handle missing parent properties"", function (done) {
","AnnotationFactory.create({})
    .then(async ({ data, viewable }) => {
      expect(data.annotationType).toEqual(AnnotationType.POPUP);
      expect(data.modificationDate).toEqual(""D:20190423"");
      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
      done();
    })
    .catch(done.fail);

  it(""should handle missing parent properties"", async function () {
    const annotation = await AnnotationFactory.create({});
    expect(annotation.data.annotationType).toEqual(AnnotationType.POPUP);
    expect(annotation.data.modificationDate).toEqual(""D:20190423"");
    expect(annotation.data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data, viewable }) => {

        expect(data.annotationType).toEqual(AnnotationType.POPUP);

        expect(data.modificationDate).toEqual(null);

        expect(data.color).toEqual(null);

        done();

      }, done.fail);

      function (done) {
","AnnotationFactory.create()
  .then(({ data, viewable }) => {
    expect(data.annotationType).toEqual(AnnotationType.POPUP);
    expect(data.modificationDate).toEqual(null);
    expect(data.color).toEqual(null);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data, viewable }) => {

          expect(data.annotationType).toEqual(AnnotationType.POPUP);

          // We should not modify the `annotationFlags` returned through

          // e.g., the API.

          expect(data.annotationFlags).toEqual(25);

          // The popup should inherit the `viewable` property of the parent.

          expect(viewable).toEqual(true);

          done();

        }, done.fail);

      function (done) {
","try {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.POPUP);
  expect(data.annotationFlags).toEqual(25);
  expect(viewable).toEqual(true);
} catch (error) {
  done.fail(error);
} finally {
  done();
}",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"        AnnotationFactory.create(

        ).then(({ data }) => {

          expect(data.title).toEqual(""Correct Title"");

          expect(data.contents).toEqual(""Correct Text"");

          expect(data.modificationDate).toEqual(""D:20190423"");

          expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));

          done();

        }, done.fail);

    it(""should handle a single ink list"", function (done) {
","AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.title).toEqual(""Correct Title"");
      expect(data.contents).toEqual(""Correct Text"");
      expect(data.modificationDate).toEqual(""D:20190423"");
      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
      done();
    })
    .catch(done.fail);

it(""should handle a single ink list"", async () => {
  try {
    const data = await AnnotationFactory.create();
    expect(data.title).toEqual(""Correct Title"");
    expect(data.contents).toEqual(""Correct Text"");
    expect(data.modificationDate).toEqual(""D:20190423"");
    expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));
  } catch (error) {
    done.fail();
  }
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.INK);

        expect(data.inkLists.length).toEqual(1);

        expect(data.inkLists[0]).toEqual([

          { x: 1, y: 1 },

          { x: 1, y: 2 },

          { x: 2, y: 2 },

          { x: 3, y: 3 },

        ]);

        done();

      }, done.fail);

    it(""should handle multiple ink lists"", function (done) {
","it(""should handle multiple ink lists"", async () => {
  const data = await AnnotationFactory.create();
  expect(data.annotationType).toEqual(AnnotationType.INK);
  expect(data.inkLists.length).toEqual(1);
  expect(data.inkLists[0]).toEqual([
    { x: 1, y: 1 },
    { x: 1, y: 2 },
    { x: 2, y: 2 },
    { x: 3, y: 3 },
  ]);
  done();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.INK);

        expect(data.inkLists.length).toEqual(2);

        expect(data.inkLists[0]).toEqual([

          { x: 1, y: 1 },

          { x: 1, y: 2 },

        ]);

        expect(data.inkLists[1]).toEqual([

          { x: 3, y: 3 },

          { x: 4, y: 5 },

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.INK);
    expect(data.inkLists.length).toEqual(2);
    expect(data.inkLists[0]).toEqual([
      { x: 1, y: 1 },
      { x: 1, y: 2 },
    ]);
    expect(data.inkLists[1]).toEqual([
      { x: 3, y: 3 },
      { x: 4, y: 5 },
    ]);
    done();
  })
  .catch(done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","it(""should set quadpoints if defined"", async () => {
    const data = await AnnotationFactory.create({
      annotationType: AnnotationType.HIGHLIGHT,
      quadPoints: [0, 0, 10, 10]
    });
  
    expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);
    expect(data.quadPoints).toEqual([0, 0, 10, 10]);
  
    done();
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null when empty"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);
    expect(data.quadPoints).toEqual([
      [
        { x: 10, y: 20 },
        { x: 20, y: 20 },
        { x: 10, y: 10 },
        { x: 20, y: 10 },
      ],
    ]);
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);
    expect(data.quadPoints).toEqual(null);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","import { AnnotationFactory } from 'pdf-lib';
import { AnnotationType } from 'pdf-lib';

async function createAnnotation() {
  const annotation = await AnnotationFactory.create();
  expect(annotation.annotationType).toEqual(AnnotationType.UNDERLINE);
  expect(annotation.quadPoints).toEqual(null);
}

it(""should set quadpoints if defined"", async () => {
  const annotation = await createAnnotation();
  expect(annotation.quadPoints).toEqual(null);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","AnnotationFactory.create()
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);
    expect(data.quadPoints).toBeNull();
    done();
  }, done.fail);
});

it(""should set quadpoints to null if not defined"", function (done) {
  AnnotationFactory.create({}, undefined, null);
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);
    expect(data.quadPoints).toBeNull();
    done();
  }, done.fail);
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","AnnotationFactory.create({
  data: {
    annotationType: AnnotationType.SQUIGGLY,
    quadPoints: null
  }
})
  .then(({ data }) => {
    expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);
    expect(data.quadPoints).toEqual(null);
    done();
  }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);

    it(""should set quadpoints to null if not defined"", function (done) {
","import { AnnotationFactory } from 'pdf-lib';

it('creates a squiggly annotation', async () => {
  const data = await AnnotationFactory.create({
    annotationType: AnnotationType.SQUIGGLY,
    quadPoints: [
      [
        { x: 10, y: 20 },
        { x: 20, y: 20 },
        { x: 10, y: 10 },
        { x: 20, y: 10 },
      ],
    ],
  });

  expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);
  expect(data.quadPoints).toEqual([
    [
      { x: 10, y: 20 },
      { x: 20, y: 20 },
      { x: 10, y: 10 },
      { x: 20, y: 10 },
    ],
  ]);
});

it('sets quadpoints to null if not defined', async () => {
  const data = await AnnotationFactory.create({
    annotationType: AnnotationType.SQUIGGLY,
  });

  expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);
  expect(data.quadPoints).toBeNull();
});",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

        expect(data.quadPoints).toEqual(null);

        done();

      }, done.fail);

    it(""should set quadpoints if defined"", function (done) {
","AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);
      expect(data.quadPoints).not.toBeNull();
      done();
    }, done.fail);
  }

  it(""should set quadpoints if defined"", function (done) {
    AnnotationFactory.create()
      .then(({ data }) => {
        expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);
        expect(data.quadPoints).not.toBeNull();
        done();
      }, done.fail);
  });",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"      AnnotationFactory.create(

      ).then(({ data }) => {

        expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);

        expect(data.quadPoints).toEqual([

          [

            { x: 10, y: 20 },

            { x: 20, y: 20 },

            { x: 10, y: 10 },

            { x: 20, y: 10 },

          ],

        ]);

        done();

      }, done.fail);
","AnnotationFactory.create()
    .then(({ data }) => {
      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);
      expect(data.quadPoints).toEqual([
        [
          { x: 10, y: 20 },
          { x: 20, y: 20 },
          { x: 10, y: 10 },
          { x: 20, y: 10 },
        ],
      ]);
      done();
    }, done.fail);",2021-04-17 18:23:40+02:00,f4237d3a09ced37f67d4859b12d5fb60bc986548
"  function runOperatorListCheck(evaluator, stream, resources, callback) {

    const result = new OperatorList();

    evaluator

      .getOperatorList({

        stream,

        task,

        resources,

        operatorList: result,

      })

      .then(

        function () {

          callback(result);

        },

        function (reason) {

          callback(reason);

        }

      );
","async function runOperatorListCheck(evaluator, stream, resources, callback) {
  try {
    const result = new OperatorList();
    await evaluator.getOperatorList({
      stream,
      task,
      resources,
      operatorList: result,
    });
    callback(result);
  } catch (error) {
    callback(error);
  }
}",2021-04-17 19:47:56+02:00,d42f3d0bfe76756b4ad233b7e1e03859009479b2
"    it(""table was truncated in the middle of functions"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font2324), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(

            /(ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)

          ).toEqual(true);

          done();

        });
","it(""table was truncated in the middle of functions"", async function () {
  const cMap = await CMapFactory.create({});
  const font = new Font(""font"", new Stream(font2324), {
    loadedName: ""font"",
    type: ""CIDFontType2"",
    differences: [],
    defaultEncoding: [],
    cMap,
    toUnicode: new ToUnicodeMap([]),
  });
  const output = await ttx(font.data);
  verifyTtxOutput(output);
  expect(/ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)).toEqual(true);
});",2021-04-19 13:26:39+02:00,3d55b2b10eb9bc0201490184a05fc5ed209521a6
"      ttx(font.data, function (output) {

        verifyTtxOutput(output);

        expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

        done();

      });

    it(""has invalid selection attributes presence"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font1282), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);

          done();

        });
","import { ttx } from 'ttx';
import { Font, Stream } from 'fontkit';
import { CMapFactory } from 'cmap-factory';
import { ToUnicodeMap } from 'unicode-properties';

async function test() {
  const font = new Font(""font"", new Stream(font1282), {
    loadedName: ""font"",
    type: ""CIDFontType2"",
    differences: [],
    defaultEncoding: [],
    cMap: await CMapFactory.create({}),
    toUnicode: new ToUnicodeMap([]),
  });

  const output = await ttx(font.data);

  verifyTtxOutput(output);

  expect(/<OS_2>\s*<version value=""3""\/>/.test(output)).toEqual(true);
}",2021-04-19 13:26:39+02:00,3d55b2b10eb9bc0201490184a05fc5ed209521a6
"    it(""has invalid version number"", function (done) {

      CMapFactory.create({

      }).then(function (cMap) {

        const font = new Font(""font"", new Stream(font2109), {

          loadedName: ""font"",

          type: ""CIDFontType2"",

          differences: [],

          defaultEncoding: [],

          cMap,

          toUnicode: new ToUnicodeMap([]),

        });

        ttx(font.data, function (output) {

          verifyTtxOutput(output);

          expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(

            true

          );

          done();

        });

    it(""has invalid glyph name indexes"", function (done) {
","it(""has invalid version number"", async () => {
  const cMap = await CMapFactory.create({});
  const font = new Font(""font"", new Stream(font2109), {
    loadedName: ""font"",
    type: ""CIDFontType2"",
    differences: [],
    defaultEncoding: [],
    cMap,
    toUnicode: new ToUnicodeMap([]),
  });
  const output = await ttx(font.data);
  verifyTtxOutput(output);
  expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(true);
  done();
});

it(""has invalid glyph name indexes"", async () => {
  const cMap = await CMapFactory.create({});
  const font = new Font(""font"", new Stream(font2109), {
    loadedName: ""font"",
    type: ""CIDFontType2"",
    differences: [],
    defaultEncoding: [],
    cMap,
    toUnicode: new ToUnicodeMap([]),
  });
  const output = await ttx(font.data);
  verifyTtxOutput(output);
  expect(/<post>\s*<formatType value=""3\.0""\/>/.test(output)).toEqual(true);
  done();
});",2021-04-19 13:26:39+02:00,3d55b2b10eb9bc0201490184a05fc5ed209521a6
"function ttx(data) {

  return new Promise((resolve, reject) => {

    const xhr = new XMLHttpRequest();

    xhr.open(""POST"", ""/ttx"");



    const encodedData = encodeFontData(data);

    xhr.setRequestHeader(""Content-type"", ""text/plain"");

    xhr.setRequestHeader(""Content-length"", encodedData.length);



    xhr.onreadystatechange = function getPdfOnreadystatechange(e) {

      if (xhr.readyState === 4) {

        if (xhr.status === 200) {

          resolve(xhr.responseText);

        } else {

          reject(new Error(xhr.statusText));

        }

      }

    };

    xhr.send(encodedData);
","async function ttx(data) {
  const xhr = new XMLHttpRequest();
  xhr.open(""POST"", ""/ttx"");

  // Set request headers
  xhr.setRequestHeader(""Content-type"", ""text/plain"");
  xhr.setRequestHeader(""Content-length"", encodedData.length);

  // Send the data
  const encodedData = encodeFontData(data);
  xhr.send(encodedData);

  try {
    const response = await new Promise((resolve, reject) => {
      xhr.onreadystatechange = function getPdfOnreadystatechange(e) {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            resolve(xhr.responseText);
          } else {
            reject(new Error(xhr.statusText));
          }
        }
      };
    });

    return response;
  } catch (error) {
    console.log(error);
  }
}",2021-04-20 23:35:25+02:00,7b8d2495cab70336858f94b40d8815617a3cc23c
"  setPDFNetworkStreamFactory(params => {

    return streamsPromise.then(streams => {

      const [{ PDFNetworkStream }, { PDFFetchStream }] = streams;

      if (isFetchSupported() && isValidFetchUrl(params.url)) {

        return new PDFFetchStream(params);

      }

      return new PDFNetworkStream(params);

    });

} else if (PDFJSDev.test(""GENERIC"")) {

  const { isNodeJS } = require(""./shared/is_node.js"");

  if (isNodeJS) {

    const PDFNodeStream = require(""./display/node_stream.js"").PDFNodeStream;

    const PDFNetworkStream = require(""./display/network.js"").PDFNetworkStream;

    let PDFFetchStream;

    if (isFetchSupported()) {

      PDFFetchStream = require(""./display/fetch_stream.js"").PDFFetchStream;

    }

      if (PDFFetchStream && isValidFetchUrl(params.url)) {

} else if (PDFJSDev.test(""CHROME"")) {

  const PDFNetworkStream = require(""./display/network.js"").PDFNetworkStream;

  let PDFFetchStream;

  const isChromeWithFetchCredentials = function () {

    // fetch does not include credentials until Chrome 61.0.3138.0 and later.

    // https://chromium.googlesource.com/chromium/src/+/2e231cf052ca5e68e22baf0008ac9e5e29121707

    try {

      // Indexed properties on window are read-only in Chrome 61.0.3151.0+

      // https://chromium.googlesource.com/chromium/src.git/+/58ab4a971b06dec13e4edf9de8382ca6847f6190

      window[999] = 123; // should throw. Note: JS strict mode MUST be enabled.

      delete window[999];

      return false;

    } catch (e) {

      return true;

    }

  };

  if (isFetchSupported() && isChromeWithFetchCredentials()) {

    PDFFetchStream = require(""./display/fetch_stream.js"").PDFFetchStream;

  }

  setPDFNetworkStreamFactory(params => {

    if (PDFFetchStream && isValidFetchUrl(params.url)) {

      return new PDFFetchStream(params);

    }

    return new PDFNetworkStream(params);

  });
","setPDFNetworkStreamFactory((params) => {
  const streamsPromise = Promise.resolve([{
      PDFNetworkStream: require(""./display/network.js"").PDFNetworkStream,
      PDFFetchStream: isFetchSupported() && isValidFetchUrl(params.url) ? require(""./display/fetch_stream.js"").PDFFetchStream : null
    }, {
      PDFNodeStream: isNodeJS() ? require(""./display/node_stream.js"").PDFNodeStream : null,
      PDFNetworkStream: require(""./display/network.js"").PDFNetworkStream,
      PDFFetchStream: isFetchSupported() && isValidFetchUrl(params.url) ? require(""./display/fetch_stream.js"").PDFFetchStream : null
    }]);
  return streamsPromise.then((streams) => {
    const [{ PDFNetworkStream }, { PDFFetchStream }] = streams;
    if (PDFFetchStream && isValidFetchUrl(params.url)) {
      return new PDFFetchStream(params);
    } else {
      return new PDFNetworkStream(params);
    }
  });
});",2021-06-11 22:53:09+02:00,ddea90b8f6fbeca189bb81254c63f406675dd973
"      const registry = properties.cidSystemInfo.registry;

      const ordering = properties.cidSystemInfo.ordering;

      const ucs2CMapName = Name.get(registry + ""-"" + ordering + ""-UCS2"");

      return CMapFactory.create({

      }).then(function (ucs2CMap) {

        const cMap = properties.cMap;

        const toUnicode = [];

        cMap.forEach(function (charcode, cid) {

          if (cid > 0xffff) {

            throw new FormatError(""Max size of CID is 65,535"");

          }

          // e) Map the CID obtained in step (a) according to the CMap

          // obtained in step (d), producing a Unicode value.

          const ucs2 = ucs2CMap.lookup(cid);

          if (ucs2) {

            toUnicode[charcode] = String.fromCharCode(

              (ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1)

            );

          }

        });

        return new ToUnicodeMap(toUnicode);

    return Promise.resolve(

      new IdentityToUnicodeMap(properties.firstChar, properties.lastChar)

    );
","const registry = properties.cidSystemInfo.registry;
const ordering = properties.cidSystemInfo.ordering;
const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
async function migrate() {
  try {
    const cmapFactory = await CMapFactory.create({});
    const ucs2CMap = await cmapFactory.create(ucs2CMapName);
    const toUnicode = [];
    for (const [charcode, cid] of properties.cMap) {
      if (cid > 0xffff) {
        throw new FormatError(""Max size of CID is 65,535"");
      }
      const ucs2 = ucs2CMap.lookup(cid);
      if (ucs2) {
        toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
      }
    }
    return new ToUnicodeMap(toUnicode);
  } catch (error) {
    console.log(error);
    return Promise.resolve(new IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
  }
}
migrate();",2021-05-17 15:40:23+02:00,edc38de37ac7a1ba659b59598a254c38ac1fcf33
"    return undefined;

  return loadScript(PDFWorker.workerSrc);

function loadAndEnablePDFBug(enabledTabs) {

  const appConfig = PDFViewerApplication.appConfig;

  return loadScript(appConfig.debuggerScriptPath).then(function () {

    PDFBug.enable(enabledTabs);

    PDFBug.init({ OPS }, appConfig.mainContainer);

  });
","async function loadAndEnablePDFBug(enabledTabs) {
  const appConfig = PDFViewerApplication.appConfig;
  await loadScript(PDFWorker.workerSrc);
  await loadScript(appConfig.debuggerScriptPath);
  PDFBug.enable(enabledTabs);
  PDFBug.init({ OPS }, appConfig.mainContainer);
}",2021-08-18 15:59:30+02:00,bc8787b04939715816722769dfa309d909d0063d
"  destroy() {

    const transportDestroyed = !this._transport

      ? Promise.resolve()

      : this._transport.destroy();

    return transportDestroyed.then(() => {

      this._transport = null;

      if (this._worker) {

        this._worker.destroy();

        this._worker = null;

      }

    });
","destroy() {

    const transportDestroyed = !this._transport

      ? Promise.resolve()

      : this._transport.destroy();

    return transportDestroyed.then(async () => {

      this._transport = null;

      if (this._worker) {

        await this._worker.destroy();

        this._worker = null;

      }

    });

  }",2021-08-29 12:11:36+02:00,ce3f5ea2bf73ab9d4a3d86bc61576f5d14785ab0
"  render(viewport, intent = ""display"") {

    return Promise.all([

      this.pdfPage.getAnnotations({ intent }),

      this._hasJSActionsPromise,

    ]).then(([annotations, hasJSActions = false]) => {

      if (this._cancelled || annotations.length === 0) {

        return;

      }

      const parameters = {

        viewport: viewport.clone({ dontFlip: true }),

        div: this.div,

        annotations,

        page: this.pdfPage,

        imageResourcesPath: this.imageResourcesPath,

        renderForms: this.renderForms,

        linkService: this.linkService,

        downloadManager: this.downloadManager,

        annotationStorage: this.annotationStorage,

        enableScripting: this.enableScripting,

        hasJSActions,

        mouseState: this._mouseState,

      };

      if (this.div) {

        // If an annotationLayer already exists, refresh its children's

        // transformation matrices.

        AnnotationLayer.update(parameters);

      } else {

        // Create an annotation layer div and render the annotations

        // if there is at least one annotation.

        this.div = document.createElement(""div"");

        this.div.className = ""annotationLayer"";

        this.pageDiv.appendChild(this.div);

        parameters.div = this.div;

        AnnotationLayer.render(parameters);

        this.l10n.translate(this.div);

      }

    });
","async render(viewport, intent = ""display"") {
    try {
      const annotations = await this.pdfPage.getAnnotations({ intent });
      if (this._cancelled || annotations.length === 0) return;
      const hasJSActions = await this._hasJSActionsPromise;
      const parameters = {
        viewport: viewport.clone({ dontFlip: true }),
        div: this.div,
        annotations,
        page: this.pdfPage,
        imageResourcesPath: this.imageResourcesPath,
        renderForms: this.renderForms,
        linkService: this.linkService,
        downloadManager: this.downloadManager,
        annotationStorage: this.annotationStorage,
        enableScripting: this.enableScripting,
        hasJSActions,
        mouseState: this._mouseState,
      };
      if (this.div) {
        AnnotationLayer.update(parameters);
      } else {
        this.div = document.createElement(""div"");
        this.div.className = ""annotationLayer"";
        this.pageDiv.appendChild(this.div);
        parameters.div = this.div;
        await AnnotationLayer.render(parameters);
        this.l10n.translate(this.div);
      }
    } catch (error) {
      console.error(""Error during rendering"", error);
    }
  }",2021-09-14 12:06:28+02:00,6cba5509f26ede9986cbc4c100b037d3347d7c91
"loadingTask.promise

  .then(function (pdfDocument) {

    console.log(""# PDF document loaded."");

    pdfDocument.getPage(1).then(function (page) {

      // Render the page on a Node canvas with 100% scale.

      const viewport = page.getViewport({ scale: 1.0 });

      const canvasFactory = new NodeCanvasFactory();

      const canvasAndContext = canvasFactory.create(

        viewport.width,

        viewport.height

      );

      const renderContext = {

        canvasContext: canvasAndContext.context,

        viewport,

        canvasFactory,

      };

      const renderTask = page.render(renderContext);

      renderTask.promise.then(function () {

        // Convert the canvas to an image buffer.

        const image = canvasAndContext.canvas.toBuffer();

        fs.writeFile(""output.png"", image, function (error) {

          if (error) {

            console.error(""Error: "" + error);

          } else {

            console.log(

              ""Finished converting first page of PDF file to a PNG image.""

            );

          }

        });

      });

  })

  .catch(function (reason) {

  });
","loadingTask.promise
  .then(async (pdfDocument) => {
    console.log(""# PDF document loaded."");
    const page = await pdfDocument.getPage(1);
    // Render the page on a Node canvas with 100% scale.
    const viewport = page.getViewport({ scale: 1.0 });
    const canvasFactory = new NodeCanvasFactory();
    const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);
    const renderContext = {
      canvasContext: canvasAndContext.context,
      viewport,
      canvasFactory,
    };
    const renderTask = page.render(renderContext);
    await renderTask.promise;
    // Convert the canvas to an image buffer.
    const image = canvasAndContext.canvas.toBuffer();
    fs.writeFile(""output.png"", image, (error) => {
      if (error) {
        console.error(""Error: "" + error);
      } else {
        console.log(""Finished converting first page of PDF file to a PNG image."");
      }
    });
  })
  .catch((reason) => {});",2021-10-14 13:26:10+10:00,37d90ec378f2ff74a9e5e150173e00517e63c4b4
"function pageLoaded() {

  loadingTask.promise.then(function (pdfDocument) {

    pdfDocument.getPage(PAGE_NUMBER).then(function (page) {

      const viewport = page.getViewport({ scale: PAGE_SCALE });

      page.getTextContent().then(function (textContent) {

        // building SVG and adding that to the DOM

        const svg = buildSVG(viewport, textContent);

        document.getElementById(""pageContainer"").appendChild(svg);

      });

    });

  });
","async function pageLoaded() {

  let pdfDocument = await loadingTask.promise;

  const page = await pdfDocument.getPage(PAGE_NUMBER);

  const viewport = page.getViewport({ scale: PAGE_SCALE });

  const textContent = await page.getTextContent();

  // building SVG and adding that to the DOM

  const svg = buildSVG(viewport, textContent);

  document.getElementById(""pageContainer"").appendChild(svg);

}",2021-10-14 14:44:00+01:00,fdf08ef3d26d7d1446ddb019668b6a71373163fc
"// Will be using promises to load document, pages and misc data instead of

// callback.

loadingTask.promise

  .then(function (doc) {

    const numPages = doc.numPages;

    console.log(""# Document Loaded"");

    console.log(""Number of Pages: "" + numPages);

    console.log();

    let lastPromise = Promise.resolve(); // will be used to chain promises

    const loadPage = function (pageNum) {

      return doc.getPage(pageNum).then(function (page) {

        console.log(""# Page "" + pageNum);

        const viewport = page.getViewport({ scale: 1.0 });

        console.log(""Size: "" + viewport.width + ""x"" + viewport.height);

        console.log();

        return page.getOperatorList().then(function (opList) {

          const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);

          svgGfx.embedFonts = true;

          return svgGfx.getSVG(opList, viewport).then(function (svg) {

            return writeSvgToFile(svg, getFilePathForPage(pageNum)).then(

              function () {

                console.log(""Page: "" + pageNum);

              },

              function (err) {

                console.log(""Error: "" + err);

              }

            );

          });

        });

      });

    };



    for (let i = 1; i <= numPages; i++) {

      lastPromise = lastPromise.then(loadPage.bind(null, i));

    }

    return lastPromise;

  })

  .then(

    function () {

      console.log(""# End of Document"");

    },

    function (err) {

      console.error(""Error: "" + err);

  );
","// Migrated code
const pdfjsLib = require('pdfjs-dist');

async function main() {
  const loadingTask = pdfjsLib.getDocument('path/to/document.pdf');

  try {
    const doc = await loadingTask.promise;
    console.log('# Document Loaded');
    const numPages = doc.numPages;
    console.log(`Number of Pages: ${numPages}`);
    console.log();

    for (let i = 1; i <= numPages; i++) {
      await loadPage(doc, i);
    }

    console.log('# End of Document');
  } catch (err) {
    console.error(`Error: ${err}`);
  }
}

async function loadPage(doc, pageNum) {
  const page = await doc.getPage(pageNum);
  console.log(`# Page ${pageNum}`);
  const viewport = page.getViewport({ scale: 1.0 });
  console.log(`Size: ${viewport.width}x${viewport.height}`);
  console.log();

  const opList = await page.getOperatorList();
  const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);
  svgGfx.embedFonts = true;

  try {
    const svg = await svgGfx.getSVG(opList, viewport);
    await writeSvgToFile(svg, getFilePathForPage(pageNum));
    console.log(`Page: ${pageNum}`);
  } catch (err) {
    console.log(`Error: ${err}`);
  }
}

main();",2021-10-18 19:22:06+01:00,0643ccb68b8c12e6734eaa02c9a2b11859096188
"loadingTask.promise.then(function (pdfDocument) {

});
",const pdfDocument = await loadingTask.promise;,2021-10-24 19:36:25+05:30,4c463c6099cea8e195203278c9be7ac656192e64
"   * @returns {Promise} Returns a promise containing a {PDFPageProxy} object.

   * @private

  _ensurePdfPageLoaded(pageView) {

      return Promise.resolve(pageView.pdfPage);

    if (this._pagesRequests.has(pageView)) {

      return this._pagesRequests.get(pageView);

    const promise = this.pdfDocument

      .getPage(pageView.id)

      .then(pdfPage => {

        if (!pageView.pdfPage) {

          pageView.setPdfPage(pdfPage);

        }

        this._pagesRequests.delete(pageView);

        return pdfPage;

      })

      .catch(reason => {

        console.error(""Unable to get page for page view"", reason);

        // Page error -- there is nothing that can be done.

        this._pagesRequests.delete(pageView);

      });

    this._pagesRequests.set(pageView, promise);

    return promise;
","async _ensurePdfPageLoaded(pageView) {
  if (!pageView.pdfPage) {
    try {
      const pdfPage = await this.pdfDocument.getPage(pageView.id);
      pageView.setPdfPage(pdfPage);
      return pdfPage;
    } catch (error) {
      console.error(""Unable to get page for page view"", error);
    }
  } else {
    return pageView.pdfPage;
  }
}",2021-11-20 18:24:12+01:00,0ebac67a9fedbc655500f29285d1632a8bb09a70
"   * @returns {PDFPage}

   * @private

  _ensurePdfPageLoaded(thumbView) {

      return Promise.resolve(thumbView.pdfPage);

    if (this._pagesRequests.has(thumbView)) {

      return this._pagesRequests.get(thumbView);

    const promise = this.pdfDocument

      .getPage(thumbView.id)

      .then(pdfPage => {

        if (!thumbView.pdfPage) {

          thumbView.setPdfPage(pdfPage);

        }

        this._pagesRequests.delete(thumbView);

        return pdfPage;

      })

      .catch(reason => {

        console.error(""Unable to get page for thumb view"", reason);

        // Page error -- there is nothing that can be done.

        this._pagesRequests.delete(thumbView);

      });

    this._pagesRequests.set(thumbView, promise);

    return promise;
","async _ensurePdfPageLoaded(thumbView) {
  if (this._pagesRequests.has(thumbView)) {
    return this._pagesRequests.get(thumbView);
  }
  const pdfPage = await this.pdfDocument.getPage(thumbView.id).catch((reason) => {
    console.error(""Unable to get page for thumb view"", reason);
    // Page error -- there is nothing that can be done.
    this._pagesRequests.delete(thumbView);
  });
  if (!thumbView.pdfPage) {
    thumbView.setPdfPage(pdfPage);
  }
  this._pagesRequests.delete(thumbView);
  return pdfPage;
}",2021-11-20 18:24:12+01:00,0ebac67a9fedbc655500f29285d1632a8bb09a70
"loadingTask.promise.then(function (pdfDocument) {

  return pdfDocument.getPage(PAGE_TO_VIEW).then(function (pdfPage) {

    // Creating the page view with default parameters.

    const pdfPageView = new pdfjsViewer.PDFPageView({

      container,

      id: PAGE_TO_VIEW,

      scale: SCALE,

      defaultViewport: pdfPage.getViewport({ scale: SCALE }),

      eventBus,

      // We can enable text/annotation/xfa/struct-layers, as needed.

      textLayerFactory: !pdfDocument.isPureXfa

        ? new pdfjsViewer.DefaultTextLayerFactory()

        : null,

      annotationLayerFactory: new pdfjsViewer.DefaultAnnotationLayerFactory(),

      xfaLayerFactory: pdfDocument.isPureXfa

        ? new pdfjsViewer.DefaultXfaLayerFactory()

        : null,

      structTreeLayerFactory: new pdfjsViewer.DefaultStructTreeLayerFactory(),

    });

    // Associate the actual page with the view, and draw it.

    pdfPageView.setPdfPage(pdfPage);

    return pdfPageView.draw();

});
","async function loadPDF() {
  const pdfDocument = await loadingTask.promise;
  const pdfPage = await pdfDocument.getPage(PAGE_TO_VIEW);
  const pdfPageView = new pdfjsViewer.PDFPageView({
    container,
    id: PAGE_TO_VIEW,
    scale: SCALE,
    defaultViewport: pdfPage.getViewport({ scale: SCALE }),
    eventBus,
    textLayerFactory: !pdfDocument.isPureXfa
      ? new pdfjsViewer.DefaultTextLayerFactory()
      : null,
    annotationLayerFactory: new pdfjsViewer.DefaultAnnotationLayerFactory(),
    xfaLayerFactory: pdfDocument.isPureXfa
      ? new pdfjsViewer.DefaultXfaLayerFactory()
      : null,
    structTreeLayerFactory: new pdfjsViewer.DefaultStructTreeLayerFactory(),
  });
  pdfPageView.setPdfPage(pdfPage);
  return pdfPageView.draw();
}",2021-11-24 13:25:36+05:30,711fbe13763b208ee335c9fdff6c7c8ca27a293f
"    return this.xref

      .fetchAsync(ref)

      .then(obj => {

        // Ensure that the object that was found is actually a Page dictionary.

        if (

          isDict(obj, ""Page"") ||

          (isDict(obj) && !obj.has(""Type"") && obj.has(""Contents""))

        ) {

          if (ref && !catalog.pageKidsCountCache.has(ref)) {

            catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.

          }

          return [obj, ref];

        throw new FormatError(

          ""The Linearization dictionary doesn't point "" +

            ""to a valid Page dictionary.""

        );

      })

      .catch(reason => {

        info(reason);

        return catalog.getPageDict(pageIndex);

      });
","return this.xref
  .fetchAsync(ref)
  .then(async (obj) => {
    if (!isDict(obj, ""Page"") && !(isDict(obj) && obj.has(""Type"") && !obj.has(""Contents""))) {
      throw new FormatError(
        ""The Linearization dictionary doesn't point to a valid Page dictionary.""
      );
    }
    if (ref && !catalog.pageKidsCountCache.has(ref)) {
      catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.
    }
    return [obj, ref];
  })
  .catch((reason) => {
    info(reason);
    return catalog.getPageDict(pageIndex);
  });",2021-11-26 19:57:47+01:00,4c56214ab48dc2b3b379c88ffd3952961526152a
"  function rasterizeTextLayer(

    return new Promise(function (resolve, reject) {
","async function rasterizeTextLayer() {

  try {

    const canvas = await createCanvas();

    const ctx = canvas.getContext('2d');

    const text = 'Hello World!';

    ctx.font = '14px Arial';

    ctx.fillStyle = '#000';

    ctx.textBaseline = 'top';

    ctx.fillText(text, 10, 50);

    const imageData = await canvas.toBlob();

    resolve(imageData);

  } catch (error) {

    reject(error);

  }

}",2021-12-05 14:04:23+01:00,5fd4276dcf7d5d9acc3afd91f67bb0de9fe3e81f
"    function next() {

      while (nodesToVisit.length) {

        const currentNode = nodesToVisit.pop();

        if (currentNode instanceof Ref) {

          const count = pageKidsCountCache.get(currentNode);

          // Skip nodes where the page can't be.

          if (count >= 0 && currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

          // Prevent circular references in the /Pages tree.

          if (visitedNodes.has(currentNode)) {

            capability.reject(

              new FormatError(""Pages tree contains circular reference."")

            );

            return;

          }

          visitedNodes.put(currentNode);



          xref.fetchAsync(currentNode).then(function (obj) {

            if (isDict(obj, ""Page"") || (isDict(obj) && !obj.has(""Kids""))) {

              // Cache the Page reference, since it can *greatly* improve

              // performance by reducing redundant lookups in long documents

              // where all nodes are found at *one* level of the tree.

              if (currentNode && !pageKidsCountCache.has(currentNode)) {

                pageKidsCountCache.put(currentNode, 1);

              }



              if (pageIndex === currentPageIndex) {

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            }

            nodesToVisit.push(obj);

            next();

          }, capability.reject);

          return;

        }



        // Must be a child page dictionary.

        if (!(currentNode instanceof Dict)) {

          capability.reject(

            new FormatError(

              ""Page dictionary kid reference points to wrong type of object.""

            )

          );

          return;

        }



        let count;

        try {

          count = currentNode.get(""Count"");

        } catch (ex) {

          if (ex instanceof MissingDataException) {

            throw ex;

          }

        if (Number.isInteger(count) && count >= 0) {

          // Cache the Kids count, since it can reduce redundant lookups in

          // documents where all nodes are found at *one* level of the tree.

          const objId = currentNode.objId;

          if (objId && !pageKidsCountCache.has(objId)) {

            pageKidsCountCache.put(objId, count);

          }

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

        let kids;

        try {

          kids = currentNode.get(""Kids"");

        } catch (ex) {

          if (ex instanceof MissingDataException) {

            throw ex;

        }

        if (!Array.isArray(kids)) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          let type;

          try {

            type = currentNode.get(""Type"");

          } catch (ex) {

            if (ex instanceof MissingDataException) {

              throw ex;

          }

          if (

            isName(type, ""Page"") ||

            (!currentNode.has(""Type"") && currentNode.has(""Contents""))

          ) {

              capability.resolve([currentNode, null]);

              return;

          capability.reject(

            new FormatError(""Page dictionary kids object is not an array."")

          );

          return;

        // Always check all `Kids` nodes, to avoid getting stuck in an empty

        // node further down in the tree (see issue5644.pdf, issue8088.pdf),

        // and to ensure that we actually find the correct `Page` dict.

        for (let last = kids.length - 1; last >= 0; last--) {

          nodesToVisit.push(kids[last]);

      capability.reject(new Error(`Page index ${pageIndex} not found.`));

    next();

    return capability.promise;
","async function next() {

  while (nodesToVisit.length) {

    const currentNode = nodesToVisit.pop();

    if (currentNode instanceof Ref) {

      let count;

      try {

        count = pageKidsCountCache.get(currentNode);

      } catch (ex) {

        if (ex instanceof MissingDataException) {

          throw ex;

        }

        if (!Number.isInteger(count) || count < 0) {

          // Prevent errors in corrupt PDF documents that violate the

          // specification by *inlining* Page dicts directly in the Kids

          // array, rather than using indirect objects (fixes issue9540.pdf).

          const type = currentNode.get(""Type"");

          if (isName(type, ""Page"") || (!currentNode.has(""Type"") && currentNode.has(""Contents""))) {

            capability.resolve([currentNode, null]);

            return;

          } else {

            // Skip nodes where the page can't be.

            if (currentPageIndex + count <= pageIndex) {

              currentPageIndex += count;

              continue;

            }

            const obj = await xref.fetchAsync(currentNode);

            if (isDict(obj, ""Page"") || (isDict(obj) && !obj.has(""Kids""))) {

              // Cache the Page reference, since it can *greatly* improve

              // performance by reducing redundant lookups in long documents

              // where all nodes are found at *one* level of the tree.

              if (currentNode && !pageKidsCountCache.has(currentNode)) {

                pageKidsCountCache.put(currentNode, 1);

              }

              if (pageIndex === currentPageIndex) {

                capability.resolve([obj, currentNode]);

              } else {

                currentPageIndex++;

                next();

              }

              return;

            }

            nodesToVisit.push(obj);

            next();

          }

        } else {

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

          const obj = await xref.fetchAsync(currentNode);

          if (isDict(obj, ""Page"") || (isDict(obj) && !obj.has(""Kids""))) {

            // Cache the Page reference, since it can *greatly* improve

            // performance by reducing redundant lookups in long documents

            // where all nodes are found at *one* level of the tree.

            if (currentNode && !pageKidsCountCache.has(currentNode)) {

              pageKidsCountCache.put(currentNode, 1);

            }

            if (pageIndex === currentPageIndex) {

              capability.resolve([obj, currentNode]);

            } else {

              currentPageIndex++;

              next();

            }

            return;

          }

          nodesToVisit.push(obj);

          next();

        }

      } catch (ex) {

        if (ex instanceof MissingDataException) {

          throw ex;

        }

        capability.reject(new FormatError(""Pages tree contains circular reference.""));

        return;

      }

    }

    // Must be a child page dictionary.

    if (!(currentNode instanceof Dict)) {

      capability.reject(new FormatError(""Page dictionary kid reference points to wrong type of object.""));

      return;

    }

    let count;

    try {

      count = currentNode.get(""Count"");

    } catch (ex) {

      if (ex instanceof MissingDataException) {

        throw ex;

      }

      if (!Number.isInteger(count) || count < 0) {

        // Prevent errors in corrupt PDF documents that violate the

        // specification by *inlining* Page dicts directly in the Kids

        // array, rather than using indirect objects (fixes issue9540.pdf).

        const type = currentNode.get(""Type"");

        if (isName(type, ""Page"") || (!currentNode.has(""Type"") && currentNode.has(""Contents""))) {

          capability.resolve([currentNode, null]);

          return;

        } else {

          // Skip nodes where the page can't be.

          if (currentPageIndex + count <= pageIndex) {

            currentPageIndex += count;

            continue;

          }

          const obj = await xref.fetchAsync(currentNode);

          if (isDict(obj, ""Page"") || (isDict(obj) && !obj.has(""Kids""))) {

            // Cache the Page reference, since it can *greatly* improve

            // performance by reducing redundant lookups in long documents

            // where all nodes are found at *one* level of the tree.

            if (currentNode && !pageKidsCountCache.has(currentNode)) {

              pageKidsCountCache.put(currentNode, 1);

            }

            if (pageIndex === currentPageIndex) {

              capability.resolve([obj, currentNode]);

            } else {

              currentPageIndex++;

              next();

            }

            return;

          }

          nodesToVisit.push(obj);

          next();

        }

      } else {

        // Skip nodes where the page can't be.

        if (currentPageIndex + count <= pageIndex) {

          currentPageIndex += count;

          continue;

        }

        const obj = await xref.fetchAsync(currentNode);

        if (isDict(obj, ""Page"") || (isDict(obj) && !obj.has(""Kids""))) {

          // Cache the Page reference, since it can *greatly* improve

          // performance by reducing redundant lookups in long documents

          // where all nodes are found at *one* level of the tree.

          if (currentNode && !pageKidsCountCache.has(currentNode)) {

            pageKidsCountCache.put(currentNode, 1);

          }

          if (pageIndex === currentPageIndex) {

            capability.resolve([obj, currentNode]);

          } else {

            currentPageIndex++;

            next();

          }

          return;

        }

        nodesToVisit.push(obj);

        next();

      }

    } catch (ex) {

      if (ex instanceof MissingDataException) {

        throw ex;

      }

      capability.reject(new FormatError(""Pages tree contains circular reference.""));

      return;

    }

  }

  capability.reject(new Error(`Page index ${pageIndex} not found.`));

}

next();

return capability.promise;",2021-12-24 13:46:35+01:00,b513c64d9da6cf050c1b5d3b0500e367b668789e
"  close() {

    this.overlayManager.close(this.overlayName).then(() => {

      this.input.value = """";

    });
","async close() {
  await this.overlayManager.close(this.overlayName);
  this.input.value = """";
}",2022-02-14 12:13:30+01:00,996396a9144ac9deb3d7bcdc82ba4363a31e2c25
"  fontFallback(id, handler) {

    const promises = [];

    this.fontCache.forEach(function (promise) {

      promises.push(promise);

    });

    return Promise.all(promises).then(translatedFonts => {

      for (const translatedFont of translatedFonts) {

        if (translatedFont.loadedName === id) {

          translatedFont.fallback(handler);

          return;

        }

    });

  cleanup(manuallyTriggered = false) {

    const promises = [];

    this.fontCache.forEach(function (promise) {

      promises.push(promise);

    });

    return Promise.all(promises).then(translatedFonts => {

      for (const { dict } of translatedFonts) {

        delete dict.cacheKey;

      }

      this.fontCache.clear();

      this.builtInCMapCache.clear();

      this.standardFontDataCache.clear();

    });
","async fontFallback(id, handler) {

  const promises = [];

  for (const promise of this.fontCache) {

    promises.push(promise);

  }

  try {

    const translatedFonts = await Promise.all(promises);

    for (const translatedFont of translatedFonts) {

      if (translatedFont.loadedName === id) {

        translatedFont.fallback(handler);

        return;

      }

  }
} catch (error) {

  console.error('Error during font fallback:', error);

}",2022-03-18 14:18:03+01:00,c0736647f9c09fa3d582bd7bc635dd854164ea07
"    return resourcesPromise.then(resources => {

      const opList = new OperatorList();

      opList.addOp(OPS.beginAnnotation, [

        data.id,

        data.rect,

        transform,

        matrix,

        isUsingOwnCanvas,

      ]);

      return evaluator

        .getOperatorList({

          stream: appearance,

          task,

          resources,

          operatorList: opList,

          fallbackFontDict: this._fallbackFontDict,

        })

        .then(() => {

          opList.addOp(OPS.endAnnotation, []);

          this.reset();

          return opList;

        });
","return resourcesPromise.then(resources => {
  const opList = new OperatorList();
  opList.addOp(OPS.beginAnnotation, [data.id, data.rect, transform, matrix, isUsingOwnCanvas]);
  return evaluator.getOperatorList({stream: appearance, task, resources, operatorList: opList, fallbackFontDict: this._fallbackFontDict}).then(() => {
    opList.addOp(OPS.endAnnotation, []);
    this.reset();
    return opList;
  });
});",2022-06-24 14:39:08+02:00,c48dc251e07482973ab14036d971cb00a241571a
"    return this._getAppearance(evaluator, task, annotationStorage).then(

      content => {

        if (this.appearance && content === null) {

          return super.getOperatorList(

            evaluator,

            task,

            intent,

            renderForms,

            annotationStorage

          );

        }

        const operatorList = new OperatorList();

        // Even if there is an appearance stream, ignore it. This is the

        // behaviour used by Adobe Reader.

        if (!this._defaultAppearance || content === null) {

          return operatorList;

        }

        const matrix = [1, 0, 0, 1, 0, 0];

        const bbox = [

          0,

          0,

          this.data.rect[2] - this.data.rect[0],

          this.data.rect[3] - this.data.rect[1],

        ];



        const transform = getTransformMatrix(this.data.rect, bbox, matrix);

        operatorList.addOp(OPS.beginAnnotation, [

          this.data.id,

          this.data.rect,

          transform,

          this.getRotationMatrix(annotationStorage),

        ]);



        const stream = new StringStream(content);

        return evaluator

          .getOperatorList({

            stream,

            task,

            resources: this._fieldResources.mergedResources,

            operatorList,

          })

          .then(function () {

            operatorList.addOp(OPS.endAnnotation, []);

            return operatorList;

          });

      }

    );
","return async this._getAppearance(evaluator, task, annotationStorage) => {
const content = await content;
if (this.appearance && content === null) {
return super.getOperatorList(
evaluator,
task,
intent,
renderForms,
annotationStorage);
}
const operatorList = new OperatorList();
// Even if there is an appearance stream, ignore it. This is the
// behaviour used by Adobe Reader.
if (!this._defaultAppearance || content === null) {
return operatorList;
}
const matrix = [1, 0, 0, 1, 0, 0];
const bbox = [
0,
0,
this.data.rect[2] - this.data.rect[0],
this.data.rect[3] - this.data.rect[1],
];
const transform = getTransformMatrix(this.data.rect, bbox, matrix);
operatorList.addOp(OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage)]);
const stream = new StringStream(content);
return await evaluator.getOperatorList({stream, task, resources: this._fieldResources.mergedResources, operatorList})
.then((operatorList) => {
operatorList.addOp(OPS.endAnnotation, []);
return operatorList;
});
}",2022-06-24 14:39:08+02:00,c48dc251e07482973ab14036d971cb00a241571a
"  getAnnotationsData(intent) {

    return this._parsedAnnotations.then(function (annotations) {

      const annotationsData = [];



      if (annotations.length === 0) {

        return annotationsData;

      const intentAny = !!(intent & RenderingIntentFlag.ANY),

        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

        intentPrint = !!(intent & RenderingIntentFlag.PRINT);

      for (const annotation of annotations) {

        // Get the annotation even if it's hidden because

        // JS can change its display.

        if (

          intentAny ||

          (intentDisplay && annotation.viewable) ||

          (intentPrint && annotation.printable)

        ) {

          annotationsData.push(annotation.data);

      return annotationsData;

    });
","getAnnotationsData(intent) {
  try {
    const parsedAnnotations = await this._parsedAnnotations;
    const annotationsData = [];
    for (const annotation of parsedAnnotations) {
      if (!!(intent & RenderingIntentFlag.ANY) ||
        !!(intent & RenderingIntentFlag.DISPLAY && annotation.viewable) ||
        !!(intent & RenderingIntentFlag.PRINT && annotation.printable)) {
        annotationsData.push(annotation.data);
      }
    }
    return annotationsData;
  } catch (error) {
    console.error(""Error getting annotations data:"", error);
    return null;
  }
}",2022-08-03 12:03:49+02:00,31155740c35f5b270ff6222682b013f53351d427
"    this.textLayerDiv.append(endOfContent);

    this.eventBus.dispatch(""textlayerrendered"", {

      source: this,

      pageNumber: this.pageNumber,

      numTextDivs: this.textDivs.length,

    });

  render() {

    if (!(this.textContent || this.textContentStream) || this.renderingDone) {

    this.cancel();

    this.textDivs.length = 0;

    const textLayerFrag = document.createDocumentFragment();

      container: textLayerFrag,

      viewport: this.viewport,

    this.textLayerRenderTask.promise.then(

      () => {

        this.textLayerDiv.append(textLayerFrag);

        this.#finishRendering();

        this.highlighter?.enable();

        this.accessibilityManager?.enable();

      },

      function (reason) {

        // Cancelled or failed to render text layer; skipping errors.

      }

    );
","this.textLayerDiv.append(endOfContent);

this.eventBus.dispatch(""textlayerrendered"", {
  source: this,
  pageNumber: this.pageNumber,
  numTextDivs: this.textDivs.length,
});

async render() {
  if (!(this.textContent || this.textContentStream) || this.renderingDone) {
    this.cancel();
    this.textDivs.length = 0;
    const textLayerFrag = document.createDocumentFragment();
    try {
      await this.textLayerRenderTask.promise;
      this.textLayerDiv.append(textLayerFrag);
      this.#finishRendering();
      this.highlighter?.enable();
      this.accessibilityManager?.enable();
    } catch (reason) {
      // Cancelled or failed to render text layer; skipping errors.
    }
  }
}",2022-11-21 17:15:39+01:00,eed9bf71c5ee16268986a743a992c61bdbcc89da
"      const result = XfaLayer.render(parameters);

      return Promise.resolve(result);

    return this.pdfPage

      .getXfa()

      .then(xfaHtml => {

        if (this._cancelled || !xfaHtml) {

          return { textDivs: [] };

        }

        const parameters = {

          viewport: viewport.clone({ dontFlip: true }),

          div: this.div,

          xfaHtml,

          annotationStorage: this.annotationStorage,

          linkService: this.linkService,

          intent,

        };

        if (this.div) {

          return XfaLayer.update(parameters);

        }

        // Create an xfa layer div and render the form

        this.div = document.createElement(""div"");

        this.pageDiv.append(this.div);

        parameters.div = this.div;

        return XfaLayer.render(parameters);

      })

      .catch(error => {

        console.error(error);

      });
","async function render() {
  try {
    const result = await XfaLayer.render(parameters);
    return Promise.resolve(result);
  } catch (error) {
    console.error(error);
  }
}",2022-12-11 13:07:44+01:00,828efd9d000ab868369ac19cbc2ed0f8cc09c92f
"gulp.task(""jsdoc"", function (done) {

  rimraf(JSDOC_BUILD_DIR, function () {

    mkdirp(JSDOC_BUILD_DIR).then(function () {

      const command =

        '""node_modules/.bin/jsdoc"" -d ' +

        JSDOC_BUILD_DIR +

        "" "" +

        JSDOC_FILES.join("" "");

      exec(command, done);

    });

  });
","gulp.task(""jsdoc"", async function () {
  await rimraf(JSDOC_BUILD_DIR);
  await mkdirp(JSDOC_BUILD_DIR);
  const command = `""node_modules/.bin/jsdoc"" -d ${JSDOC_BUILD_DIR} ${JSDOC_FILES.join("" "")}`;
  await exec(command);
});",2023-01-15 11:37:53+01:00,32357e3d172a552e0408b3e1ed743e87fe7d5a21
"   * @param {PDFManager} pdfManager

   * @param {boolean} collectFields

  static create(xref, ref, pdfManager, idFactory, collectFields, pageRef) {

    return Promise.all([

      pdfManager.ensureCatalog(""acroForm""),

      // Only necessary to prevent the `pdfManager.docBaseUrl`-getter, used

      // with certain Annotations, from throwing and thus breaking parsing:

      pdfManager.ensureCatalog(""baseUrl""),

      // Only necessary in the `Catalog.parseDestDictionary`-method,

      // when parsing ""GoToE"" actions:

      pdfManager.ensureCatalog(""attachments""),

      pdfManager.ensureDoc(""xfaDatasets""),

      collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1,

      pageRef ? pdfManager.ensureCatalog(""structTreeRoot"") : null,

    ]).then(

      ([

        acroForm,

        baseUrl,

        attachments,

        xfaDatasets,

        pageIndex,

        structTreeRoot,

      ]) =>

        pdfManager.ensure(this, ""_create"", [

          xref,

          ref,

          pdfManager,

          idFactory,

          acroForm,

          attachments,

          xfaDatasets,

          collectFields,

          pageIndex,

          structTreeRoot,

          pageRef,

        ])

    );
","async create(xref, ref, pdfManager, idFactory, collectFields, pageRef) {

  try {

    const acroForm = await pdfManager.ensureCatalog(""acroForm"");

    const baseUrl = await pdfManager.ensureCatalog(""baseUrl"");

    const attachments = await pdfManager.ensureCatalog(""attachments"");

    const xfaDatasets = await pdfManager.ensureDoc(""xfaDatasets"");

    const pageIndex = collectFields ? await this._getPageIndex(xref, ref, pdfManager) : -1;

    const structTreeRoot = pageRef ? await pdfManager.ensureCatalog(""structTreeRoot"") : null;

    return await pdfManager.ensure(this, ""_create"", [
      xref,
      ref,
      pdfManager,
      idFactory,
      acroForm,
      attachments,
      xfaDatasets,
      collectFields,
      pageIndex,
      structTreeRoot,
      pageRef,
    ]);

  } catch (e) {

    throw new Error(""Error during PDF parsing: "" + e.message);

  }

}",2023-09-07 14:14:35+02:00,df9cce39c09cde3a4fa5f523c1115e83280a163f
"        return Promise.all(annotationPromises).then(function (annotations) {

          if (annotations.length === 0) {

            return annotations;

          }



          const sortedAnnotations = [];

          let popupAnnotations;

          // Ensure that PopupAnnotations are handled last, since they depend on

          // their parent Annotation in the display layer; fixes issue 11362.

          for (const annotation of annotations) {

            if (!annotation) {

              continue;

            }

            if (annotation instanceof PopupAnnotation) {

              (popupAnnotations ||= []).push(annotation);

              continue;

            }

            sortedAnnotations.push(annotation);

          if (popupAnnotations) {

            sortedAnnotations.push(...popupAnnotations);

          return sortedAnnotations;

        });

    return shadow(this, ""_parsedAnnotations"", parsedAnnotations);
","return await Promise.all(annotationPromises).then((annotations) => {
  if (annotations.length === 0) {
    return annotations;
  }
  const sortedAnnotations = [];
  let popupAnnotations;
  for (const annotation of annotations) {
    if (!annotation) {
      continue;
    }
    if (annotation instanceof PopupAnnotation) {
      (popupAnnotations ||= []).push(annotation);
      continue;
    }
    sortedAnnotations.push(annotation);
  }
  if (popupAnnotations) {
    sortedAnnotations.push(...popupAnnotations);
  }
  return sortedAnnotations;
});",2023-09-07 14:14:35+02:00,df9cce39c09cde3a4fa5f523c1115e83280a163f
"        return Promise.all(promises).then(refs => {

          let newRefs = [];

          let xfaData = null;

          if (isPureXfa) {

            xfaData = refs[0];

            if (!xfaData) {

              return stream.bytes;

            }

          } else {

            newRefs = refs.flat(2);



            if (newRefs.length === 0) {

              // No new refs so just return the initial bytes

              return stream.bytes;

            }

          const needAppearances =

            acroFormRef &&

            acroForm instanceof Dict &&

            newRefs.some(ref => ref.needAppearances);



          const xfa = (acroForm instanceof Dict && acroForm.get(""XFA"")) || null;

          let xfaDatasetsRef = null;

          let hasXfaDatasetsEntry = false;

          if (Array.isArray(xfa)) {

            for (let i = 0, ii = xfa.length; i < ii; i += 2) {

              if (xfa[i] === ""datasets"") {

                xfaDatasetsRef = xfa[i + 1];

                hasXfaDatasetsEntry = true;

              }

            }

            if (xfaDatasetsRef === null) {

              xfaDatasetsRef = xref.getNewTemporaryRef();

            }

          } else if (xfa) {

            // TODO: Support XFA streams.

            warn(""Unsupported XFA type."");

          let newXrefInfo = Object.create(null);

          if (xref.trailer) {

            // Get string info from Info in order to compute fileId.

            const infoObj = Object.create(null);

            const xrefInfo = xref.trailer.get(""Info"") || null;

            if (xrefInfo instanceof Dict) {

              xrefInfo.forEach((key, value) => {

                if (typeof value === ""string"") {

                  infoObj[key] = stringToPDFString(value);

                }

              });

            newXrefInfo = {

              rootRef: xref.trailer.getRaw(""Root"") || null,

              encryptRef: xref.trailer.getRaw(""Encrypt"") || null,

              newRef: xref.getNewTemporaryRef(),

              infoRef: xref.trailer.getRaw(""Info"") || null,

              info: infoObj,

              fileIds: xref.trailer.get(""ID"") || null,

              startXRef: linearization

                ? startXRef

                : xref.lastXRefStreamPos ?? startXRef,

              filename,

            };

          return incrementalUpdate({

            originalData: stream.bytes,

            xrefInfo: newXrefInfo,

            newRefs,

            xref,

            hasXfa: !!xfa,

            xfaDatasetsRef,

            hasXfaDatasetsEntry,

            needAppearances,

            acroFormRef,

            acroForm,

            xfaData,

          }).finally(() => {

            xref.resetNewTemporaryRef();

          });
","return async () => {
  try {
    const newRefs = [];
    let xfaData = null;
    if (isPureXfa) {
      xfaData = refs[0];
      if (!xfaData) {
        return stream.bytes;
      }
    } else {
      newRefs = refs.flat(2);
      if (newRefs.length === 0) {
        // No new refs so just return the initial bytes
        return stream.bytes;
      }
    }
    const needAppearances = acroFormRef && acroForm instanceof Dict && newRefs.some(ref => ref.needAppearances);
    const xfa = (acroForm instanceof Dict && acroForm.get(""XFA"")) || null;
    let xfaDatasetsRef = null;
    let hasXfaDatasetsEntry = false;
    if (Array.isArray(xfa)) {
      for (let i = 0, ii = xfa.length; i < ii; i += 2) {
        if (xfa[i] === ""datasets"") {
          xfaDatasetsRef = xfa[i + 1];
          hasXfaDatasetsEntry = true;
        }
      }
      if (xfaDatasetsRef === null) {
        xfaDatasetsRef = xref.getNewTemporaryRef();
      }
    } else if (xfa) {
      // TODO: Support XFA streams.
      warn(""Unsupported XFA type."");
    }
    const newXrefInfo = Object.create(null);
    if (xref.trailer) {
      // Get string info from Info in order to compute fileId.
      const infoObj = Object.create(null);
      const xrefInfo = xref.trailer.get(""Info"") || null;
      if (xrefInfo instanceof Dict) {
        xrefInfo.forEach((key, value) => {
          if (typeof value === ""string"") {
            infoObj[key] = stringToPDFString(value);
          }
        });
        newXrefInfo = {
          rootRef: xref.trailer.getRaw(""Root"") || null,
          encryptRef: xref.trailer.getRaw(""Encrypt"") || null,
          newRef: xref.getNewTemporaryRef(),
          infoRef: xref.trailer.getRaw(""Info"") || null,
          info: infoObj,
          fileIds: xref.trailer.get(""ID"") || null,
          startXRef: linearization ? startXRef : xref.lastXRefStreamPos ?? startXRef,
          filename,
        };
      }
    }
    const result = await incrementalUpdate({
      originalData: stream.bytes,
      xrefInfo: newXrefInfo,
      newRefs,
      xref,
      hasXfa: !!xfa,
      xfaDatasetsRef,
      hasXfaDatasetsEntry,
      needAppearances,
      acroFormRef,
      acroForm,
      xfaData,
    });
    await result.finally(() => {
      xref.resetNewTemporaryRef();
    });
  } catch (error) {
    console.error(error);
  }
};",2023-09-16 13:06:48+02:00,ff96c413d3efdc3ec08ff6c7596d57b555c1af99
"  addAltTextButton() {

    AnnotationEditor._l10nPromise

      .get(""editor_alt_text_button_label"")

      .then(msg => {

        altText.textContent = msg;

        altText.setAttribute(""aria-label"", msg);

      });
","addAltTextButton() async {
  const msg = await AnnotationEditor._l10nPromise.get(""editor_alt_text_button_label"");
  altText.textContent = msg;
  altText.setAttribute(""aria-label"", msg);
}",2023-09-22 09:43:19+02:00,050093c9f519154f26f3d5757ffc7290fd98ba8f
"    return this.loadFont(

    )

      .then(translated => {

        if (!translated.font.isType3Font) {

          return translated;

        }

        return translated

          .loadType3Data(this, resources, task)

          .then(function () {

            // Add the dependencies to the parent operatorList so they are

            // resolved before Type3 operatorLists are executed synchronously.

            operatorList.addDependencies(translated.type3Dependencies);



            return translated;

          })

          .catch(

            reason =>

              new TranslatedFont({

                loadedName: ""g_font_error"",

                font: new ErrorFont(`Type3 font load error: ${reason}`),

                dict: translated.font,

                evaluatorOptions: this.options,

              })

          );

      })

      .then(translated => {

        state.font = translated.font;

        translated.send(this.handler);

        return translated.loadedName;

      });
","async function loadFont() {
  try {
    const translated = await this.loadFont();
    if (!translated.font.isType3Font) {
      return translated;
    }
    await translated.loadType3Data(this, resources, task);
    operatorList.addDependencies(translated.type3Dependencies);
    state.font = translated.font;
    translated.send(this.handler);
    return translated.loadedName;
  } catch (reason) {
    return new TranslatedFont({
      loadedName: ""g_font_error"",
      font: new ErrorFont(`Type3 font load error: ${reason}`),
      dict: translated.font,
      evaluatorOptions: this.options,
    });
  }
}",2024-01-21 17:32:05+01:00,fc62eec9017721af1dae51336a1190223ba37008
"    function handleSetFont(fontName, fontRef) {

      return self

        .loadFont(fontName, fontRef, resources)

        .then(function (translated) {

          if (!translated.font.isType3Font) {

            return translated;

          }

          return translated

            .loadType3Data(self, resources, task)

            .catch(function () {

              // Ignore Type3-parsing errors, since we only use `loadType3Data`

              // here to ensure that we'll always obtain a useful /FontBBox.

            })

            .then(function () {

              return translated;

            });

        })

        .then(function (translated) {

          textState.loadedName = translated.loadedName;

          textState.font = translated.font;

          textState.fontMatrix =

            translated.font.fontMatrix || FONT_IDENTITY_MATRIX;

        });
","function handleSetFont(fontName, fontRef) {
  return self
    .loadFont(fontName, fontRef, resources)
    .then((translated) => {
      if (!translated.font.isType3Font) {
        return translated;
      }
      return translated
        .loadType3Data(self, resources, task)
        .catch(() => {
          // Ignore Type3-parsing errors, since we only use `loadType3Data` here to ensure that we'll always obtain a useful /FontBBox.
        })
        .then(() => translated);
    })
    .then((translated) => {
      textState.loadedName = translated.loadedName;
      textState.font = translated.font;
      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
    });
}",2024-01-21 17:32:05+01:00,fc62eec9017721af1dae51336a1190223ba37008
"        return this.extractDataStructures(dict, dict, properties).then(

          newProperties => {

            if (widths) {

              const glyphWidths = [];

              let j = firstChar;

              for (const width of widths) {

                glyphWidths[j++] = this.xref.fetchIfRef(width);

              }

              newProperties.widths = glyphWidths;

            } else {

              newProperties.widths = this.buildCharCodeToWidth(

                metrics.widths,

                newProperties

              );

            }

            return new Font(baseFontName, file, newProperties);

          }
","async function extractDataStructures(dict, properties) {
  // Convert the dictionary to a properties object
  const newProperties = await this.xref.fetchIfRef(properties);
  
  if (widths) {
    // Initialize an array for the glyph widths
    const glyphWidths = [];
    
    // Iterate over the widths and fetch them from the xref
    let j = firstChar;
    for (const width of widths) {
      glyphWidths[j++] = await this.xref.fetchIfRef(width);
    }
    
    // Set the new properties object's widths property to the glyph widths array
    newProperties.widths = glyphWidths;
  } else {
    // Build a char code to width mapping from the metrics widths and set it on the new properties object
    newProperties.widths = this.buildCharCodeToWidth(metrics.widths, newProperties);
  }
  
  // Return a new Font instance with the base font name, file, and new properties
  return new Font(baseFontName, file, newProperties);
}",2024-01-21 17:36:50+01:00,d1bef8cb8660a5da1e250ed4888c3b8f7779bd4a
"    return this.extractDataStructures(dict, baseDict, properties).then(

      newProperties => {

        this.extractWidths(dict, descriptor, newProperties);



        return new Font(fontName.name, fontFile, newProperties);

      }
","Code:
    async function extractDataStructures(dict, baseDict, properties) {

        const newProperties = await this.extractWidths(dict, descriptor, newProperties);

        return new Font(fontName.name, fontFile, newProperties);

    }",2024-01-21 17:36:50+01:00,d1bef8cb8660a5da1e250ed4888c3b8f7779bd4a
"    return this.getOperatorList({

    }).then(function () {

      operatorList.addOp(OPS.paintFormXObjectEnd, []);

      if (group) {

        operatorList.addOp(OPS.endGroup, [groupOptions]);

      }

      if (optionalContent !== undefined) {

        operatorList.addOp(OPS.endMarkedContent, []);

      }

    });
","return this.getOperatorList({})
    .then(() => {
      operatorList.addOp(OPS.paintFormXObjectEnd, []);
      if (group) {
        operatorList.addOp(OPS.endGroup, [groupOptions]);
      }
      if (optionalContent !== undefined) {
        operatorList.addOp(OPS.endMarkedContent, []);
      }
    });",2024-01-22 12:14:30+01:00,1cc83c4fdc614c41cf314296cf0160693c9b60da
"    return promise.then(function () {

      if (gStateObj.length > 0) {

        operatorList.addOp(OPS.setGState, [gStateObj]);

      }

      if (isSimpleGState) {

        localGStateCache.set(cacheKey, gStateRef, gStateObj);

      }

    });
","return async () => {
  if (gStateObj.length > 0) {
    operatorList.addOp(OPS.setGState, [gStateObj]);
  }
  if (isSimpleGState) {
    localGStateCache.set(cacheKey, gStateRef, gStateObj);
  }
};",2024-01-22 12:17:20+01:00,cf0797dfbd7fe1f7dcd9f1d4e60848a3a2a5de19
"    return toUnicodePromise

      .then(readToUnicode => {

        properties.toUnicode = readToUnicode;

        return this.buildToUnicode(properties);

      })

      .then(builtToUnicode => {

        properties.toUnicode = builtToUnicode;

        if (cidToGidBytes) {

          properties.cidToGidMap = this.readCidToGidMap(

            cidToGidBytes,

            builtToUnicode

          );

        }

        return properties;

      });
","async function migrateCode() {
  try {
    const toUnicodePromise = this.readCMap(properties.toUnicode);
    const readToUnicode = await toUnicodePromise;
    properties.toUnicode = readToUnicode;
    const builtToUnicode = this.buildToUnicode(properties);
    properties.toUnicode = builtToUnicode;
    if (cidToGidBytes) {
      properties.cidToGidMap = this.readCidToGidMap(
        cidToGidBytes,
        builtToUnicode
      );
    }
    return properties;
  } catch (error) {
    throw new Error(`Error while migrating code: ${error}`);
  }
}",2024-01-22 12:22:48+01:00,f5c01188dc8fbb586664bf68ef492c26813d5253
"  readToUnicode(cmapObj) {

      return Promise.resolve(null);

      return CMapFactory.create({

      }).then(function (cmap) {

        return new ToUnicodeMap(cmap.getMap());

      });

    } else if (cmapObj instanceof BaseStream) {

      return CMapFactory.create({

        encoding: cmapObj,

        fetchBuiltInCMap: this._fetchBuiltInCMapBound,

        useCMap: null,

      }).then(

        function (cmap) {

          if (cmap instanceof IdentityCMap) {

            return new IdentityToUnicodeMap(0, 0xffff);

          const map = new Array(cmap.length);

          // Convert UTF-16BE

          // NOTE: cmap can be a sparse array, so use forEach instead of

          // `for(;;)` to iterate over all keys.

          cmap.forEach(function (charCode, token) {

            // Some cmaps contain *only* CID characters (fixes issue9367.pdf).

            if (typeof token === ""number"") {

              map[charCode] = String.fromCodePoint(token);

              return;

            }

            const str = [];

            for (let k = 0; k < token.length; k += 2) {

              const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

              if ((w1 & 0xf800) !== 0xd800) {

                // w1 < 0xD800 || w1 > 0xDFFF

                str.push(w1);

                continue;

              }

              k += 2;

              const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);

              str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);

            map[charCode] = String.fromCodePoint(...str);

          });

          return new ToUnicodeMap(map);

        },

        reason => {

          if (reason instanceof AbortException) {

            return null;

          }

          if (this.options.ignoreErrors) {

            warn(`readToUnicode - ignoring ToUnicode data: ""${reason}"".`);

            return null;

          throw reason;

      );

    return Promise.resolve(null);
","async function readToUnicode(cmapObj) {
  if (cmapObj instanceof CMap) {
    const map = new Array(cmapObj.length);
    cmapObj.forEach(function (charCode, token) {
      // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
      if (typeof token === ""number"") {
        map[charCode] = String.fromCodePoint(token);
        return;
      }
      const str = [];
      for (let k = 0; k < token.length; k += 2) {
        const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
        if ((w1 & 0xf800) !== 0xd800) {
          // w1 < 0xD800 || w1 > 0xDFFF
          str.push(w1);
          continue;
        }
        k += 2;
        const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
        str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
      }
      map[charCode] = String.fromCodePoint(...str);
    });
    return new ToUnicodeMap(map);
  } else if (cmapObj instanceof BaseStream) {
    const cmap = await CMapFactory.create({
      encoding: cmapObj,
      fetchBuiltInCMap: this._fetchBuiltInCMapBound,
      useCMap: null,
    });
    if (cmap instanceof IdentityCMap) {
      return new IdentityToUnicodeMap(0, 0xffff);
    } else if (cmap) {
      const map = new Array(cmap.length);
      cmap.forEach(function (charCode, token) {
        // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
        if (typeof token === ""number"") {
          map[charCode] = String.fromCodePoint(token);
          return;
        }
        const str = [];
        for (let k = 0; k < token.length; k += 2) {
          const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
          if ((w1 & 0xf800) !== 0xd800) {
            // w1 < 0xD800 || w1 > 0xDFFF
            str.push(w1);
            continue;
          }
          k += 2;
          const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
          str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
        }
        map[charCode] = String.fromCodePoint(...str);
      });
      return new ToUnicodeMap(map);
    } else {
      return null;
    }
  } else if (cmapObj === null) {
    return Promise.resolve(null);
  }
}",2024-01-22 12:44:32+01:00,f21a30dfb4c7812e4b31acbb15206f24611ae58b
"function waitOnEventOrTimeout({ target, name, delay = 0 }) {

  return new Promise(function (resolve, reject) {

    if (

      typeof target !== ""object"" ||

      !(name && typeof name === ""string"") ||

      !(Number.isInteger(delay) && delay >= 0)

    ) {

      throw new Error(""waitOnEventOrTimeout - invalid parameters."");

    }



    function handler(type) {

      if (target instanceof EventBus) {

        target._off(name, eventHandler);

      } else {

        target.removeEventListener(name, eventHandler);

      }



      if (timeout) {

        clearTimeout(timeout);

      }

      resolve(type);

    }

    const eventHandler = handler.bind(null, WaitOnType.EVENT);

      target._on(name, eventHandler);

      target.addEventListener(name, eventHandler);

    const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);

    const timeout = setTimeout(timeoutHandler, delay);

  });
","function waitOnEventOrTimeout({ target, name, delay = 0 }) {
  return new Promise((resolve, reject) => {
    if (
      typeof target !== ""object"" ||
      !(name && typeof name === ""string"") ||
      !(Number.isInteger(delay) && delay >= 0)
    ) {
      throw new Error(""waitOnEventOrTimeout - invalid parameters."");
    }
    function handler(type) {
      if (target instanceof EventBus) {
        target._off(name, eventHandler);
      } else {
        target.removeEventListener(name, eventHandler);
      }
      if (timeout) {
        clearTimeout(timeout);
      }
      resolve(type);
    }
    const eventHandler = handler.bind(null, WaitOnType.EVENT);
    target._on(name, eventHandler);
    target.addEventListener(name, eventHandler);
    const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
    const timeout = setTimeout(timeoutHandler, delay);
  });
}",2024-03-28 16:42:37+01:00,e4d0e84802098251bd72ffa6ef28907d1ce50f2a
"        this.pdfDocument

          .getPageIndex(destRef)

          .then(pageIndex => {

            this.cachePageRef(pageIndex + 1, destRef);

            this.#goToDestinationHelper(rawDest, namedDest, explicitDest);

          })

          .catch(() => {

            console.error(

              `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

                `a valid page reference, for dest=""${rawDest}"".`

            );

          });

        return;

        `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

          `a valid destination reference, for dest=""${rawDest}"".`

        `PDFLinkService.#goToDestinationHelper: ""${pageNumber}"" is not ` +

          `a valid page number, for dest=""${rawDest}"".`
","\`\`\`javascript

this.pdfDocument

  .getPageIndex(destRef)

  .then((pageIndex) => {

    this.cachePageRef(pageIndex + 1, destRef);

    return this.#goToDestinationHelper(rawDest, namedDest, explicitDest);

  })

  .catch(() => {

    console.error(

      `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

        `a valid page reference, for dest=""${rawDest}"".`

    );

  });

return;

\`\`\`",2024-04-24 21:39:10+02:00,fa69d9a3bce242bc4ee3eed44a0c6eed5ce17d74
"    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);

    return dataPromises.then(([contentStream]) => {

      const partialEvaluator = new PartialEvaluator({

        xref: this.xref,

        handler,

        pageIndex: this.pageIndex,

        idFactory: this._localIdFactory,

        fontCache: this.fontCache,

        builtInCMapCache: this.builtInCMapCache,

        standardFontDataCache: this.standardFontDataCache,

        globalImageCache: this.globalImageCache,

        systemFontCache: this.systemFontCache,

        options: this.evaluatorOptions,

      });

      return partialEvaluator.getTextContent({

        stream: contentStream,

        task,

        resources: this.resources,

        includeMarkedContent,

        disableNormalization,

        sink,

        viewBox: this.view,

      });
","const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);

async function getTextContent(task, includeMarkedContent, disableNormalization, sink) {
  const [contentStream] = await dataPromises;

  const partialEvaluator = new PartialEvaluator({
    xref: this.xref,
    handler,
    pageIndex: this.pageIndex,
    idFactory: this._localIdFactory,
    fontCache: this.fontCache,
    builtInCMapCache: this.builtInCMapCache,
    standardFontDataCache: this.standardFontDataCache,
    globalImageCache: this.globalImageCache,
    systemFontCache: this.systemFontCache,
    options: this.evaluatorOptions,
  });

  return partialEvaluator.getTextContent({
    stream: contentStream,
    task,
    resources: this.resources,
    includeMarkedContent,
    disableNormalization,
    sink,
    viewBox: this.view,
  });
}",2024-04-15 12:30:09+02:00,6d523c316cf5d2c47d5e0cf0adfe3e0a57875b97
"    return new Promise((resolve, reject) => {

      fs.readFile(params.path, (error, data) => {

        if (error || !data) {

          reject(error || new Error(`Empty file for: ${params.path}`));

          return;

        }

        resolve(new Uint8Array(data));

      });

    });
","return async () => {

  const data = await fs.readFile(params.path);

  if (!data) {

    throw new Error(`Empty file for: ${params.path}`);

  }

  return new Uint8Array(data);

};",2024-09-22 12:57:23+02:00,0a621ba73a974d1052fc9a6f796632be3c9b975e
"  _fetchData(url, compressionType) {

    return fetchData(

    ).then(data => ({

      cMapData:

        data instanceof ArrayBuffer

          ? new Uint8Array(data)

          : stringToBytes(data),

      compressionType,

    }));
","async function fetchData(url, compressionType) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    return {
      cMapData: data instanceof ArrayBuffer
        ? new Uint8Array(data)
        : stringToBytes(data),
      compressionType,
    };
  } catch (error) {
    console.log('Error fetching data:', error);
  }
}",2024-10-20 17:54:04+02:00,df696063b95ef45ec9cfca077787f91c04ea8c4e
"  _fetchData(url) {

    return fetchData(url, /* type = */ ""arraybuffer"").then(

      data => new Uint8Array(data)

    );
","async function fetchData(url) {
  const response = await fetch(url);
  const data = await response.arrayBuffer();
  return new Uint8Array(data);
}",2024-10-20 17:54:04+02:00,df696063b95ef45ec9cfca077787f91c04ea8c4e
"const fetchData = function (url) {

  return fs.promises.readFile(url).then(data => new Uint8Array(data));

};
","async function fetchData(url) {
  const data = await fs.promises.readFile(url);
  return new Uint8Array(data);
}",2024-10-20 17:54:04+02:00,df696063b95ef45ec9cfca077787f91c04ea8c4e
"  _fetchData(url, compressionType) {

    return fetchData(url).then(data => ({ cMapData: data, compressionType }));
","\`\`\`javascript
async function fetchData(url, compressionType) {
  const response = await fetch(url);
  const data = await response.json();
  return { cMapData: data, compressionType };
}
\`\`\`",2024-10-20 17:54:04+02:00,df696063b95ef45ec9cfca077787f91c04ea8c4e
"    messageHandler.on(""ReaderHeadersReady"", data => {

      const headersCapability = Promise.withResolvers();

      const fullReader = this._fullReader;

      fullReader.headersReady.then(() => {

        // If stream or range are disabled, it's our only way to report

        // loading progress.

        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {

          if (this._lastProgress) {

            loadingTask.onProgress?.(this._lastProgress);

          }

          fullReader.onProgress = evt => {

            loadingTask.onProgress?.({

              loaded: evt.loaded,

              total: evt.total,

            });

          };

        }

        headersCapability.resolve({

          isStreamingSupported: fullReader.isStreamingSupported,

          isRangeSupported: fullReader.isRangeSupported,

          contentLength: fullReader.contentLength,

        });

      }, headersCapability.reject);

      return headersCapability.promise;
","messageHandler.on(""ReaderHeadersReady"", async data => {
  const fullReader = this._fullReader;
  await fullReader.headersReady;
  if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
    if (this._lastProgress) {
      loadingTask.onProgress?.(this._lastProgress);
    }
    fullReader.onProgress = evt => {
      loadingTask.onProgress?.({ loaded: evt.loaded, total: evt.total });
    };
  }
  return {
    isStreamingSupported: fullReader.isStreamingSupported,
    isRangeSupported: fullReader.isRangeSupported,
    contentLength: fullReader.contentLength,
  };
});",2024-10-29 13:21:25+01:00,afb4813d1c4288011c93383d28c4445e9af28596
"        function (pdfDoc) {

          return pdfDoc.getPage(1).then(function (pdfPage) {

            return pdfPage.getAnnotations();

          });
","async function getAnnotations(pdfDoc) {
  const pdfPage = await pdfDoc.getPage(1);
  return await pdfPage.getAnnotations();
}",2025-03-02 18:58:52+01:00,7b5cd9cddd4977f0d28894c4bbf1cd869c8bf0a8
"      pageColors: this.pageColors,

    const resultPromise = renderTask.promise.then(

      () => this.#finishRenderTask(renderTask, canvas),

      error => this.#finishRenderTask(renderTask, canvas, error)

    );

    resultPromise.finally(() => {

      zeroCanvas(canvas);



      this.eventBus.dispatch(""thumbnailrendered"", {

        source: this,

        pageNumber: this.id,

        pdfPage: this.pdfPage,

      });

    return resultPromise;
","async #finishRenderTask(renderTask, canvas) {
  try {
    await renderTask.promise;
    zeroCanvas(canvas);
    this.eventBus.dispatch(""thumbnailrendered"", {
      source: this,
      pageNumber: this.id,
      pdfPage: this.pdfPage,
    });
    return true;
  } catch (error) {
    this.#finishRenderTask(renderTask, canvas, error);
  }
}",2025-03-15 13:57:15+01:00,6548c9f1f61dd4f85e9081409de2db279dd7ce68
"  getContentStream() {

    return this.pdfManager.ensure(this, ""content"").then(content => {

      if (content instanceof BaseStream) {

        return content;

      }

      if (Array.isArray(content)) {

        return new StreamsSequenceStream(

          content,

          this._onSubStreamError.bind(this)

        );

      }

      // Replace non-existent page content with empty content.

      return new NullStream();

    });
","getContentStream() {
    try {
      const content = this.pdfManager.ensure(this, ""content"");
      if (content instanceof BaseStream) {
        return content;
      } else if (Array.isArray(content)) {
        return new StreamsSequenceStream(
          content,
          this._onSubStreamError.bind(this)
        );
      } else {
        // Replace non-existent page content with empty content.
        return new NullStream();
      }
    } catch (error) {
      throw new Error(""Failed to get content stream: "" + error);
    }
  }",2025-03-17 13:20:51+01:00,d00482380af454d544324d927ec1af9e17ccb4a8
"    return this._parsedAnnotations.then(function (annotations) {

      const promises = [];

      for (const annotation of annotations) {

        promises.push(

          annotation

            .save(partialEvaluator, task, annotationStorage, changes)

            .catch(function (reason) {

              warn(

                ""save - ignoring annotation data during "" +

                  `""${task.name}"" task: ""${reason}"".`

              );

              return null;

            })

        );

      }

      return Promise.all(promises);

    });

  loadResources(keys) {

    this.resourcesPromise ||= this.pdfManager.ensure(this, ""resources"");

    return this.resourcesPromise.then(() => {

      const objectLoader = new ObjectLoader(this.resources, keys, this.xref);

      return objectLoader.load();

    });

  getOperatorList({
","async function parseAnnotations() {
  try {
    const annotations = await this._parsedAnnotations;
    const promises = [];
    for (const annotation of annotations) {
      promises.push(
        annotation
          .save(partialEvaluator, task, annotationStorage, changes)
          .catch((reason) => {
            warn(`save - ignoring annotation data during ""${task.name}"" task: ${reason}.`);
            return null;
          })
      );
    }
    await Promise.all(promises);
  } catch (error) {
    console.log(""Error parsing annotations:"", error);
  }
}",2025-03-17 13:20:51+01:00,d00482380af454d544324d927ec1af9e17ccb4a8
"      return partialEvaluator

        .getOperatorList({

          stream: contentStream,

          task,

          resources: this.resources,

          operatorList: opList,

        })

        .then(() => opList);

    return Promise.all([

    ]).then(function ([pageOpList, annotations, newAnnotations]) {

      if (newAnnotations) {

        // Some annotations can already exist (if it has the refToReplace

        // property). In this case, we replace the old annotation by the new

        // one.

        annotations = annotations.filter(

          a => !(a.ref && deletedAnnotations.has(a.ref))

        );

        for (let i = 0, ii = newAnnotations.length; i < ii; i++) {

          const newAnnotation = newAnnotations[i];

          if (newAnnotation.refToReplace) {

            const j = annotations.findIndex(

              a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)

            );

            if (j >= 0) {

              annotations.splice(j, 1, newAnnotation);

              newAnnotations.splice(i--, 1);

              ii--;

            }

        annotations = annotations.concat(newAnnotations);

        annotations.length === 0 ||

        intent & RenderingIntentFlag.ANNOTATIONS_DISABLE

        pageOpList.flush(/* lastChunk = */ true);

        return { length: pageOpList.totalLength };

      }

      const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),

        isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),

        intentAny = !!(intent & RenderingIntentFlag.ANY),

        intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),

        intentPrint = !!(intent & RenderingIntentFlag.PRINT);



      // Collect the operator list promises for the annotations. Each promise

      // is resolved with the complete operator list for a single annotation.

      const opListPromises = [];

      for (const annotation of annotations) {

        if (

          intentAny ||

          (intentDisplay &&

            annotation.mustBeViewed(annotationStorage, renderForms) &&

            annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||

          (intentPrint && annotation.mustBePrinted(annotationStorage))

        ) {

          opListPromises.push(

            annotation

              .getOperatorList(

                partialEvaluator,

                task,

                intent,

                annotationStorage

              )

              .catch(function (reason) {

                warn(

                  ""getOperatorList - ignoring annotation data during "" +

                    `""${task.name}"" task: ""${reason}"".`

                );

                return {

                  opList: null,

                  separateForm: false,

                  separateCanvas: false,

                };

              })

          );

        }

      return Promise.all(opListPromises).then(function (opLists) {

        let form = false,

          canvas = false;

        for (const { opList, separateForm, separateCanvas } of opLists) {

          pageOpList.addOpList(opList);

          form ||= separateForm;

          canvas ||= separateCanvas;

        }

        pageOpList.flush(

          /* lastChunk = */ true,

          /* separateAnnots = */ { form, canvas }

        );

        return { length: pageOpList.totalLength };

      });

    });
","async function renderPage(pdfDocument, pageIndex, intent) {
  const task = pdfDocument.getRenderTask({
    canvasContext: canvas.getContext('2d'),
    transform: [1, 0, 0, 1, 0, 0],
    viewport: pdfDocument.getPage(pageIndex).getViewport({ scale }),
  });

  await task.promise;
}",2025-03-17 13:20:51+01:00,d00482380af454d544324d927ec1af9e17ccb4a8
"  loadResources(keys, appearance) {

    return appearance.dict.getAsync(""Resources"").then(resources => {

      if (!resources) {

        return undefined;

      }



      const objectLoader = new ObjectLoader(resources, keys, resources.xref);

      return objectLoader.load().then(() => resources);

    });
","loadResources(keys, appearance) {

    return appearance.dict.getAsync(""Resources"").then(async (resources) => {

      if (!resources) {

        return undefined;

      }



      const objectLoader = new ObjectLoader(resources, keys, resources.xref);

      await objectLoader.load();

      return resources;

    });

  }",2025-05-06 15:28:36+02:00,62009ffa701a69f2ff179682169dae53d1d336b8
"function createIgnorer(ignorePath, withNodeModules) {

  return (!ignorePath

    ? Promise.resolve(null)

    : getFileContentOrNull(path.resolve(ignorePath))

  ).then(ignoreContent => _createIgnorer(ignoreContent, withNodeModules));
","async function createIgnorer(ignorePath, withNodeModules) {
  if (!ignorePath) {
    return null;
  }
  const ignoreContent = await getFileContentOrNull(path.resolve(ignorePath));
  return _createIgnorer(ignoreContent, withNodeModules);
}",2019-11-15 01:23:06+08:00,98ec2c4512014649e2c82d18b4f9e4163a0c1784
"function getFileInfo(filePath, opts) {

    return Promise.reject(

      new TypeError(

        `expect \`filePath\` to be a string, got \`${typeof filePath}\``

      )

  return createIgnorer(opts.ignorePath, opts.withNodeModules).then(ignorer =>

    _getFileInfo({

      ignorer,

      filePath: normalizeFilePath(filePath, opts.ignorePath),

      plugins: opts.plugins,

      resolveConfig: opts.resolveConfig,

      sync: false

    })

  );
","async function getFileInfo(filePath, opts) {
  if (typeof filePath !== 'string') {
    throw new TypeError(`Expect \`filePath\` to be a string, got \`${typeof filePath}\``);
  }
  const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);
  const normalizedFilePath = normalizeFilePath(filePath, opts.ignorePath);
  const plugins = opts.plugins;
  const resolveConfig = opts.resolveConfig;
  const sync = false;
  return _getFileInfo({ ignorer, filePath: normalizedFilePath, plugins, resolveConfig, sync });
}",2019-11-15 01:23:06+08:00,98ec2c4512014649e2c82d18b4f9e4163a0c1784
"function resolveConfigFile(filePath) {

  return load(filePath).then(result => {

    return result ? result.filepath : null;

  });
","function resolveConfigFile(filePath) {
  try {
    const result = await load(filePath);
    return result ? result.filepath : null;
  } catch (error) {
    console.log(error);
  }
}",2019-11-15 01:23:06+08:00,98ec2c4512014649e2c82d18b4f9e4163a0c1784
"const editorconfigAsyncNoCache = (filePath, config) => {

  return Promise.resolve(maybeParse(filePath, config, editorconfig.parse)).then(

    editorConfigToPrettier

  );

const editorconfigAsyncWithCache = mem(editorconfigAsyncNoCache);

const editorconfigSyncWithCache = mem(editorconfigSyncNoCache);
","\`\`\`javascript
const editorconfigAsyncNoCache = async (filePath, config) => {
  try {
    const maybeParse = await Promise.resolve(maybeParse(filePath, config, editorconfig.parse));
    return editorConfigToPrettier(maybeParse);
  } catch (err) {
    throw new Error(`Error parsing EditorConfig file: ${err}`);
  }
};
const editorconfigAsyncWithCache = mem(editorconfigAsyncNoCache);
const editorconfigSyncWithCache = mem(editorconfigSyncNoCache);
\`\`\`",2020-01-29 01:10:01+08:00,c493bdef8d1d7816e18627f2afd8a1952037c6a6
"  const { output } = bundleConfig;

  return bundler(bundleConfig, cache)

    .catch((error) => {

      console.log(FAIL + ""\n"");

      handleError(error);

    })

    .then((result) => {

      if (result.cached) {

        console.log(CACHED);

      } else {

        console.log(OK);

    });
","const { output } = bundleConfig;

  return bundler(bundleConfig, cache)
    .then((result) => {
      if (result.cached) {
        console.log(CACHED);
      } else {
        console.log(OK);
      }
      return result;
    })
    .catch((error) => {
      console.log(FAIL + ""\n"");
      handleError(error);
    });",2020-06-12 06:42:42+05:30,b3ea6799589d863972d858e24b4341530aa1df2e
"function logPromise(name, promise) {

  return promise

    .then((result) => {

      process.stdout.write(`${OK}\n`);

      return result;

    })

    .catch((err) => {

      process.stdout.write(`${FAIL}\n`);

      throw err;

    });

function runYarn(script) {

  return execa(""yarn"", [

    ""--silent"",

    ...(Array.isArray(script) ? script : [script]),

  ]).catch((error) => {

    throw new Error(`\`yarn ${script}\` failed\n${error.stdout}`);

  });
","async function logPromise(name, promise) {
  try {
    const result = await promise;
    process.stdout.write(`${OK}\n`);
    return result;
  } catch (err) {
    process.stdout.write(`${FAIL}\n`);
    throw err;
  }
}

async function runYarn(script) {
  try {
    const result = await execa(""yarn"", [""--silent"", ...(Array.isArray(script) ? script : [script])]);
    return result;
  } catch (error) {
    throw new Error(`\`yarn ${script}\` failed\n${error.stdout}`);
  }
}",2021-04-21 22:15:12+08:00,916693c066f0d215342d174eea870cd3fb887654
"function formatStdin(context) {

  const ignorer = createIgnorerFromContextOrDie(context);

  getStdin()

    .then((input) => {

      if (

        relativeFilepath &&

        ignorer.ignores(fixWindowsSlashes(relativeFilepath))

      ) {

        writeOutput(context, { formatted: input });

        return;

      }

      const options = getOptionsForFile(context, filepath);

      if (listDifferent(context, input, options, ""(stdin)"")) {

        return;

      }

      writeOutput(context, format(context, input, options), options);

    })

    .catch((error) => {

      handleError(context, relativeFilepath || ""stdin"", error);

    });

function formatFiles(context) {

  const ignorer = createIgnorerFromContextOrDie(context);
","Markdown
---

async function formatStdin(context) {

const ignorer = createIgnorerFromContextOrDie(context);

try {

  let input = await getStdin();

  if (

    relativeFilepath &&

    ignorer.ignores(fixWindowsSlashes(relativeFilepath))

  ) {

    writeOutput(context, { formatted: input });

    return;

  }

  const options = getOptionsForFile(context, filepath);

  if (listDifferent(context, input, options, ""(stdin)"")) {

    return;

  }

  writeOutput(context, format(context, input, options), options);

} catch (error) {

  handleError(context, relativeFilepath || ""stdin"", error);

}

async function formatFiles(context) {

const ignorer = createIgnorerFromContextOrDie(context);

try {

  let files = await globby(context.input, { absolute: true });

  for (let file of files) {

    if (ignorer.ignores(file)) continue;

    let input = await readFileAsync(file, 'utf8');

    const options = getOptionsForFile(context, file);

    if (listDifferent(context, input, options, file)) {

      continue;

    }

    writeOutput(context, format(context, input, options), options);

  }

} catch (error) {

  handleError(context, relativeFilepath || ""stdin"", error);

}",2021-05-11 06:50:50+08:00,6e71422548dd99522d86de9c2a25930e469ce5e4
"function getFileContentOrNull(filename) {

  return new Promise((resolve, reject) => {

    fs.readFile(filename, ""utf8"", (error, data) => {

      if (error && error.code !== ""ENOENT"") {

        reject(createError(filename, error));

      } else {

        resolve(error ? null : data);

      }

    });

  });
","async function getFileContentOrNull(filename) {
  try {
    const data = await fs.readFile(filename, ""utf8"");
    return data;
  } catch (error) {
    if (error.code !== ""ENOENT"") {
      throw createError(filename, error);
    } else {
      return null;
    }
  }
}",2021-05-16 12:42:15+08:00,90ea7e4a4f24adeb320dea79413fbdac402b1253
"    worker

      .format(code, options, { ast, doc, comments, reformat })

      .then((result) => this.setState(result));
","async function format() {
    const result = await worker.format(code, options, { ast, doc, comments, reformat });
    this.setState(result);
  }",2022-04-29 14:22:24+08:00,c6d6b258331cca8fa739514557bd5b1aac67199d
"  componentDidMount() {

    this.worker.getMetadata().then(({ supportInfo, version }) => {

      this.setState({

        loaded: true,

        availableOptions: supportInfo.options.map(augmentOption),

        version: fixPrettierVersion(version),

      });
","componentDidMount() {
    try {
      const { supportInfo, version } = await this.worker.getMetadata();
      this.setState({
        loaded: true,
        availableOptions: supportInfo.options.map(augmentOption),
        version: fixPrettierVersion(version),
      });
    } catch (error) {
      console.error(error);
    }
  }",2022-04-29 14:22:24+08:00,c6d6b258331cca8fa739514557bd5b1aac67199d
"    if (sync) {

      resolvedConfig = config.resolveConfig.sync(filePath);

    } else {

      return config.resolveConfig(filePath).then((resolvedConfig) => {

        fileInfo.inferredParser = getFileParser(

          resolvedConfig,

          filePath,

          plugins

        );

        return fileInfo;

      });

    }
","if (sync) {
  const resolvedConfig = config.resolveConfig.sync(filePath);
} else {
  try {
    const resolvedConfig = await config.resolveConfig(filePath);
    fileInfo.inferredParser = getFileParser(
      resolvedConfig,
      filePath,
      plugins
    );
    return fileInfo;
  } catch (error) {
    // handle error
  }
}",2022-05-05 19:15:08+08:00,34fadbe67d13df908023fb9a047eee1e90734aec
" * @template {Options} Opts

 * @param {Opts} opts

 * @return {Opts[""sync""] extends true ? SyncExplorer : Explorer}

function getExplorer(opts) {

  // Normalize opts before passing to a memoized function

  opts = { sync: false, cache: false, ...opts };

  return getExplorerMemoized(opts);

function _resolveConfig(filePath, opts, sync) {

    sync: Boolean(sync),

  /** @type {[any, any]} */

  const arr = [

  ];



  const unwrapAndMerge = ([result, editorConfigured]) => {

    const merged = {

      ...editorConfigured,

      ...mergeOverrides(result, filePath),

    };



    for (const optionName of [""plugins"", ""pluginSearchDirs""]) {

      if (Array.isArray(merged[optionName])) {

        merged[optionName] = merged[optionName].map((value) =>

          typeof value === ""string"" && value.startsWith(""."") // relative path

            ? path.resolve(path.dirname(result.filepath), value)

            : value

        );

      }

    }



    if (!result && !editorConfigured) {

      return null;

    }

    // We are not using this option

    delete merged.insertFinalNewline;

    return merged;

  if (loadOpts.sync) {

    return unwrapAndMerge(arr);

  return Promise.all(arr).then(unwrapAndMerge);

}



const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);

resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);
","```
Markdown
---

\`\`\`js
async function getExplorer(opts) {
  // Normalize opts before passing to a memoized function
  opts = { sync: false, cache: false, ...opts };
  return await getExplorerMemoized(opts);
}

async function _resolveConfig(filePath, opts, sync) {
  const unwrapAndMerge = async ([result, editorConfigured]) => {
    if (!result && !editorConfigured) {
      return null;
    }
    // We are not using this option
    delete merged.insertFinalNewline;
    return merged;
  };
  const arr = [
    result,
    editorConfigured,
  ];
  if (loadOpts.sync) {
    return unwrapAndMerge(arr);
  }
  return Promise.all(arr).then(unwrapAndMerge);
}

async function resolveConfig(filePath, opts) {
  await _resolveConfig(filePath, opts, false);
}

resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);
\`\`\`",2022-05-05 19:15:08+08:00,34fadbe67d13df908023fb9a047eee1e90734aec
"test(""API resolveConfig with no args"", () =>

  prettier.resolveConfig().then((result) => {

    expect(result).toEqual({});

  }));



test(""API resolveConfig.sync with no args"", () => {

  expect(prettier.resolveConfig.sync()).toEqual({});

});



test(""API resolveConfig with file arg"", () => {

  const file = path.resolve(path.join(__dirname, ""../cli/config/js/file.js""));

  return prettier.resolveConfig(file).then((result) => {

    expect(result).toMatchObject({

      tabWidth: 8,

    });

  });

test(""API resolveConfig.sync with file arg"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

test(""API resolveConfig with file arg and extension override"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/no-config/file.ts"")

  );

  return prettier.resolveConfig(file).then((result) => {

    expect(result).toMatchObject({

      semi: true,

    });

  });

});



test(""API resolveConfig.sync with file arg and extension override"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

test(""API resolveConfig with file arg and .editorconfig"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/editorconfig/file.js"")

  );

  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {

    expect(result).toMatchObject({

      useTabs: true,

      tabWidth: 8,

      printWidth: 100,

    });

  });

});



test(""API resolveConfig.sync with file arg and .editorconfig"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).toMatchObject({

test(""API resolveConfig.sync with file arg and .editorconfig (key = unset)"", () => {

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).not.toMatchObject({ tabWidth: ""unset"" });

});



test(""API resolveConfig with nested file arg and .editorconfig"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/editorconfig/lib/file.js"")

  );

  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {

    expect(result).toMatchObject({

      useTabs: false,

      tabWidth: 2,

      printWidth: 100,

    });

  });

test(""API resolveConfig.sync with nested file arg and .editorconfig"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).toMatchObject({

test(""API resolveConfig with nested file arg and .editorconfig and indent_size = tab"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/editorconfig/lib/indent_size=tab.js"")

  );

  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {

    expect(result).toMatchObject({

      useTabs: false,

      tabWidth: 8,

      printWidth: 100,

    });

  });

});



test(""API resolveConfig.sync with nested file arg and .editorconfig and indent_size = tab"", () => {

  expect(prettier.resolveConfig.sync(file)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(file, { editorconfig: true })

  ).toMatchObject({
","test(""API resolveConfig with no args"", async () => {
  const result = await prettier.resolveConfig();
  expect(result).toEqual({});
});

test(""API resolveConfig.sync with no args"", () => {
  expect(prettier.resolveConfig.sync()).toEqual({});
});

test(""API resolveConfig with file arg"", async () => {
  const file = path.resolve(path.join(__dirname, ""../cli/config/js/file.js""));
  const result = await prettier.resolveConfig(file);
  expect(result).toMatchObject({
    tabWidth: 8,
  });
});

test(""API resolveConfig.sync with file arg"", () => {
  const file = path.resolve(path.join(__dirname, ""../cli/config/js/file.js""));
  expect(prettier.resolveConfig.sync(file)).toMatchObject({
    tabWidth: 8,
  });
});

test(""API resolveConfig with file arg and extension override"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/no-config/file.ts"")
  );
  const result = await prettier.resolveConfig(file);
  expect(result).toMatchObject({
    semi: true,
  });
});

test(""API resolveConfig.sync with file arg and extension override"", () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/no-config/file.ts"")
  );
  expect(prettier.resolveConfig.sync(file)).toMatchObject({
    semi: true,
  });
});

test(""API resolveConfig with file arg and .editorconfig"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/file.js"")
  );
  const result = await prettier.resolveConfig(file, { editorconfig: true });
  expect(result).toMatchObject({
    useTabs: true,
    tabWidth: 8,
    printWidth: 100,
  });
});

test(""API resolveConfig.sync with file arg and .editorconfig"", () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/file.js"")
  );
  expect(prettier.resolveConfig.sync(file, { editorconfig: true })).toMatchObject({
    useTabs: true,
    tabWidth: 8,
    printWidth: 100,
  });
});

test(""API resolveConfig with nested file arg and .editorconfig"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/file.js"")
  );
  const result = await prettier.resolveConfig(file, { editorconfig: true });
  expect(result).toMatchObject({
    useTabs: false,
    tabWidth: 2,
    printWidth: 100,
  });
});

test(""API resolveConfig.sync with nested file arg and .editorconfig"", () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/file.js"")
  );
  expect(prettier.resolveConfig.sync(file, { editorconfig: true })).toMatchObject({
    useTabs: false,
    tabWidth: 2,
    printWidth: 100,
  });
});

test(""API resolveConfig with nested file arg and .editorconfig and indent_size = tab"", async () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/indent_size=tab.js"")
  );
  const result = await prettier.resolveConfig(file, { editorconfig: true });
  expect(result).toMatchObject({
    useTabs: false,
    tabWidth: 8,
    printWidth: 100,
  });
});

test(""API resolveConfig.sync with nested file arg and .editorconfig and indent_size = tab"", () => {
  const file = path.resolve(
    path.join(__dirname, ""../cli/config/editorconfig/lib/indent_size=tab.js"")
  );
  expect(prettier.resolveConfig.sync(file, { editorconfig: true })).toMatchObject({
    useTabs: false,
    tabWidth: 8,
    printWidth: 100,
  });
});",2022-05-05 19:15:08+08:00,34fadbe67d13df908023fb9a047eee1e90734aec
"  expect(prettier.resolveConfig.sync(doubleQuote)).toMatchObject({

test(""API resolveConfig removes $schema option"", () => {

  return prettier.resolveConfig(file).then((result) => {

    expect(result).toEqual({

      tabWidth: 42,

    });

  });

});



test(""API resolveConfig.sync removes $schema option"", () => {

  const file = path.resolve(

    path.join(__dirname, ""../cli/config/$schema/index.js"")

  );

  expect(prettier.resolveConfig.sync(file)).toEqual({

test(""API resolveConfig resolves relative path values based on config filepath"", () => {

  expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toMatchObject({

  expect(

    prettier.resolveConfig.sync(

  ).toMatchObject({

test(""API resolveConfig de-references to an external module"", () => {

  expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toEqual({
","test(""API resolveConfig removes $schema option"", () => {
  const file = path.join(__dirname, ""../cli/config/$schema/index.js"");
  expect(prettier.resolveConfig.sync(file)).toMatchObject({
    tabWidth: 42,
  });
});

test(""API resolveConfig.sync removes $schema option"", () => {
  const file = path.join(__dirname, ""../cli/config/$schema/index.js"");
  expect(prettier.resolveConfig.sync(file)).toEqual({
    tabWidth: 42,
  });
});

test(""API resolveConfig resolves relative path values based on config filepath"", () => {
  const file = `${currentDir}/index.js`;
  expect(prettier.resolveConfig.sync(file)).toMatchObject({
    tabWidth: 42,
  });
});

test(""API resolveConfig de-references to an external module"", () => {
  const file = `${currentDir}/index.js`;
  expect(prettier.resolveConfig.sync(file)).toEqual({
    tabWidth: 42,
  });
});",2022-05-05 19:15:08+08:00,34fadbe67d13df908023fb9a047eee1e90734aec
"var require_async5 = __commonJS({

    var stream_1 = require_stream3();

        this._reader = new stream_1.default(this._settings);

      read(task) {

        const entries = [];

        return new Promise((resolve, reject) => {

          const stream2 = this.api(root, task, options);

          stream2.once(""error"", reject);

          stream2.on(""data"", (entry) => entries.push(options.transform(entry)));

          stream2.once(""end"", () => resolve(entries));

        });
","var require_async5 = __commonJS({
  var stream_1 = require_stream3();
  this._reader = new stream_1.default(this._settings);

  async read(task) {
    const entries = [];

    try {
      const stream2 = this.api(root, task, options);
      stream2.on(""data"", (entry) => entries.push(options.transform(entry)));
      await new Promise((resolve, reject) => {
        stream2.once(""error"", reject);
        stream2.once(""end"", () => resolve(entries));
      });
    } catch (err) {
      throw err;
    }

    return entries;
  }
});",2022-12-23 22:45:45+09:00,08a51db63f34895c58471857cd55740a8f85d8ab
"    launchApp = function(appName, args, callback) {

        return new Promise((resolve) => {

            // if appName is an object and args is not set, then appName is actually args

            if (typeof appName === 'object' && !args) {

                args = appName;

                appName = undefined;

            }



            this.#postMessageWithCallback('launchApp', resolve, { app_name: appName, args });

        })
","async function launchApp(appName, args) {
  if (typeof appName === 'object' && !args) {
    args = appName;
    appName = undefined;
  }
  return this.#postMessageWithCallback('launchApp', { app_name: appName, args });
}",2024-09-01 22:38:40-04:00,18a24f614fe09423c953848d27e171361335bed4
"import { svelte } from '../helpers.js';

describe('preprocess', () => {

	it('preprocesses entire component', () => {

		const source = `

			<h1>Hello __NAME__!</h1>

		`;

		const expected = `

			<h1>Hello world!</h1>

		`;

		return svelte.preprocess(source, {

			markup: ({ content }) => {

				return {

					code: content.replace('__NAME__', 'world')

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses style', () => {

		const source = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: $brand;

				}

			</style>

		`;



		const expected = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: purple;

				}

			</style>

		`;



		return svelte.preprocess(source, {

			style: ({ content }) => {

				return {

					code: content.replace('$brand', 'purple')

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses style asynchronously', () => {

		const source = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: $brand;

				}

			</style>

		`;



		const expected = `

			<div class='brand-color'>$brand</div>



			<style>

				.brand-color {

					color: purple;

				}

			</style>

		`;



		return svelte.preprocess(source, {

			style: ({ content }) => {

				return Promise.resolve({

					code: content.replace('$brand', 'purple')

				});

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses script', () => {

		const source = `

			<script>

				console.log(__THE_ANSWER__);

			</script>

		`;



		const expected = `

			<script>

				console.log(42);

			</script>

		`;



		return svelte.preprocess(source, {

			script: ({ content }) => {

				return {

					code: content.replace('__THE_ANSWER__', '42')

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('preprocesses multiple matching tags', () => {

		const source = `

			<script>

				REPLACEME

			</script>

			<style>

				SHOULD NOT BE REPLACED

			</style>

			<script>

				REPLACEMETOO

			</script>

		`;



		const expected = `

			<script>

				replaceme

			</script>

			<style>

				SHOULD NOT BE REPLACED

			</style>

			<script>

				replacemetoo

			</script>

		`;



		return svelte.preprocess(source, {

			script: ({ content }) => {

				return {

					code: content.toLowerCase()

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('parses attributes', () => {

		const source = `

			<style type='text/scss' data-foo=""bar"" bool></style>

		`;



		const expected = `

			<style type='text/scss' data-foo=""bar"" bool>PROCESSED</style>

		`;



		return svelte.preprocess(source, {

			style: ({ attributes }) => {

				assert.deepEqual(attributes, {

					type: 'text/scss',

					'data-foo': 'bar',

					bool: true

				});

				return { code: 'PROCESSED' };

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});



	it('provides filename to processing hooks', () => {

		const source = `

			<h1>Hello __MARKUP_FILENAME__!</h1>

			<style>.red { color: __STYLE_FILENAME__; }</style>

			<script>console.log('__SCRIPT_FILENAME__');</script>

		`;



		const expected = `

			<h1>Hello file.html!</h1>

			<style>.red { color: file.html; }</style>

			<script>console.log('file.html');</script>

		`;



		return svelte.preprocess(source, {

			filename: 'file.html',

			markup: ({ content, filename }) => {

				return {

					code: content.replace('__MARKUP_FILENAME__', filename)

				};

			},

			style: ({ content, filename }) => {

				return {

					code: content.replace('__STYLE_FILENAME__', filename)

				};

			},

			script: ({ content, filename }) => {

				return {

					code: content.replace('__SCRIPT_FILENAME__', filename)

				};

			}

		}).then(processed => {

			assert.equal(processed.toString(), expected);

		});

	});

	it('ignores null/undefined returned from preprocessor', () => {

		const source = `

			<script>

				console.log('ignore me');

			</script>

		`;

		const expected = `

			<script>

				console.log('ignore me');

			</script>

		`;

		return svelte.preprocess(source, {

			script: () => null

		}).then(processed => {

			assert.equal(processed.toString(), expected);
","import { svelte } from '../helpers.js';

describe('preprocess', () => {
  it('preprocesses entire component', async () => {
    const source = `
      <h1>Hello __NAME__!</h1>
    `;
    const expected = `
      <h1>Hello world!</h1>
    `;
    const processed = await svelte.preprocess(source, {
      markup: ({ content }) => {
        return {
          code: content.replace('__NAME__', 'world'),
        };
      },
    });
    assert.equal(processed.toString(), expected);
  });

  it('preprocesses style', async () => {
    const source = `
      <div class='brand-color'>$brand</div>
      <style>
        .brand-color {
          color: $brand;
        }
      </style>
    `;
    const expected = `
      <div class='brand-color'>$brand</div>
      <style>
        .brand-color {
          color: purple;
        }
      </style>
    `;
    const processed = await svelte.preprocess(source, {
      style: ({ content }) => {
        return {
          code: content.replace('$brand', 'purple'),
        };
      },
    });
    assert.equal(processed.toString(), expected);
  });

  it('preprocesses style asynchronously', async () => {
    const source = `
      <div class='brand-color'>$brand</div>
      <style>
        .brand-color {
          color: $brand;
        }
      </style>
    `;
    const expected = `
      <div class='brand-color'>$brand</div>
      <style>
        .brand-color {
          color: purple;
        }
      </style>
    `;
    const processed = await svelte.preprocess(source, {
      style: ({ content }) => {
        return Promise.resolve({ code: content.replace('$brand', 'purple') });
      },
    });
    assert.equal(processed.toString(), expected);
  });

  it('preprocesses script', async () => {
    const source = `
      <script>
        console.log(__THE_ANSWER__);
      </script>
    `;
    const expected = `
      <script>
        console.log(42);
      </script>
    `;
    const processed = await svelte.preprocess(source, {
      script: ({ content }) => {
        return { code: content.replace('__THE_ANSWER__', '42') };
      },
    });
    assert.equal(processed.toString(), expected);
  });

  it('preprocesses multiple matching tags', async () => {
    const source = `
      <script>
        REPLACEME
      </script>
      <style>
        SHOULD NOT BE REPLACED
      </style>
      <script>
        REPLACEMETOO
      </script>
    `;
    const expected = `
      <script>
        replaceme
      </script>
      <style>
        SHOULD NOT BE REPLACED
      </style>
      <script>
        replacemetoo
      </script>
    `;
    const processed = await svelte.preprocess(source, {
      script: ({ content }) => {
        return { code: content.toLowerCase() };
      },
    });
    assert.equal(processed.toString(), expected);
  });

  it('parses attributes', async () => {
    const source = `
      <style type='text/scss' data-foo=""bar"" bool></style>
    `;
    const expected = `
      <style type='text/scss' data-foo=""bar"" bool>PROCESSED</style>
    `;
    const processed = await svelte.preprocess(source, {
      style: ({ attributes }) => {
        assert.deepEqual(attributes, {
          type: 'text/scss',
          'data-foo': 'bar',
          bool: true,
        });
        return { code: 'PROCESSED' };
      },
    });
    assert.equal(processed.toString(), expected);
  });

  it('provides filename to processing hooks', async () => {
    const source = `
      <h1>Hello __MARKUP_FILENAME__!</h1>
      <style>.red { color: __STYLE_FILENAME__; }</style>
      <script>console.log('__SCRIPT_FILENAME__');</script>
    `;
    const expected = `
      <h1>Hello file.html!</h1>
      <style>.red { color: file.html; }</style>
      <script>console.log('file.html');</script>
    `;
    const processed = await svelte.preprocess(source, {
      filename: 'file.html',
      markup: ({ content, filename }) => {
        return {
          code: content.replace('__MARKUP_FILENAME__', filename),
        };
      },
      style: ({ content, filename }) => {
        return {
          code: content.replace('__STYLE_FILENAME__', filename),
        };
      },
      script: ({ content, filename }) => {
        return {
          code: content.replace('__SCRIPT_FILENAME__', filename),
        };
      },
    });
    assert.equal(processed.toString(), expected);
  });

  it('ignores null/undefined returned from preprocessor', async () => {
    const source = `
      <script>
        console.log('ignore me');
      </script>
    `;
    const expected = `
      <script>
        console.log('ignore me');
      </script>
    `;
    const processed = await svelte.preprocess(source, {
      script: () => null,
    });
    assert.equal(processed.toString(), expected);
  });
});",2019-01-13 18:44:10-05:00,dcfe85ecdbe39f71138469a5faceb1fadf8b0c8f
"			})

				.then(bundle => bundle.generate({ format: 'iife', name: 'test' }))

				.then(result => {

					bundle = result.output[0].code;



					const nightmare = new Nightmare({ show: false });



					nightmare.on('console', (type, ...args) => {

						console[type](...args);

					});



					return nightmare

						.goto('http://localhost:6789')

						.evaluate(() => {

							return test(document.querySelector('main'));

						})

						.then(result => {

							if (result) console.log(result);

							return nightmare.end();

						})

						.catch(message => {

							console.log(addLineNumbers(bundle));

							return nightmare.end().then(() => {

								throw new Error(message);

							});

						});

				});
","})

		.then(bundle => bundle.generate({ format: 'iife', name: 'test' }))

		.then(result => {

			let bundle = result.output[0].code;



			const nightmare = new Nightmare({ show: false });



			nightmare.on('console', (type, ...args) => {

				console[type](...args);

			});



			return nightmare

				.goto('http://localhost:6789')

				.evaluate(() => {

					return test(document.querySelector('main'));

				})

				.then(result => {

					if (result) console.log(result);

					return nightmare.end();

				})

				.catch(message => {

					console.log(addLineNumbers(bundle));

					return nightmare.end().then(() => {

						throw new Error(message);

					});

				});

		});",2019-03-10 16:00:37-04:00,95649da5524c3a8dfd03b54bf85564d06ad52bb7
"fetch(`https://api.github.com/repos/sveltejs/svelte/stats/contributors`)

	.then(r => r.json())

	.then(contributors => {

		const munged = contributors

			.sort((a, b) => b.total - a.total)

			.map(({ author }) => ({ name: author.login, src: author.avatar_url }));

		const str = `[\n\t${munged.map(c => `{ name: '${c.name}', src: '${c.src}' }`).join(',\n\t')}\n]`;

		fs.writeFileSync(`../src/routes/_contributors.js`, `export default ${str};`);

	});
","fetch('https://api.github.com/repos/sveltejs/svelte/stats/contributors')
  .then(r => r.json())
  .then(async (contributors) => {
    const munged = contributors
      .sort((a, b) => b.total - a.total)
      .map(({ author }) => ({ name: author.login, src: author.avatar_url }));
    const str = `[${munged.map(c => `{ name: '${c.name}', src: '${c.src}' }`).join(',')}]`;
    fs.writeFileSync(`../src/routes/_contributors.js`, `export default ${str};`);
  });",2019-04-07 09:56:47-04:00,3f02d999cd7b2a746d277dc4defc7b56c0482afc
"let fulfil;

let thePromise = new Promise((f) => {

	fulfil = f;

});

	props: {

		thePromise

	test({ assert, component, target }) {

		fulfil(42);



		return thePromise

			.then(() => {

				assert.htmlEqual(

					target.innerHTML,

					`

					<p>the value is 42</p>

				`

				);



				let reject;



				thePromise = new Promise((f, r) => {

					reject = r;

				});



				component.thePromise = thePromise;



				assert.htmlEqual(

					target.innerHTML,

					`

					<p>loading...</p>

				`

				);



				reject(new Error('something broke'));



				return thePromise.catch(() => {});

			})

			.then(() => {

				assert.htmlEqual(

					target.innerHTML,

					`

					<p>oh no! something broke</p>

				`

				);

			});
","let fulfil;

let thePromise = new Promise((f) => {
  fulfil = f;
});

props: {
  thePromise
}

test({ assert, component, target }) {
  fulfil(42);

  try {
    await thePromise;
    assert.htmlEqual(
      target.innerHTML,
      `
        <p>the value is 42</p>
      `
    );

    let reject;

    thePromise = new Promise((f, r) => {
      reject = r;
    });

    component.thePromise = thePromise;

    assert.htmlEqual(
      target.innerHTML,
      `
        <p>loading...</p>
      `
    );

    reject(new Error('something broke'));

    return thePromise.catch(() => {});
  } catch (error) {
    assert.htmlEqual(
      target.innerHTML,
      `
        <p>oh no! something broke</p>
      `
    );
  }
}",2023-05-18 00:45:20+05:45,783bd9899e16276786d3fb6e96a59083e13efe7f
"export const requestResolvedSubtree = path => system => {

  const {

    errActions,

    fn: {

      resolveSubtree,

      AST: { getLineNumberForPath }

    },

    specSelectors,

    specActions,

  } = system

  const specStr = specSelectors.specStr()

  const currentValue = specSelectors.specResolvedSubtree(path)

  if(currentValue) {

    return

  }

  return resolveSubtree(specSelectors.specJson().toJS(), path)

    .then(({ spec, errors }) => {

      errActions.clear({

        type: ""thrown""

      })

            console.error(err)
","export const requestResolvedSubtree = async (path, system) => {
  const {
    errActions,
    fn: { resolveSubtree },
    specSelectors,
    specActions,
  } = system;
  const specStr = specSelectors.specStr();
  const currentValue = specSelectors.specResolvedSubtree(path);
  if (currentValue) return;
  try {
    const { spec, errors } = await resolveSubtree(specSelectors.specJson().toJS(), path);
    errActions.clear({ type: ""thrown"" });
    console.error(errors);
    return spec;
  } catch (err) {
    errActions.set({ type: ""thrown"", error: err });
    throw err;
  }
};",2018-02-23 22:25:28-08:00,ba1603a7e2caf4ab2b6ab6e9e98f78e17d2248ce
"			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

			//

			session.addEventListener( 'inputsourceschange', updateInputSources );

	function updateInputSources( event ) {
","await session.requestReferenceSpace(referenceSpaceType);

session.addEventListener('inputsourceschange', updateInputSources);

async function updateInputSources(event) {

}",2020-11-24 16:44:18+01:00,6ff1d1bd7183e9f4ec75075dccb6410a605de3d6
"			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

			//

			session.addEventListener( 'inputsourceschange', updateInputSources );

	function updateInputSources( event ) {
","async function updateInputSources( event ) {
    // Get the list of input sources from the event data
    const inputs = event.data;

    // Check if any new inputs have been added
    for ( let i = 0; i < inputs.length; i++ ) {
        const input = inputs[i];
        if ( input.gacing === 'true' ) {
            console.log( 'New input added:', input );
        }
    }
}",2021-01-16 21:37:11+00:00,edb93edd82d340f7a9b97c25665df21de27f38b0
"    return createLiveImage(base, info, name);

  const whiteLineMaterial = new THREE.LineBasicMaterial({

    color: 0xffffff,

    transparent: true,

    opacity: 0.5,

  });

  const blackLineMaterial = new THREE.LineBasicMaterial({

    color: 0x000000,

    transparent: true,

    opacity: 0.5,

  });



  function addGeometry(root, info, args = []) {

    return promise.then((geometryInfo) => {

      if (geometryInfo instanceof THREE.BufferGeometry ||

          geometryInfo instanceof THREE.Geometry) {

        const geometry = geometryInfo;

        geometryInfo = {

          geometry,

        };

      }

      const boxGeometry = geometryInfo.geometry || geometryInfo.lineGeometry;

      boxGeometry.computeBoundingBox();

      const centerOffset = new THREE.Vector3();

      boxGeometry.boundingBox.getCenter(centerOffset).multiplyScalar(-1);

      if (geometryInfo.geometry) {

        if (!info.material) {

          const material = new THREE.MeshPhongMaterial({

            flatShading: info.flatShading === false ? false : true,

            side: THREE.DoubleSide,

          });

          material.color.setHSL(Math.random(), .5, .5);

          info.material = material;

        }

        const mesh = new THREE.Mesh(geometryInfo.geometry, info.material);

        mesh.position.copy(centerOffset);

        root.add(mesh);

      }

      if (info.showLines !== false) {

        const lineMesh = new THREE.LineSegments(

          geometryInfo.lineGeometry || geometryInfo.geometry,

          geometryInfo.geometry ? whiteLineMaterial : blackLineMaterial);

        lineMesh.position.copy(centerOffset);

        root.add(lineMesh);

    });

  function updateGeometry(root, info, params) {

    addGeometry(root, info, Object.values(params)).then(() => {

      oldChildren.forEach((child) => {

        root.remove(child);

        child.geometry.dispose();

      });

  function createLiveImage(elem, info, name) {
","return createLiveImageAsync(base, info, name).then((result) => {
    const root = result[0];
    const info = result[1];
    const name = result[2];
    return addGeometryAsync(root, info, name).then(() => {
        oldChildren.forEach((child) => {
            root.remove(child);
            child.geometry.dispose();
        });
        updateGeometryAsync(root, info, params).then(() => {
            return createLiveImageAsync(base, info, name);
        });
    });
});",2020-03-26 18:16:42+09:00,3714df0b234c3b509a0e169b0621045eda4af5cf
"    addGeometry(root, info).then(() => {

      threejsLessonUtils.addDiagram(elem, {create: () => root});

    });
","async function addGeometry(root, info) {
  await addGeometry(root, info);
  threejsLessonUtils.addDiagram(elem, { create: () => root });
}",2020-03-26 18:16:42+09:00,3714df0b234c3b509a0e169b0621045eda4af5cf
"		const writer = this;



		Promise.all( this.pending ).then( function () {

			const buffers = writer.buffers;

			const json = writer.json;

			const options = writer.options;

			const extensionsUsed = writer.extensionsUsed;

			// Merge buffers.

			const blob = new Blob( buffers, { type: 'application/octet-stream' } );

			// Declare extensions.

			const extensionsUsedList = Object.keys( extensionsUsed );

			if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;

			// Update bytelength of the single buffer.

			if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

			if ( options.binary === true ) {

				// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

				const reader = new window.FileReader();

				reader.readAsArrayBuffer( blob );

				reader.onloadend = function () {

					// Binary chunk.

					const binaryChunk = getPaddedArrayBuffer( reader.result );

					const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

					binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

					binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );



					// JSON chunk.

					const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

					const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

					jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

					jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );



					// GLB header.

					const header = new ArrayBuffer( GLB_HEADER_BYTES );

					const headerView = new DataView( header );

					headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

					headerView.setUint32( 4, GLB_VERSION, true );

					const totalByteLength = GLB_HEADER_BYTES

						+ jsonChunkPrefix.byteLength + jsonChunk.byteLength

						+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;

					headerView.setUint32( 8, totalByteLength, true );



					const glbBlob = new Blob( [

						header,

						jsonChunkPrefix,

						jsonChunk,

						binaryChunkPrefix,

						binaryChunk

					], { type: 'application/octet-stream' } );



					const glbReader = new window.FileReader();

					glbReader.readAsArrayBuffer( glbBlob );

					glbReader.onloadend = function () {



						onDone( glbReader.result );



					};

			} else {

				if ( json.buffers && json.buffers.length > 0 ) {

					const reader = new window.FileReader();

					reader.readAsDataURL( blob );

					reader.onloadend = function () {

						const base64data = reader.result;

						json.buffers[ 0 ].uri = base64data;

						onDone( json );

					};

				} else {

					onDone( json );

				}

		} );
","const writer = this;

async function generateGlb() {
  try {
    const buffers = await Promise.all(writer.pending);
    const json = writer.json;
    const options = writer.options;
    const extensionsUsed = writer.extensionsUsed;
  
    // Merge buffers.
    const blob = new Blob(buffers, { type: 'application/octet-stream' });
  
    // Declare extensions.
    const extensionsUsedList = Object.keys(extensionsUsed);
    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;
  
    // Update bytelength of the single buffer.
    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;
  
    if (options.binary === true) {
      const reader = new window.FileReader();
      await reader.readAsArrayBuffer(blob);
      const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
      binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
      binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
  
      // JSON chunk.
      const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);
      const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
      jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
      jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
  
      // GLB header.
      const header = new ArrayBuffer(GLB_HEADER_BYTES);
      const headerView = new DataView(header);
      headerView.setUint32(0, GLB_HEADER_MAGIC, true);
      headerView.setUint32(4, GLB_VERSION, true);
      const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
      headerView.setUint32(8, totalByteLength, true);
  
      const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], { type: 'application/octet-stream' });
  
      const glbReader = new window.FileReader();
      await glbReader.readAsArrayBuffer(glbBlob);
      return glbReader.result;
    } else {
      if (json.buffers && json.buffers.length > 0) {
        const reader = new window.FileReader();
        await reader.readAsDataURL(blob);
        const base64data = reader.result;
        json.buffers[0].uri = base64data;
        return json;
      } else {
        return json;
      }
    }
  } catch (error) {
    console.log(error);
  }
}",2021-11-11 21:13:28+01:00,429b3d3f6e4aa25b528891bb297c1daac726b1c6
"			Promise.all( this.pending ).then( function () {



				const buffers = writer.buffers;

				const json = writer.json;

				const options = writer.options;

				const extensionsUsed = writer.extensionsUsed; // Merge buffers.



				const blob = new Blob( buffers, {

					type: 'application/octet-stream'

				} ); // Declare extensions.



				const extensionsUsedList = Object.keys( extensionsUsed );

				if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.



				if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;



				if ( options.binary === true ) {



					// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

					const reader = new window.FileReader();

					reader.readAsArrayBuffer( blob );

					reader.onloadend = function () {

						// Binary chunk.

						const binaryChunk = getPaddedArrayBuffer( reader.result );

						const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

						binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

						binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true ); // JSON chunk.

						const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

						const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

						jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

						jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true ); // GLB header.

						const header = new ArrayBuffer( GLB_HEADER_BYTES );

						const headerView = new DataView( header );

						headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

						headerView.setUint32( 4, GLB_VERSION, true );

						const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;

						headerView.setUint32( 8, totalByteLength, true );

						const glbBlob = new Blob( [ header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk ], {

							type: 'application/octet-stream'

						} );

						const glbReader = new window.FileReader();

						glbReader.readAsArrayBuffer( glbBlob );

						glbReader.onloadend = function () {

							onDone( glbReader.result );

						};

				} else {

					if ( json.buffers && json.buffers.length > 0 ) {

						const reader = new window.FileReader();

						reader.readAsDataURL( blob );

						reader.onloadend = function () {

							const base64data = reader.result;

							json.buffers[ 0 ].uri = base64data;

							onDone( json );

						};

					} else {

						onDone( json );

					}

			} );
","async function migrate() {
  try {
    const pending = this.pending;
    const writer = new BlobWriter();
    await Promise.all(pending);
    const buffers = writer.buffers;
    const json = writer.json;
    const options = writer.options;
    const extensionsUsed = writer.extensionsUsed;
    // Merge buffers.
    const blob = new Blob(buffers, { type: 'application/octet-stream' });
    // Declare extensions.
    const extensionsUsedList = Object.keys(extensionsUsed);
    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;
    // Update bytelength of the single buffer.
    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;
    if (options.binary === true) {
      const reader = new FileReader();
      await reader.readAsArrayBuffer(blob);
      // Binary chunk.
      const binaryChunk = getPaddedArrayBuffer(reader.result, 0x20);
      const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
      binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
      binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.
      const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);
      const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
      jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
      jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.
      const header = new ArrayBuffer(GLB_HEADER_BYTES);
      const headerView = new DataView(header);
      headerView.setUint32(0, GLB_HEADER_MAGIC, true);
      headerView.setUint32(4, GLB_VERSION, true);
      const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
      headerView.setUint32(8, totalByteLength, true);
      const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], { type: 'application/octet-stream' });
      const glbReader = new FileReader();
      await glbReader.readAsArrayBuffer(glbBlob);
      return glbReader.result;
    } else {
      if (json.buffers && json.buffers.length > 0) {
        const reader = new FileReader();
        await reader.readAsDataURL(blob);
        const base64data = reader.result;
        json.buffers[0].uri = base64data;
        return json;
      } else {
        return json;
      }
    }
  } catch (error) {
    console.error(error);
  }
}",2021-11-15 05:37:14-05:00,9c57b2e117e7e615cf8c9645fad90e4ad8ce6757
"			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {



				const times = new BigUint64Array( resultBuffer.getMappedRange() );

				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;



				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();

			} );
","await resultBuffer.mapAsync(GPUMapMode.READ);

const times = new BigUint64Array(resultBuffer.getMappedRange());
const duration = Number(times[1] - times[0]) / 1000000;

this.renderer.info.updateTimestamp(type, duration);
resultBuffer.unmap();",2025-01-10 15:36:29+08:00,5fb35c77b98b0c3d438100035a1e8dafeca5eb2a
"			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

				const times = new BigUint64Array( resultBuffer.getMappedRange() );

				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;

				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();





			} );
","async function renderLoop() {
  await resultBuffer.mapAsync(GPUMapMode.READ);

  const times = new BigUint64Array(resultBuffer.getMappedRange());

  const duration = Number(times[1] - times[0]) / 1000000;

  this.renderer.info.updateTimestamp(type, duration);

  resultBuffer.unmap();
}",2025-01-10 12:04:38+01:00,0a7d33cbfd6c6b913b80d5ddcb15dbb2198606ce
"			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

				const times = new BigUint64Array( resultBuffer.getMappedRange() );

				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;

				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();





			} );
","async function() {
  const resultBuffer = this.renderer.getGPU().createBuffer(this.renderer.info.gpuSize);
  await resultBuffer.mapAsync(GPUMapMode.READ);
  const times = new BigUint64Array(resultBuffer.getMappedRange());
  const duration = Number(times[1] - times[0]) / 1000000;
  this.renderer.info.updateTimestamp(type, duration);
  resultBuffer.unmap();
}",2025-01-10 12:04:38+01:00,0a7d33cbfd6c6b913b80d5ddcb15dbb2198606ce
"function loadNoteToEditor(noteId) {

    $.get(baseApiUrl + 'notes/' + noteId).then(note => {

        globalCurrentNote = note;

        globalCurrentNoteLoadTime = Math.floor(new Date().getTime() / 1000);

        if (newNoteCreated) {

            newNoteCreated = false;

            $(""#note-title"").focus().select();

        }

        handleEncryption(note.detail.encryption > 0, false, () => {

            $(""#note-detail-wrapper"").show();

            // this may fal if the dialog has not been previously opened

            try {

                $(""#encryption-password-dialog"").dialog('close');

            }

            catch(e) {}

            $(""#encryption-password"").val('');

            decryptNoteIfNecessary(note);

            $(""#note-title"").val(note.detail.note_title);

            noteChangeDisabled = true;

            // Clear contents and remove all stored history. This is to prevent undo from going across notes

            $('#note-detail').summernote('reset');

            $('#note-detail').summernote('code', note.detail.note_text);

            document.location.hash = noteId;

            addRecentNote(noteId, note.detail.note_id);

            noteChangeDisabled = false;

            setNoteBackgroundIfEncrypted(note);

        });

    });

function loadNote(noteId, callback) {

    $.get(baseApiUrl + 'notes/' + noteId).then(note => {

        if (note.detail.encryption > 0 && !isEncryptionAvailable()) {

            return;

        }

        decryptNoteIfNecessary(note);

        callback(note);

    });
","async function loadNoteToEditor(noteId) {
  try {
    const response = await fetch(`${baseApiUrl}notes/${noteId}`);
    const note = await response.json();
    globalCurrentNote = note;
    globalCurrentNoteLoadTime = Math.floor(new Date().getTime() / 1000);
    if (newNoteCreated) {
      newNoteCreated = false;
      $(""#note-title"").focus().select();
    }
    handleEncryption(note.detail.encryption > 0, false, () => {
      $(""#note-detail-wrapper"").show();
      // this may fal if the dialog has not been previously opened
      try {
        $(""#encryption-password-dialog"").dialog('close');
      } catch (e) {}
      $(""#encryption-password"").val('');
      decryptNoteIfNecessary(note);
      $(""#note-title"").val(note.detail.note_title);
      noteChangeDisabled = true;
      // Clear contents and remove all stored history. This is to prevent undo from going across notes
      $('#note-detail').summernote('reset');
      $('#note-detail').summernote('code', note.detail.note_text);
      document.location.hash = noteId;
      addRecentNote(noteId, note.detail.note_id);
      noteChangeDisabled = false;
      setNoteBackgroundIfEncrypted(note);
    });
  } catch (error) {
    console.log(error);
  }
}",2017-11-03 20:01:32-04:00,702d47e6b0b1c71ead1111c1d3952fbaf86abf2a
"    encryptionPasswordFormEl.submit(() => {

        getDataKey(password).then(key => {

            dialogEl.dialog(""close"");



            dataKey = key;

            decryptTreeItems();

            if (encryptionDeferred !== null) {

                encryptionDeferred.resolve();

                encryptionDeferred = null;

            }

        })

            .catch(reason => {

                console.log(reason);

                error(reason);

            });

        return false;

    });
","encryptionPasswordFormEl.submit(async () => {

        try {

            const key = await getDataKey(password);

            dialogEl.dialog(""close"");



            dataKey = key;

            decryptTreeItems();

            if (encryptionDeferred !== null) {

                encryptionDeferred.resolve();

                encryptionDeferred = null;

            }

        } catch (reason) {

            console.log(reason);

            error(reason);

        }

        return false;

    });",2017-11-08 22:33:08-05:00,4efa00f36bf435f49180a7900a9a00406651a49f
"    server.get('recent-notes').then(result => {

    });
",const result = await server.get('recent-notes');,2017-12-03 10:42:23-05:00,34f1eb930c01b6c34eaa18b0a514bc6da77acbf8
"            server.get('notes?search=' + searchText).then(resp => {

                // Pass a string to perform case insensitive matching

                getTree().filterBranches(node => {

                    return resp.includes(node.data.note_id);

                });

            });
","server.get('notes?search=' + searchText).then(async (resp) => {

    // Pass a string to perform case insensitive matching

    await getTree().filterBranches(node => {

      return resp.includes(node.data.note_id);

    });

  });",2018-01-15 20:54:22-05:00,7ea23586fe04814a9780e70dd0b7808e6620d98d
"    function loadTree() {

        return server.get('tree').then(resp => {

            startNotePath = resp.start_note_path;

            if (document.location.hash) {

                startNotePath = getNotePathFromAddress();

            }

            return prepareNoteTree(resp.notes);

        });
","async function loadTree() {
  const resp = await server.get('tree');
  startNotePath = resp.start_note_path;
  if (document.location.hash) {
    startNotePath = getNotePathFromAddress();
  }
  return prepareNoteTree(resp.notes);
}",2018-02-12 23:53:00-05:00,0e9473119ebd0bcfd77eaf78e27ab33827b33586
"$form.submit(() => {

    server.put('tree/' + branchId + '/set-prefix', {

        prefix: prefix

    }).then(() => treeService.setPrefix(branchId, prefix));
","$form.submit(async () => {

    await server.put('tree/' + branchId + '/set-prefix', {

        prefix: prefix

    });

    treeService.setPrefix(branchId, prefix);

});",2018-03-27 22:42:46-04:00,b10b0048f31e7ec5b828aa4c86d070ad8bf08115
"$(document).ready(() => {

    server.get('migration').then(result => {

        const appDbVersion = result.app_dbVersion;

        const dbVersion = result.dbVersion;

        if (appDbVersion === dbVersion) {

            $(""#up-to-date"").show();

        }

        else {

            $(""#need-to-migrate"").show();

            $(""#app-db-version"").html(appDbVersion);

            $(""#db-version"").html(dbVersion);

        }

    });
","async function onReady() {
    try {
        const result = await server.get('migration');
        const appDbVersion = result.app_dbVersion;
        const dbVersion = result.dbVersion;
        if (appDbVersion === dbVersion) {
            $(""#up-to-date"").show();
        } else {
            $(""#need-to-migrate"").show();
            $(""#app-db-version"").html(appDbVersion);
            $(""#db-version"").html(dbVersion);
        }
    } catch (error) {
        console.log(error);
    }
}",2018-04-05 23:17:19-04:00,e827ddffb9279a0dcd67d62efd0a38d280cb3e91
"            $.post('/api/setup/sync-from-server', {

            }).then(() => {

                window.location.replace(""/"");

            }).catch((err) => {

                alert(""Error, see dev console for details."");

                console.error(err);
","async function setupSyncFromServer() {
  try {
    await $.post('/api/setup/sync-from-server', {});
    window.location.replace(""/"");
  } catch (err) {
    alert(""Error, see dev console for details."");
    console.error(err);
  }
}",2018-07-23 21:15:32+02:00,1fe7c62f5a90e8dbf6e93f268069dbf87fc59d74
"    exportService.importIntoNote(currentNode.data.noteId).then(() => {

        $dialog.modal('hide');

    });
","exportService.importIntoNote(currentNode.data.noteId)
  .then(() => $dialog.modal('hide'))
  .catch((error) => console.log(error));",2019-02-10 15:33:56+01:00,51175e3676ab98a678e49d9d17c7ab1cf1630bb9
"function showDialog() {

    server.get('sql/schema').then(tables => {

        $tables.empty();



        for (const table of tables) {

            const $tableLink = $('<a href=""javascript:"">').text(table.name);



            const $columns = $(""<table>"");



            for (const column of table.columns) {

                $columns.append(

                    $(""<tr>"")

                        .append($(""<td>"").text(column.name))

                        .append($(""<td>"").text(column.type))

                );

            }



            $tableLink

                .attr(""title"", $columns.html())

                .tooltip({ html: true })

                .click(() => codeEditor.setValue(""SELECT * FROM "" + table.name + "" LIMIT 100""));



            $tables.append($tableLink).append("" "");

        }

    });


","async function showDialog() {
  const tables = await server.get('sql/schema');
  $tables.empty();
  for (const table of tables) {
    const $tableLink = $('<a href=""javascript:"">').text(table.name);
    const $columns = $(""<table>"");
    for (const column of table.columns) {
      $columns.append(
        $(""<tr>"")
          .append($(""<td>"").text(column.name))
          .append($(""<td>"").text(column.type))
      );
    }
    $tableLink
      .attr(""title"", $columns.html())
      .tooltip({ html: true })
      .click(() => codeEditor.setValue(`SELECT * FROM ${table.name} LIMIT 100`));
    $tables.append($tableLink).append("" "");
  }
}",2019-02-13 23:27:00+01:00,dad47d115f010cff18239b787e80b76c5fea2b81
"        libraryLoader.requireLibrary(libraryLoader.SORTABLE).then(() => {

            new Sortable(this.$widgetsEnabled[0], {

                group: 'widgets',

                handle: '.handle',

                animation: 150

            });

            new Sortable(this.$widgetsDisabled[0], {

                group: 'widgets',

                handle: '.handle',

                animation: 150
","libraryLoader.requireLibrary(libraryLoader.SORTABLE).then(() => {
  new Sortable(this.$widgetsEnabled[0], {
    group: 'widgets',
    handle: '.handle',
    animation: 150,
  });
  new Sortable(this.$widgetsDisabled[0], {
    group: 'widgets',
    handle: '.handle',
    animation: 150,
  });
});",2019-08-22 22:14:01+02:00,b84542064cd4d0615f298f9f9ef68690c8fe92a6
"    // code below shouldn't be necessary normally, however there's some problem with interaction with context menu plugin

    // after opening context menu, standard shortcuts don't work, but they are detected here

    // so we essentially takeover the standard handling with our implementation.

    ""left"": node => {

        node.navigate($.ui.keyCode.LEFT, true).then(treeService.clearSelectedNodes);



        return false;

    },

    ""right"": node => {

        node.navigate($.ui.keyCode.RIGHT, true).then(treeService.clearSelectedNodes);

    },

    ""up"": node => {

        node.navigate($.ui.keyCode.UP, true).then(treeService.clearSelectedNodes);

        return false;

    },

    ""down"": node => {

        node.navigate($.ui.keyCode.DOWN, true).then(treeService.clearSelectedNodes);

        return false;

    },

    ""ctrl+shift+s"": node => {

        searchNoteService.searchInSubtree(node.data.noteId);

        return false;

};

export default keyBindings;
","const keyBindings = {
     ""left"": async (node) => {
       await node.navigate($.ui.keyCode.LEFT, true);
       treeService.clearSelectedNodes();
       return false;
     },
     ""right"": async (node) => {
       await node.navigate($.ui.keyCode.RIGHT, true);
       treeService.clearSelectedNodes();
       return false;
     },
     ""up"": async (node) => {
       await node.navigate($.ui.keyCode.UP, true);
       treeService.clearSelectedNodes();
       return false;
     },
     ""down"": async (node) => {
       await node.navigate($.ui.keyCode.DOWN, true);
       treeService.clearSelectedNodes();
       return false;
     },
     ""ctrl+shift+s"": async (node) => {
       searchNoteService.searchInSubtree(node.data.noteId);
       return false;
     },
   };
   
   export default keyBindings;",2019-11-21 22:24:07+01:00,465c3b87a76f5396d0e2fd3dc69330b8887be847
"        server.put('options', opts).then(() => {

            toastService.showPersistent({

                id: ""options-change-saved"",

                title: ""Options status"",

                message: ""Options change have been saved."",

                icon: ""slider"",

                closeAfter: 2000

            })
","server.put('options', opts).then(() => {
    toastService.showPersistent({
        id: ""options-change-saved"",
        title: ""Options status"",
        message: ""Options change have been saved."",
        icon: ""slider"",
        closeAfter: 2000,
    });
});",2022-11-20 23:20:42+01:00,bcb3a707f403e711c4a1bbe89deba313c34d7ae3
"import froca from ""../../services/froca.js"";



// FIXME: this widget might not be useful anymore

    targetNote(noteId) {

        froca.getNote(noteId).then(note => {

            if (!note) {

                console.log(`Note ${noteId} has not been found. This might happen on the first run before the target note is created.`);



                if (!this.retried) {

                    this.retried = true;



                    setTimeout(() => this.targetNote(noteId), 15000); // should be higher than timeout for checkHiddenSubtree

                }

                return;

            }

            this.icon(note.getIcon());

            this.title(() => {

                const n = froca.getNoteFromCache(noteId);



                // always fresh, always decoded (when protected session is available)

                return n.title;

            });



            this.refreshIcon();

        });

        this.onClick(() => appContext.tabManager.openTabWithNoteWithHoisting(noteId, true));

        return this;
","import froca from ""../../services/froca.js"";

async function targetNote(noteId) {
    try {
        const note = await froca.getNote(noteId);
        if (!note) {
            console.log(`Note ${noteId} has not been found. This might happen on the first run before the target note is created.`);
            if (!this.retried) {
                this.retried = true;
                setTimeout(() => this.targetNote(noteId), 15000); // should be higher than timeout for checkHiddenSubtree
            }
        } else {
            this.icon(note.getIcon());
            this.title(() => {
                const n = froca.getNoteFromCache(noteId);
                return n.title;
            });
            this.refreshIcon();
            appContext.tabManager.openTabWithNoteWithHoisting(noteId, true);
        }
    } catch (error) {
        console.log(""Error in targetNote"", error);
    }
}

export default targetNote;",2022-12-19 23:19:47+01:00,8c4dda45eff76887b6690eb3f67dba35456548c4
"var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {

    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }

    return new (P || (P = Promise))(function (resolve, reject) {

        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }

        function rejected(value) { try { step(generator[""throw""](value)); } catch (e) { reject(e); } }

        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }

        step((generator = generator.apply(thisArg, _arguments || [])).next());

    });

};

    return function (html) {

        return __awaiter(this, void 0, void 0, function* () {

            const manifestJson = dist_1.parseManifestJsonOnce(process.env.UNI_INPUT_DIR);

            const title = ((_a = manifestJson.h5) === null || _a === void 0 ? void 0 : _a.title) || manifestJson.name || '';

            return html.replace(/<title>(.*?)<\/title>/, `<title>${title}</title>`);

        });
","const __awaiter = (this && this.__awaiter) || function(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function(resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
    function rejected(value) { try { step(generator[""throw""](value)); } catch (e) { reject(e); } }
    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

return function(html) {
  return __awaiter(this, void 0, void 0, async function() {
    const manifestJson = dist_1.parseManifestJsonOnce(process.env.UNI_INPUT_DIR);
    const title = ((_a = manifestJson.h5) === null || _a === void 0 ? void 0 : _a.title) || manifestJson.name || '';
    return html.replace(/<title>(.*?)<\/title>/, `<title>${title}</title>`);
  });
}",2021-08-04 11:50:18+08:00,96a868a4de206af9466cbea9ab84300f47842f89
"var __async = (__this, __arguments, generator) => {

  return new Promise((resolve, reject) => {

    var fulfilled = (value) => {

      try {

        step(generator.next(value));

      } catch (e2) {

        reject(e2);

      }

    };

    var rejected = (value) => {

      try {

        step(generator.throw(value));

      } catch (e2) {

        reject(e2);

      }

    };

    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);

    step((generator = generator.apply(__this, __arguments)).next());

  });

};

  (_0, _1) => __async(void 0, [_0, _1], function* (_, { resolve, reject }) {

      const data = yield navigator.clipboard.readText();

  })

  (_0, _1) => __async(void 0, [_0, _1], function* ({ data }, { resolve, reject }) {

      yield navigator.clipboard.writeText(data);

  }),
","var async = (this, arguments, generator) => {

  return new Promise((resolve, reject) => {

    var fulfilled = (value) => {

      try {

        step(generator.next(value));

      } catch (e2) {

        reject(e2);

      }

    };

    var rejected = (value) => {

      try {

        step(generator.throw(value));

      } catch (e2) {

        reject(e2);

      }

    };

    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);

    step((generator = generator.apply(this, arguments)).next());

  });

};

async(_0, _1) => {

      const data = await navigator.clipboard.readText();

},

async(_0, _1) => {

      await navigator.clipboard.writeText(data);

});",2022-10-08 14:21:26+08:00,7a479da856f34e7e247c9761dd67e195034c2df2
"exports.mssqlQuery = function (connectionString, query) {

    return new Promise((resolve, reject) => {

        mssql.connect(connectionString).then(pool => {

            return pool.request()

                .query(query);

        }).then(result => {

            resolve(result);

        }).catch(err => {

            reject(err);

        }).finally(() => {

            mssql.close();

        });

    });
","exports.mssqlQuery = async (connectionString, query) => {
  try {
    const pool = await mssql.connect(connectionString);
    const result = await pool.request().query(query);
    return result;
  } catch (err) {
    throw err;
  } finally {
    await mssql.close();
  }
};",2023-01-01 22:27:14+08:00,39ac9b887e0fbf98b0c53d1c37b75383d6458ecf
"const { warn, error } = require('./util/log')

program

  .usage('<app-name>')

  .parse(process.argv)



const projectName = program.args[0]

if (!projectName) {

  warn(`\n  Please provide an app name.`)

  program.outputHelp()

  process.exit(1)

}

const createGenerator = (id, requirePath = id) => ({

  id,

  apply: require(requirePath)

})

const builtInGenerators = fs

  .readdirSync(path.resolve(__dirname, './generators'))

  .filter(dir => dir.charAt(0) !== '.')

  .map(id => createGenerator(id, `./generators/${id}`))

debug(builtInGenerators)

const installedGenerators = resolveInstalledGenerators().map(id => {

  return createGenerator(id)

})

const targetDir = path.resolve(process.cwd(), projectName)

const creator = new Creator(projectName, builtInGenerators.concat(installedGenerators))

creator

  .create(targetDir)

  .then(() => {

    // TODO: log instructions

  })

  .catch(error)
","const { warn, error } = require('./util/log')
const program = require('commander')
const path = require('path')
const fs = require('fs')
const debug = require('debug')('create-react-app:index')

async function resolveInstalledGenerators() {
  try {
    const generatorDir = path.resolve(process.cwd(), 'generators');
    return (await fs.promises.readdir(generatorDir)).filter((dir) => dir.charAt(0) !== '.')
  } catch (e) {
    error('Error resolving installed generators', e);
    process.exit(1);
  }
}

async function createApp(projectName, targetDir) {
  try {
    const builtInGenerators = (await fs.promises.readdir(path.resolve(__dirname, './generators')))
      .filter((dir) => dir.charAt(0) !== '.')
      .map((id) => createGenerator(id, `./generators/${id}`));
    const installedGenerators = await resolveInstalledGenerators().map((id) => {
      return createGenerator(id);
    });
    const creator = new Creator(projectName, builtInGenerators.concat(installedGenerators));
    await creator.create(targetDir);
  } catch (e) {
    error('Error creating app', e);
  }
}

async function main() {
  const program = require('commander');
  const projectName = program.args[0];
  if (!projectName) {
    warn(`\n  Please provide an app name.`);
    program.outputHelp();
    process.exit(1);
  }
  await createApp(projectName, path.resolve(process.cwd(), projectName));
}

main()
  .then(() => {
    // TODO: log instructions
  })
  .catch((e) => {
    error('Error creating app', e);
  });",2017-12-28 13:06:17-05:00,9fc43f8fa51f5a5d1c36d07ea34db0f042264316
"  const chalk = require('chalk')



  function run (command, args, rawArgs) {

    removeArg(rawArgs, 'url')

    removeArg(rawArgs, 'mode')



    const serverPromise = args.url

      ? Promise.resolve({ url: args.url })

      : api.service.run('serve')



    return serverPromise.then(({ url, server }) => {

      const { info } = require('@vue/cli-shared-utils')

      info(`Starting e2e tests...`)



      const cyArgs = [

        command, // open or run

        '--config', `baseUrl=${url}`,

        ...rawArgs

      ]



      const execa = require('execa')

      const cypressBinPath = require.resolve('cypress/bin/cypress')

      const runner = execa(cypressBinPath, cyArgs, { stdio: 'inherit' })

      if (server) {

        runner.on('exit', () => server.close())

        runner.on('error', () => server.close())

      }



      if (process.env.VUE_CLI_TEST) {

        runner.on('exit', code => {

          process.exit(code)

        })

      }



      return runner

    })

  }



  const commandOptions = {

    '--mode': 'specify the mode the dev server should run in. (default: production)',

    '--url': 'run e2e tests against given url instead of auto-starting dev server'

  }



  api.registerCommand('e2e', {

    description: 'run e2e tests headlessly with `cypress run`',

    usage: 'vue-cli-service e2e [options]',

    options: Object.assign({

      '-s, --spec': 'runs a specific spec file. defaults to ""all""'

    }, commandOptions),

  }, (args, rawArgs) => run('run', args, rawArgs))

  api.registerCommand('e2e:open', {

    description: 'run e2e tests in interactive mode with `cypress open`',

    usage: 'vue-cli-service e2e:open [options]',

    options: commandOptions,

    details:

      `All Cypress CLI options are supported:\n` +

      chalk.yellow(`https://docs.cypress.io/guides/guides/command-line.html#cypress-open`)

  }, (args, rawArgs) => run('open', args, rawArgs))

  e2e: 'production',

  'e2e:open': 'production'
","const chalk = require('chalk');

function removeArg(rawArgs, argName) {
  const index = rawArgs.indexOf(argName);
  if (index > -1) {
    return rawArgs.splice(index, 1);
  }
}

async function run(command, args, rawArgs) {
  removeArg(rawArgs, 'url');
  removeArg(rawArgs, 'mode');

  const server = await (args.url ? { url: args.url } : api.service.run('serve'));
  const { info } = require('@vue/cli-shared-utils');

  if (server) {
    info(`Starting e2e tests...`);
  }

  const cyArgs = [command, '--config', `baseUrl=${url}`, ...rawArgs];
  const execa = require('execa');
  const cypressBinPath = require.resolve('cypress/bin/cypress');
  const runner = await execa(cypressBinPath, cyArgs, { stdio: 'inherit' });

  if (server) {
    runner.on('exit', () => server.close());
    runner.on('error', () => server.close());
  }

  if (process.env.VUE_CLI_TEST) {
    runner.on('exit', code => {
      process.exit(code);
    });
  }

  return runner;
}

const commandOptions = {
  '--mode': 'specify the mode the dev server should run in. (default: production)',
  '--url': 'run e2e tests against given url instead of auto-starting dev server'
};

api.registerCommand('e2e', {
  description: 'run e2e tests headlessly with `cypress run`',
  usage: 'vue-cli-service e2e [options]',
  options: Object.assign({ '-s, --spec': 'runs a specific spec file. defaults to ""all""' }, commandOptions),
}, (args, rawArgs) => run('run', args, rawArgs));

api.registerCommand('e2e:open', {
  description: 'run e2e tests in interactive mode with `cypress open`',
  usage: 'vue-cli-service e2e:open [options]',
  options: commandOptions,
  details:
    `All Cypress CLI options are supported:\n` + chalk.yellow(`https://docs.cypress.io/guides/guides/command-line.html#cypress-open`)
}, (args, rawArgs) => run('open', args, rawArgs));",2018-05-01 18:15:25-04:00,69ebd800a2cd0726aa4bbeb1bdb3ade3bc0c0c4f
"function list (base, context) {

  return new Promise((resolve, reject) => {

    fs.readdir(base, 'utf8', (err, files) => {

      if (err) {

        reject(err)

      } else {

        resolve(files.map(

          file => ({

            path: path.join(base, file),

            name: file

          })

        ).filter(

          file => fs.statSync(file.path).isDirectory()

        ))

      }

  })
","async function list (base, context) {
  try {
    const files = await fs.promises.readdir(base, 'utf8');
    return files.map((file) => ({
      path: path.join(base, file),
      name: file
    })).filter((file) => fs.statSync(file.path).isDirectory());
  } catch (err) {
    throw err;
  }
}",2018-05-02 17:18:01+02:00,d2d2f7f346cd0a4faf24f754817e07163365b6e5
"function deleteFolder (file) {

  return new Promise((resolve, reject) => {

    rimraf(file, err => {

      if (err) {

        reject(err)

      } else {

        resolve()

      }

    })

  })
","function deleteFolder(file) {
	return new Promise((resolve, reject) => {
		rimraf(file, (err) => {
			if (err) {
				reject(err);
			} else {
				resolve();
			}
		});
	});
}",2018-05-02 17:18:01+02:00,d2d2f7f346cd0a4faf24f754817e07163365b6e5
