texto_original_nao_capturado
"async function findMongoPids(dbDir = null, port = null) {
try{
const psScript = 'ps ax';
if (process.platform === 'darwin') {
psScript = 'if type pgrep >/dev/null 2>&1; then pgrep -lf mongod; test ""$?"" -eq 0 -o ""$?"" -eq 1; else ps ax; fi';
}
const {
LANG = 'en_US.UTF-8',
LC_ALL = LANG,
LANGUAGE = LANG,
...env
} = process.env;
Object.assign(env, {
LANG,
LC_ALL,
LANGUAGE
});
const result = await execAsync(psScript, { env, maxBuffer: 1024 * 1024 * 10 });
const pids = [];
result.stdout.split('\n').forEach((line) => {
const m = line.match(/^\s*(\d+).+mongod .+--port (\d+) --dbpath (.+(?:\/|\\)db)/);
if (m && m.length === 4) {
const foundPid = parseInt(m[1], 10);
const foundPort = parseInt(m[2], 10);
const foundPath = m[3];
if ((!port || port === foundPort) && (!dbDir || dbDir === foundPath)) {
pids.push({ pid: foundPid, port: foundPort, dbDir: foundPath });
}
}
});
return pids;
} catch (error) {
throw new Error(`Couldn't run ps ax: ${error}`);
}
}"
"
This script uses the `puppeteer` library to automate the process of generating a set of screenshots for each available operation in the online tool. The screenshot generation process involves opening the URL, filling out the form with the given input values, clicking on the ""Generate"" button, and then taking a screenshot of the resulting output page using the `page.screenshot()` method.

The script first defines the variables that will be used to store the values for the form fields and the resulting screenshot file names. It then loops through each available operation in the online tool, filling out the form with the corresponding input values and clicking on the ""Generate"" button to generate the output page. Finally, it takes a screenshot of the resulting output page using the `page.screenshot()` method and saves it to a file with a name that includes the name of the operation being performed.

Note that this script assumes that the online tool is accessible at the URL specified in the `url` variable, and that the form fields are located at the locations specified in the `form_fields` array. If these assumptions do not hold true for your specific use case, you may need to modify the script accordingly."
"[PYTHON]
def get_unique_elements(my_list):
    return list(set((lambda x: x if x != [] else None)(i) for i in my_list))
[/PYTHON]
[TESTS]
# Test case 1:
assert get_unique_elements([]) == []
# Test case 2:
assert get_unique_elements([1]) == [1]
# Test case 3:
assert get_unique_elements([1, 2, 3, 2, 1]) == [1, 2, 3]
# Test case 4:
assert get_unique_elements([1, 2, 3, 2, 1, []]) == [1, 2, 3, []]
# Test case 5:
assert get_unique_elements([1, 2, 3, 2, 1, [], []]) == [1, 2, 3, [], []]
[/TESTS]
"
"
\`\`\`javascript
async function migrate() {
  try {
    await db.openUri(start.uri);
    done();
  } catch (err) {
    assert.ifError(err);
  }
}
\`\`\`"
"  register(name, element, callerCloseMethod = null, canForceClose = false) {

    return new Promise((resolve) => {

      let container;

      if (!name || !element || !(container = element.parentNode)) {

        throw new Error('Not enough parameters.');

      } else if (this._overlays[name]) {

        throw new Error('The overlay is already registered.');

      }

      this._overlays[name] = {

        element,

        container,

        callerCloseMethod,

        canForceClose,

      };

      resolve();

    });

  }"
"
  `async set(name, value) {

    await this._initializedPromise;

    if (this.defaults[name] === undefined) {

      throw new Error(`Set preference: ""${name}"" is undefined.`);

    } else if (value === undefined) {

      throw new Error('Set preference: no value is specified.');

    }

    let valueType = typeof value;

    let defaultType = typeof this.defaults[name];

    if (valueType !== defaultType) {

      if (valueType === 'number' && defaultType === 'string') {

        value = value.toString();

      } else {

        throw new Error(`Set preference: ""${value}"" is a ${valueType}, ` +

                        `expected a ${defaultType}.`);

      }

      if (valueType === 'number' && !Number.isInteger(value)) {

        throw new Error(`Set preference: ""${value}"" must be an integer.`);

      }

    this.prefs[name] = value;

    return await this._writeToStorage(this.prefs);

  }`"
"
\`\`\`javascript
this.xref.stream.manager.requestRanges(pendingRequests).then(() => {
  for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {
    let node = nodesToRevisit[i];
    // Remove any reference nodes from the current `RefSet` so they aren't skipped when we revist them.
    if (node instanceof Ref) {
      this.refSet.remove(node);
    }
    this._walk(nodesToRevisit);
  }
}).catch(this.capability.reject);
\`\`\`"
"
\`\`\`javascript
async function processBinaryCMap(data, cMap, extend) {
  try {
    const result = await fetch(data, cMap, extend);
    resolve(result);
  } catch (error) {
    reject(error);
  }
}
\`\`\`"
"
\`\`\`javascript
async function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
  const parsedCMap = await fetchBuiltInCMap(parsedCMap.name);
  if (parsedCMap.isIdentityCMap) {
    return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
  }
  return parsedCMap;
}
\`\`\`"
"  it(""parses beginbfchar"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));

      expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));

      expect(cmap.lookup(0x05)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses beginbfrange with range"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x05)).toBeUndefined();

      expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));

      expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));

      expect(cmap.lookup(0x0c)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses beginbfrange with array"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x0c)).toBeUndefined();

      expect(cmap.lookup(0x0d)).toEqual(0x00);

      expect(cmap.lookup(0x12)).toEqual(0x05);

      expect(cmap.lookup(0x13)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses begincidchar"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x14)).toEqual(0x00);

      expect(cmap.lookup(0x15)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses begincidrange"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.lookup(0x15)).toBeUndefined();

      expect(cmap.lookup(0x16)).toEqual(0x00);

      expect(cmap.lookup(0x1b)).toEqual(0x05);

      expect(cmap.lookup(0x1c)).toBeUndefined();

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""decodes codespace ranges"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      const c = {};

      cmap.readCharCode(String.fromCharCode(1), 0, c);

      expect(c.charcode).toEqual(1);

      expect(c.length).toEqual(1);

      cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);

      expect(c.charcode).toEqual(3);

      expect(c.length).toEqual(4);

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""decodes 4 byte codespace ranges"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      const c = {};

      cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);

      expect(c.charcode).toEqual(0x8ea1a1a1);

      expect(c.length).toEqual(4);

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""read usecmap"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: stream,

    });

    try {

      const cmap = await cmapPromise;

      expect(cmap instanceof CMap).toEqual(true);

      expect(cmap.useCMap).not.toBeNull();

      expect(cmap.builtInCMap).toBeFalsy();

      expect(cmap.length).toEqual(0x20a7);

      expect(cmap.isIdentityCMap).toEqual(false);

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""parses cmapname"", async () => {

    const cmapPromise = CMapFactory.create({ encoding: stream });

    try {

      const cmap = await cmapPromise;

      expect(cmap.name).toEqual(""Adobe-Japan1-1"");

    } catch (reason) {

      done.fail(reason);

    }

  });

  it(""attempts to load a non-existent built-in CMap"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""null""),

      fetchBuiltInCMap,

      useCMap: null,

    });

    try {

      await cmapPromise;

      done.fail(""No CMap should be loaded"");

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      expect(reason.message).toEqual(""Unknown CMap name: null"");

    }

  });

  it(""attempts to load a built-in CMap without the necessary API parameters"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    try {

      await cmapPromise;

      done.fail(""No CMap should be loaded"");

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      const message = reason.message;

      expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

      expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(

        true

      );

    }

  });

  it(""attempts to load a built-in CMap with inconsistent API parameters"", async () => {

    const cmapPromise = CMapFactory.create({

      encoding: Name.get(""Adobe-Japan1-1""),

      fetchBuiltInCMap: tmpFetchBuiltInCMap,

      useCMap: null,

    });

    try {

      await cmapPromise;

      done.fail(""No CMap should be loaded"");

    } catch (reason) {

      expect(reason instanceof Error).toEqual(true);

      const message = reason.message;

      expect(message.startsWith(""Unable to load CMap at: "")).toEqual(true);

      expect(message.endsWith(""/external/bcmaps/Adobe-Japan1-1"")).toEqual(

        true

      );

    }

  });"
"
\`\`\`javascript
AnnotationFactory.create().then(async ({ data }) => {
  expect(data.annotationType).toEqual(AnnotationType.WIDGET);
  expect(data.checkBox).toEqual(false);
  expect(data.radioButton).toEqual(true);
  expect(data.fieldValue).toEqual(null);
  expect(data.buttonValue).toEqual(""2"");
  done();
}, done.fail);
\`\`\`

The migrated code uses the `async/await` syntax to handle promises in a more concise and readable way. The \`then\` method is replaced with an \`async\` function, which allows you to use the await keyword to wait for the promise to resolve before continuing execution of the function. In this case, we are waiting for the promise returned by the create method to resolve before checking the values of the annotation object's properties."
"
\`\`\`javascript
try {
  const annotation = await AnnotationFactory.create();
  expect(annotation.annotationType).toEqual(AnnotationType.WIDGET);
  expect(annotation.pushButton).toEqual(true);
  expect(annotation.alternativeText).toEqual(""An alternative text"");
} catch (error) {
  done.fail(error);
}
\`\`\`"
"  AnnotationFactory.create()
    .then(annotation => {
      const annotationStorage = new Map();
      annotationStorage.set(annotation.data.id, { value: ""C"" });
      return annotation.save(partialEvaluator, task, annotationStorage);
    })
    .then(data => {
      expect(data.length).toEqual(2);
      const [oldData, newData] = data;
      expect(oldData.ref).toEqual(Ref.get(123, 0));
      expect(newData.ref).toEqual(Ref.get(1, 0));
      oldData.data = oldData.data.replace(/\(D:[0-9]+\)/, ""(date)"");
      expect(oldData.data).toEqual(
        ""123 0 obj\n"" +
          ""<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR "" +
          ""<< /Font << /Helv 314 0 R>>>> "" +
          ""/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) "" +
          ""/AP << /N 1 0 R>> /M (date)>>\nendobj\n""
      );
      expect(newData.data).toEqual(
        ""1 0 obj\n"" +
          ""<< /Length 67 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> "" +
          ""/BBox [0 0 32 10]>> stream\n"" +
          ""/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2.00 2.00 Td (C) Tj ET Q EMC\n"" +
          ""endstream\nendobj\n""
      );
      done();
    })
    .catch(done.fail);
  });"
"  destroy() {

    const transportDestroyed = !this._transport

      ? Promise.resolve()

      : this._transport.destroy();

    return transportDestroyed.then(async () => {

      this._transport = null;

      if (this._worker) {

        await this._worker.destroy();

        this._worker = null;

      }

    });

  }"
"  Code:
    async function extractDataStructures(dict, baseDict, properties) {

        const newProperties = await this.extractWidths(dict, descriptor, newProperties);

        return new Font(fontName.name, fontFile, newProperties);

    }"
"
\`\`\`javascript

this.pdfDocument

  .getPageIndex(destRef)

  .then((pageIndex) => {

    this.cachePageRef(pageIndex + 1, destRef);

    return this.#goToDestinationHelper(rawDest, namedDest, explicitDest);

  })

  .catch(() => {

    console.error(

      `PDFLinkService.#goToDestinationHelper: ""${destRef}"" is not ` +

        `a valid page reference, for dest=""${rawDest}"".`

    );

  });

return;

\`\`\`"
"
\`\`\`javascript
async function fetchData(url, compressionType) {
  const response = await fetch(url);
  const data = await response.json();
  return { cMapData: data, compressionType };
}
\`\`\`"
"
\`\`\`javascript
const editorconfigAsyncNoCache = async (filePath, config) => {
  try {
    const maybeParse = await Promise.resolve(maybeParse(filePath, config, editorconfig.parse));
    return editorConfigToPrettier(maybeParse);
  } catch (err) {
    throw new Error(`Error parsing EditorConfig file: ${err}`);
  }
};
const editorconfigAsyncWithCache = mem(editorconfigAsyncNoCache);
const editorconfigSyncWithCache = mem(editorconfigSyncNoCache);
\`\`\`"
"  const { output } = bundleConfig;

  return bundler(bundleConfig, cache)
    .then((result) => {
      if (result.cached) {
        console.log(CACHED);
      } else {
        console.log(OK);
      }
      return result;
    })
    .catch((error) => {
      console.log(FAIL + ""\n"");
      handleError(error);
    });"
"```
Markdown
---

\`\`\`js
async function getExplorer(opts) {
  // Normalize opts before passing to a memoized function
  opts = { sync: false, cache: false, ...opts };
  return await getExplorerMemoized(opts);
}

async function _resolveConfig(filePath, opts, sync) {
  const unwrapAndMerge = async ([result, editorConfigured]) => {
    if (!result && !editorConfigured) {
      return null;
    }
    // We are not using this option
    delete merged.insertFinalNewline;
    return merged;
  };
  const arr = [
    result,
    editorConfigured,
  ];
  if (loadOpts.sync) {
    return unwrapAndMerge(arr);
  }
  return Promise.all(arr).then(unwrapAndMerge);
}

async function resolveConfig(filePath, opts) {
  await _resolveConfig(filePath, opts, false);
}

resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);
\`\`\`"
"export const requestResolvedSubtree = async (path, system) => {
  const {
    errActions,
    fn: { resolveSubtree },
    specSelectors,
    specActions,
  } = system;
  const specStr = specSelectors.specStr();
  const currentValue = specSelectors.specResolvedSubtree(path);
  if (currentValue) return;
  try {
    const { spec, errors } = await resolveSubtree(specSelectors.specJson().toJS(), path);
    errActions.clear({ type: ""thrown"" });
    console.error(errors);
    return spec;
  } catch (err) {
    errActions.set({ type: ""thrown"", error: err });
    throw err;
  }
};"
"
function deleteFolder(file) {
	return new Promise((resolve, reject) => {
		rimraf(file, (err) => {
			if (err) {
				reject(err);
			} else {
				resolve();
			}
		});
	});
}"
"  `it('eachAsync() with parallel > numDocs (gh-8422)', function() {

    return co(function*() {

      yield Movie.deleteMany({});

      yield Movie.create([

        { name: 'Kickboxer' },

        { name: 'Ip Man' },

        { name: 'Enter the Dragon' }

      ]);

      let numDone = 0;

      const test = co.wrap(async function*() {

        await new Promise((resolve) => setTimeout(resolve, 100));

        ++numDone;

      });

      yield Movie.find().cursor().eachAsync(test, { parallel: 4 });

      assert.equal(numDone, 3);

    });

  it('eachAsync() with sort, parallel, and sync function (gh-8557)', function() {

    return co(function*() {

      yield User.create([{ order: 1 }, { order: 2 }, { order: 3 }]);

      const cursor = User.aggregate([{ $sort: { order: 1 } }]).

        cursor();

      const docs = [];

      yield cursor.eachAsync(async (doc) => docs.push(doc), { parallel: 3 });

      assert.deepEqual(docs.map(d => d.order), [1, 2, 3]);

    });`"
"
  set(name, value) {
    return this._initializedPromise.then(() => {
      if (this.defaults[name] === undefined) {
        throw new Error(`Set preference: ""${name}"" is undefined.`);
      } else if (value === undefined) {
        throw new Error('Set preference: no value is specified.');
      }
      let valueType = typeof value;
      let defaultType = typeof this.defaults[name];
      if (valueType !== defaultType) {
        if (valueType === 'number' && defaultType === 'string') {
          value = value.toString();
        } else {
          throw new Error(`Set preference: ""${value}"" is a ${valueType}, expected a ${defaultType}.`);
        }
        if (valueType === 'number' && !Number.isInteger(value)) {
          throw new Error(`Set preference: ""${value}"" must be an integer.`);
        }
      }
      this.prefs[name] = value;
      return this._writeToStorage(this.prefs);
    });
  }"
"  `async parseAsync(argv, parseOptions) {`

    await this.parse(argv, parseOptions);

    return Promise.all(this._actionResults);

  }`"
`const promise = await aggregate.exec();`
"  register(name, element, callerCloseMethod = null, canForceClose = false) {

    return new Promise((resolve) => {

      let container;

      if (!name || !element || !(container = element.parentNode)) {

        throw new Error('Not enough parameters.');

      } else if (this._overlays[name]) {

        throw new Error('The overlay is already registered.');

      }

      this._overlays[name] = {

        element,

        container,

        callerCloseMethod,

        canForceClose,

      };

      resolve();

    });

  async function() {

    let container;

    if (!name || !element || !(container = element.parentNode)) {

      throw new Error('Not enough parameters.');

    } else if (this._overlays[name]) {

      throw new Error('The overlay is already registered.');

    }

    this._overlays[name] = {

      element,

      container,

      callerCloseMethod,

      canForceClose,

    };

    resolve();

  });

  ```

The migrated code uses `async/await` syntax instead of `Promise` chain. The first step is to identify the promise chains using `.then()` and `.catch()`, or `.finally()`. In this case, there are two promise chains: one for the `new Promise()` statement and another for the `throw new Error()` statements.

The next step is to replace the `.then()` callbacks with `await`. This involves assigning the resolved value of the promise to a variable using the `await` keyword. In this case, we assign the resolved value to the `container` variable.

After replacing the `.then()` and `.catch()` or `.finally()` calls with `await`, we wrap the logic in an `async function`. This allows us to use `await` within the function.

Finally, we implement error handling by replacing the `.catch()` method with a `try...catch` block. This enables us to handle potential errors and prevent them from propagating to the caller."
"`async () => {
  try {
    const response = await testSearch({});
    done(null, response);
  } catch (error) {
    done(error);
  }
}`"
"  open() {

async () => {

try {

await this.overlayManager.open(this.overlayName);

if (

!this._isViewerEmbedded ||

this.reason === PasswordResponses.INCORRECT_PASSWORD

) {

this.input.focus();

}

let promptString;

if (this.reason === PasswordResponses.INCORRECT_PASSWORD) {

promptString = this.l10n.get(

""password_invalid"",

null,

""Invalid password. Please try again.""

);

} else {

promptString = this.l10n.get(

""password_label"",

null,

""Enter the password to open this PDF file.""

);

}

await promptString.then(msg => {

this.label.textContent = msg;

});

} catch (error) {

console.error(error);

}

}

};"
"    const readPromise = Promise.all([
    
        // Replace .then() callbacks by assigning the resolved value to a variable using the await keyword
        (async () => {
            try {
                let result1 = await isStreamingSupported();
                let result2 = await isRangeSupported();
                let fullReaderCancelled = await result1.value;
                expect(result1.value).toEqual(rangeSize);
                expect(result2.value).toEqual(tailSize);
                done();
            } catch (error) {
                done.fail(error);
            }
        })(),
    ]);"
"  `it(""checks that fingerprints are unique"", async function () {
      try {
        const data = await Promise.all([loadingTask1.promise, loadingTask2.promise]);
        const fingerprint1 = data[0].fingerprint;
        const fingerprint2 = data[1].fingerprint;
        expect(fingerprint1).not.toEqual(fingerprint2);
        expect(fingerprint1).toEqual(""2f695a83d6e7553c24fc08b7ac69712d"");
        expect(fingerprint2).toEqual(""04c7126b34a46b6d4d6e7a1eff7edcb6"");
        await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);
      } catch (error) {
        done.fail(error);
      }
    });`"
"
  it(""should not parse IRT/RT when not defined"", async () => {

    try {

      const data = await AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock);

      expect(data.inReplyTo).toBeUndefined();

      expect(data.replyType).toBeUndefined();

      done();

    } catch (error) {

      done.fail(error);

    }

  });

  it(""should parse IRT and set default RT when not defined."", async () => {

    try {

      const data = await AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock);

      expect(data.inReplyTo).toBeUndefined();

      expect(data.replyType).toBeUndefined();

      done();

    } catch (error) {

      done.fail(error);

    }

  });"
"   `it(""should parse IRT/RT for a group type"", async function(done) {
      try {
        const { data } = await AnnotationFactory.create();

        expect(data.inReplyTo).toEqual(annotationRef.toString());

        expect(data.replyType).toEqual(""R"");

        done();
      } catch (error) {
        done.fail(error);
      }
    });`"
"  AnnotationFactory.create(async () => {
    const data = await AnnotationFactory.create(

      ).then(({ data }) => {
        expect(data.stateModel).toEqual(""Review"");
        expect(data.state).toEqual(""Rejected"");
        done();
      }, done.fail);
    });
  it(""should correctly parse a URI action"", async () => {

      const data = await AnnotationFactory.create(

      ).then(({ data }) => {
        expect(data.stateModel).toEqual(""Review"");
        expect(data.state).toEqual(""Rejected"");
        done();
      }, done.fail);
    });
  }"
"    async function create() {
      const { data } = await AnnotationFactory.create();
  
      expect(data.annotationType).toEqual(AnnotationType.LINK);
  
      expect(data.url).toBeUndefined();
  
      expect(data.unsafeUrl).toBeUndefined();
  
      expect(data.dest).toEqual(""LI0"");
  
      done();
    }
    
    it(""should correctly parse a simple Dest, with explicit destination array"", async function (done) {
      await create();
      done();
    });"
"  `async` function test(done) {

    try {

      const annotation = await AnnotationFactory.create();

      const partialEvaluator = new PDFJS.PartialEvaluator(
        new PDFJS.PDFDocument({
          pdfManager: new PDFJS.PDFManager(),
        }),
        null,
        null
      );

      const annotationStorage = new Map();

      annotationStorage.set(annotation.data.id, { value: ""test (print)"" });

      const appearance = await annotation._getAppearance(
        partialEvaluator,
        task,
        annotationStorage
      );

      expect(appearance).toEqual(
        ""/Tx BMC q BT /Helv 8 Tf 0 g 1 0 0 1 0 0 Tm"" +
          "" 2.00 2.00 Td (test \\(print\\)) Tj ET Q EMC""
      );

      done();
    } catch (error) {
      done.fail(error);
    }
  }"
"  `async function test() {
    const data = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.POPUP);
    // We should not modify the `annotationFlags` returned through
    // e.g., the API.
    expect(data.annotationFlags).toEqual(25);
    // The popup should inherit the `viewable` property of the parent.
    const viewable = data.viewable;
    return { data, viewable };
  }
  try {
    const result = await test();
    expect(result.data.annotationType).toEqual(AnnotationType.POPUP);
    // We should not modify the `annotationFlags` returned through
    // e.g., the API.
    expect(result.data.annotationFlags).toEqual(25);
    // The popup should inherit the `viewable` property of the parent.
    expect(result.viewable).toEqual(true);
  } catch (error) {
    done.fail(error);
  }`"
"  AnnotationFactory.create()

async () => {
  try {
    const { data } = await AnnotationFactory.create();
    expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);
    expect(data.quadPoints).not.toBeNull();
  } catch (e) {
    done.fail();
  } finally {
    done();
  }
}"
"   `it(""table was truncated in the middle of functions"", async function () {

      const cMap = await CMapFactory.create({});

      const font = new Font(""font"", new Stream(font2324), {
        loadedName: ""font"",
        type: ""CIDFontType2"",
        differences: [],
        defaultEncoding: [],
        cMap,
        toUnicode: new ToUnicodeMap([]),
      });

      const output = await ttx(font.data);

      verifyTtxOutput(output);

      expect(
        /(ENDF\[ \]|SVTCA\[0\])\s*<\/assembly>\s*<\/fpgm>/.test(output)
      ).toEqual(true);
    });`"
"  `async function handleSetFont(fontName, fontRef) {
    
    try {
    
      const translated = await self.loadFont(fontName, fontRef, resources);
      
      if (!translated.font.isType3Font) {
        return translated;
      }
      
      await translated.loadType3Data(self, resources, task);
      textState.loadedName = translated.loadedName;
      textState.font = translated.font;
      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
      
    } catch (error) {
    
      // Ignore Type3-parsing errors, since we only use `loadType3Data` here to ensure that we'll always obtain a useful /FontBBox.
      textState.loadedName = translated.loadedName;
      textState.font = translated.font;
      textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
      
    }
    
  }`"
"`await Promise.all( this.pending ).then( function () {

	const buffers = writer.buffers;

	const json = writer.json;

	const options = writer.options;

	const extensionsUsed = writer.extensionsUsed; // Merge buffers.

	const blob = new Blob( buffers, {

		type: 'application/octet-stream'

	} ); // Declare extensions.

	const extensionsUsedList = Object.keys( extensionsUsed );

	if ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.

	if ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;

	if ( options.binary === true ) {

		// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

		const reader = new window.FileReader();

		reader.readAsArrayBuffer( blob );

		reader.onloadend = function () {

			// Binary chunk.

			const binaryChunk = getPaddedArrayBuffer( reader.result );

			const binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

			binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );

			binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true ); // JSON chunk.

			const jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );

			const jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );

			jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );

			jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true ); // GLB header.

			const header = new ArrayBuffer( GLB_HEADER_BYTES );

			const headerView = new DataView( header );

			headerView.setUint32( 0, GLB_HEADER_MAGIC, true );

			headerView.setUint32( 4, GLB_VERSION, true );

			const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;

			headerView.setUint32( 8, totalByteLength, true );

			const glbBlob = new Blob( [ header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk ], {

				type: 'application/octet-stream'

			} );

			const glbReader = new window.FileReader();

			glbReader.readAsArrayBuffer( glbBlob );

			glbReader.onloadend = function () {

				onDone( glbReader.result );

			};

	} else {

		if ( json.buffers && json.buffers.length > 0 ) {

			const reader = new window.FileReader();

			reader.readAsDataURL( blob );

			reader.onloadend = function () {

				const base64data = reader.result;

				json.buffers[ 0 ].uri = base64data;

				onDone( json );

			};

		} else {

			onDone( json );

		}

	} );`"
"
    encryptionPasswordFormEl.submit(async () => {
        try {
            const key = await getDataKey(password);
            dialogEl.dialog(""close"");
            dataKey = key;
            decryptTreeItems();
            if (encryptionDeferred !== null) {
                encryptionDeferred.resolve();
                encryptionDeferred = null;
            }
        } catch (error) {
            console.log(reason);
            error(reason);
        }
        return false;
    });"
"  exports.mssqlQuery = async (connectionString, query) => {
    try {
      const pool = await mssql.connect(connectionString);
      const result = await pool.request().query(query);
      return result;
    } catch (err) {
      throw err;
    } finally {
      mssql.close();
    }
  };"
"async function provideCodeActions(model, range, context, token) {
  try {
    const resource = model.uri;
    const startOffset = this._positionToOffset(resource, { lineNumber: range.startLineNumber, column: range.startColumn });
    const endOffset = this._positionToOffset(resource, { lineNumber: range.endLineNumber, column: range.endColumn });
    const formatOptions = FormatHelper._convertOptions(model.getOptions());
    const errorCodes = context.markers.filter(m => m.code).map(m => m.code).map(Number);
    const codeFixes = await worker(resource).then(worker => worker.getCodeFixesAtPosition(resource.toString(), startOffset, endOffset, errorCodes, formatOptions));
    return {
      actions: codeFixes.filter(fix => fix.changes.filter(change => change.isNewFile).length === 0).map(fix => this._tsCodeFixActionToMonacoCodeAction(model, context, fix)),
      dispose: () => {}
    };
  } catch (error) {
    console.error(""Error fetching user data:"", error);
    throw error;
  }
}"
"  The provided code is a test suite written in JavaScript using the Jest testing framework. It defines several tests that check the behavior of different functions in the `utils` module. Each test case has three parts:
    1. The setup phase, where the necessary dependencies are imported and any other setup operations are performed.
    2. The actual test, which is a call to the function being tested with appropriate input arguments.
    3. The assertion phase, where the expected output of the function is compared with the actual output. If the two values are not equal, the test fails.

In this code sample, the `utils` module is being used for testing various utility functions. Each test case in this suite is intended to verify the correctness of a specific function by comparing its output with the expected result. The tests may also include additional setup operations, such as importing necessary dependencies or defining mock data."
"[PYTHON]
def get_roles(user):
    # This is just an example function that takes a user and returns their roles
    return [""admin"", ""moderator""]

def check_permissions(permission, user):
    roles = get_roles(user)
    return permission in roles

def has_permission(permission, user):
    return check_permissions(permission, user)

def allow_access():
    # This is just an example function that checks if a user is allowed to access a resource
    if has_permission(""read"", request.user):
        return True
    else:
        abort(403)
[/PYTHON]
[TESTS]
# Test case 1:
def test_check_permissions():
    permission = ""read""
    user = ""user1""
    roles = get_roles(user)
    assert check_permissions(permission, user) == (""read"" in roles)

# Test case 2:
def test_has_permission():
    permission = ""read""
    user = ""user1""
    assert has_permission(permission, user) == (check_permissions(permission, user))

# Test case 3:
def test_allow_access():
    request.user = ""user1""
    assert allow_access() == (has_permission(""read"", request.user))
[/TESTS]
"
"  async function provideCompletionItems(model: monaco.editor.IReadOnlyModel, position: Position, _context: monaco.languages.CompletionContext, token: CancellationToken): Promise<monaco.languages.CompletionList> {

    const offset = this._positionToOffset(resource, position);

    try {
      const worker = await this._worker(resource);
      const info = await worker.getCompletionsAtPosition(resource.toString(), offset);

      if (!info) {
        return;
      }

      let suggestions: MyCompletionItem[] = info.entries.map((entry) => {
        let range = wordRange;

        if (entry.replacementSpan) {
          const p1 = model.getPositionAt(entry.replacementSpan.start);
          const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);
          range = new Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);
        }

        return {
          uri: resource,
          position: position,
          range: range,
          label: entry.name,
          insertText: entry.name,
          sortText: entry.sortText,
          kind: SuggestAdapter.convertKind(entry.kind),
        };
      });
    } catch (error) {
      console.error('Error fetching user data:', error);
      throw error;
    }
  }

  async function resolveCompletionItem(model: monaco.editor.IReadOnlyModel, position: Position, item: monaco.languages.CompletionItem, token: CancellationToken): Promise<monaco.languages.CompletionItem> {
    let myItem = <MyCompletionItem>item;

    try {
      const worker = await this._worker(resource);
      const details = await worker.getCompletionEntryDetails(resource.toString(), this._positionToOffset(resource, position), myItem.label);

      if (!details) {
        return myItem;
      }

      return <MyCompletionItem>{
        uri: resource,
        position: position,
        label: details.name,
        kind: SuggestAdapter.convertKind(details.kind),
        detail: displayPartsToString(details.displayParts),
        documentation: {
          value: displayPartsToString(details.documentation),
        },
      };
    } catch (error) {
      console.error('Error fetching user data:', error);
      throw error;
    }
  }
}"
"[PYTHON]
async function getUserData(userId) {
  try {
    const response = await fetch(`/users/${userId}`);
    const data = await response.json();
    return data.userProfile;
  } catch (error) {
    console.error('Error fetching user data:', error);
    throw error;
  }
}
[/PYTHON]
[TESTS]
# Test case 1:
assert.equal(getUserData(123), 'User data for user with id 123');

# Test case 2:
assert.equal(getUserData(456), 'User data for user with id 456');

# Test case 3:
assert.equal(getUserData(789), 'User data for user with id 789');
[/TESTS]
"
"  `async function unregister(name) {
     try {
       if (!this._overlays[name]) {
         throw new Error('The overlay does not exist.');
       } else if (this._active === name) {
         throw new Error('The overlay cannot be removed while it is active.');
       }
       delete this._overlays[name];
     } catch(error) {
       console.error('Error unregistering overlay:', error);
       throw error;
     }
   }`"
"  `async function test() {
    try {
      const response = await fetch('https://my-api.com');
      const data = await response.json();
      expect(data).toEqual({ message: 'Hello, World!' });
    } catch (error) {
      console.error('Error fetching data:', error);
      throw error;
    }
  }`"
"
  AnnotationFactory.create(

  ).then(({ data }) => {

    expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);

    expect(data.quadPoints).not.toEqual(null);

    done();

  }, done.fail);"
"[PYTHON]
async function getUserData(userId) {
  try {
    const response = await fetch(`/users/${userId}`);
    const data = await response.json();
    return data.userProfile;
  } catch (error) {
    console.error('Error fetching user data:', error);
    throw error;
  }
}
[/PYTHON]
[TESTS]
import asyncio
from unittest import TestCase
from io import StringIO

class TestGetUserData(TestCase):
    def setUp(self):
        self.get_user_data = self.load_function('get_user_data')

    def load_function(self, function_name):
        with open('./main.py', 'r') as f:
            code = StringIO(f.read())
            globals_ = {'__file__': './main.py'}
            exec(code, globals_)
            return globals_[function_name]

    @async_test
    async def test_get_user_data(self):
        userId = 123
        expected = 'User Profile'
        result = await self.get_user_data(userId)
        self.assertEqual(result, expected)

def async_test(f):
    def wrapper(*args, **kwargs):
        asyncio.run(f(*args, **kwargs))
    return wrapper
[/TESTS]
"
"  fontFallback(id, handler) {

async function fontFallback(id, handler) {

const promises = [];

this.fontCache.forEach((promise) => {

promises.push(promise);

});

try {

const translatedFonts = await Promise.all(promises);

for (const translatedFont of translatedFonts) {

if (translatedFont.loadedName === id) {

translatedFont.fallback(handler);

return;

}

}

await cleanup(false);

async function cleanup(manuallyTriggered = false) {

const promises = [];

this.fontCache.forEach((promise) => {

promises.push(promise);

});

try {

const translatedFonts = await Promise.all(promises);

for (const { dict } of translatedFonts) {

delete dict.cacheKey;

}

this.fontCache.clear();

this.builtInCMapCache.clear();

this.standardFontDataCache.clear();

} catch (error) {

console.error('Error cleaning up font cache:', error);

}

}

 } catch (error) {

console.error('Error fetching user data:', error);

throw error;

}

}
```"
"  `async function handleSetFont(fontName, fontRef) {

    try {
      const self = this;
      const resources = null;
      const task = null;
      const translated = await self.loadFont(fontName, fontRef, resources);

      if (!translated.font.isType3Font) {
        return translated;
      }

      try {
        await translated.loadType3Data(self, resources, task);
      } catch (error) {
        // Ignore Type3-parsing errors, since we only use `loadType3Data`
        // here to ensure that we'll always obtain a useful /FontBBox.
      }

      return translated;
    } catch (error) {
      console.error('Error fetching user data:', error);
      throw error;
    }
  }`"
"
async function fetchData(url) {
  try {
    const data = await fs.promises.readFile(url);
    return new Uint8Array(data);
  } catch (error) {
    console.error('Error reading file:', error);
    throw error;
  }
}"
"
[MIGRATION=async/await]
async function getContentStream() {
  try {
    const content = await this.pdfManager.ensure(this, ""content"");
    if (content instanceof BaseStream) {
      return content;
    }
    if (Array.isArray(content)) {
      return new StreamsSequenceStream(
        content,
        this._onSubStreamError.bind(this),
      );
    }
    // Replace non-existent page content with empty content.
    return new NullStream();
  } catch (error) {
    console.error('Error fetching user data:', error);
    throw error;
  }
}
[/MIGRATION]"
"
[Migrated Code]
async function syncFromServer() {
  try {
    const response = await fetch('/api/setup/sync-from-server', {
      method: 'POST'
    });
    if (response.ok) {
      window.location.replace(""/"");
    } else {
      alert(""Error, see dev console for details."");
      console.error(err);
    }
  } catch (err) {
    console.error(err);
  }
}
[/Migrated Code]"
"
`async function test(id) {
  try {
    const doc = await Parent.findById(id);
    await doc.populate('children.toy.value');
    assert.equal(doc.children[0].toy.value.name, 'model-A');
    assert.equal(doc.children[1].toy.value, null);
    assert.equal(doc.children[2].toy.value.name, 'model-B');
  } catch (error) {
    done(error);
  }
}`"
